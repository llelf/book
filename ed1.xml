<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<book role="animal">
  <title>Real World OCaml</title>
 
  
  <bookinfo>
  <othercredit role="proofreader">
    <firstname>Becca</firstname>

    <surname>Freed</surname>
  </othercredit>

  <othercredit role="interiordesigner">
    <firstname>David</firstname>

    <surname>Futato</surname>
  </othercredit>

  <othercredit role="illustrator">
    <firstname>Rebecca</firstname>

    <surname>Demarest</surname>
  </othercredit>

  <othercredit role="coverdesigner">
    <firstname>Randy</firstname>

    <surname>Comer</surname>
  </othercredit>

  <!-- All rights reserved. -->

  <publisher>
    <publishername>O’Reilly Media, Inc.</publishername>

    <address format="linespecific">
      <street>1005 Gravenstein Highway North</street>
      <city>Sebastopol</city>
      <state>CA</state>
      <postcode>95472</postcode>
    </address>
  </publisher>

  <legalnotice role="printlocation">
    <para>Printed in the United States of America.</para>
  </legalnotice>

  <legalnotice role="printer">
    <para>[LSI]</para>
  </legalnotice>

  <legalnotice role="use">
    <para>O’Reilly books may be purchased for educational, business, or sales
    promotional use. Online editions are also available for most titles
    (<ulink role="orm:hideurl:ital" url="http://my.safaribooksonline.com/?portal=oreilly">http://my.safaribooksonline.com</ulink>).
    For more information, contact our corporate/institutional sales
    department: 800-998-9938 or <phrase role="keep-together"><email>corporate@oreilly.com</email></phrase>.</para>
  </legalnotice>

  <legalnotice role="trademarks">
    <para>Nutshell Handbook, the Nutshell Handbook logo, and the O’Reilly logo
    are registered trademarks of O’Reilly Media, Inc. <emphasis>Real World
      OCaml</emphasis>, the image of a Bactrian camel, and related trade dress
    are trademarks of O’Reilly Media, Inc.</para>

    <para>Many of the designations used by manufacturers and sellers to
    distinguish their products are claimed as trademarks. Where those
    designations appear in this book, and O’Reilly Media, Inc., was aware of a
    trademark claim, the designations have been printed in caps or initial
    caps.</para>
  </legalnotice>

  <legalnotice role="damages">
    <para>While every precaution has been taken in the preparation of this
    book, the publisher and authors assume no responsibility for errors or
    omissions, or for damages resulting from the use of the information
    contained herein.</para>
  </legalnotice>

  <isbn>9781449323912</isbn>

  <edition>1</edition>

  <author>
    <firstname>Yaron</firstname>

    <surname>Minsky</surname>

    <authorblurb>
      <para>Yaron Minsky heads the technology group at Jane Street, a
      proprietary trading firm that is the largest industrial user of OCaml.
      He was responsible for introducing OCaml to the company and for managing
      the company's transition to using OCaml for all of its core
      infrastructure. Today, billions of dollars worth of securities
      transactions flow each day through those systems. Yaron obtained his PhD
      in Computer Science from Cornell University, where he studied
      distributed systems. Yaron has lectured, blogged, and written about
      OCaml for years, with articles published in <emphasis>Communications of
      the ACM</emphasis> and the <emphasis>Journal of Functional
      Programming</emphasis>. He chairs the steering committee of the
      Commercial Users of Functional Programming, and is a member of the
      steering committee for the International Conference on Functional
      Programming.</para>
    </authorblurb>
  </author>

  <author>
    <firstname>Anil</firstname>

    <surname>Madhavapeddy</surname>

    <authorblurb>
      <para>Anil Madhavapeddy is a senior research fellow at the University of
      Cambridge, based in the Systems Research Group. He was on the original
      team that developed the Xen hypervisor, and he helped develop an
      industry-leading cloud management toolstack written entirely in OCaml.
      This XenServer product has been deployed on hundreds of thousands of
      physical hosts and drives critical infrastructure for many Fortune 500
      companies. Prior to obtaining his PhD in 2006 from the University of
      Cambridge, Anil had a diverse background in industry at Network
      Appliance, NASA, and Internet Vision. In addition to professional and
      academic activities, he is an active member of the open source
      development community with the OpenBSD operating system, is co-chair of
      the Commercial Uses of Functional Programming workshop, and serves on
      the boards of startup companies such as Ashima Arts, where OCaml is
      extensively used.</para>
    </authorblurb>
  </author>

  <author>
    <firstname>Jason</firstname>

    <surname>Hickey</surname>

    <authorblurb>
      <para>Jason Hickey is a software engineer at Google Inc. in Mountain
      View, California. He is part of the team that designs and develops the
      global computing infrastructure used to support Google services,
      including the software systems for managing and scheduling massively
      distributed computing resources. Prior to joining Google, Jason was an
      assistant professor of computer science at Caltech, where his research
      was in reliable and fault-tolerant computing systems, including
      programming language design, formal methods, compilers, and new models
      of distributed computation. He obtained his PhD in computer science from
      Cornell University, where he studied programming languages. He is the
      author of the MetaPRL system, a logical framework for design and
      analysis of large software systems; and OMake, an advanced build system
      for large software projects. He is also the author of the textbook
      <emphasis>An Introduction to Objective Caml</emphasis>
      (unpublished).</para>
    </authorblurb>
  </author>

  <editor>
    <firstname>Mike</firstname>

    <surname>Loukides</surname>
  </editor>

  <editor>
    <firstname>Andy</firstname>

    <surname>Oram</surname>
  </editor>

  <copyright>
    <year>2014</year>

    <holder>Yaron Minsky, Anil Madhavapeddy, Jason Hickey</holder>
  </copyright>

  <editor role="production">
    <firstname>Christopher</firstname>

    <surname>Hearse</surname>
  </editor>

  <editor role="copy">
    <firstname>Amanda</firstname>

    <surname>Kersey</surname>
  </editor>

  <othercredit role="indexer">
    <firstname>Judith</firstname>

    <surname>McConville</surname>
  </othercredit>

  <printhistory>
    <formalpara>
      <title>First Edition</title>

      <para>November, 2013</para>
    </formalpara>
  </printhistory>

  <revhistory>
    <revision>
      <date>2013-10-31</date>
      <revremark>First release</revremark>
    </revision>
  </revhistory>

  <legalnotice role="perfect">
    <para/>
  </legalnotice>
  <mediaobject role="cover"> <!-- source in the cover -->
<imageobject role="front-large" remap="lrg">
<imagedata format="PNG" fileref="images/cover.png"/>
</imageobject>
</mediaobject>
</bookinfo>
  
  <dedication id="dedication">
  <title>Dedication</title>
  <para>For Lisa, a believer in the power of words, who helps me find mine. —Yaron</para>
  <para>For Mum and Dad, who took me to the library and unlocked my imagination. —Anil</para>
  <para>For Nobu, who takes me on a new journey every day. —Jason</para>
</dedication>

  <preface id="prologue">
  <title>Prologue</title>

  <sect1 id="why-ocaml">
    <title>Why OCaml?</title>
    <para>Programming languages matter. They affect the reliability, security, and efficiency of the
      code you write, as well as how easy it is to read, refactor, and extend. The languages you
      know can also change how you think, influencing the way you design software even when you're
      not using them. </para>
    <para>We wrote this book because we believe in the importance of programming languages, and that
      OCaml in particular is an important language to learn. The three of us have been using OCaml
      in our academic and professional lives for over 15 years, and in that time we've come to see
      it as a secret weapon for building complex software systems. This book aims to make this
      secret weapon available to a wider audience, by providing a clear guide to what you need to
      know to use OCaml effectively in the real world. </para>
    <para>What makes OCaml special is that it occupies a sweet spot in the space of programming
      language designs. It provides a combination of efficiency, expressiveness and practicality
      that is matched by no other language. That is in large part because OCaml is an elegant
      combination of a few key language features that have been developed over the last 40
        years.<indexterm class="singular">
        <primary>OCaml</primary>
        <secondary>key features of</secondary>
      </indexterm> These include: </para>

    <itemizedlist>
      <listitem>
        <para><emphasis>Garbage collection</emphasis> for automatic memory
        management, now a feature of almost every modern, high-level
        language.</para>
      </listitem>

      <listitem>
        <para><emphasis>First-class functions</emphasis> that can be passed around like ordinary
          values, as seen in JavaScript, Common Lisp, and C#.</para>
      </listitem>

      <listitem>
        <para><emphasis>Static type-checking</emphasis> to increase
        performance and reduce the number of runtime errors, as found in Java
        and C#.</para>
      </listitem>

      <listitem>
        <para><emphasis>Parametric polymorphism</emphasis>, which enables the
        construction of abstractions that work across different data types,
        similar to generics in Java and C# and templates in <phrase role="keep-together">C++.</phrase></para>
      </listitem>

      <listitem>
        <para>Good support for <emphasis>immutable programming</emphasis>, i.e., programming without
          making destructive updates to data structures. This is present in traditional functional
            <phrase role="keep-together">languages</phrase> like Scheme, and is also found in
          distributed, big-data frameworks like Hadoop.</para>
      </listitem>

      <listitem>
        <para><emphasis>Automatic type inference</emphasis> to avoid having to
        laboriously define the type of every single variable in a program and
        instead have them inferred based on how a value is used. Available in
        a limited form in C# with implicitly typed local variables, and in
        C++11 with its <literal moreinfo="none">auto</literal> keyword.</para>
      </listitem>

      <listitem>
        <para><emphasis>Algebraic data types</emphasis> and <emphasis>pattern
        matching</emphasis> to define and manipulate complex data structures.
        Available in Scala and F#.</para>
      </listitem>
    </itemizedlist>

    <para>Some of you will know and love all of these features, and for others they will be largely
      new, but most of you will have seen <emphasis>some</emphasis> of them in other languages that
      you've used. As we'll demonstrate over the course of this book, there is something
      transformative about having them all together and able to interact in a single language.
      Despite their importance, these ideas have made only limited inroads into mainstream
      languages, and when they do arrive there, like first-class functions in C# or parametric
      polymorphism in Java, it's typically in a limited and awkward form. The only languages that
      completely embody these ideas are <emphasis>statically typed, functional programming
        languages</emphasis> like OCaml, F#, Haskell, Scala, and Standard ML.<indexterm class="singular">
        <primary>OCaml</primary>
        <secondary>benefits of</secondary>
      </indexterm></para>

    <para>Among this worthy set of languages, OCaml stands apart because it
    manages to provide a great deal of power while remaining highly pragmatic.
    The compiler has a straightforward compilation strategy that produces
    performant code without requiring heavy optimization and without the
    complexities of dynamic just-in-time (JIT) compilation. This, along with
    OCaml's strict evaluation model, makes runtime behavior easy to predict.
    The garbage collector is <emphasis>incremental</emphasis>, letting you
    avoid large garbage collection (GC)-related pauses, and
    <emphasis>precise</emphasis>, meaning it will collect all unreferenced
    data (unlike many reference-counting collectors), and the runtime is
    simple and highly portable.</para>

    <para>All of this makes OCaml a great choice for programmers who want to
    step up to a better programming language, and at the same time get
    practical work done.</para>

    <sect2 id="a-brief-history-from-the-1960s">
      <title>A Brief History</title>

      <para>OCaml was written in 1996 by Xavier Leroy, Jérôme Vouillon, Damien
      Doligez, and Didier Rémy at INRIA in France. It was inspired by a long
      line of research into ML starting in the 1960s, and continues to have
      deep links to the academic community.<indexterm class="singular">
          <primary>OCaml</primary>

          <secondary>history of</secondary>
        </indexterm></para>

      <para>ML was originally the <emphasis>meta language</emphasis> of the
      LCF (Logic for Computable Functions) proof assistant released by Robin
      Milner in 1972 (at Stanford, and later at Cambridge). ML was turned into
      a compiler in order to make it easier to use LCF on different machines,
      and it was gradually turned into a full-fledged system of its own by the
      1980s.</para>

      <para>The first implementation of Caml appeared in 1987. It was created
      by Ascánder Suárez and later continued by Pierre Weis and Michel Mauny.
      In 1990, Xavier Leroy and Damien Doligez built a new implementation
      called Caml Light that was based on a bytecode interpreter with a fast,
      sequential garbage collector. Over the next few years useful libraries
      appeared, such as Michel Mauny's syntax manipulation tools, and this
      helped promote the use of Caml in education and research teams.</para>

      <para>Xavier Leroy continued extending Caml Light with new features,
      which resulted in the 1995 release of Caml Special Light. This improved
      the executable efficiency significantly by adding a fast native code
      compiler that made Caml's performance competitive with mainstream
      languages such as C++. A module system inspired by Standard ML also
      provided powerful facilities for abstraction and made larger-scale
      programs easier to construct.</para>

      <para>The modern OCaml emerged in 1996, when a powerful and elegant
      object system was implemented by Didier Rémy and Jérôme Vouillon. This
      object system was notable for supporting many common object-oriented
      idioms in a statically type-safe way, whereas the same idioms required
      runtime checks in languages such as C++ or Java. In 2000, Jacques
      Garrigue extended OCaml with several new features such as polymorphic
      methods, variants, and labeled and optional arguments.</para>

      <para>The last decade has seen OCaml attract a significant user base,
      and language improvements have been steadily added to support the
      growing commercial and academic <phrase role="keep-together">codebases</phrase>. First-class modules,
      Generalized Algebraic Data Types (GADTs), and dynamic linking have
      improved the flexibility of the language. There is also fast native code
      support for x86_64, ARM, PowerPC, and Sparc, making OCaml a good choice
      for systems where resource usage, predictability, and performance all
      matter.</para>
    </sect2>

    <sect2 id="the-core-standard-library">
      <title>The Core Standard Library</title>

      <para>A language on its own isn't enough. You also need a rich set of
      libraries to base your applications on. A common source of frustration
      for those learning OCaml is that the standard library that ships with
      the compiler is limited, covering only a small subset of the
      functionality you would expect from a general-purpose standard library.
      That's because the standard library isn't a general-purpose tool; it was
      developed for use in bootstrapping the compiler and is purposefully kept
      small and simple.<indexterm class="singular">
          <primary>Core standard library</primary>

          <secondary>development of</secondary>
        </indexterm><indexterm class="singular">
          <primary>OCaml</primary>

          <secondary>Core standard library</secondary>
        </indexterm></para>

      <para>Happily, in the world of open source software, nothing stops
      alternative libraries from being written to supplement the
      compiler-supplied standard library, and this is exactly what the Core
      distribution is.</para>

      <para>Jane Street, a company that has been using OCaml for more than a
      decade, developed Core for its own internal use, but designed it from
      the start with an eye toward being a general-purpose standard library.
      Like the OCaml language itself, Core is engineered with correctness,
      reliability, and performance in mind.</para>

      <para>Core is distributed with syntax extensions that provide useful new
      functionality to OCaml, and there are additional libraries such as the
      Async network communications library that extend the reach of Core into
      building complex distributed systems. All of these libraries are
      distributed under a liberal Apache 2 license to permit free use in
      hobby, academic, and commercial settings.</para>
    </sect2>

    <sect2 id="the-ocaml-platform">
      <title>The OCaml Platform</title>

      <para>Core is a comprehensive and effective standard library, but
      there's much more OCaml software out there. A large community of
      programmers has been using OCaml since its first release in 1996, and
      has generated many useful libraries and tools. We'll introduce some of
      these libraries in the course of the examples presented in the
      book.<indexterm class="singular">
          <primary>OCaml</primary>

          <secondary>third-party libraries for</secondary>
        </indexterm></para>

      <para>The installation and management of these third-party libraries is made much easier via a
        package management tool known as <ulink url="http://opam.ocaml.org/">OPAM</ulink>. We'll explain more about OPAM
        as the book unfolds, but it forms the basis of the Platform, which is a set of tools and
        libraries that, along with the OCaml compiler, lets you build real-world applications
        quickly and effectively.</para>

      <para>We'll also use OPAM for installing the <command moreinfo="none">utop</command> command-line interface. This is a modern
      interactive tool that supports command history, macro expansion, module
      completion, and other niceties that make it much more pleasant to work
      with the language. We'll be using <command moreinfo="none">utop</command> throughout the book to let you step
      through the examples interactively.</para>
    </sect2>
  </sect1>

  <sect1 id="about-this-book">
    <title>About This Book</title>

    <para><emphasis>Real World OCaml</emphasis> is aimed at programmers who
    have some experience with conventional programming languages, but not
    specifically with statically typed functional programming. Depending on
    your background, many of the concepts we cover will be new, including
    traditional functional-programming techniques like higher-order functions
    and immutable data types, as well as aspects of OCaml's powerful type and
    module systems.</para>

    <para>If you already know OCaml, this book may surprise you. Core redefines most of the standard
      namespace to make better use of the OCaml module system and expose a number of powerful,
      reusable data structures by default. Older OCaml code will still interoperate with Core, but
      you may need to adapt it for maximal benefit. All the new code that we write uses Core, and we
      believe the Core model is worth learning; it's been successfully used on large,
      multimillion-line codebases and removes a big barrier to building sophisticated applications
      in OCaml.</para>

    <para>Code that uses only the traditional compiler standard library will
    always exist, but there are other online resources for learning how that
    works. <emphasis>Real World OCaml</emphasis> focuses on the techniques the
    authors have used in their personal experience to construct scalable,
    robust software systems.</para>

    <sect2 id="what-to-expect">
      <title>What to Expect</title>

      <para><emphasis>Real World OCaml</emphasis> is split into three
      parts:</para>

      <itemizedlist>
        <listitem>
          <para>Part I covers the language itself, opening with a guided tour
          designed to provide a quick sketch of the language. Don't expect to
          understand everything in the tour; it's meant to give you a taste of
          many different aspects of the language, but the ideas covered there
          will be explained in more depth in the chapters that follow.</para>

          <para>After covering the core language, Part I then moves onto more
          advanced features like modules, functors, and objects, which may
          take some time to digest. Understanding these concepts is important,
          though. These ideas will put you in good stead even beyond OCaml
          when switching to other modern languages, many of which have drawn
          inspiration from ML.</para>
        </listitem>

        <listitem>
          <para>Part II builds on the basics by working through useful tools and techniques for
            addressing common practical applications, from command-line parsing to asynchronous
            network programming. Along the way, you'll see how some of the <phrase role="keep-together">concepts</phrase> from Part I are glued together into real
            libraries and tools that combine different features of the language to good
            effect.</para>
        </listitem>

        <listitem>
          <para>Part III discusses OCaml's runtime system and compiler
          toolchain. It is remarkably simple when compared to some other
          language implementations (such as Java's or .NET's CLR). Reading
          this part will enable you to build very-high-performance systems, or
          to interface with C libraries. This is also where we talk about
          profiling and debugging techniques using tools such as GNU <command moreinfo="none">gdb</command>.</para>
        </listitem>
      </itemizedlist>
    </sect2>

    <sect2 id="installation-instructions">
      <title>Installation Instructions</title>

      <para><emphasis>Real World OCaml</emphasis> uses some tools that we've
      developed while writing this book. Some of these resulted in
      improvements to the OCaml compiler, which means that you will need to
      ensure that you have an up-to-date development environment (using the
      4.01 version of the compiler). The installation process is largely automated through the OPAM package manager.
      Instructions on how to it set up and what packages to install can be found at <ulink url="http://realworldocaml.org/install">this Real World OCaml page</ulink>.<indexterm class="singular">
          <primary>installation instructions</primary>
        </indexterm><indexterm class="singular">
          <primary>OCaml</primary>

          <secondary>installation instructions</secondary>
        </indexterm></para>

      <para>As of publication time, the Windows operating system is
      unsupported by Core, and so only Mac OS X, Linux, FreeBSD, and OpenBSD
      can be expected to work reliably. Please check the online installation
      instructions for updates regarding Windows, or install a Linux virtual
      machine to work through the book as it stands.<indexterm class="singular">
          <primary>OCaml</primary>

          <secondary>operating system support</secondary>
        </indexterm></para>

      <para>This book is not intended as a reference manual. We aim to teach
      you about the language and about libraries tools and techniques that
      will help you be a more effective OCaml programmer. But it's no
      replacement for API documentation or the OCaml manual and man pages. You
      can find documentation for all of the libraries and tools referenced in
      the book <ulink url="https://realworldocaml.org/doc">online</ulink>.</para>
    </sect2>

    <sect2 id="code-examples">
      <title>Code Examples</title>

      <para>All of the code examples in this book are available freely online
      under a public-domain-like license. You are most welcome to copy and use
      any of the snippets as you see fit in your own code, without any
      attribution or other restrictions on their use.<indexterm class="singular">
          <primary>OCaml</primary>

          <secondary>code examples for</secondary>
        </indexterm></para>

      <para>The code repository is available online at <ulink url="https://github.com/realworldocaml/examples"/>. Every code snippet in the book has a clickable
        header that tells you the filename in that repository to find the source code, shell script,
        or ancillary data file that the snippet was sourced from.</para>

      <para>If you feel your use of code examples falls outside fair use or
      the permission given above, feel free to contact us at
      <email>permissions@oreilly.com</email>.</para>
    </sect2>
  </sect1>

  <sect1>
    <title>Safari® Books Online</title>

    <note role="safarienabled">
      <para>Safari Books Online (<ulink role="orm:hideurl:ital" url="http://my.safaribooksonline.com/?portal=oreilly">www.safaribooksonline.com</ulink>)
      is an on-demand digital library that delivers expert <ulink role="orm:hideurl" url="http://www.safaribooksonline.com/content">content</ulink> in both
      book and video form from the world’s leading authors in technology and
      business. Technology professionals, software developers, web designers,
      and business and creative professionals use Safari Books Online as their
      primary resource for research, problem solving, learning, and
      certification training.</para>
    </note>

    <para>Safari Books Online offers a range of <ulink role="orm:hideurl" url="http://www.safaribooksonline.com/subscriptions">product mixes</ulink>
    and pricing programs for <ulink role="orm:hideurl" url="http://www.safaribooksonline.com/organizations-teams">organizations</ulink>,
    <ulink role="orm:hideurl" url="http://www.safaribooksonline.com/government">government
    agencies</ulink>, and <ulink role="orm:hideurl" url="http://www.safaribooksonline.com/individuals">individuals</ulink>.
    Subscribers have access to thousands of books, training videos, and
    prepublication manuscripts in one fully searchable database from
    publishers like O’Reilly Media, Prentice Hall Professional, Addison-Wesley
    Professional, Microsoft Press, Sams, Que, Peachpit Press, Focal Press,
    Cisco Press, John Wiley &amp; Sons, Syngress, Morgan Kaufmann, IBM
    Redbooks, Packt, Adobe Press, FT Press, Apress, Manning, New Riders,
    McGraw-Hill, Jones &amp; Bartlett, Course Technology, and dozens <ulink role="orm:hideurl" url="http://www.safaribooksonline.com/publishers">more</ulink>. For more
    information about Safari Books Online, please visit us <ulink role="orm:hideurl" url="http://www.safaribooksonline.com/">online</ulink>.</para>
  </sect1>
<?hard-pagebreak?>
  <sect1>
    <title>How to Contact Us</title>

    <para>Please address comments and questions concerning this book to the
    publisher:</para>

    <simplelist type="vert">
      <member>O’Reilly Media, Inc.</member>

      <member>1005 Gravenstein Highway North</member>

      <member>Sebastopol, CA 95472</member>

      <member>800-998-9938 (in the United States or Canada)</member>

      <member>707-829-0515 (international or local)</member>

      <member>707-829-0104 (fax)</member>
    </simplelist>

    <para>We have a web page for this book, where we list errata, examples,
    and any additional information. You can access this page at:</para>

    <simplelist type="vert">
      <member><ulink url="http://oreil.ly/realworldOCaml"/></member>
    </simplelist>

    <para>To comment or ask technical questions about this book, send email
    to:</para>

    <simplelist type="vert">
      <member><email>bookquestions@oreilly.com</email></member>
    </simplelist>

    <para>For more information about our books, courses, conferences, and
    news, see our website at <ulink url="http://www.oreilly.com"/>.</para>

    <para>Find us on Facebook: <ulink url="http://facebook.com/oreilly"/></para>

    <para>Follow us on Twitter: <ulink url="http://twitter.com/oreillymedia"/></para>

    <para>Watch us on YouTube: <ulink url="http://www.youtube.com/oreillymedia"/></para>
  </sect1>

  <sect1>
    <title>Contributors</title>

    <para>We would especially like to thank the following individuals for
    improving <emphasis>Real World OCaml</emphasis>:</para>

    <itemizedlist>
      <listitem>
        <para>Leo White contributed greatly to the content and examples in
        <xref linkend="objects"/> and <xref linkend="classes"/>.</para>
      </listitem>

      <listitem>
        <para>Jeremy Yallop authored and documented the Ctypes library
        described in <xref linkend="foreign-function-interface"/>.</para>
      </listitem>

      <listitem>
        <para>Stephen Weeks is responsible for much of the modular architecture behind Core, and his
          extensive notes formed the basis of <xref linkend="memory-representation-of-values"/> and
            <xref linkend="understanding-the-garbage-collector"/>.</para>
      </listitem>
      <listitem>
        <para>Jeremie Dimino, the author of <emphasis>utop</emphasis>, the interactive command-line
          interface that is used throughout this book. We're particularly grateful for the changes
          that he pushed through to make <emphasis>utop</emphasis> work better in the context of the
          book. </para>
      </listitem>
      <listitem>
        <para>The many people who collectively submitted over 2400 comments to online drafts of this
          book, through whose efforts countless errors were found and fixed.</para>
      </listitem>
    </itemizedlist>
  </sect1>
</preface>

  <part>
  <title>Language Concepts</title>

  <partintro>
    <para>Part I covers the basic language concepts you'll need to know when building OCaml
      programs. It opens up with a guided tour to give you a quick overview of the language using an
      interactive command-line interface. The subsequent chapters cover the material that is touched
      upon by the tour in much more detail, including detailed coverage of OCaml's approach to
      imperative programming.</para>

    <para>The last few chapters introduce OCaml's powerful abstraction facilities. We start by using
      functors to build a library for programming with intervals, and then use first-class modules
      to build a type-safe plugin system. OCaml also supports object-oriented programming, and we
      close Part I with two chapters that cover the object system; the first showing how to use
      OCaml's objects directly, and the second showing how to use the class system to add more
      advanced features like inheritance. This description comes together in the design of a simple
      object-oriented graphics library.</para>
  </partintro>

  <chapter id="a-guided-tour">
  <title>A Guided Tour</title>

  <para>This chapter gives an overview of OCaml by walking through a series of
  small examples that cover most of the major features of the language. This
  should provide a sense of what OCaml can do, without getting too deep into
  any one topic.</para>

  <para>Throughout the book we're going to use Core, a more full-featured and capable replacement
    for OCaml's standard library. We'll also use <command moreinfo="none">utop</command>, a shell
    that lets you type in expressions and evaluate them interactively. <command moreinfo="none">utop</command> is an easier-to-use version of OCaml's standard toplevel (which you can start
    by typing <emphasis>ocaml</emphasis> at the command line). These instructions will assume you're
    using <command moreinfo="none">utop</command> specifically.</para>

  <para>Before getting started, make sure you have a working OCaml installation so you can try out
    the examples as you read through the chapter. </para>

  <sect1 id="ocaml-as-a-calculator">
    <title>OCaml as a Calculator</title>

    <para>The first thing you need to do when using Core is to open<indexterm class="singular">
        <primary>OCaml</primary>

        <secondary>numerical calculations in</secondary>
      </indexterm><indexterm class="singular">
        <primary>numerical calculations</primary>
      </indexterm><indexterm class="singular">
        <primary>Core standard library</primary>

        <secondary>opening</secondary>
      </indexterm> <literal moreinfo="none">Core.Std</literal>:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/guided-tour/main.topscript">OCaml utop</ulink></para>

    <programlisting format="linespecific" language="ocaml">$ utop

<prompt moreinfo="none"># </prompt><userinput moreinfo="none">open Core.Std;;</userinput>
</programlisting>

    <para>This makes the definitions in Core available and is required for
    many of the examples in the tour and in the remainder of the book.</para>

    <para>Now let's try a few simple numerical calculations:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/guided-tour/main.topscript">OCaml utop</ulink> (part 1)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">3 + 4;;</userinput>
<computeroutput moreinfo="none">- : int = 7</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">8 / 3;;</userinput>
<computeroutput moreinfo="none">- : int = 2</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">3.5 +. 6.;;</userinput>
<computeroutput moreinfo="none">- : float = 9.5</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">30_000_000 / 300_000;;</userinput>
<computeroutput moreinfo="none">- : int = 100</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">sqrt 9.;;</userinput>
<computeroutput moreinfo="none">- : float = 3.</computeroutput></programlisting>

    <para>By and large, this is pretty similar to what you'd find in any
    programming language, but a few things jump right out at you:</para>

    <itemizedlist>
      <listitem>
        <para>We needed to type <literal moreinfo="none">;;</literal> in order
        to tell the toplevel that it should evaluate an expression. This is a
        peculiarity of the toplevel that is not required in standalone
        programs (though it is sometimes helpful to include <literal moreinfo="none">;;</literal> to improve OCaml's error reporting, by
        making it more explicit where a given top-level declaration was
        intended to end).</para>
      </listitem>

      <listitem>
        <para>After evaluating an expression, the toplevel first prints the type of the result, and
          then prints the result itself.</para>
      </listitem>

      <listitem>
        <para>Function arguments are separated by spaces instead of by
        parentheses and commas, which is more like the UNIX shell than it is
        like traditional programming languages such as C or Java.</para>
      </listitem>

      <listitem>
        <para>OCaml allows you to place underscores in the middle of numeric literals to improve
          readability. Note that underscores can be placed anywhere within a number, not just every
          three digits.</para>
      </listitem>

      <listitem>
        <para>OCaml carefully distinguishes between <literal moreinfo="none">float</literal>, the
          type for floating-point numbers, and <literal moreinfo="none">int</literal>, the type for
          integers. The types have different literals (<literal moreinfo="none">6.</literal> instead
          of <literal moreinfo="none">6</literal>) and different infix operators (<literal moreinfo="none">+.</literal> instead of <literal moreinfo="none">+</literal>), and OCaml
          doesn't automatically cast between these types. This can be a bit of a nuisance, but it
          has its benefits, since it prevents some kinds of bugs that arise in other languages due
          to unexpected differences between the behavior of <literal moreinfo="none">int</literal>
          and <literal moreinfo="none">float</literal>. For example, in many languages, <literal moreinfo="none">1 / 3</literal> is zero, but <literal moreinfo="none">1 / 3.0</literal>
          is a third. OCaml requires you to be explicit about which operation you're doing.</para>
      </listitem>
    </itemizedlist>

    <para>We can also create a variable to name the value of a given
    expression, using the <literal moreinfo="none">let</literal> keyword. This
    is known as a <emphasis>let binding</emphasis>:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/guided-tour/main.topscript">OCaml utop</ulink> (part 2)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let x = 3 + 4;;</userinput>
<computeroutput moreinfo="none">val x : int = 7</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let y = x + x;;</userinput>
<computeroutput moreinfo="none">val y : int = 14</computeroutput></programlisting>

    <para>After a new variable is created, the toplevel tells us the name of
    the variable (<literal moreinfo="none">x</literal> or <literal moreinfo="none">y</literal>), in addition to its type (<literal moreinfo="none">int</literal>) and value (<literal moreinfo="none">7</literal> or <literal moreinfo="none">14</literal>).</para>

    <para>Note that there are some constraints on what identifiers can be used
    for variable names. Punctuation is excluded, except for <literal moreinfo="none">_</literal> and <literal moreinfo="none">'</literal>, and
    variables must start with a lowercase letter or an underscore. Thus, these
    are legal:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/guided-tour/main.topscript">OCaml utop</ulink> (part 3)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let x7 = 3 + 4;;</userinput>
<computeroutput moreinfo="none">val x7 : int = 7</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let x_plus_y = x + y;;</userinput>
<computeroutput moreinfo="none">val x_plus_y : int = 21</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let x' = x + 1;;</userinput>
<computeroutput moreinfo="none">val x' : int = 8</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let _x' = x' + x';;</userinput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">_x';;</userinput>
<computeroutput moreinfo="none">- : int = 16</computeroutput></programlisting>

    <para>Note that by default, <command moreinfo="none">utop</command>
    doesn't bother to print out variables starting with an underscore.</para>

    <para>The following examples, however, are not legal:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/guided-tour/main.topscript">OCaml utop</ulink> (part 4) </para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let Seven = 3 + 4;;</userinput>
<computeroutput moreinfo="none">Characters 4-9:</computeroutput>
<computeroutput moreinfo="none">Error: Unbound constructor Seven</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let 7x = 7;;</userinput>
<computeroutput moreinfo="none">Characters 5-10:</computeroutput>
<computeroutput moreinfo="none">Error: This expression should not be a function, the expected type is</computeroutput>
<computeroutput moreinfo="none">int</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let x-plus-y = x + y;;</userinput>
<computeroutput moreinfo="none">Characters 4-5:</computeroutput>
<computeroutput moreinfo="none">Error: Parse error: [fun_binding] expected after [ipatt] (in [let_binding])</computeroutput></programlisting>

    <para>The error messages here are a little confusing, but they'll make
    more sense as you learn more about the language.</para>
  </sect1>

  <sect1 id="functions-and-type-inference">
    <title>Functions and Type Inference</title>

    <para>The <literal moreinfo="none">let</literal> syntax can also be used
    to define a function:<indexterm class="singular">
        <primary>let syntax</primary>

        <secondary>function definition with</secondary>
      </indexterm><indexterm class="singular">
        <primary>functions</primary>

        <secondary>defining</secondary>
      </indexterm></para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/guided-tour/main.topscript">OCaml utop</ulink> (part 5)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let square x = x * x ;;</userinput>
<computeroutput moreinfo="none">val square : int -&gt; int = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">square 2;;</userinput>
<computeroutput moreinfo="none">- : int = 4</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">square (square 2);;</userinput>
<computeroutput moreinfo="none">- : int = 16</computeroutput></programlisting>

    <para>Functions in OCaml are values like any other, which is why we use
    the <literal moreinfo="none">let</literal> keyword to bind a function to a
    variable name, just as we use <literal moreinfo="none">let</literal> to
    bind a simple value like an integer to a variable name. When using
    <literal moreinfo="none">let</literal> to define a function, the first
    identifier after the <literal moreinfo="none">let</literal> is the
    function name, and each subsequent identifier is a different argument to
    the function. Thus, <literal moreinfo="none">square</literal> is a
    function with a single argument.</para>

    <para>Now that we're creating more interesting values like functions, the
    types have gotten more interesting too. <literal moreinfo="none">int -&gt;
    int</literal> is a function type, in this case indicating a function that
    takes an <literal moreinfo="none">int</literal> and returns an <literal moreinfo="none">int</literal>. We can also write functions that take
    multiple arguments. (Note that the following example will not work if you
    haven't opened <literal moreinfo="none">Core.Std</literal> as was
    suggested earlier.)<indexterm class="singular">
        <primary>multi-argument functions</primary>
      </indexterm><indexterm class="singular">
        <primary>functions</primary>

        <secondary>with multiple arguments</secondary>
      </indexterm></para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/guided-tour/main.topscript">OCaml utop</ulink> (part 6)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let ratio x y =</userinput>
<userinput moreinfo="none">     Float.of_int x /. Float.of_int y</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val ratio : int -&gt; int -&gt; float = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">ratio 4 7;;</userinput>
<computeroutput moreinfo="none">- : float = 0.571428571429</computeroutput></programlisting>

    <para>The preceding example also happens to be our first use of modules.
    Here, <literal moreinfo="none">Float.of_int</literal> refers to the
    <literal moreinfo="none">of_int</literal> function contained in the
    <literal moreinfo="none">Float</literal> module. This is different from
    what you might expect from an object-oriented language, where dot-notation
    is typically used for accessing a method of an object. Note that module
    names always start with a capital letter.</para>

    <para>The notation for the type-signature of a multiargument function may
    be a little surprising at first, but we'll explain where it comes from
    when we get to function currying in <xref linkend="multi-argument-functions"/>. For the moment, think of the arrows
    as separating different arguments of the function, with the type after the
    final arrow being the return value. Thus, <literal moreinfo="none">int
    -&gt; int -&gt; float</literal> describes a function that takes two
    <literal moreinfo="none">int</literal> arguments and returns a <literal moreinfo="none">float</literal>.</para>

    <para>We can also write functions that take other functions as arguments.
    Here's an example of a function that takes three arguments: a test
    function and two integer arguments. The function returns the sum of the
    integers that pass the test:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/guided-tour/main.topscript">OCaml utop</ulink>  (part 7)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let sum_if_true test first second =</userinput>
<userinput moreinfo="none">    (if test first then first else 0)</userinput>
<userinput moreinfo="none">    + (if test second then second else 0)</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val sum_if_true : (int -&gt; bool) -&gt; int -&gt; int -&gt; int = &lt;fun&gt;</computeroutput></programlisting>

    <para>If we look at the inferred type signature in detail, we see that the
    first argument is a function that takes an integer and returns a boolean,
    and that the remaining two arguments are integers. Here's an example of
    this function in action:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/guided-tour/main.topscript">OCaml utop</ulink> (part 8)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let even x =</userinput>
<userinput moreinfo="none">    x mod 2 = 0 ;;</userinput>
<computeroutput moreinfo="none">val even : int -&gt; bool = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">sum_if_true even 3 4;;</userinput>
<computeroutput moreinfo="none">- : int = 4</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">sum_if_true even 2 4;;</userinput>
<computeroutput moreinfo="none">- : int = 6</computeroutput></programlisting>

    <para>Note that in the definition of <literal moreinfo="none">even</literal>, we used <literal moreinfo="none">=</literal> in two different ways: once as the part of the
    <literal>let</literal> binding that separates the thing being defined from
    its definition; and once as an equality test, when comparing <literal moreinfo="none">x mod 2</literal> to <literal moreinfo="none">0</literal>.
    These are very different operations despite the fact that they share some
    syntax.</para>

    <sect2 id="type-inference">
      <title>Type Inference</title>

      <para>As the types we encounter get more complicated, you might ask
      yourself how OCaml is able to figure them out, given that we didn't
      write down any explicit type information.<indexterm class="singular">
          <primary>type inference</primary>

          <secondary>process of</secondary>
        </indexterm></para>

      <para>OCaml determines the type of an expression using a technique called <emphasis>type
          inference</emphasis>, by which the type of an expression is inferred from the available
        type information about the components of that expression.</para>

      <para>As an example, let's walk through the process of inferring the
      type of <literal moreinfo="none">sum_if_true</literal>:</para>

      <orderedlist>
        <listitem>
          <para>OCaml requires that both branches of an <literal moreinfo="none">if</literal> statement have the same type, so the
          expression <literal moreinfo="none">if test first then first else
          0</literal> requires that <literal moreinfo="none">first</literal>
          must be the same type as <literal moreinfo="none">0</literal>, and
          so <literal moreinfo="none">first</literal> must be of type <literal moreinfo="none">int</literal>. Similarly, from <literal moreinfo="none">if test second then second else 0</literal> we can
          infer that <literal moreinfo="none">second</literal> has type
          <literal moreinfo="none">int</literal>.</para>
        </listitem>

        <listitem>
          <para><literal moreinfo="none">test</literal> is passed <literal moreinfo="none">first</literal> as an argument. Since <literal moreinfo="none">first</literal> has type <literal moreinfo="none">int</literal>, the input type of <literal moreinfo="none">test</literal> must be <literal moreinfo="none">int</literal>.</para>
        </listitem>

        <listitem>
          <para><literal moreinfo="none">test first</literal> is used as the
          condition in an <literal moreinfo="none">if</literal> statement, so
          the return type of <literal moreinfo="none">test</literal> must be
          <literal moreinfo="none">bool</literal>.</para>
        </listitem>

        <listitem>
          <para>The fact that <literal moreinfo="none">+</literal> returns
          <literal moreinfo="none">int</literal> implies that the return value
          of <literal moreinfo="none">sum_if_true</literal> must be
          int.</para>
        </listitem>
      </orderedlist>

      <para>Together, that nails down the types of all the variables, which
      determines the overall type of <literal moreinfo="none">sum_if_true</literal>.</para>

      <para>Over time, you'll build a rough intuition for how the OCaml
      inference engine works, which makes it easier to reason through your
      programs. You can make it easier to understand the types of a given
      expression by adding explicit type annotations. These annotations don't
      change the behavior of an OCaml program, but they can serve as useful
      documentation, as well as catch unintended type changes. They can also
      be helpful in figuring out why a given piece of code fails to
      compile.</para>

      <para>Here's an annotated version of <literal moreinfo="none">sum_if_true</literal>:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/guided-tour/main.topscript">OCaml utop</ulink> (part 9)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let sum_if_true (test : int -&gt; bool) (x : int) (y : int) : int =</userinput>
<userinput moreinfo="none">     (if test x then x else 0)</userinput>
<userinput moreinfo="none">     + (if test y then y else 0)</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val sum_if_true : (int -&gt; bool) -&gt; int -&gt; int -&gt; int = &lt;fun&gt;</computeroutput></programlisting>

      <para>In the above, we've marked every argument to the function with its
      type, with the final annotation indicating the type of the return value.
      Such type annotations can be placed on any expression in an OCaml
      program:</para>
    </sect2>

    <sect2 id="inferring-generic-types">
      <title>Inferring Generic Types</title>

      <para>Sometimes, there isn't enough information to fully determine the
      concrete type of a given value. Consider this function.<indexterm class="singular">
          <primary>type inference</primary>

          <secondary>generic types</secondary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/guided-tour/main.topscript">OCaml utop</ulink> (part 10)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let first_if_true test x y =</userinput>
<userinput moreinfo="none">    if test x then x else y</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val first_if_true : ('a -&gt; bool) -&gt; 'a -&gt; 'a -&gt; 'a = &lt;fun&gt;</computeroutput></programlisting>

      <para><literal moreinfo="none">first_if_true</literal> takes as its
      arguments a function <literal moreinfo="none">test</literal>, and two
      values, <literal moreinfo="none">x</literal> and <literal moreinfo="none">y</literal>, where <literal moreinfo="none">x</literal>
      is to be returned if <literal moreinfo="none">test x</literal> evaluates
      to <literal moreinfo="none">true</literal>, and <literal moreinfo="none">y</literal> otherwise. So what's the type of <literal moreinfo="none">first_if_true</literal>? There are no obvious clues such
      as arithmetic operators or literals to tell you what the type of
      <literal moreinfo="none">x</literal> and <literal moreinfo="none">y</literal> are. That makes it seem like one could use
      <literal moreinfo="none">first_if_true</literal> on values of any
      type.</para>

      <para>Indeed, if we look at the type returned by the toplevel, we see that rather than choose
        a single concrete type, OCaml has introduced a <emphasis>type variable</emphasis>
        <literal moreinfo="none">'a</literal> to express that the type is generic. (You can tell
        it's a type variable by the leading single quote mark.) In particular, the type of the
          <literal moreinfo="none">test</literal> argument is <literal moreinfo="none">('a -&gt;
          bool)</literal>, which means that <literal moreinfo="none">test</literal> is a
        one-argument function whose return value is <literal moreinfo="none">bool</literal> and
        whose argument could be of any type <literal moreinfo="none">'a</literal>. But, whatever
        type <literal moreinfo="none">'a</literal> is, it has to be the same as the type of the
        other two arguments, <literal moreinfo="none">x</literal> and <literal moreinfo="none">y</literal>, and of the return value of <literal moreinfo="none">first_if_true</literal>.
        This kind of genericity is called <emphasis>parametric polymorphism</emphasis> because it
        works by parameterizing the type in question with a type variable. It is very similar to
        generics in C# and Java.<indexterm class="singular">
          <primary>parametric polymorphism</primary>
        </indexterm><indexterm class="singular">
          <primary>type variables</primary>
        </indexterm></para>

      <para>The generic type of <literal moreinfo="none">first_if_true</literal> allows us to write this:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/guided-tour/main.topscript">OCaml utop</ulink> (part 11)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let long_string s = String.length s &gt; 6;;</userinput>
<computeroutput moreinfo="none">val long_string : string -&gt; bool = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">first_if_true long_string "short" "loooooong";;</userinput>
<computeroutput moreinfo="none">- : string = "loooooong"</computeroutput></programlisting>

      <para>As well as this:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/guided-tour/main.topscript">OCaml utop</ulink> (part 12)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let big_number x = x &gt; 3;;</userinput>
<computeroutput moreinfo="none">val big_number : int -&gt; bool = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">first_if_true big_number 4 3;;</userinput>
<computeroutput moreinfo="none">- : int = 4</computeroutput></programlisting>

      <para>Both <literal moreinfo="none">long_string</literal> and <literal moreinfo="none">big_number</literal> are functions, and each is passed
      to <literal moreinfo="none">first_if_true</literal> with two other
      arguments of the appropriate type (strings in the first example, and
      integers in the second). But we can't mix and match two different
      concrete types for <literal moreinfo="none">'a</literal> in the same use
      of <literal moreinfo="none">first_if_true</literal>:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/guided-tour/main.topscript">OCaml utop</ulink> (part 13)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">first_if_true big_number "short" "loooooong";;</userinput>
<computeroutput moreinfo="none">Characters 25-32:</computeroutput>
<computeroutput moreinfo="none">Error: This expression has type string but an expression was expected of type</computeroutput>
<computeroutput moreinfo="none">         int</computeroutput></programlisting>

      <para>In this example, <literal moreinfo="none">big_number</literal>
      requires that <literal moreinfo="none">'a</literal> be instantiated as
      <literal moreinfo="none">int</literal>, whereas <literal moreinfo="none">"short"</literal> and <literal moreinfo="none">"loooooong"</literal> require that <literal moreinfo="none">'a</literal> be instantiated as <literal moreinfo="none">string</literal>, and they can't both be right at the
      same time.</para>

      <note>
        <title>Type Errors Versus Exceptions</title>

        <para>There's a big difference in OCaml (and really in any compiled
        language) between errors that are caught at compile time and those
        that are caught at runtime. It's better to catch errors as early as
        possible in the development process, and compilation time is best of
        all.<indexterm class="singular">
            <primary>runtime exceptions vs. type errors</primary>
          </indexterm><indexterm class="singular">
            <primary>errors</primary>

            <secondary>runtime vs. compile time</secondary>
          </indexterm><indexterm class="singular">
            <primary>exceptions</primary>

            <secondary>vs. type errors</secondary>
          </indexterm><indexterm class="singular">
            <primary>type errors vs. exceptions</primary>
          </indexterm></para>

        <para>Working in the toplevel somewhat obscures the difference between
        runtime and compile-time errors, but that difference is still there.
        Generally, type errors like this one:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/guided-tour/main.topscript">OCaml utop</ulink> (part 14)</para>

        <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let add_potato x =</userinput>
<userinput moreinfo="none">     x + "potato";;</userinput>
<computeroutput moreinfo="none">Characters 28-36:</computeroutput>
<computeroutput moreinfo="none">Error: This expression has type string but an expression was expected of type</computeroutput>
<computeroutput moreinfo="none">         int</computeroutput></programlisting>

        <para>are compile-time errors (because <literal moreinfo="none">+</literal> requires that both its arguments be of
        type <literal moreinfo="none">int</literal>), whereas errors that
        can't be caught by the type system, like division by zero, lead to
        runtime exceptions:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/guided-tour/main.topscript">OCaml utop</ulink> (part 15)</para>

        <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let is_a_multiple x y =</userinput>
<userinput moreinfo="none">     x mod y = 0 ;;</userinput>
<computeroutput moreinfo="none">val is_a_multiple : int -&gt; int -&gt; bool = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">is_a_multiple 8 2;;</userinput>
<computeroutput moreinfo="none">- : bool = true</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">is_a_multiple 8 0;;</userinput>
<computeroutput moreinfo="none">Exception: Division_by_zero.</computeroutput></programlisting>

        <para>The distinction here is that type errors will stop you whether
        or not the offending code is ever actually executed. Merely defining
        <literal moreinfo="none">add_potato</literal> is an error, whereas
        <literal moreinfo="none">is_a_multiple</literal> only fails when it's
        called, and then, only when it's called with an input that triggers
        the exception.</para>
      </note>
    </sect2>
  </sect1>

  <sect1 id="tuples-lists-options-and-pattern-matching">
    <title>Tuples, Lists, Options, and Pattern Matching</title>

    <sect2 id="tuples">
      <title>Tuples</title>

      <para>So far we've encountered a handful of basic types like <literal moreinfo="none">int</literal>, <literal moreinfo="none">float</literal>,
      and <literal moreinfo="none">string</literal>, as well as function types
      like <literal moreinfo="none">string -&gt; int</literal>. But we haven't
      yet talked about any data structures. We'll start by looking at a
      particularly simple data structure, the tuple. A tuple is an ordered
      collection of values that can each be of a different type. You can
      create a tuple by joining values together with a comma:<indexterm class="singular">
          <primary>tuples</primary>
        </indexterm><indexterm class="singular">
          <primary>data structures</primary>

          <secondary>tuples</secondary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/guided-tour/main.topscript">OCaml utop</ulink> (part 16)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let a_tuple = (3,"three");;</userinput>
<computeroutput moreinfo="none">val a_tuple : int * string = (3, "three")</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let another_tuple = (3,"four",5.);;</userinput>
<computeroutput moreinfo="none">val another_tuple : int * string * float = (3, "four", 5.)</computeroutput></programlisting>

      <para>(For the mathematically inclined, the <literal moreinfo="none">*</literal> character is used because the set of all
      pairs of type <literal moreinfo="none">t * s</literal> corresponds to
      the Cartesian product of the set of elements of type <literal moreinfo="none">t</literal> and the set of elements of type <literal moreinfo="none">s</literal>.)</para>

      <para>You can extract the components of a tuple using OCaml's
      pattern-matching syntax, as shown below:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/guided-tour/main.topscript">OCaml utop</ulink> (part 17)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let (x,y) = a_tuple;;</userinput>
<computeroutput moreinfo="none">val x : int = 3</computeroutput>
<computeroutput moreinfo="none">val y : string = "three"</computeroutput></programlisting>

      <para>Here, the <literal moreinfo="none">(x,y)</literal> on the lefthand side of the <literal moreinfo="none">let</literal> binding is the pattern. This pattern lets us mint the new
        variables <literal moreinfo="none">x</literal> and <literal moreinfo="none">y</literal>,
        each bound to different components of the value being matched. These can now be used in
        subsequent expressions:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/guided-tour/main.topscript">OCaml utop</ulink> (part 18)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">x + String.length y;;</userinput>
<computeroutput moreinfo="none">- : int = 8</computeroutput></programlisting>

      <para>Note that the same syntax is used both for constructing and for
      pattern matching on tuples.</para>

      <para>Pattern matching can also show up in function arguments. Here's a
      function for computing the distance between two points on the plane,
      where each point is represented as a pair of <literal moreinfo="none">float</literal>s. The pattern-matching syntax lets us
      get at the values we need with a minimum of fuss:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/guided-tour/main.topscript">OCaml utop</ulink> (part 19)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let distance (x1,y1) (x2,y2) =</userinput>
<userinput moreinfo="none">    sqrt ((x1 -. x2) ** 2. +. (y1 -. y2) ** 2.)</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val distance : float * float -&gt; float * float -&gt; float = &lt;fun&gt;</computeroutput></programlisting>

      <para>The <literal moreinfo="none">**</literal> operator used above is
      for raising a floating-point number to a power.</para>

      <para>This is just a first taste of pattern matching. Pattern matching
      is a pervasive tool in OCaml, and as you'll see, it has surprising
      power.</para>
    </sect2>

    <sect2 id="lists">
      <title>Lists</title>

      <para>Where tuples let you combine a fixed number of items, potentially
      of different types, lists let you hold any number of items of the same
      type. Consider the following example:<indexterm class="startofrange" id="DSlists">
          <primary>data structures</primary>

          <secondary>lists</secondary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/guided-tour/main.topscript">OCaml utop</ulink> (part 20)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let languages = ["OCaml";"Perl";"C"];;</userinput>
<computeroutput moreinfo="none">val languages : string list = ["OCaml"; "Perl"; "C"]</computeroutput></programlisting>

      <para>Note that you can't mix elements of different types in the same
      list, unlike tuples:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/guided-tour/main.topscript">OCaml utop</ulink> (part 21)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let numbers = [3;"four";5];;</userinput>
<computeroutput moreinfo="none">Characters 17-23:</computeroutput>
<computeroutput moreinfo="none">Error: This expression has type string but an expression was expected of type</computeroutput>
<computeroutput moreinfo="none">         int</computeroutput></programlisting>

      <sect3 id="the-list-module">
        <title>The List module</title>

        <para>Core comes with a <literal moreinfo="none">List</literal> module
        that has a rich collection of functions for working with lists. We can
        access values from within a module by using dot notation. For example,
        this is how we compute the length of a list:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/guided-tour/main.topscript">OCaml utop</ulink> (part 22)</para>

        <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">List.length languages;;</userinput>
<computeroutput moreinfo="none">- : int = 3</computeroutput></programlisting>

        <para>Here's something a little more complicated. We can compute the
        list of the lengths of each language as follows:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/guided-tour/main.topscript">OCaml utop</ulink> (part 23)</para>

        <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">List.map languages ~f:String.length;;</userinput>
<computeroutput moreinfo="none">- : int list = [5; 4; 1]</computeroutput></programlisting>

        <para><literal moreinfo="none">List.map</literal> takes two arguments:
        a list and a function for transforming the elements of that list. It
        returns a new list with the transformed elements and does not modify
        the original list.</para>

        <para>Notably, the function passed to <literal moreinfo="none">List.map</literal> is passed under a <emphasis>labeled
        argument</emphasis> <literal moreinfo="none">~f</literal>. Labeled
        arguments are specified by name rather than by position, and thus
        allow you to change the order in which arguments are presented to a
        function without changing its behavior, as you can see here:<indexterm class="singular">
            <primary>arguments</primary>

            <secondary>labeled arguments</secondary>
          </indexterm><indexterm class="singular">
            <primary>labeled arguments</primary>
          </indexterm></para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/guided-tour/main.topscript">OCaml utop</ulink> (part 24)</para>

        <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">List.map ~f:String.length languages;;</userinput>
<computeroutput moreinfo="none">- : int list = [5; 4; 1]</computeroutput></programlisting>

        <para>We'll learn more about labeled arguments and why they're
        important in <xref linkend="variables-and-functions"/>.</para>
      </sect3>

      <sect3 id="constructing-lists-with">
        <title>Constructing lists with ::</title>

        <para>In addition to constructing lists using brackets, we can use the
        operator <literal moreinfo="none">::</literal> for adding elements to
        the front of a list:<indexterm class="singular">
            <primary>operators</primary>

            <secondary>: : operator</secondary>
          </indexterm><indexterm class="singular">
            <primary>lists</primary>

            <secondary>operator : :</secondary>
          </indexterm></para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/guided-tour/main.topscript">OCaml utop</ulink> (part 25)</para>

        <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">"French" :: "Spanish" :: languages;;</userinput>
<computeroutput moreinfo="none">- : string list = ["French"; "Spanish"; "OCaml"; "Perl"; "C"]</computeroutput></programlisting>

        <para>Here, we're creating a new and extended list, not changing the list we started with,
          as you can see below:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/guided-tour/main.topscript">OCaml utop</ulink> (part 26)</para>

        <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">languages;;</userinput>
<computeroutput moreinfo="none">- : string list = ["OCaml"; "Perl"; "C"]</computeroutput></programlisting>

        <note>
          <title>Semicolons Versus Commas</title>

          <para>Unlike many other languages, OCaml uses semicolons to separate
          list elements in lists rather than commas. Commas, instead, are used
          for separating elements in a tuple. If you try to use commas in a
          list, you'll see that your code compiles but doesn't do quite what
          you might expect:<indexterm class="singular">
              <primary>commas vs. semicolons</primary>
            </indexterm><indexterm class="singular">
              <primary>semicolons vs. commas</primary>
            </indexterm></para>

          <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/guided-tour/main.topscript">OCaml utop</ulink> (part 27)</para>

          <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">["OCaml", "Perl", "C"];;</userinput>
<computeroutput moreinfo="none">- : (string * string * string) list = [("OCaml", "Perl", "C")]</computeroutput></programlisting>

          <para>In particular, rather than a list of three strings, what we
          have is a singleton list containing a three-tuple of strings.</para>

          <para>This example uncovers the fact that commas create a tuple,
          even if there are no surrounding parens. So, we can write:</para>

          <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/guided-tour/main.topscript">OCaml utop</ulink> (part 28)</para>

          <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">1,2,3;;</userinput>
<computeroutput moreinfo="none">- : int * int * int = (1, 2, 3)</computeroutput></programlisting>

          <para>to allocate a tuple of integers. This is generally considered
          poor style and should be avoided.</para>
        </note>

        <para>The bracket notation for lists is really just syntactic sugar
        for <literal moreinfo="none">::</literal>. Thus, the following
        declarations are all equivalent. Note that <literal moreinfo="none">[]</literal> is used to represent the empty list and
        that <literal moreinfo="none">::</literal> is
        right-associative:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/guided-tour/main.topscript">OCaml utop</ulink>
        (part 29)</para>

        <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">[1; 2; 3];;</userinput>
<computeroutput moreinfo="none">- : int list = [1; 2; 3]</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">1 :: (2 :: (3 :: []));;</userinput>
<computeroutput moreinfo="none">- : int list = [1; 2; 3]</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">1 :: 2 :: 3 :: [];;</userinput>
<computeroutput moreinfo="none">- : int list = [1; 2; 3]</computeroutput></programlisting>

        <para>The <literal moreinfo="none">::</literal> operator can only be
        used for adding one element to the front of the list, with the list
        terminating at <literal moreinfo="none">[]</literal>, the empty list.
        There's also a list concatenation operator, <literal moreinfo="none">@</literal>, which can concatenate two lists:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/guided-tour/main.topscript">OCaml utop</ulink>
        (part 30)</para>

        <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">[1;2;3] @ [4;5;6];;</userinput>
<computeroutput moreinfo="none">- : int list = [1; 2; 3; 4; 5; 6]</computeroutput></programlisting>

        <para>It's important to remember that, unlike <literal moreinfo="none">::</literal>, this is not a constant-time operation.
        Concatenating two lists takes time proportional to the length of the
        first list.</para>
      </sect3>

      <sect3 id="list-patterns-using-match">
        <title>List patterns using match</title>

        <para>The elements of a list can be accessed through pattern matching.
        List patterns are based on the two list constructors, <literal moreinfo="none">[]</literal> and <literal moreinfo="none">::</literal>. Here's a simple example:<indexterm class="singular">
            <primary>pattern matching</primary>

            <secondary sortas="lists">in lists</secondary>
          </indexterm><indexterm class="singular">
            <primary>lists</primary>

            <secondary>pattern matching</secondary>
          </indexterm></para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/guided-tour/main.topscript">OCaml utop</ulink>
        (part 31)</para>

        <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let my_favorite_language (my_favorite :: the_rest) =</userinput>
<userinput moreinfo="none">     my_favorite</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">Characters 25-69:</computeroutput>
<computeroutput moreinfo="none">Warning 8: this pattern-matching is not exhaustive.</computeroutput>
<computeroutput moreinfo="none">Here is an example of a value that is not matched:</computeroutput>
<computeroutput moreinfo="none">[]</computeroutput>
<computeroutput moreinfo="none">val my_favorite_language : 'a list -&gt; 'a = &lt;fun&gt;</computeroutput></programlisting>

        <para>By pattern matching using <literal moreinfo="none">::</literal>,
        we've isolated and named the first element of the list (<literal moreinfo="none">my_favorite</literal>) and the remainder of the list
        (<literal moreinfo="none">the_rest</literal>). If you know Lisp or
        Scheme, what we've done is the equivalent of using the functions
        <literal moreinfo="none">car</literal> and <literal moreinfo="none">cdr</literal> to isolate the first element of a list
        and the remainder of that list.</para>

        <para>As you can see, however, the toplevel did not like this
        definition and spit out a warning indicating that the pattern is not
        exhaustive. This means that there are values of the type in question
        that won't be captured by the pattern. The warning even gives an
        example of a value that doesn't match the provided pattern, in
        particular, <literal moreinfo="none">[]</literal>, the empty list. If
        we try to run <literal moreinfo="none">my_favorite_language</literal>,
        we'll see that it works on nonempty list and fails on empty
        ones:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/guided-tour/main.topscript">OCaml utop</ulink>
        (part 32)</para>

        <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">my_favorite_language ["English";"Spanish";"French"];;</userinput>
<computeroutput moreinfo="none">- : string = "English"</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">my_favorite_language [];;</userinput>
<computeroutput moreinfo="none">Exception: (Match_failure //toplevel// 0 25).</computeroutput></programlisting>

        <para>You can avoid these warnings, and more importantly make sure
        that your code actually handles all of the possible cases, by using a
        <literal moreinfo="none">match</literal> statement instead.</para>

        <para>A <literal moreinfo="none">match</literal> statement is a kind
        of juiced-up version of the <literal>switch</literal> statement found
        in C and Java. It essentially lets you list a sequence of patterns,
        separated by pipe characters (|). (The one before the first case is
        optional.) The compiler then dispatches to the code following the
        first matching pattern. As we've already seen, the pattern can mint
        new variables that correspond to substructures of the value being
        matched.</para>

        <para>Here's a new version of <literal moreinfo="none">my_favorite_language</literal> that uses <literal moreinfo="none">match</literal> and doesn't trigger a compiler
        warning:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/guided-tour/main.topscript">OCaml utop</ulink>
        (part 33)</para>

        <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let my_favorite_language languages =</userinput>
<userinput moreinfo="none">    match languages with</userinput>
<userinput moreinfo="none">    | first :: the_rest -&gt; first</userinput>
<userinput moreinfo="none">    | [] -&gt; "OCaml" (* A good default! *)</userinput>
<userinput moreinfo="none"> ;;</userinput>
<computeroutput moreinfo="none">val my_favorite_language : string list -&gt; string = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">my_favorite_language ["English";"Spanish";"French"];;</userinput>
<computeroutput moreinfo="none">- : string = "English"</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">my_favorite_language [];;</userinput>
<computeroutput moreinfo="none">- : string = "OCaml"</computeroutput></programlisting>

        <para>The preceding code also includes our first comment. OCaml
        comments are bounded by <literal moreinfo="none">(*</literal> and
        <literal moreinfo="none">*)</literal> and can be nested arbitrarily
        and cover multiple lines. There's no equivalent of C++-style
        single-line comments that are prefixed by <literal moreinfo="none">//</literal>.</para>

        <para>The first pattern, <literal moreinfo="none">first ::
        the_rest</literal>, covers the case where <literal moreinfo="none">languages</literal> has at least one element, since
        every list except for the empty list can be written down with one or
        more <literal moreinfo="none">::</literal>'s. The second pattern,
        <literal moreinfo="none">[]</literal>, matches only the empty list.
        These cases are exhaustive, since every list is either empty or has at
        least one element, a fact that is verified by the compiler.</para>
      </sect3>

      <sect3 id="recursive-list-functions">
        <title>Recursive list functions</title>

        <para>Recursive functions, or functions that call themselves, are an
        important technique in OCaml and in any functional language. The
        typical approach to designing a recursive function is to separate the
        logic into a set of <emphasis>base cases</emphasis> that can be solved
        directly and a set of <emphasis>inductive cases</emphasis>, where the
        function breaks the problem down into smaller pieces and then calls
        itself to solve those smaller problems.<indexterm class="singular">
            <primary>recursive functions</primary>

            <secondary>list functions</secondary>
          </indexterm><indexterm class="singular">
            <primary>lists</primary>

            <secondary>recursive list functions</secondary>
          </indexterm></para>

        <para>When writing recursive list functions, this separation between
        the base cases and the inductive cases is often done using pattern
        matching. Here's a simple example of a function that sums the elements
        of a list:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/guided-tour/main.topscript">OCaml utop</ulink>
        (part 34)</para>

        <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let rec sum l =</userinput>
<userinput moreinfo="none">    match l with</userinput>
<userinput moreinfo="none">    | [] -&gt; 0                   (* base case *)</userinput>
<userinput moreinfo="none">    | hd :: tl -&gt; hd + sum tl   (* inductive case *)</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val sum : int list -&gt; int = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">sum [1;2;3];;</userinput>
<computeroutput moreinfo="none">- : int = 6</computeroutput></programlisting>

        <para>Following the common OCaml idiom, we use <literal moreinfo="none">hd</literal> to refer to the head of the list and
        <literal moreinfo="none">tl</literal> to refer to the tail. Note that
        we had to use the <literal moreinfo="none">rec</literal> keyword to
        allow <literal moreinfo="none">sum</literal> to refer to itself. As
        you might imagine, the base case and inductive case are different arms
        of the match.</para>

        <para>Logically, you can think of the evaluation of a simple recursive
        function like <literal moreinfo="none">sum</literal> almost as if it
        were a mathematical equation whose meaning you were unfolding step by
        step:</para>

        <para role="sourcecode">OCaml: <ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/guided-tour/recursion.ml">guided-tour/recursion.ml</ulink></para>

        <programlisting format="linespecific" language="ocaml">sum [1;2;3]
= 1 + sum [2;3]
= 1 + (2 + sum [3])
= 1 + (2 + (3 + sum []))
= 1 + (2 + (3 + 0))
= 1 + (2 + 3)
= 1 + 5
= 6</programlisting>

        <para>This suggests a reasonable mental model for what OCaml is
        actually doing to evaluate a recursive function.</para>

        <para>We can introduce more complicated list patterns as well. Here's
        a function for removing sequential duplicates:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/guided-tour/main.topscript">OCaml utop</ulink>
        (part 35)</para>

        <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let rec destutter list =</userinput>
<userinput moreinfo="none">    match list with</userinput>
<userinput moreinfo="none">    | [] -&gt; []</userinput>
<userinput moreinfo="none">    | hd1 :: hd2 :: tl -&gt;</userinput>
<userinput moreinfo="none">      if hd1 = hd2 then destutter (hd2 :: tl)</userinput>
<userinput moreinfo="none">      else hd1 :: destutter (hd2 :: tl)</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">Characters 29-171:</computeroutput>
<computeroutput moreinfo="none">Warning 8: this pattern-matching is not exhaustive.</computeroutput>
<computeroutput moreinfo="none">Here is an example of a value that is not matched:</computeroutput>
<computeroutput moreinfo="none">_::[]</computeroutput>
<computeroutput moreinfo="none">val destutter : 'a list -&gt; 'a list = &lt;fun&gt;</computeroutput></programlisting>

        <para>Again, the first arm of the match is the base case, and the
        second is the inductive. Unfortunately, this code has a problem, as is
        indicated by the warning message. In particular, we don't handle
        one-element lists. We can fix this warning by adding another case to
        the match:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/guided-tour/main.topscript">OCaml utop</ulink>
        (part 36)</para>

        <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let rec destutter list =</userinput>
<userinput moreinfo="none">    match list with</userinput>
<userinput moreinfo="none">    | [] -&gt; []</userinput>
<userinput moreinfo="none">    | [hd] -&gt; [hd]</userinput>
<userinput moreinfo="none">    | hd1 :: hd2 :: tl -&gt;</userinput>
<userinput moreinfo="none">      if hd1 = hd2 then destutter (hd2 :: tl)</userinput>
<userinput moreinfo="none">      else hd1 :: destutter (hd2 :: tl)</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val destutter : 'a list -&gt; 'a list = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">destutter ["hey";"hey";"hey";"man!"];;</userinput>
<computeroutput moreinfo="none">- : string list = ["hey"; "man!"]</computeroutput></programlisting>

        <para>Note that this code used another variant of the list pattern,
        <literal moreinfo="none">[hd]</literal>, to match a list with a single
        element. We can do this to match a list with any fixed number of
        elements; for example, <literal moreinfo="none">[x;y;z]</literal> will
        match any list with exactly three elements and will bind those
        elements to the variables <literal moreinfo="none">x</literal>,
        <literal moreinfo="none">y</literal>, and <literal moreinfo="none">z</literal>.</para>

        <para>In the last few examples, our list processing code involved a
        lot of recursive functions. In practice, this isn't usually necessary.
        Most of the time, you'll find yourself happy to use the iteration
        functions found in the <literal moreinfo="none">List</literal> module.
        But it's good to know how to use recursion when you need to do
        something new.<indexterm class="endofrange" startref="DSlists"/></para>
      </sect3>
    </sect2>

    <sect2 id="options">
      <title>Options</title>

      <para>Another common data structure in OCaml is the option. An option is
      used to express that a value might or might not be present. For
      example:<indexterm class="singular">
          <primary>options</primary>
        </indexterm><indexterm class="singular">
          <primary>data structures</primary>

          <secondary>options</secondary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/guided-tour/main.topscript">OCaml utop</ulink>
      (part 37)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let divide x y =</userinput>
<userinput moreinfo="none">    if y = 0 then None else Some (x/y) ;;</userinput>
<computeroutput moreinfo="none">val divide : int -&gt; int -&gt; int option = &lt;fun&gt;</computeroutput></programlisting>

      <para>The function <literal moreinfo="none">divide</literal> either returns <literal moreinfo="none">None</literal> if the divisor is zero, or <literal moreinfo="none">Some</literal> of the result of the division otherwise. <literal>Some</literal> and
          <literal>None</literal> are constructors that let you build optional values, just as
          <literal>::</literal> and <literal>[]</literal> let you build lists. You can think of an
        option as a specialized list that can only have zero or one elements.</para>

      <para>To examine the contents of an option, we use pattern matching, as
      we did with tuples and lists. Consider the following function for
      creating a log entry string given an optional time and a message. If no
      time is provided (i.e., if the time is <literal moreinfo="none">None</literal>), the current time is computed and used
      in its place:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/guided-tour/main.topscript">OCaml utop</ulink>
      (part 38)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let log_entry maybe_time message =</userinput>
<userinput moreinfo="none">    let time =</userinput>
<userinput moreinfo="none">      match maybe_time with</userinput>
<userinput moreinfo="none">      | Some x -&gt; x</userinput>
<userinput moreinfo="none">      | None -&gt; Time.now ()</userinput>
<userinput moreinfo="none">    in</userinput>
<userinput moreinfo="none">    Time.to_sec_string time ^ " -- " ^ message</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val log_entry : Time.t option -&gt; string -&gt; string = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">log_entry (Some Time.epoch) "A long long time ago";;</userinput>
<computeroutput moreinfo="none">- : string = "1970-01-01 01:00:00 -- A long long time ago"</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">log_entry None "Up to the minute";;</userinput>
<computeroutput moreinfo="none">- : string = "2013-08-18 14:48:08 -- Up to the minute"</computeroutput></programlisting>

      <para>This example uses Core's <literal moreinfo="none">Time</literal>
      module for dealing with time, as well as the <literal moreinfo="none">^</literal> operator for concatenating strings. The
      concatenation operator is provided as part of the <literal moreinfo="none">Pervasives</literal> module, which is automatically
      opened in every OCaml program.</para>

      <note>
        <title>Nesting lets with let and in</title>

        <para><literal moreinfo="none">log_entry</literal> was our first use of <literal moreinfo="none">let</literal> to define a new variable within the body of a function. A
            <literal moreinfo="none">let</literal> paired with an <literal moreinfo="none">in</literal> can be used to introduce a new binding within any local scope, including a
          function body. The <literal moreinfo="none">in</literal> marks the beginning of the scope
          within which the new variable can be used. Thus, we could write:<indexterm class="singular">
            <primary>let syntax</primary>
            <secondary>nested let binding</secondary>
          </indexterm></para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/guided-tour/local_let.topscript">OCaml utop</ulink></para>

        <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let x = 7 in</userinput>
<userinput moreinfo="none">  x + x</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">- : int = 14</computeroutput></programlisting>

        <para>Note that the scope of the <literal>let</literal> binding is
        terminated by the double-semicolon, so the value of <literal moreinfo="none">x</literal> is no longer available:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/guided-tour/local_let.topscript">OCaml utop</ulink>
        (part 1)</para>

        <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">x;;</userinput>
<computeroutput moreinfo="none">Characters -1-1:</computeroutput>
<computeroutput moreinfo="none">Error: Unbound value x</computeroutput></programlisting>

        <para>We can also have multiple <literal>let</literal> statements in a
        row, each one adding a new variable binding to what came
        before:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/guided-tour/local_let.topscript">OCaml utop</ulink>
        (part 2)</para>

        <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let x = 7 in</userinput>
<userinput moreinfo="none">  let y = x * x in</userinput>
<userinput moreinfo="none">  x + y</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">- : int = 56</computeroutput></programlisting>

        <para>This kind of nested <literal>let</literal> binding is a common
        way of building up a complex expression, with each <literal moreinfo="none">let</literal> naming some component, before combining
        them in one final expression.</para>
      </note>

      <para>Options are important because they are the standard way in OCaml
      to encode a value that might not be there; there's no such thing as a
      <literal moreinfo="none">NullPointerException</literal> in OCaml. This
      is different from most other languages, including Java and C#, where
      most if not all data types are <emphasis>nullable</emphasis>, meaning
      that, whatever their type is, any given value also contains the
      possibility of being a null value. In such languages, null is lurking
      everywhere.<indexterm class="singular">
          <primary>datatypes</primary>

          <secondary>nullable</secondary>
        </indexterm></para>

      <para>In OCaml, however, missing values are explicit. A value of type <literal moreinfo="none">string * string</literal> always contains two well-defined values of type <literal moreinfo="none">string</literal>. If you want to allow, say, the first of those to be
        absent, then you need to change the type to <literal moreinfo="none">string option *
          string</literal>. As we'll see in <xref linkend="error-handling"/>, this explicitness
        allows the compiler to provide a great deal of help in making sure you're correctly handling
        the possibility of missing data.</para>
    </sect2>
  </sect1>

  <sect1 id="records-and-variants">
    <title>Records and Variants</title>

    <para>So far, we've only looked at data structures that were predefined in
    the language, like lists and tuples. But OCaml also allows us to define
    new data types. Here's a toy example of a data type representing a point
    in two-dimensional space:<indexterm class="singular">
        <primary>datatypes</primary>

        <secondary>defining new</secondary>
      </indexterm></para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/guided-tour/main.topscript">OCaml utop</ulink>
    (part 41)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">type point2d = { x : float; y : float };;</userinput>
<computeroutput moreinfo="none">type point2d = { x : float; y : float; }</computeroutput></programlisting>

    <para><literal moreinfo="none">point2d</literal> is a
    <emphasis>record</emphasis> type, which you can think of as a tuple where
    the individual fields are named, rather than being defined positionally.
    Record types are easy enough to construct:<indexterm class="singular">
        <primary>records</primary>

        <secondary>record types</secondary>
      </indexterm><indexterm class="singular">
        <primary>datatypes</primary>

        <secondary>record types</secondary>
      </indexterm></para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/guided-tour/main.topscript">OCaml utop</ulink>
    (part 42)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let p = { x = 3.; y = -4. };;</userinput>
<computeroutput moreinfo="none">val p : point2d = {x = 3.; y = -4.}</computeroutput></programlisting>

    <para>And we can get access to the contents of these types using pattern
    matching:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/guided-tour/main.topscript">OCaml utop</ulink>
    (part 43)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let magnitude { x = x_pos; y = y_pos } =</userinput>
<userinput moreinfo="none">    sqrt (x_pos ** 2. +. y_pos ** 2.);;</userinput>
<computeroutput moreinfo="none">val magnitude : point2d -&gt; float = &lt;fun&gt;</computeroutput></programlisting>

    <para>The pattern match here binds the variable <literal moreinfo="none">x_pos</literal> to the value contained in the <literal moreinfo="none">x</literal> field, and the variable <literal moreinfo="none">y_pos</literal> to the value in the <literal moreinfo="none">y</literal> field.</para>

    <para>We can write this more tersely using what's called <emphasis>field punning</emphasis>. In
      particular, when the name of the field and the name of the variable it is bound to coincide,
      we don't have to write them both down. Using this, our magnitude function can be rewritten as
        follows:<indexterm class="singular">
        <primary>fields</primary>
        <secondary>field punning</secondary>
      </indexterm></para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/guided-tour/main.topscript">OCaml utop</ulink>
    (part 44)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let magnitude { x; y } = sqrt (x ** 2. +. y ** 2.);;</userinput>
<computeroutput moreinfo="none">val magnitude : point2d -&gt; float = &lt;fun&gt;</computeroutput></programlisting>

    <para>Alternatively, we can use dot notation for accessing record fields:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/guided-tour/main.topscript">OCaml utop</ulink>
    (part 45)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let distance v1 v2 =</userinput>
<userinput moreinfo="none">     magnitude { x = v1.x -. v2.x; y = v1.y -. v2.y };;</userinput>
<computeroutput moreinfo="none">val distance : point2d -&gt; point2d -&gt; float = &lt;fun&gt;</computeroutput></programlisting>

    <para>And we can of course include our newly defined types as components
    in larger types. Here, for example, are some types for modeling different
    geometric objects that contain values of type <literal moreinfo="none">point2d</literal>:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/guided-tour/main.topscript">OCaml utop</ulink>
    (part 46)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">type circle_desc  = { center: point2d; radius: float }</userinput>
<userinput moreinfo="none">  type rect_desc    = { lower_left: point2d; width: float; height: float }</userinput>
<userinput moreinfo="none">  type segment_desc = { endpoint1: point2d; endpoint2: point2d } ;;</userinput>
<computeroutput moreinfo="none">type circle_desc = { center : point2d; radius : float; }</computeroutput>
<computeroutput moreinfo="none">type rect_desc = { lower_left : point2d; width : float; height : float; }</computeroutput>
<computeroutput moreinfo="none">type segment_desc = { endpoint1 : point2d; endpoint2 : point2d; }</computeroutput></programlisting>

    <para>Now, imagine that you want to combine multiple objects of these
    types together as a description of a multiobject scene. You need some
    unified way of representing these objects together in a single type. One
    way of doing this is using a <emphasis>variant</emphasis> type:<indexterm class="singular">
        <primary>datatypes</primary>

        <secondary>variant types</secondary>
      </indexterm><indexterm class="singular">
        <primary>variant types</primary>

        <secondary>combining multiple object types with</secondary>
      </indexterm></para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/guided-tour/main.topscript">OCaml utop</ulink>
    (part 47)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">type scene_element =</userinput>
<userinput moreinfo="none">    | Circle  of circle_desc</userinput>
<userinput moreinfo="none">    | Rect    of rect_desc</userinput>
<userinput moreinfo="none">    | Segment of segment_desc</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">type scene_element =</computeroutput>
<computeroutput moreinfo="none">    Circle of circle_desc</computeroutput>
<computeroutput moreinfo="none">  | Rect of rect_desc</computeroutput>
<computeroutput moreinfo="none">  | Segment of segment_desc</computeroutput></programlisting>

    <para>The <literal moreinfo="none">|</literal> character separates the
    different cases of the variant (the first <literal moreinfo="none">|</literal> is optional), and each case has a capitalized
    tag, like <literal moreinfo="none">Circle</literal>, <literal moreinfo="none">Rect</literal> or <literal moreinfo="none">Segment</literal>, to distinguish that case from the
    others.</para>

    <para>Here's how we might write a function for testing whether a point is
    in the interior of some element of a list of <literal moreinfo="none">scene_element</literal>s:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/guided-tour/main.topscript">OCaml utop</ulink>
    (part 48)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let is_inside_scene_element point scene_element =</userinput>
<userinput moreinfo="none">     match scene_element with</userinput>
<userinput moreinfo="none">     | Circle { center; radius } -&gt;</userinput>
<userinput moreinfo="none">       distance center point &lt; radius</userinput>
<userinput moreinfo="none">     | Rect { lower_left; width; height } -&gt;</userinput>
<userinput moreinfo="none">       point.x    &gt; lower_left.x &amp;&amp; point.x &lt; lower_left.x +. width</userinput>
<userinput moreinfo="none">       &amp;&amp; point.y &gt; lower_left.y &amp;&amp; point.y &lt; lower_left.y +. height</userinput>
<userinput moreinfo="none">     | Segment { endpoint1; endpoint2 } -&gt; false</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val is_inside_scene_element : point2d -&gt; scene_element -&gt; bool = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let is_inside_scene point scene =</userinput>
<userinput moreinfo="none">     List.exists scene</userinput>
<userinput moreinfo="none">       ~f:(fun el -&gt; is_inside_scene_element point el)</userinput>
<userinput moreinfo="none">   ;;</userinput>
<computeroutput moreinfo="none">val is_inside_scene : point2d -&gt; scene_element list -&gt; bool = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">is_inside_scene {x=3.;y=7.}</userinput>
<userinput moreinfo="none">    [ Circle {center = {x=4.;y= 4.}; radius = 0.5 } ];;</userinput>
<computeroutput moreinfo="none">- : bool = false</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">is_inside_scene {x=3.;y=7.}</userinput>
<userinput moreinfo="none">    [ Circle {center = {x=4.;y= 4.}; radius = 5.0 } ];;</userinput>
<computeroutput moreinfo="none">- : bool = true</computeroutput></programlisting>

    <para>You might at this point notice that the use of <literal moreinfo="none">match</literal> here is reminiscent of how we used
    <literal moreinfo="none">match</literal> with <literal moreinfo="none">option</literal> and <literal moreinfo="none">list</literal>. This is no accident: <literal moreinfo="none">option</literal> and <literal moreinfo="none">list</literal> are really just examples of variant types
    that happen to be important enough to be defined in the standard library
    (and in the case of lists, to have some special syntax).</para>

    <para>We also made our first use of an <emphasis>anonymous
    function</emphasis> in the call to <literal moreinfo="none">List.exists</literal>. Anonymous functions are declared
    using the <literal moreinfo="none">fun</literal> keyword, and don't need
    to be explicitly named. Such functions are common in OCaml, particularly
    when using iteration functions like <literal moreinfo="none">List.exists</literal>.<indexterm class="singular">
        <primary>anonymous functions</primary>
      </indexterm><indexterm class="singular">
        <primary>functions</primary>

        <secondary>anonymous functions</secondary>
      </indexterm></para>

    <para>The purpose of <literal moreinfo="none">List.exists</literal> is to
    check if there are any elements of the list in question on which the
    provided function evaluates to <literal moreinfo="none">true</literal>. In
    this case, we're using <literal moreinfo="none">List.exists</literal> to
    check if there is a scene element within which our point resides.</para>
  </sect1>

  <sect1 id="imperative-programming">
    <title>Imperative Programming</title>

    <para>The code we've written so far has been almost entirely
    <emphasis>pure</emphasis> or <emphasis>functional</emphasis>, which
    roughly speaking means that the code in question doesn't modify variables
    or values as part of its execution. Indeed, almost all of the data
    structures we've encountered are <emphasis>immutable</emphasis>, meaning
    there's no way in the language to modify them at all. This is a quite
    different style from <emphasis>imperative</emphasis> programming, where
    computations are structured as sequences of instructions that operate by
    making modifications to the state of the program.<indexterm class="singular">
        <primary>functional code</primary>
      </indexterm><indexterm class="singular">
        <primary>pure code</primary>
      </indexterm><indexterm class="singular">
        <primary>data structures</primary>

        <secondary>immutable</secondary>
      </indexterm><indexterm class="singular">
        <primary>programming</primary>

        <secondary>immutable vs. imperative</secondary>
      </indexterm></para>

    <para>Functional code is the default in OCaml, with variable bindings and
    most data structures being immutable. But OCaml also has excellent support
    for imperative programming, including mutable data structures like arrays
    and hash tables, and control-flow constructs like <literal>for</literal>
    and <literal>while</literal> loops.</para>

    <sect2 id="arrays">
      <title>Arrays</title>

      <para>Perhaps the simplest mutable data structure in OCaml is the array.
      Arrays in OCaml are very similar to arrays in other languages like C:
      indexing starts at 0, and accessing or modifying an array element is a
      constant-time operation. Arrays are more compact in terms of memory
      utilization than most other data structures in OCaml, including lists.
      Here's an example:<indexterm class="singular">
          <primary>data structures</primary>

          <secondary>arrays</secondary>
        </indexterm><indexterm class="singular">
          <primary>arrays</primary>

          <secondary>imperative programming and</secondary>
        </indexterm><indexterm class="singular">
          <primary>imperative programming</primary>

          <secondary>arrays</secondary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/guided-tour/main.topscript">OCaml utop</ulink>
      (part 49)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let numbers = [| 1; 2; 3; 4 |];;</userinput>
<computeroutput moreinfo="none">val numbers : int array = [|1; 2; 3; 4|]</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">numbers.(2) &lt;- 4;;</userinput>
<computeroutput moreinfo="none">- : unit = ()</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">numbers;;</userinput>
<computeroutput moreinfo="none">- : int array = [|1; 2; 4; 4|]</computeroutput></programlisting>

      <para>The <literal moreinfo="none">.(i)</literal> syntax is used to
      refer to an element of an array, and the <literal moreinfo="none">&lt;-</literal> syntax is for modification. Because the
      elements of the array are counted starting at zero, element <phrase role="keep-together"><literal moreinfo="none">.(2)</literal> is</phrase>
      the third element.</para>

      <para>The <literal moreinfo="none">unit</literal> type that we see in the preceding code is
        interesting in that it has only one possible value, written <literal moreinfo="none">()</literal>. This means that a value of type <literal moreinfo="none">unit</literal>
        doesn't convey any information, and so is generally used as a placeholder. Thus, we use
          <literal moreinfo="none">unit</literal> for the return value of an operation like setting
        a mutable field that communicates by side effect rather than by returning a value. It's also
        used as the argument to functions that don't require an input value. This is similar to the
        role that <literal moreinfo="none">void</literal> plays in languages like C and Java.</para>
    </sect2>

    <sect2 id="mutable-record-fields">
      <title>Mutable Record Fields</title>

      <para>The array is an important mutable data structure, but it's not the only one. Records,
        which are immutable by default, can have some of their fields explicitly declared as
        mutable. Here's a small example of a data structure for storing a running statistical
        summary of a collection of numbers. <indexterm class="singular">
          <primary>imperative programming</primary>
          <secondary>mutable record fields</secondary>
        </indexterm><indexterm class="singular">
          <primary>mutable record fields</primary>
        </indexterm><indexterm class="singular">
          <primary>data structures</primary>
          <secondary>mutable record fields</secondary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/guided-tour/main.topscript">OCaml utop</ulink>
      (part 50)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">type running_sum =</userinput>
<userinput moreinfo="none">   { mutable sum: float;</userinput>
<userinput moreinfo="none">     mutable sum_sq: float; (* sum of squares *)</userinput>
<userinput moreinfo="none">     mutable samples: int;</userinput>
<userinput moreinfo="none">   }</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">type running_sum = {</computeroutput>
<computeroutput moreinfo="none">  mutable sum : float;</computeroutput>
<computeroutput moreinfo="none">  mutable sum_sq : float;</computeroutput>
<computeroutput moreinfo="none">  mutable samples : int;</computeroutput>
<computeroutput moreinfo="none">}</computeroutput></programlisting>

      <para>The fields in <literal moreinfo="none">running_sum</literal> are
      designed to be easy to extend incrementally, and sufficient to compute
      means and standard deviations, as shown in the following example. Note
      that there are two <literal>let</literal> bindings in a row without a
      double semicolon between them. That's because the double semicolon is
      required only to tell <emphasis>utop</emphasis> to process the input,
      not to separate two declarations:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/guided-tour/main.topscript">OCaml utop</ulink>
      (part 51)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let mean rsum = rsum.sum /. float rsum.samples</userinput>
<userinput moreinfo="none">  let stdev rsum =</userinput>
<userinput moreinfo="none">     sqrt (rsum.sum_sq /. float rsum.samples</userinput>
<userinput moreinfo="none">           -. (rsum.sum /. float rsum.samples) ** 2.) ;;</userinput>
<computeroutput moreinfo="none">val mean : running_sum -&gt; float = &lt;fun&gt;</computeroutput>
<computeroutput moreinfo="none">val stdev : running_sum -&gt; float = &lt;fun&gt;</computeroutput></programlisting>

      <para>We use the function <literal moreinfo="none">float</literal> above, which is a
        convenient equivalent of <literal moreinfo="none">Float.of_int</literal> provided by the
          <literal moreinfo="none">Pervasives</literal> library.</para>

      <para>We also need functions to create and update <literal moreinfo="none">running_sum</literal>s:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/guided-tour/main.topscript">OCaml utop</ulink>
      (part 52)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let create () = { sum = 0.; sum_sq = 0.; samples = 0 }</userinput>
<userinput moreinfo="none">  let update rsum x =</userinput>
<userinput moreinfo="none">     rsum.samples &lt;- rsum.samples + 1;</userinput>
<userinput moreinfo="none">     rsum.sum     &lt;- rsum.sum     +. x;</userinput>
<userinput moreinfo="none">     rsum.sum_sq  &lt;- rsum.sum_sq  +. x *. x</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val create : unit -&gt; running_sum = &lt;fun&gt;</computeroutput>
<computeroutput moreinfo="none">val update : running_sum -&gt; float -&gt; unit = &lt;fun&gt;</computeroutput></programlisting>

      <para><literal moreinfo="none">create</literal> returns a <literal moreinfo="none">running_sum</literal> corresponding to the empty set, and <literal moreinfo="none">update
          rsum x</literal> changes <literal moreinfo="none">rsum</literal> to reflect the addition
        of <literal moreinfo="none">x</literal> to its set of samples by updating the number of
        samples, the sum, and the sum of squares.</para>

      <para>Note the use of single semicolons to sequence operations. When we were working purely
        functionally, this wasn't necessary, but you start needing it when you're writing imperative
        code.</para>

      <para>Here's an example of <literal moreinfo="none">create</literal> and
      <literal moreinfo="none">update</literal> in action. Note that this code
      uses <literal moreinfo="none">List.iter</literal>, which calls the
      function <literal moreinfo="none">~f</literal> on each element of the
      provided list:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/guided-tour/main.topscript">OCaml utop</ulink>
      (part 53)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let rsum = create ();;</userinput>
<computeroutput moreinfo="none">val rsum : running_sum = {sum = 0.; sum_sq = 0.; samples = 0}</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">List.iter [1.;3.;2.;-7.;4.;5.] ~f:(fun x -&gt; update rsum x);;</userinput>
<computeroutput moreinfo="none">- : unit = ()</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">mean rsum;;</userinput>
<computeroutput moreinfo="none">- : float = 1.33333333333</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">stdev rsum;;</userinput>
<computeroutput moreinfo="none">- : float = 3.94405318873</computeroutput></programlisting>

      <para>It's worth noting that the preceding algorithm is numerically
      naive and has poor precision in the presence of cancellation. You can
      look at this Wikipedia <ulink url="http://en.wikipedia.org/wiki/Algorithms_for_calculating_variance">article
      on algorithms for calculating variance</ulink> for more details, paying
      particular attention to the weighted incremental and parallel
      algorithms.</para>
    </sect2>

    <sect2 id="refs">
      <title>Refs</title>

      <para>We can create a single mutable value by using a <literal moreinfo="none">ref</literal>. The <literal moreinfo="none">ref</literal> type comes predefined in the standard
      library, but there's nothing really special about it. It's just a record
      type with a single mutable field called <literal moreinfo="none">contents</literal>:<indexterm class="singular">
          <primary>records</primary>

          <secondary>record types</secondary>
        </indexterm><indexterm class="singular">
          <primary>imperative programming</primary>

          <secondary>ref type</secondary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/guided-tour/main.topscript">OCaml utop</ulink>
      (part 54)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let x = { contents = 0 };;</userinput>
<computeroutput moreinfo="none">val x : int ref = {contents = 0}</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">x.contents &lt;- x.contents + 1;;</userinput>
<computeroutput moreinfo="none">- : unit = ()</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">x;;</userinput>
<computeroutput moreinfo="none">- : int ref = {contents = 1}</computeroutput></programlisting>

      <para>There are a handful of useful functions and operators defined for
      <literal moreinfo="none">ref</literal>s to make them more convenient to
      work with:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/guided-tour/main.topscript">OCaml utop</ulink>
      (part 55)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let x = ref 0  (* create a ref, i.e., { contents = 0 } *) ;;</userinput>
<computeroutput moreinfo="none">val x : int ref = {contents = 0}</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">!x             (* get the contents of a ref, i.e., x.contents *) ;;</userinput>
<computeroutput moreinfo="none">- : int = 0</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">x := !x + 1    (* assignment, i.e., x.contents &lt;- ... *) ;;</userinput>
<computeroutput moreinfo="none">- : unit = ()</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">!x ;;</userinput>
<computeroutput moreinfo="none">- : int = 1</computeroutput></programlisting>

      <para>There's nothing magical with these operators either. You can
      completely reimplement the <literal moreinfo="none">ref</literal> type
      and all of these operators in just a few lines of code:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/guided-tour/main.topscript">OCaml utop</ulink>
      (part 56)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">type 'a ref = { mutable contents : 'a }</userinput>
<userinput moreinfo="none"/>
<userinput moreinfo="none">  let ref x = { contents = x }</userinput>
<userinput moreinfo="none">  let (!) r = r.contents</userinput>
<userinput moreinfo="none">  let (:=) r x = r.contents &lt;- x</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">type 'a ref = { mutable contents : 'a; }</computeroutput>
<computeroutput moreinfo="none">val ref : 'a -&gt; 'a ref = &lt;fun&gt;</computeroutput>
<computeroutput moreinfo="none">val ( ! ) : 'a ref -&gt; 'a = &lt;fun&gt;</computeroutput>
<computeroutput moreinfo="none">val ( := ) : 'a ref -&gt; 'a -&gt; unit = &lt;fun&gt;</computeroutput></programlisting>

      <para>The <literal moreinfo="none">'a</literal> before the
      <literal>ref</literal> indicates that the <literal moreinfo="none">ref</literal> type is polymorphic, in the same way that
      lists are polymorphic, meaning it can contain values of any type. The
      parentheses around <literal moreinfo="none">!</literal> and <literal moreinfo="none">:=</literal> are needed because these are operators,
      rather than ordinary functions.<indexterm class="singular">
          <primary>parametric polymorphism</primary>
        </indexterm></para>

      <para>Even though a <literal moreinfo="none">ref</literal> is just
      another record type, it's important because it is the standard way of
      simulating the traditional mutable variables you'll find in most
      languages. For example, we can sum over the elements of a list
      imperatively by calling <literal moreinfo="none">List.iter</literal> to
      call a simple function on every element of a list, using a
      <literal>ref</literal> to accumulate the results:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/guided-tour/main.topscript">OCaml utop</ulink>
      (part 57)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let sum list =</userinput>
<userinput moreinfo="none">    let sum = ref 0 in</userinput>
<userinput moreinfo="none">    List.iter list ~f:(fun x -&gt; sum := !sum + x);</userinput>
<userinput moreinfo="none">    !sum</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val sum : int list -&gt; int = &lt;fun&gt;</computeroutput></programlisting>

      <para>This isn't the most idiomatic way to sum up a list, but it shows how you can use a
          <literal>ref</literal> in place of a mutable variable.</para>
    </sect2>

    <sect2 id="for-and-while-loops">
      <title>For and While Loops</title>

      <para>OCaml also supports traditional imperative control-flow constructs
      like <literal>for and while</literal> loops. Here, for example, is some
      code for permuting an array that uses a <literal>for</literal> loop. We
      use the <literal moreinfo="none">Random</literal> module as our source
      of randomness. <literal moreinfo="none">Random</literal> starts with a
      default seed, but you can call <literal moreinfo="none">Random.self_init</literal> to choose a new seed at
      random:<indexterm class="singular">
          <primary>Random module</primary>
        </indexterm><indexterm class="singular">
          <primary>while loops</primary>
        </indexterm><indexterm class="singular">
          <primary>for loops</primary>
        </indexterm><indexterm class="singular">
          <primary>imperative programming</primary>

          <secondary>for and while loops</secondary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/guided-tour/main.topscript">OCaml utop</ulink>
      (part 58)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let permute array =</userinput>
<userinput moreinfo="none">    let length = Array.length array in</userinput>
<userinput moreinfo="none">    for i = 0 to length - 2 do</userinput>
<userinput moreinfo="none">       (* pick a j to swap with *)</userinput>
<userinput moreinfo="none">       let j = i + Random.int (length - i) in</userinput>
<userinput moreinfo="none">       (* Swap i and j *)</userinput>
<userinput moreinfo="none">       let tmp = array.(i) in</userinput>
<userinput moreinfo="none">       array.(i) &lt;- array.(j);</userinput>
<userinput moreinfo="none">       array.(j) &lt;- tmp</userinput>
<userinput moreinfo="none">    done</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val permute : 'a array -&gt; unit = &lt;fun&gt;</computeroutput></programlisting>

      <para>From a syntactic perspective, you should note the keywords that
      distinguish a <literal>for</literal> loop: <literal moreinfo="none">for</literal>, <literal moreinfo="none">to</literal>,
      <literal moreinfo="none">do</literal>, and <literal moreinfo="none">done</literal>.</para>

      <para>Here's an example run of this code:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/guided-tour/main.topscript">OCaml utop</ulink>
      (part 59)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let ar = Array.init 20 ~f:(fun i -&gt; i);;</userinput>
<computeroutput moreinfo="none">val ar : int array =</computeroutput>
<computeroutput moreinfo="none">  [|0; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19|]</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">permute ar;;</userinput>
<computeroutput moreinfo="none">- : unit = ()</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">ar;;</userinput>
<computeroutput moreinfo="none">- : int array =</computeroutput>
<computeroutput moreinfo="none">[|1; 2; 4; 6; 11; 7; 14; 9; 10; 0; 13; 16; 19; 12; 17; 5; 3; 18; 8; 15|]</computeroutput></programlisting>

      <para>OCaml also supports <literal>while</literal> loops, as shown in
      the following function for finding the position of the first negative
      entry in an array. Note that <literal moreinfo="none">while</literal>
      (like <literal moreinfo="none">for</literal>) is also a keyword:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/guided-tour/main.topscript">OCaml utop</ulink>
      (part 60)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let find_first_negative_entry array =</userinput>
<userinput moreinfo="none">     let pos = ref 0 in</userinput>
<userinput moreinfo="none">     while !pos &lt; Array.length array &amp;&amp; array.(!pos) &gt;= 0 do</userinput>
<userinput moreinfo="none">       pos := !pos + 1</userinput>
<userinput moreinfo="none">     done;</userinput>
<userinput moreinfo="none">     if !pos = Array.length array then None else Some !pos</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val find_first_negative_entry : int array -&gt; int option = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">find_first_negative_entry [|1;2;0;3|];;</userinput>
<computeroutput moreinfo="none">- : int option = None</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">find_first_negative_entry [|1;-2;0;3|];;</userinput>
<computeroutput moreinfo="none">- : int option = Some 1</computeroutput></programlisting>

      <para>As a side note, the preceding code takes advantage of the fact
      that <literal moreinfo="none">&amp;&amp;</literal>, OCaml's And
      operator, short-circuits. In particular, in an expression of the form
      <emphasis><literal moreinfo="none">expr1</literal></emphasis> <literal moreinfo="none">&amp;&amp;</literal> <emphasis><literal moreinfo="none">expr2</literal></emphasis>, <emphasis><literal moreinfo="none">expr2</literal></emphasis> will only be evaluated if
      <emphasis><literal moreinfo="none">expr1</literal></emphasis> evaluated
      to true. Were it not for that, then the preceding function would result
      in an out-of-bounds error. Indeed, we can trigger that out-of-bounds
      error by rewriting the function to avoid the short-circuiting:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/guided-tour/main.topscript">OCaml utop</ulink>
      (part 61)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let find_first_negative_entry array =</userinput>
<userinput moreinfo="none">     let pos = ref 0 in</userinput>
<userinput moreinfo="none">     while</userinput>
<userinput moreinfo="none">       let pos_is_good = !pos &lt; Array.length array in</userinput>
<userinput moreinfo="none">       let element_is_non_negative = array.(!pos) &gt;= 0 in</userinput>
<userinput moreinfo="none">       pos_is_good &amp;&amp; element_is_non_negative</userinput>
<userinput moreinfo="none">     do</userinput>
<userinput moreinfo="none">       pos := !pos + 1</userinput>
<userinput moreinfo="none">     done;</userinput>
<userinput moreinfo="none">     if !pos = Array.length array then None else Some !pos</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val find_first_negative_entry : int array -&gt; int option = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">find_first_negative_entry [|1;2;0;3|];;</userinput>
<computeroutput moreinfo="none">Exception: (Invalid_argument "index out of bounds").</computeroutput></programlisting>

      <para>The Or operator, <literal moreinfo="none">||</literal>,
      short-circuits in a similar way to <literal moreinfo="none">&amp;&amp;</literal>.</para>
    </sect2>
  </sect1>

  <sect1 id="a-complete-program">
    <title>A Complete Program</title>

    <para>So far, we've played with the basic features of the language via
    <command moreinfo="none">utop</command>. Now we'll show how to create a
    simple standalone program. In particular, we'll create a program that sums
    up a list of numbers read in from the standard input.<indexterm class="singular">
        <primary>programming</primary>

        <secondary>simple standalone example</secondary>
      </indexterm></para>

    <para>Here's the code, which you can save in a file called
    <filename>sum.ml</filename>. Note that we don't terminate expressions with
    <literal moreinfo="none">;;</literal> here, since it's not required
    outside the toplevel:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/guided-tour/sum.ml">OCaml</ulink></para>

    <programlisting format="linespecific" language="ocaml">open Core.Std

let rec read_and_accumulate accum =
  let line = In_channel.input_line In_channel.stdin in
  match line with
  | None -&gt; accum
  | Some x -&gt; read_and_accumulate (accum +. Float.of_string x)

let () =
  printf "Total: %F\n" (read_and_accumulate 0.)</programlisting>

    <para>This is our first use of OCaml's input and output routines. The
    function <literal moreinfo="none">read_and_accumulate</literal> is a
    recursive function that uses <literal moreinfo="none">In_channel.input_line</literal> to read in lines one by
    one from the standard input, invoking itself at each iteration with its
    updated accumulated sum. Note that <literal moreinfo="none">input_line</literal> returns an optional value, with
    <literal moreinfo="none">None</literal> indicating the end of the input
    stream.</para>

    <para>After <literal moreinfo="none">read_and_accumulate</literal>
    returns, the total needs to be printed. This is done using the <literal moreinfo="none">printf</literal> command, which provides support for
    type-safe format strings, similar to what you'll find in a variety of
    languages. The format string is parsed by the compiler and used to
    determine the number and type of the remaining arguments that are
    <phrase role="keep-together">required</phrase>. In this case, there is a single formatting directive, <literal moreinfo="none">%F</literal>, so <literal moreinfo="none">printf</literal>
    expects one additional argument of type <literal moreinfo="none">float</literal>.</para>

    <sect2 id="compiling-and-running">
      <title>Compiling and Running</title>

      <para>We'll compile our program using <command moreinfo="none">corebuild</command>, a small
        wrapper on top of <command moreinfo="none">ocamlbuild</command>, a build tool that ships
        with the OCaml compiler. The <command moreinfo="none">corebuild</command> script is
        installed along with Core, and its purpose is to pass in the flags required for building a
        program with Core.<indexterm class="singular">
          <primary>corebuild</primary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/guided-tour/build_sum.out">Terminal</ulink></para>

      <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">corebuild sum.native</userinput>
  </programlisting>

      <para>The <literal moreinfo="none">.native</literal> suffix indicates that we're building a
        native-code executable, which we'll discuss more in <xref linkend="files-modules-and-programs"/>. Once the build completes, we can use the resulting
        program like any command-line utility. We can feed input to <literal moreinfo="none">sum.native</literal> by typing in a sequence of numbers, one per line, hitting
          <userinput>Ctrl-D</userinput> when we're done:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/guided-tour/sum.out">Terminal</ulink></para>

      <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">./sum.native</userinput>
<computeroutput moreinfo="none">1</computeroutput>
<computeroutput moreinfo="none">2</computeroutput>
<computeroutput moreinfo="none">3</computeroutput>
<computeroutput moreinfo="none">94.5</computeroutput>
<computeroutput moreinfo="none">Total: 100.5</computeroutput></programlisting>

      <para>More work is needed to make a really usable command-line program,
      including a proper command-line parsing interface and better error
      handling, all of which is covered in <xref linkend="command-line-parsing"/>.</para>
    </sect2>
  </sect1>

  <sect1 id="where-to-go-from-here">
    <title>Where to Go from Here</title>

    <para>That's it for the guided tour! There are plenty of features left and
    lots of details to explain, but we hope that you now have a sense of what
    to expect from OCaml, and that you'll be more comfortable reading the rest
    of the book as a result.</para>
  </sect1>
</chapter>

  <chapter id="variables-and-functions">
  <title>Variables and Functions</title>

  <para>Variables and functions are fundamental ideas that show up in virtually all programming
    languages. OCaml has a different take on these concepts than most languages you're likely to
    have encountered, so this chapter will cover OCaml's approach to variables and functions in some
    detail, starting with the basics of how to define a variable, and ending with the intricacies of
    functions with labeled and optional arguments.</para>

  <para>Don't be discouraged if you find yourself overwhelmed by some of the details, especially
    toward the end of the chapter. The concepts here are important, but if they don't connect for
    you on your first read, you should return to this chapter after you've gotten a better sense for
    the rest of the language.</para>

  <sect1 id="variables">
    <title>Variables</title>

    <para>At its simplest, a variable is an identifier whose meaning is bound
    to a particular value. In OCaml these bindings are often introduced using
    the <literal moreinfo="none">let</literal> keyword. We can type a
    so-called <emphasis>top-level</emphasis> <literal moreinfo="none">let</literal> binding with the following syntax. Note that
    variable names must start with a lowercase letter or an
    underscore:<indexterm class="singular">
        <primary>bindings</primary>

        <secondary>top-level</secondary>
      </indexterm><indexterm class="singular">
        <primary>top-level bindings</primary>
      </indexterm><indexterm class="singular">
        <primary>let syntax</primary>

        <secondary>top-level bindings</secondary>
      </indexterm></para>

    <para role="sourcecode">
      <ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variables-and-functions/let.syntax">Syntax</ulink></para>

    <programlisting format="linespecific" language="ocaml">let <emphasis>&lt;variable&gt;</emphasis> = <emphasis>&lt;expr&gt;</emphasis></programlisting>

    <para>As we'll see when we get to the module system in <xref linkend="files-modules-and-programs"/>, this same syntax is used for <literal>let</literal>
      bindings at the top level of a module.</para>

    <para>Every variable binding has a <emphasis>scope</emphasis>, which is
    the portion of the code that can refer to that binding. When using
    <command moreinfo="none">utop</command>, the scope of a top-level
    <literal>let</literal> binding is everything that follows it in the
    session. When it shows up in a module, the scope is the remainder of that
    module.<indexterm class="singular">
        <primary>variables</primary>

        <secondary>scope of</secondary>
      </indexterm><indexterm class="singular">
        <primary>bindings</primary>

        <secondary>scope of</secondary>
      </indexterm><indexterm class="singular">
        <primary>scope</primary>
      </indexterm></para>

    <para>Here's a simple example:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variables-and-functions/main.topscript">OCaml utop</ulink></para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let x = 3;;</userinput>
<computeroutput moreinfo="none">val x : int = 3</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let y = 4;;</userinput>
<computeroutput moreinfo="none">val y : int = 4</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let z = x + y;;</userinput>
<computeroutput moreinfo="none">val z : int = 7</computeroutput></programlisting>

    <para><literal moreinfo="none">let</literal> can also be used to create a
    variable binding whose scope is limited to a particular expression, using
    the following syntax:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variables-and-functions/let_in.syntax">Syntax</ulink></para>

    <programlisting format="linespecific" language="ocaml">let <emphasis>&lt;variable&gt;</emphasis> = <emphasis>&lt;expr1&gt;</emphasis> in <emphasis>&lt;expr2&gt;</emphasis></programlisting>

    <para>This first evaluates <emphasis><literal moreinfo="none">expr1</literal></emphasis> and
      then evaluates <emphasis><literal moreinfo="none">expr2</literal></emphasis> with
          <emphasis><literal moreinfo="none">variable</literal></emphasis> bound to whatever value
      was produced by the evaluation of <emphasis><literal moreinfo="none">expr1</literal></emphasis>. Here's how it looks in practice:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variables-and-functions/main.topscript">OCaml utop</ulink>
    (part 1)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let languages = "OCaml,Perl,C++,C";;</userinput>
<computeroutput moreinfo="none">val languages : string = "OCaml,Perl,C++,C"</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let dashed_languages =</userinput>
<userinput moreinfo="none">    let language_list = String.split languages ~on:',' in</userinput>
<userinput moreinfo="none">    String.concat ~sep:"-" language_list</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val dashed_languages : string = "OCaml-Perl-C++-C"</computeroutput></programlisting>

    <para>Note that the scope of <literal moreinfo="none">language_list</literal> is just the expression <literal moreinfo="none">String.concat ~sep:"-" language_list</literal> and is not
    available at the toplevel, as we can see if we try to access it
    now:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variables-and-functions/main.topscript">OCaml utop</ulink>
    (part 2)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">language_list;;</userinput>
<computeroutput moreinfo="none">Characters -1-13:</computeroutput>
<computeroutput moreinfo="none">Error: Unbound value language_list</computeroutput></programlisting>

    <para>A <literal>let</literal> binding in an inner scope can
    <emphasis>shadow</emphasis>, or hide, the definition from an outer scope.
    So, for example, we could have written the <literal moreinfo="none">dashed_languages</literal> example as follows:<indexterm class="singular">
        <primary>variables</primary>

        <secondary>shadowing of</secondary>
      </indexterm><indexterm class="singular">
        <primary>shadowing</primary>
      </indexterm></para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variables-and-functions/main.topscript">OCaml utop</ulink>
    (part 3)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let languages = "OCaml,Perl,C++,C";;</userinput>
<computeroutput moreinfo="none">val languages : string = "OCaml,Perl,C++,C"</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let dashed_languages =</userinput>
<userinput moreinfo="none">     let languages = String.split languages ~on:',' in</userinput>
<userinput moreinfo="none">     String.concat ~sep:"-" languages</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val dashed_languages : string = "OCaml-Perl-C++-C"</computeroutput></programlisting>

    <para>This time, in the inner scope we called the list of strings <literal moreinfo="none">languages</literal> instead of <literal moreinfo="none">language_list</literal>, thus hiding the original
    definition of <literal moreinfo="none">languages</literal>. But once the
    definition of <literal moreinfo="none">dashed_languages</literal> is
    complete, the inner scope has closed and the original definition of
    languages reappears:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variables-and-functions/main.topscript">OCaml utop</ulink>
    (part 4)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">languages;;</userinput>
<computeroutput moreinfo="none">- : string = "OCaml,Perl,C++,C"</computeroutput></programlisting>

    <para>One common idiom is to use a series of nested <literal moreinfo="none">let</literal>/<literal moreinfo="none">in</literal>
    expressions to build up the components of a larger computation. Thus, we
    might write:<indexterm class="singular">
        <primary>let syntax</primary>

        <secondary>nested bindings</secondary>
      </indexterm><indexterm class="singular">
        <primary>nested let binding</primary>
      </indexterm></para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variables-and-functions/main.topscript">OCaml utop</ulink>
    (part 5)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let area_of_ring inner_radius outer_radius =</userinput>
<userinput moreinfo="none">     let pi = acos (-1.) in</userinput>
<userinput moreinfo="none">     let area_of_circle r = pi *. r *. r in</userinput>
<userinput moreinfo="none">     area_of_circle outer_radius -. area_of_circle inner_radius</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val area_of_ring : float -&gt; float -&gt; float = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">area_of_ring 1. 3.;;</userinput>
<computeroutput moreinfo="none">- : float = 25.1327412287</computeroutput></programlisting>

    <para>It's important not to confuse a sequence of <literal>let</literal>
    bindings with the modification of a mutable variable. For example,
    consider how <literal moreinfo="none">area_of_ring</literal> would work if
    we had instead written this purposefully confusing bit of code:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variables-and-functions/main.topscript">OCaml utop</ulink>
    (part 6)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let area_of_ring inner_radius outer_radius =</userinput>
<userinput moreinfo="none">     let pi = acos (-1.) in</userinput>
<userinput moreinfo="none">     let area_of_circle r = pi *. r *. r in</userinput>
<userinput moreinfo="none">     let pi = 0. in</userinput>
<userinput moreinfo="none">     area_of_circle outer_radius -. area_of_circle inner_radius</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">Characters 126-128:</computeroutput>
<computeroutput moreinfo="none">Warning 26: unused variable pi.</computeroutput>
<computeroutput moreinfo="none">val area_of_ring : float -&gt; float -&gt; float = &lt;fun&gt;</computeroutput></programlisting>

    <para>Here, we redefined <literal moreinfo="none">pi</literal> to be zero after the definition
      of <literal moreinfo="none">area_of_circle</literal>. You might think that this would mean
      that the result of the computation would now be zero, but in fact, the behavior of the
      function is unchanged. That's because the original definition of <literal moreinfo="none">pi</literal> wasn't changed; it was just shadowed, which means that any subsequent
      reference to <literal moreinfo="none">pi</literal> would see the new definition of <literal moreinfo="none">pi</literal> as <literal>0</literal>, but earlier references would be
      unchanged. But there is no later use of <literal moreinfo="none">pi</literal>, so the binding
      of <literal moreinfo="none">pi</literal> to <literal moreinfo="none">0.</literal> made no
      difference. This explains the warning produced by the toplevel telling us that there is an
      unused definition of <literal moreinfo="none">pi</literal>.</para>

    <para>In OCaml, <literal>let</literal> bindings are immutable. There are
    many kinds of mutable values in OCaml, which we'll discuss in <xref linkend="imperative-programming-1"/>, but there are no mutable
    variables.</para>

    <note>
      <title>Why Don't Variables Vary?</title>

      <para>One source of confusion for people new to OCaml is the fact that
      variables are immutable. This seems pretty surprising even on linguistic
      terms. Isn't the whole point of a variable that it can vary?<indexterm class="singular">
          <primary>variables</primary>

          <secondary>immutability of</secondary>
        </indexterm></para>

      <para>The answer to this is that variables in OCaml (and generally in functional languages)
        are really more like variables in an equation than a variable in an imperative language. If
        you think about the mathematical identity <literal moreinfo="none">x(y + z) = xy +
          xz</literal>, there's no notion of mutating the variables <literal moreinfo="none">x</literal>, <literal moreinfo="none">y</literal>, and <literal moreinfo="none">z</literal>. They vary in the sense that you can instantiate this equation with different
        numbers for those variables, and it still holds.</para>

      <para>The same is true in a functional language. A function can be
      applied to different inputs, and thus its variables will take on
      different values, even without mutation.</para>
    </note>

    <sect2 id="pattern-matching-and-let">
      <title>Pattern Matching and let</title>

      <para>Another useful feature of <literal>let</literal> bindings is that
      they support the use of <emphasis>patterns</emphasis> on the lefthand
      side. Consider the following code, which uses <literal moreinfo="none">List.unzip</literal>, a function for converting a list
      of pairs into a pair of lists:<indexterm class="singular">
          <primary>pattern matching</primary>

          <secondary sortas="let">and let</secondary>
        </indexterm><indexterm class="singular">
          <primary>let syntax</primary>

          <secondary>pattern matching</secondary>
        </indexterm><indexterm class="singular">
          <primary>variables</primary>

          <secondary>pattern matching in</secondary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variables-and-functions/main.topscript">OCaml utop</ulink>
      (part 7)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let (ints,strings) = List.unzip [(1,"one"); (2,"two"); (3,"three")];;</userinput>
<computeroutput moreinfo="none">val ints : int list = [1; 2; 3]</computeroutput>
<computeroutput moreinfo="none">val strings : string list = ["one"; "two"; "three"]</computeroutput></programlisting>

      <para>Here, <literal moreinfo="none">(ints,strings)</literal> is a
      pattern, and the <literal moreinfo="none">let</literal> binding assigns
      values to both of the identifiers that show up in that pattern. A
      pattern is essentially a description of the shape of a data structure,
      where some components are identifiers to be bound. As we saw in <xref linkend="tuples-lists-options-and-pattern-matching"/>, OCaml has
      patterns for a variety of different data types.</para>

      <para>Using a pattern in a <literal>let</literal> binding makes the most sense for a pattern
        that is <emphasis>irrefutable</emphasis>, <emphasis>i.e.</emphasis>, where any value of the
        type in question is guaranteed to match the pattern. Tuple and record patterns are
        irrefutable, but list patterns are not. Consider the following code that implements a
        function for upper casing the first element of a comma-separated list:<indexterm class="singular">
          <primary>irrefutable patterns</primary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variables-and-functions/main.topscript">OCaml utop</ulink>
      (part 8)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let upcase_first_entry line =</userinput>
<userinput moreinfo="none">     let (first :: rest) = String.split ~on:',' line in</userinput>
<userinput moreinfo="none">     String.concat ~sep:"," (String.uppercase first :: rest)</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">Characters 40-53:</computeroutput>
<computeroutput moreinfo="none">Warning 8: this pattern-matching is not exhaustive.</computeroutput>
<computeroutput moreinfo="none">Here is an example of a value that is not matched:</computeroutput>
<computeroutput moreinfo="none">[]</computeroutput>
<computeroutput moreinfo="none">val upcase_first_entry : string -&gt; string = &lt;fun&gt;</computeroutput></programlisting>

      <para>This case can't really come up in practice, because <literal moreinfo="none">String.split</literal> always returns a list with at
      least one element. But the compiler doesn't know this, and so it emits
      the warning. It's generally better to use a <literal>match</literal>
      statement to handle such cases explicitly:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variables-and-functions/main.topscript">OCaml utop</ulink>
      (part 9)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let upcase_first_entry line =</userinput>
<userinput moreinfo="none">     match String.split ~on:',' line with</userinput>
<userinput moreinfo="none">     | [] -&gt; assert false (* String.split returns at least one element *)</userinput>
<userinput moreinfo="none">     | first :: rest -&gt; String.concat ~sep:"," (String.uppercase first :: rest)</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val upcase_first_entry : string -&gt; string = &lt;fun&gt;</computeroutput></programlisting>

      <para>Note that this is our first use of <literal moreinfo="none">assert</literal>, which is useful for marking cases that
      should be impossible. We'll discuss <literal moreinfo="none">assert</literal> in more detail in <xref linkend="error-handling"/>.</para>
    </sect2>
  </sect1>

  <sect1 id="functions">
    <title>Functions</title>

    <para>Given that OCaml is a functional language, it's no surprise that
    functions are important and pervasive. Indeed, functions have come up in
    almost every example we've done so far. This section will go into more
    depth, explaining the details of how OCaml's functions work. As you'll
    see, functions in OCaml differ in a variety of ways from what you'll find
    in most mainstream languages.</para>

    <sect2 id="anonymous-functions">
      <title>Anonymous Functions</title>

      <para>We'll start by looking at the most basic style of function declaration in OCaml: the
          <emphasis>anonymous function</emphasis>. An anonymous function is a function that is
        declared without being named. These can be declared using the <literal moreinfo="none">fun</literal> keyword, as shown here:<indexterm class="singular">
          <primary>fun keyword</primary>
          <secondary>anonymous functions</secondary>
        </indexterm><indexterm class="singular">
          <primary>anonymous functions</primary>
        </indexterm><indexterm class="singular">
          <primary>functions</primary>
          <secondary>anonymous functions</secondary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variables-and-functions/main.topscript">OCaml utop</ulink>
      (part 10)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">(fun x -&gt; x + 1);;</userinput>
<computeroutput moreinfo="none">- : int -&gt; int = &lt;fun&gt;</computeroutput></programlisting>

      <para>Anonymous functions operate in much the same way as named
      functions. For example, we can apply an anonymous function to an
      argument:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variables-and-functions/main.topscript">OCaml utop</ulink>
      (part 11)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">(fun x -&gt; x + 1) 7;;</userinput>
<computeroutput moreinfo="none">- : int = 8</computeroutput></programlisting>

      <para>Or pass it to another function. Passing functions to iteration
      functions like <literal moreinfo="none">List.map</literal> is probably
      the most common use case for anonymous functions:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variables-and-functions/main.topscript">OCaml utop</ulink>
      (part 12)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">List.map ~f:(fun x -&gt; x + 1) [1;2;3];;</userinput>
<computeroutput moreinfo="none">- : int list = [2; 3; 4]</computeroutput></programlisting>

      <para>You can even stuff them into a data structure:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variables-and-functions/main.topscript">OCaml utop</ulink>
      (part 13)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let increments = [ (fun x -&gt; x + 1); (fun x -&gt; x + 2) ] ;;</userinput>
<computeroutput moreinfo="none">val increments : (int -&gt; int) list = [&lt;fun&gt;; &lt;fun&gt;]</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">List.map ~f:(fun g -&gt; g 5) increments;;</userinput>
<computeroutput moreinfo="none">- : int list = [6; 7]</computeroutput></programlisting>

      <para>It's worth stopping for a moment to puzzle this example out, since this kind of
        higher-order use of functions can be a bit obscure at first. Notice that <literal moreinfo="none">(fun g -&gt; g 5)</literal> is a function that takes a function as an
        argument, and then applies that function to the number <literal moreinfo="none">5</literal>.
        The invocation of <literal moreinfo="none">List.map</literal> applies <literal moreinfo="none">(fun g -&gt; g 5)</literal> to the elements of the <literal moreinfo="none">increments</literal> list (which are themselves functions) and returns the
        list containing the results of these function applications.</para>

      <para>The key thing to understand is that functions are ordinary values
      in OCaml, and you can do everything with them that you'd do with an
      ordinary value, including passing them to and returning them from other
      functions and storing them in data structures. We even name functions in
      the same way that we name other values, by using a
      <literal>let</literal> binding:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variables-and-functions/main.topscript">OCaml utop</ulink>
      (part 14)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let plusone = (fun x -&gt; x + 1);;</userinput>
<computeroutput moreinfo="none">val plusone : int -&gt; int = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">plusone 3;;</userinput>
<computeroutput moreinfo="none">- : int = 4</computeroutput></programlisting>

      <para>Defining named functions is so common that there is some syntactic
      sugar for it. Thus, the following definition of <literal moreinfo="none">plusone</literal> is equivalent to the previous
      definition:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variables-and-functions/main.topscript">OCaml utop</ulink>
      (part 15)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let plusone x = x + 1;;</userinput>
<computeroutput moreinfo="none">val plusone : int -&gt; int = &lt;fun&gt;</computeroutput></programlisting>

      <para>This is the most common and convenient way to declare a function, but syntactic niceties
        aside, the two styles of function definition are equivalent.</para>

      <note>
        <title>let and fun</title>

        <para>Functions and <literal>let</literal> bindings have a lot to do
        with each other. In some sense, you can think of the parameter of a
        function as a variable being bound to the value passed by the caller.
        Indeed, the following two expressions are nearly equivalent:<indexterm class="singular">
            <primary>let syntax</primary>

            <secondary>functions and</secondary>
          </indexterm></para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variables-and-functions/main.topscript">OCaml utop</ulink>
        (part 16)</para>

        <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">(fun x -&gt; x + 1) 7;;</userinput>
<computeroutput moreinfo="none">- : int = 8</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let x = 7 in x + 1;;</userinput>
<computeroutput moreinfo="none">- : int = 8</computeroutput></programlisting>

        <para>This connection is important, and will come up more when
        programming in a monadic style, as we'll see in <xref linkend="concurrent-programming-with-async"/>.</para>
      </note>
    </sect2>

    <sect2 id="multi-argument-functions">
      <title>Multiargument functions</title>

      <para>OCaml of course also supports multiargument functions, such
      as:<indexterm class="singular">
          <primary>fun keyword</primary>

          <secondary>multi-argument functions</secondary>
        </indexterm><indexterm class="singular">
          <primary>multi-argument functions</primary>
        </indexterm><indexterm class="singular">
          <primary>functions</primary>

          <secondary>multi-argument functions</secondary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variables-and-functions/main.topscript">OCaml utop</ulink>
      (part 17)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let abs_diff x y = abs (x - y);;</userinput>
<computeroutput moreinfo="none">val abs_diff : int -&gt; int -&gt; int = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">abs_diff 3 4;;</userinput>
<computeroutput moreinfo="none">- : int = 1</computeroutput></programlisting>

      <para>You may find the type signature of <literal moreinfo="none">abs_diff</literal> with all of its arrows a little hard
      to parse. To understand what's going on, let's rewrite <literal moreinfo="none">abs_diff</literal> in an equivalent form, using the
      <literal moreinfo="none">fun</literal> keyword:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variables-and-functions/main.topscript">OCaml utop</ulink>
      (part 18)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let abs_diff =</userinput>
<userinput moreinfo="none">    (fun x -&gt; (fun y -&gt; abs (x - y)));;</userinput>
<computeroutput moreinfo="none">val abs_diff : int -&gt; int -&gt; int = &lt;fun&gt;</computeroutput></programlisting>

      <para>This rewrite makes it explicit that <literal moreinfo="none">abs_diff</literal> is actually a function of one
      argument that returns another function of one argument, which itself
      returns the final result. Because the functions are nested, the inner
      expression <literal moreinfo="none">abs (x - y)</literal> has access to
      both <literal moreinfo="none">x</literal>, which was bound by the outer
      function application, and <literal moreinfo="none">y</literal>, which
      was bound by the inner one.</para>

      <para>This style of function is called a <emphasis>curried</emphasis>
      function. (Currying is named after Haskell Curry, a logician who had a
      significant impact on the design and theory of programming languages.)
      The key to interpreting the type signature of a curried function is the
      observation that <literal moreinfo="none">-&gt;</literal> is
      right-associative. The type signature of <literal moreinfo="none">abs_diff</literal> can therefore be parenthesized as
      follows:<indexterm class="singular">
          <primary>curried functions</primary>
        </indexterm><indexterm class="singular">
          <primary>functions</primary>

          <secondary>curried functions</secondary>
        </indexterm></para>

      <para role="sourcecode">OCaml: <ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variables-and-functions/abs_diff.mli">variables-and-functions/abs_diff.mli</ulink></para>

      <programlisting format="linespecific" language="ocaml">val abs_diff : int -&gt; (int -&gt; int)</programlisting>

      <para>The parentheses don't change the meaning of the signature, but
      they make it easier to see the currying.</para>

      <para>Currying is more than just a theoretical curiosity. You can make
      use of currying to specialize a function by feeding in some of the
      arguments. Here's an example where we create a specialized version of
      <literal moreinfo="none">abs_diff</literal> that measures the distance
      of a given number from <literal moreinfo="none">3</literal>:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variables-and-functions/main.topscript">OCaml utop</ulink>
      (part 19)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let dist_from_3 = abs_diff 3;;</userinput>
<computeroutput moreinfo="none">val dist_from_3 : int -&gt; int = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">dist_from_3 8;;</userinput>
<computeroutput moreinfo="none">- : int = 5</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">dist_from_3 (-1);;</userinput>
<computeroutput moreinfo="none">- : int = 4</computeroutput></programlisting>

      <para>The practice of applying some of the arguments of a curried
      function to get a new function is called <emphasis>partial
      application</emphasis>.<indexterm class="singular">
          <primary>partial application</primary>
        </indexterm></para>

      <para>Note that the <literal moreinfo="none">fun</literal> keyword
      supports its own syntax for currying, so the following definition of
      <literal moreinfo="none">abs_diff</literal> is equivalent to the
      previous one.<indexterm class="singular">
          <primary>fun keyword</primary>

          <secondary>currying syntax</secondary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variables-and-functions/main.topscript">OCaml utop</ulink>
      (part 20)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let abs_diff = (fun x y -&gt; abs (x - y));;</userinput>
<computeroutput moreinfo="none">val abs_diff : int -&gt; int -&gt; int = &lt;fun&gt;</computeroutput></programlisting>

      <para>You might worry that curried functions are terribly expensive, but
      this is not the case. In OCaml, there is no penalty for calling a
      curried function with all of its arguments. (Partial application,
      unsurprisingly, does have a small extra cost.)</para>

      <para>Currying is not the only way of writing a multiargument function
      in OCaml. It's also possible to use the different parts of a tuple as
      different arguments. So, we could write:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variables-and-functions/main.topscript">OCaml utop</ulink>
      (part 21)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let abs_diff (x,y) = abs (x - y);;</userinput>
<computeroutput moreinfo="none">val abs_diff : int * int -&gt; int = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">abs_diff (3,4);;</userinput>
<computeroutput moreinfo="none">- : int = 1</computeroutput></programlisting>

      <para>OCaml handles this calling convention efficiently as well. In
      particular it does not generally have to allocate a tuple just for the
      purpose of sending arguments to a tuple-style function. You can't,
      however, use partial application for this style of function.</para>

      <para>There are small trade-offs between these two approaches, but most
      of the time, one should stick to currying, since it's the default style
      in the OCaml world.</para>
    </sect2>

    <sect2 id="recursive-functions">
      <title>Recursive Functions</title>

      <para>A function is <emphasis>recursive</emphasis> if it refers to
      itself in its definition. Recursion is important in any programming
      language, but is particularly important in functional languages, because
      it is the way that you build looping constructs. (As will be discussed
      in more detail in <xref linkend="imperative-programming-1"/>, OCaml
      also supports imperative looping constructs like <literal moreinfo="none">for</literal> and <literal moreinfo="none">while</literal>, but these are only useful when using
      OCaml's imperative features.)<indexterm class="singular">
          <primary>recursive functions</primary>

          <secondary>definition of</secondary>
        </indexterm><indexterm class="singular">
          <primary>functions</primary>

          <secondary>recursive functions</secondary>
        </indexterm></para>

      <para>In order to define a recursive function, you need to mark the
      <literal>let</literal> binding as recursive with the <literal moreinfo="none">rec</literal> keyword, as shown in this function for
      finding the first sequentially repeated element in a list:<indexterm class="singular">
          <primary>rec keyword</primary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variables-and-functions/main.topscript">OCaml utop</ulink>
      (part 22)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let rec find_first_stutter list =</userinput>
<userinput moreinfo="none">    match list with</userinput>
<userinput moreinfo="none">    | [] | [_] -&gt;</userinput>
<userinput moreinfo="none">      (* only zero or one elements, so no repeats *)</userinput>
<userinput moreinfo="none">      None</userinput>
<userinput moreinfo="none">    | x :: y :: tl -&gt;</userinput>
<userinput moreinfo="none">      if x = y then Some x else find_first_stutter (y::tl)</userinput>
<userinput moreinfo="none">   ;;</userinput>
<computeroutput moreinfo="none">val find_first_stutter : 'a list -&gt; 'a option = &lt;fun&gt;</computeroutput></programlisting>

      <para>Note that in the code, the pattern <literal moreinfo="none">| [] |
      [_]</literal> is what's called an <emphasis>or-pattern</emphasis>, which
      is a disjunction of two patterns, meaning that it will be considered a
      match if either pattern matches. In this case, <literal moreinfo="none">[]</literal> matches the empty list, and <literal moreinfo="none">[_]</literal> matches any single element list. The
      <literal moreinfo="none">_</literal> is there so we don't have to put an
      explicit name on that single element.<indexterm class="singular">
          <primary>or patterns</primary>
        </indexterm></para>

      <para>We can also define multiple mutually recursive values by using
      <literal moreinfo="none">let rec</literal> combined with the <literal moreinfo="none">and</literal> keyword. Here's a (gratuitously
      inefficient) example:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variables-and-functions/main.topscript">OCaml utop</ulink>
      (part 23)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let rec is_even x =</userinput>
<userinput moreinfo="none">    if x = 0 then true else is_odd (x - 1)</userinput>
<userinput moreinfo="none">  and is_odd x =</userinput>
<userinput moreinfo="none">    if x = 0 then false else is_even (x - 1)</userinput>
<userinput moreinfo="none"> ;;</userinput>
<computeroutput moreinfo="none">val is_even : int -&gt; bool = &lt;fun&gt;</computeroutput>
<computeroutput moreinfo="none">val is_odd : int -&gt; bool = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">List.map ~f:is_even [0;1;2;3;4;5];;</userinput>
<computeroutput moreinfo="none">- : bool list = [true; false; true; false; true; false]</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">List.map ~f:is_odd [0;1;2;3;4;5];;</userinput>
<computeroutput moreinfo="none">- : bool list = [false; true; false; true; false; true]</computeroutput></programlisting>

      <para>OCaml distinguishes between nonrecursive definitions (using
      <literal moreinfo="none">let</literal>) and recursive definitions (using
      <literal moreinfo="none">let rec</literal>) largely for technical
      reasons: the type-inference algorithm needs to know when a set of
      function definitions are mutually recursive, and for reasons that don't
      apply to a pure language like Haskell, these have to be marked
      explicitly by the programmer.<indexterm class="singular">
          <primary>let syntax</primary>

          <secondary>nonrecursive vs. recursive functions</secondary>
        </indexterm></para>

      <para>But this decision has some good effects. For one thing, recursive
      (and especially mutually recursive) definitions are harder to reason
      about than nonrecursive ones. It's therefore useful that, in the absence
      of an explicit <literal moreinfo="none">rec</literal>, you can assume
      that a <literal>let</literal> binding is nonrecursive, and so can only
      build upon previous bindings.</para>

      <para>In addition, having a nonrecursive form makes it easier to create
      a new definition that extends and supersedes an existing one by
      shadowing it.</para>
    </sect2>

    <sect2 id="prefix-and-infix-operators">
      <title>Prefix and Infix Operators</title>

      <para>So far, we've seen examples of functions used in both prefix and
      infix style:<indexterm class="singular">
          <primary>operators</primary>

          <secondary>prefix and infix operators</secondary>
        </indexterm><indexterm class="singular">
          <primary>infix operators</primary>
        </indexterm><indexterm class="singular">
          <primary>prefix operators</primary>
        </indexterm><indexterm class="startofrange" id="FNCprf">
          <primary>functions</primary>

          <secondary>prefix and infix operators</secondary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variables-and-functions/main.topscript">OCaml utop</ulink>
      (part 24)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">Int.max 3 4  (* prefix *);;</userinput>
<computeroutput moreinfo="none">- : int = 4</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">3 + 4        (* infix  *);;</userinput>
<computeroutput moreinfo="none">- : int = 7</computeroutput></programlisting>

      <para>You might not have thought of the second example as an ordinary
      function, but it very much is. Infix operators like <literal moreinfo="none">+</literal> really only differ syntactically from other
      functions. In fact, if we put parentheses around an infix operator, you
      can use it as an ordinary prefix function:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variables-and-functions/main.topscript">OCaml utop</ulink>
      (part 25)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">(+) 3 4;;</userinput>
<computeroutput moreinfo="none">- : int = 7</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">List.map ~f:((+) 3) [4;5;6];;</userinput>
<computeroutput moreinfo="none">- : int list = [7; 8; 9]</computeroutput></programlisting>

      <para>In the second expression, we've partially applied <literal moreinfo="none">(+)</literal> to create a function that increments its
      single argument by <literal moreinfo="none">3</literal>.</para>

      <para>A function is treated syntactically as an operator if the name of
      that function is chosen from one of a specialized set of identifiers.
      This set includes identifiers that are sequences of characters from the
      following set:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variables-and-functions/operators.syntax">Syntax</ulink></para>

      <programlisting format="linespecific">! $ % &amp; * + - . / : &lt; = &gt; ? @ ^ | ~</programlisting>

      <para><literal>or</literal> is one of a handful of predetermined
      strings, including <literal moreinfo="none">mod</literal>, the modulus
      operator, and <literal moreinfo="none">lsl</literal>, for "logical shift
      left," a bit-shifting operation.</para>

      <para>We can define (or redefine) the meaning of an operator. Here's an
      example of a simple vector-addition operator on <literal>int</literal>
      pairs:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variables-and-functions/main.topscript">OCaml utop</ulink>
      (part 26)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let (+!) (x1,y1) (x2,y2) = (x1 + x2, y1 + y2);;</userinput>
<computeroutput moreinfo="none">val ( +! ) : int * int -&gt; int * int -&gt; int * int = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">(3,2) +! (-2,4);;</userinput>
<computeroutput moreinfo="none">- : int * int = (1, 6)</computeroutput></programlisting>

      <para>Note that you have to be careful when dealing with operators
      containing <literal moreinfo="none">*</literal>. Consider the following
      example:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variables-and-functions/main.topscript">OCaml utop</ulink>
      (part 27)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let (***) x y = (x ** y) ** y;;</userinput>
<computeroutput moreinfo="none">Characters 17-18:</computeroutput>
<computeroutput moreinfo="none">Error: This expression has type int but an expression was expected of type</computeroutput>
<computeroutput moreinfo="none">         float</computeroutput></programlisting>

      <para>What's going on is that <literal moreinfo="none">(***)</literal>
      isn't interpreted as an operator at all; it's read as a comment! To get
      this to work properly, we need to put spaces around any operator that
      begins or ends with <literal moreinfo="none">*</literal>:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variables-and-functions/main.topscript">OCaml utop</ulink>
      (part 28)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let ( *** ) x y = (x ** y) ** y;;</userinput>
<computeroutput moreinfo="none">val ( *** ) : float -&gt; float -&gt; float = &lt;fun&gt;</computeroutput></programlisting>

      <para>The syntactic role of an operator is typically determined by its
      first character or two, though there are a few exceptions. <xref linkend="table2_1"/> breaks the different operators and other syntactic
      forms into groups from highest to lowest precedence, explaining how each
      behaves syntactically. We write <literal moreinfo="none">!</literal>...
      to indicate the class of operators beginning with <literal moreinfo="none">!</literal>.</para>

      <table id="table2_1">
        <title>Precedence and associativity</title>

        <tgroup cols="2">
          <colspec align="left" colwidth="37*"/>

          <colspec align="left" colwidth="23*"/>

          <thead>
            <row>
              <entry>Operator prefix</entry>

              <entry>Associativity</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><literal moreinfo="none">!</literal>..., <literal moreinfo="none">?</literal>..., <literal moreinfo="none">~</literal>...</entry>

              <entry>Prefix</entry>
            </row>

            <row>
              <entry><literal moreinfo="none">.</literal>, <literal moreinfo="none">.(</literal>, <literal moreinfo="none">.[</literal></entry>

              <entry>-</entry>
            </row>

            <row>
              <entry>function application, constructor, <literal moreinfo="none">assert</literal>, <literal moreinfo="none">lazy</literal></entry>

              <entry>Left associative</entry>
            </row>

            <row>
              <entry><literal moreinfo="none">-</literal>, <literal moreinfo="none">-.</literal></entry>

              <entry>Prefix</entry>
            </row>

            <row>
              <entry><literal moreinfo="none">**</literal>..., <literal moreinfo="none">lsl</literal>, <literal moreinfo="none">lsr</literal>, <literal moreinfo="none">asr</literal></entry>

              <entry>Right associative</entry>
            </row>

            <row>
              <entry><literal moreinfo="none">*</literal>..., <literal moreinfo="none">/</literal>..., <literal moreinfo="none">%</literal>..., <literal moreinfo="none">mod</literal>, <literal moreinfo="none">land</literal>, <literal moreinfo="none">lor</literal>, <literal moreinfo="none">lxor</literal></entry>

              <entry>Left associative</entry>
            </row>

            <row>
              <entry><literal moreinfo="none">+</literal>..., <literal moreinfo="none">-</literal>...</entry>

              <entry>Left associative</entry>
            </row>

            <row>
              <entry><literal moreinfo="none">::</literal></entry>

              <entry>Right associative</entry>
            </row>

            <row>
              <entry><literal moreinfo="none">@</literal>..., <literal moreinfo="none">^</literal>...</entry>

              <entry>Right associative</entry>
            </row>

            <row>
              <entry><literal moreinfo="none">=</literal>..., <literal moreinfo="none">&lt;</literal>..., <literal moreinfo="none">&gt;</literal>..., <literal moreinfo="none">|</literal>..., <literal moreinfo="none">&amp;</literal>..., <literal moreinfo="none">$</literal>...</entry>

              <entry>Left associative</entry>
            </row>

            <row>
              <entry><literal moreinfo="none">&amp;</literal>, <literal moreinfo="none">&amp;&amp;</literal></entry>

              <entry>Right associative</entry>
            </row>

            <row>
              <entry><literal moreinfo="none">or</literal>, <literal moreinfo="none">||</literal></entry>

              <entry>Right associative</entry>
            </row>

            <row>
              <entry><literal moreinfo="none">,</literal></entry>

              <entry>-</entry>
            </row>

            <row>
              <entry><literal moreinfo="none">&lt;-</literal>, <literal moreinfo="none">:=</literal></entry>

              <entry>Right associative</entry>
            </row>

            <row>
              <entry><literal moreinfo="none">if</literal></entry>

              <entry>-</entry>
            </row>

            <row>
              <entry><literal moreinfo="none">;</literal></entry>

              <entry>Right associative</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>There's one important special case: <literal moreinfo="none">-</literal> and <literal moreinfo="none">-.</literal>,
      which are the integer and floating-point subtraction operators, and can
      act as both prefix operators (for negation) and infix operators (for
      subtraction). So, both <literal moreinfo="none">-x</literal> and
      <literal moreinfo="none">x - y</literal> are meaningful expressions.
      Another thing to remember about negation is that it has lower precedence
      than function application, which means that if you want to pass a
      negative value, you need to wrap it in parentheses, as you can see in
      this code:<indexterm class="singular">
          <primary>operators</primary>

          <secondary>negation operators</secondary>
        </indexterm><indexterm class="singular">
          <primary>operators</primary>

          <secondary>subtraction operators</secondary>
        </indexterm><indexterm class="singular">
          <primary>subtraction operators</primary>
        </indexterm><indexterm class="singular">
          <primary>negation operators</primary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variables-and-functions/main.topscript">OCaml utop</ulink>
      (part 29)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">Int.max 3 (-4);;</userinput>
<computeroutput moreinfo="none">- : int = 3</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Int.max 3 -4;;</userinput>
<computeroutput moreinfo="none">Characters -1-9:</computeroutput>
<computeroutput moreinfo="none">Error: This expression has type int -&gt; int</computeroutput>
<computeroutput moreinfo="none">       but an expression was expected of type int</computeroutput></programlisting>

      <para>Here, OCaml is interpreting the second expression as equivalent
      to:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variables-and-functions/main.topscript">OCaml utop</ulink>
      (part 30)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">(Int.max 3) - 4;;</userinput>
<computeroutput moreinfo="none">Characters 1-10:</computeroutput>
<computeroutput moreinfo="none">Error: This expression has type int -&gt; int</computeroutput>
<computeroutput moreinfo="none">       but an expression was expected of type int</computeroutput></programlisting>

      <para>which obviously doesn't make sense.</para>

      <para>Here's an example of a very useful operator from the standard
      library whose behavior depends critically on the precedence rules
      described previously:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variables-and-functions/main.topscript">OCaml utop</ulink>
      (part 31)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let (|&gt;) x f = f x ;;</userinput>
<computeroutput moreinfo="none">val ( |&gt; ) : 'a -&gt; ('a -&gt; 'b) -&gt; 'b = &lt;fun&gt;</computeroutput></programlisting>

      <para>It's not quite obvious at first what the purpose of this operator
      is: it just takes a value and a function and applies the function to the
      value. Despite that bland-sounding description, it has the useful role
      of a sequencing operator, similar in spirit to using the pipe character
      in the UNIX shell. Consider, for example, the following code for
      printing out the unique elements of your <literal moreinfo="none">PATH</literal>. Note that <literal moreinfo="none">List.dedup</literal> that follows removes duplicates
      from a list by sorting the list using the provided comparison
      function:<indexterm class="singular">
          <primary>lists</primary>

          <secondary>duplicate removal</secondary>
        </indexterm><indexterm class="singular">
          <primary>duplicates, removing</primary>
        </indexterm><indexterm class="singular">
          <primary>List.dedup</primary>
        </indexterm><indexterm class="singular">
          <primary>operators</primary>

          <secondary>sequencing operators</secondary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variables-and-functions/main.topscript">OCaml utop</ulink>
      (part 32)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let path = "/usr/bin:/usr/local/bin:/bin:/sbin";;</userinput>
<computeroutput moreinfo="none">val path : string = "/usr/bin:/usr/local/bin:/bin:/sbin"</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">String.split ~on:':' path</userinput>
<userinput moreinfo="none">  |&gt; List.dedup ~compare:String.compare</userinput>
<userinput moreinfo="none">  |&gt; List.iter ~f:print_endline</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">/bin</computeroutput>
<computeroutput moreinfo="none">/sbin</computeroutput>
<computeroutput moreinfo="none">/usr/bin</computeroutput>
<computeroutput moreinfo="none">/usr/local/bin</computeroutput>
<computeroutput moreinfo="none">- : unit = ()</computeroutput></programlisting>

      <para>Note that we can do this without <literal moreinfo="none">|&gt;</literal>, but the result is a bit more
      verbose:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variables-and-functions/main.topscript">OCaml utop</ulink>
      (part 33)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let split_path = String.split ~on:':' path in</userinput>
<userinput moreinfo="none">  let deduped_path = List.dedup ~compare:String.compare split_path in</userinput>
<userinput moreinfo="none">  List.iter ~f:print_endline deduped_path</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">/bin</computeroutput>
<computeroutput moreinfo="none">/sbin</computeroutput>
<computeroutput moreinfo="none">/usr/bin</computeroutput>
<computeroutput moreinfo="none">/usr/local/bin</computeroutput>
<computeroutput moreinfo="none">- : unit = ()</computeroutput></programlisting>

      <para>An important part of what's happening here is partial application.
      For example, <literal moreinfo="none">List.iter</literal> normally takes
      two arguments: a function to be called on each element of the list, and
      the list to iterate over. We can call <literal moreinfo="none">List.iter</literal> with all its arguments:<indexterm class="singular">
          <primary>partial application</primary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variables-and-functions/main.topscript">OCaml utop</ulink>
      (part 34)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">List.iter ~f:print_endline ["Two"; "lines"];;</userinput>
<computeroutput moreinfo="none">Two</computeroutput>
<computeroutput moreinfo="none">lines</computeroutput>
<computeroutput moreinfo="none">- : unit = ()</computeroutput></programlisting>

      <para>Or, we can pass it just the function argument, leaving us with a
      function for printing out a list of strings:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variables-and-functions/main.topscript">OCaml utop</ulink>
      (part 35)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">List.iter ~f:print_endline;;</userinput>
<computeroutput moreinfo="none">- : string list -&gt; unit = &lt;fun&gt;</computeroutput></programlisting>

      <para>It is this later form that we're using in the preceding <literal moreinfo="none">|&gt;</literal> pipeline.</para>

      <para>But <literal moreinfo="none">|&gt;</literal> only works in the intended way because it
        is left-associative. Let's see what happens if we try using a right-associative operator,
        like (^&gt;):</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variables-and-functions/main.topscript">OCaml utop</ulink>
      (part 36)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let (^&gt;) x f = f x;;</userinput>
<computeroutput moreinfo="none">val ( ^&gt; ) : 'a -&gt; ('a -&gt; 'b) -&gt; 'b = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Sys.getenv_exn "PATH"</userinput>
<userinput moreinfo="none">  ^&gt; String.split ~on:':' path</userinput>
<userinput moreinfo="none">  ^&gt; List.dedup ~compare:String.compare</userinput>
<userinput moreinfo="none">  ^&gt; List.iter ~f:print_endline</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">Characters 98-124:</computeroutput>
<computeroutput moreinfo="none">Error: This expression has type string list -&gt; unit</computeroutput>
<computeroutput moreinfo="none">       but an expression was expected of type</computeroutput>
<computeroutput moreinfo="none">         (string list -&gt; string list) -&gt; 'a</computeroutput>
<computeroutput moreinfo="none">       Type string list is not compatible with type</computeroutput>
<computeroutput moreinfo="none">         string list -&gt; string list </computeroutput></programlisting>

      <para>The type error is a little bewildering at first glance. What's
      going on is that, because <literal moreinfo="none">^&gt;</literal> is
      right associative, the operator is trying to feed the value <literal moreinfo="none">List.dedup ~compare:String.compare</literal> to the
      function <literal moreinfo="none">List.iter ~f:print_endline</literal>.
      But <literal moreinfo="none">List.iter ~f:print_endline</literal>
      expects a list of strings as its input, not a function.</para>

      <para>The type error aside, this example highlights the importance of
      choosing the operator you use with care, particularly with respect to
      associativity.<indexterm class="endofrange" startref="FNCprf"/></para>
    </sect2>

    <sect2 id="declaring-functions-with-function">
      <title>Declaring Functions with Function</title>

      <para>Another way to define a function is using the <literal moreinfo="none">function</literal> keyword. Instead of having syntactic
      support for declaring multiargument (curried) functions, <literal moreinfo="none">function</literal> has built-in pattern matching. Here's
      an example:<indexterm class="singular">
          <primary>functions</primary>

          <secondary>defining</secondary>
        </indexterm><indexterm class="singular">
          <primary>function keyword</primary>
        </indexterm><indexterm class="singular">
          <primary>functions</primary>

          <secondary>declaring with function keyword</secondary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variables-and-functions/main.topscript">OCaml utop</ulink>
      (part 37)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let some_or_zero = function</userinput>
<userinput moreinfo="none">     | Some x -&gt; x</userinput>
<userinput moreinfo="none">     | None -&gt; 0</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val some_or_zero : int option -&gt; int = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">List.map ~f:some_or_zero [Some 3; None; Some 4];;</userinput>
<computeroutput moreinfo="none">- : int list = [3; 0; 4]</computeroutput></programlisting>

      <para>This is equivalent to combining an ordinary function definition
      with a <literal moreinfo="none">match</literal>:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variables-and-functions/main.topscript">OCaml utop</ulink>
      (part 38)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let some_or_zero num_opt =</userinput>
<userinput moreinfo="none">    match num_opt with</userinput>
<userinput moreinfo="none">    | Some x -&gt; x</userinput>
<userinput moreinfo="none">    | None -&gt; 0</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val some_or_zero : int option -&gt; int = &lt;fun&gt;</computeroutput></programlisting>

      <para>We can also combine the different styles of function declaration
      together, as in the following example, where we declare a two-argument
      (curried) function with a pattern match on the second argument:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variables-and-functions/main.topscript">OCaml utop</ulink>
      (part 39)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let some_or_default default = function</userinput>
<userinput moreinfo="none">     | Some x -&gt; x</userinput>
<userinput moreinfo="none">     | None -&gt; default</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val some_or_default : 'a -&gt; 'a option -&gt; 'a = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">some_or_default 3 (Some 5);;</userinput>
<computeroutput moreinfo="none">- : int = 5</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">List.map ~f:(some_or_default 100) [Some 3; None; Some 4];;</userinput>
<computeroutput moreinfo="none">- : int list = [3; 100; 4]</computeroutput></programlisting>

      <para>Also, note the use of partial application to generate the function
      passed to <literal moreinfo="none">List.map</literal>. In other words,
      <literal moreinfo="none">some_or_default 100</literal> is a function
      that was created by feeding just the first argument to <literal moreinfo="none">some_or_default</literal>.</para>
    </sect2>

    <sect2 id="labeled-arguments">
      <title>Labeled Arguments</title>

      <para>Up until now, the functions we've defined have specified their arguments positionally,
          <emphasis>i.e.</emphasis>, by the order in which the arguments are passed to the function.
        OCaml also supports labeled arguments, which let you identify a function argument by name.
        Indeed, we've already encountered functions from Core like <literal moreinfo="none">List.map</literal> that use labeled arguments. Labeled arguments are marked by a leading
        tilde, and a label (followed by a colon) is put in front of the variable to be labeled.
        Here's an example:<indexterm class="singular">
          <primary>labeled arguments</primary>
        </indexterm><indexterm class="singular">
          <primary>arguments</primary>
          <secondary>labeled arguments</secondary>
        </indexterm><indexterm class="singular">
          <primary>functions</primary>
          <secondary>labeled arguments</secondary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variables-and-functions/main.topscript">OCaml utop</ulink>
      (part 40)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let ratio ~num ~denom = float num /. float denom;;</userinput>
<computeroutput moreinfo="none">val ratio : num:int -&gt; denom:int -&gt; float = &lt;fun&gt;</computeroutput></programlisting>

      <para>We can then provide a labeled argument using a similar convention.
      As you can see, the arguments can be provided in any order:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variables-and-functions/main.topscript">OCaml utop</ulink>
      (part 41)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">ratio ~num:3 ~denom:10;;</userinput>
<computeroutput moreinfo="none">- : float = 0.3</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">ratio ~denom:10 ~num:3;;</userinput>
<computeroutput moreinfo="none">- : float = 0.3</computeroutput></programlisting>

      <para>OCaml also supports <emphasis>label punning</emphasis>, meaning
      that you get to drop the text after the <literal moreinfo="none">:</literal> if the name of the label and the name of the
      variable being used are the same. We were actually already using label
      punning when defining <literal moreinfo="none">ratio</literal>. The
      following shows how punning can be used when invoking a
      function:<indexterm class="singular">
          <primary>punning</primary>
        </indexterm><indexterm class="singular">
          <primary>label punning</primary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variables-and-functions/main.topscript">OCaml utop</ulink>
      (part 42)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let num = 3 in</userinput>
<userinput moreinfo="none">  let denom = 4 in</userinput>
<userinput moreinfo="none">  ratio ~num ~denom;;</userinput>
<computeroutput moreinfo="none">- : float = 0.75</computeroutput></programlisting>

      <para>Labeled arguments are useful in a few different cases:</para>

      <itemizedlist>
        <listitem>
          <para>When defining a function with lots of arguments. Beyond a
          certain number, arguments are easier to remember by name than by
          position.<indexterm class="singular">
              <primary>functions</primary>

              <secondary>with multiple arguments</secondary>
            </indexterm><indexterm class="singular">
              <primary>multi-argument functions</primary>
            </indexterm></para>
        </listitem>

        <listitem>
          <para>When the meaning of a particular argument is unclear from the
          type alone. Consider a function for creating a hash table whose
          first argument is the initial size of the array backing the hash
          table, and the second is a Boolean flag, which indicates whether
          that array will ever shrink when elements are removed:</para>

          <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variables-and-functions/htable_sig1.ml">OCaml</ulink></para>

          <programlisting format="linespecific" language="ocaml">val create_hashtable : int -&gt; bool -&gt; ('a,'b) Hashtable.t</programlisting>

          <para>The signature makes it hard to divine the meaning of those two
          arguments. but with labeled arguments, we can make the intent
          immediately clear:</para>

          <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variables-and-functions/htable_sig2.ml">OCaml</ulink></para>

          <programlisting format="linespecific" language="ocaml">val create_hashtable :
  init_size:int -&gt; allow_shrinking:bool -&gt; ('a,'b) Hashtable.t</programlisting>

          <para>Choosing label names well is especially important for Boolean
          values, since it's often easy to get confused about whether a value
          being true is meant to enable or disable a given feature.</para>
        </listitem>

        <listitem>
          <para>When defining functions that have multiple arguments that
          might get confused with each other. This is most at issue when the
          arguments are of the same type. For example, consider this signature
          for a function that extracts a substring:</para>

          <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variables-and-functions/substring_sig1.ml">OCaml</ulink></para>

          <programlisting format="linespecific" language="ocaml">val substring: string -&gt; int -&gt; int -&gt; string</programlisting>

          <para>Here, the two <literal>ints</literal> are the starting position and length of the
            substring to extract, respectively. We can make this fact more obvious from the
            signature by adding labeled:</para>

          <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variables-and-functions/substring_sig2.ml">OCaml</ulink></para>

          <programlisting format="linespecific" language="ocaml">val substring: string -&gt; pos:int -&gt; len:int -&gt; string</programlisting>

          <para>This improves the readability of both the signature and of
          client code that makes use of <literal moreinfo="none">substring</literal> and makes it harder to
          accidentally swap the position and the length.</para>
        </listitem>

        <listitem>
          <para>When you want flexibility on the order in which arguments are
          passed. Consider a function like <literal moreinfo="none">List.iter</literal>, which takes two arguments: a
          function and a list of elements to call that function on. A common
          pattern is to partially apply <literal moreinfo="none">List.iter</literal> by giving it just the function,
          as in the following example from earlier in the chapter:</para>

          <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variables-and-functions/main.topscript">OCaml utop</ulink>
          (part 43)</para>

          <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">String.split ~on:':' path</userinput>
<userinput moreinfo="none">  |&gt; List.dedup ~compare:String.compare</userinput>
<userinput moreinfo="none">  |&gt; List.iter ~f:print_endline</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">/bin</computeroutput>
<computeroutput moreinfo="none">/sbin</computeroutput>
<computeroutput moreinfo="none">/usr/bin</computeroutput>
<computeroutput moreinfo="none">/usr/local/bin</computeroutput>
<computeroutput moreinfo="none">- : unit = ()</computeroutput></programlisting>

          <para>This requires that we put the function argument first. In
          other cases, you want to put the function argument second. One
          common reason is readability. In particular, a multiline function
          passed as an argument to another function is easiest to read when it
          is the final argument to that function.</para>
        </listitem>
      </itemizedlist>

      <sect3 id="higher-order-functions-and-labels">
        <title>Higher-order functions and labels</title>

        <para>One surprising gotcha with labeled arguments is that while order doesn't matter when
          calling a function with labeled arguments, it does matter in a higher-order context,
            <emphasis>e.g.</emphasis>, when passing a function with labeled arguments to another
          function. Here's an example:<indexterm class="singular">
            <primary>higher-order functions, and labels</primary>
          </indexterm><indexterm class="singular">
            <primary>functions</primary>
            <secondary>higher-order and labels</secondary>
          </indexterm></para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variables-and-functions/main.topscript">OCaml utop</ulink>
        (part 44)</para>

        <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let apply_to_tuple f (first,second) = f ~first ~second;;</userinput>
<computeroutput moreinfo="none">val apply_to_tuple : (first:'a -&gt; second:'b -&gt; 'c) -&gt; 'a * 'b -&gt; 'c = &lt;fun&gt;</computeroutput></programlisting>

        <para>Here, the definition of <literal moreinfo="none">apply_to_tuple</literal> sets up the expectation that
        its first argument is a function with two labeled arguments, <literal moreinfo="none">first</literal> and <literal moreinfo="none">second</literal>, listed in that order. We could have
        defined <literal moreinfo="none">apply_to_tuple</literal> differently
        to change the order in which the labeled arguments were listed:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variables-and-functions/main.topscript">OCaml utop</ulink>
        (part 45)</para>

        <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let apply_to_tuple_2 f (first,second) = f ~second ~first;;</userinput>
<computeroutput moreinfo="none">val apply_to_tuple_2 : (second:'a -&gt; first:'b -&gt; 'c) -&gt; 'b * 'a -&gt; 'c = &lt;fun&gt;</computeroutput></programlisting>

        <para>It turns out this order matters. In particular, if we define a
        function that has a different order</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variables-and-functions/main.topscript">OCaml utop</ulink>
        (part 46)</para>

        <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let divide ~first ~second = first / second;;</userinput>
<computeroutput moreinfo="none">val divide : first:int -&gt; second:int -&gt; int = &lt;fun&gt;</computeroutput></programlisting>

        <para>we'll find that it can't be passed in to <literal moreinfo="none">apply_to_tuple_2</literal>.</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variables-and-functions/main.topscript">OCaml utop</ulink>
        (part 47)</para>

        <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">apply_to_tuple_2 divide (3,4);;</userinput>
<computeroutput moreinfo="none">Characters 17-23:</computeroutput>
<computeroutput moreinfo="none">Error: This expression has type first:int -&gt; second:int -&gt; int</computeroutput>
<computeroutput moreinfo="none">       but an expression was expected of type second:'a -&gt; first:'b -&gt; 'c</computeroutput></programlisting>

        <para>But, it works smoothly with the original <literal moreinfo="none">apply_to_tuple</literal>:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variables-and-functions/main.topscript">OCaml utop</ulink>
        (part 48)</para>

        <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let apply_to_tuple f (first,second) = f ~first ~second;;</userinput>
<computeroutput moreinfo="none">val apply_to_tuple : (first:'a -&gt; second:'b -&gt; 'c) -&gt; 'a * 'b -&gt; 'c = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">apply_to_tuple divide (3,4);;</userinput>
<computeroutput moreinfo="none">- : int = 0</computeroutput></programlisting>

        <para>As a result, when passing labeled functions as arguments, you
        need to take care to be consistent in your ordering of labeled
        arguments.</para>
      </sect3>
    </sect2>

    <sect2 id="optional-arguments">
      <title>Optional Arguments</title>

      <para>An optional argument is like a labeled argument that the caller
      can choose whether or not to provide. Optional arguments are passed in
      using the same syntax as labeled arguments, and, like labeled arguments,
      can be provided in any order.<indexterm class="startofrange" id="ARGopt">
          <primary>arguments</primary>

          <secondary>optional arguments</secondary>
        </indexterm><indexterm class="startofrange" id="FNCopt">
          <primary>functions</primary>

          <secondary>optional arguments</secondary>
        </indexterm></para>

      <para>Here's an example of a string concatenation function with an
      optional separator. This function uses the <literal moreinfo="none">^</literal> operator for pairwise string
      concatenation:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variables-and-functions/main.topscript">OCaml utop</ulink>
      (part 49)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let concat ?sep x y =</userinput>
<userinput moreinfo="none">     let sep = match sep with None -&gt; "" | Some x -&gt; x in</userinput>
<userinput moreinfo="none">     x ^ sep ^ y</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val concat : ?sep:string -&gt; string -&gt; string -&gt; string = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">concat "foo" "bar"             (* without the optional argument *);;</userinput>
<computeroutput moreinfo="none">- : string = "foobar"</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">concat ~sep:":" "foo" "bar"    (* with the optional argument    *);;</userinput>
<computeroutput moreinfo="none">- : string = "foo:bar"</computeroutput></programlisting>

      <para>Here, <literal moreinfo="none">?</literal> is used in the
      definition of the function to mark <literal moreinfo="none">sep</literal> as optional. And while the caller can pass
      a value of type <literal moreinfo="none">string</literal> for <literal moreinfo="none">sep</literal>, internally to the function, <literal moreinfo="none">sep</literal> is seen as a <literal moreinfo="none">string option</literal>, with <literal moreinfo="none">None</literal> appearing when <literal moreinfo="none">sep</literal> is not provided by the caller.</para>

      <para>The preceding example needed a bit of boilerplate to choose a
      default separator when none was provided. This is a common enough
      pattern that there's an explicit syntax for providing a default value,
      which allows us to write <literal moreinfo="none">concat</literal> more
      concisely:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variables-and-functions/main.topscript">OCaml utop</ulink>
      (part 50)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let concat ?(sep="") x y = x ^ sep ^ y ;;</userinput>
<computeroutput moreinfo="none">val concat : ?sep:string -&gt; string -&gt; string -&gt; string = &lt;fun&gt;</computeroutput></programlisting>

      <para>Optional arguments are very useful, but they're also easy to abuse. The key advantage of
        optional arguments is that they let you write functions with multiple arguments that users
        can ignore most of the time, only worrying about them when they specifically want to invoke
        those options. They also allow you to extend an API with new functionality without changing
        existing code.</para>

      <para>The downside is that the caller may be unaware that there is a
      choice to be made, and so may unknowingly (and wrongly) pick the default
      behavior. Optional arguments really only make sense when the extra
      concision of omitting the argument outweighs the corresponding loss of
      explicitness.</para>

      <para>This means that rarely used functions should not have optional arguments. A good rule of
        thumb is to avoid optional arguments for functions internal to a module,
          <emphasis>i.e.</emphasis>, functions that are not included in the module's interface, or
          <literal moreinfo="none">mli</literal> file. We'll learn more about <literal moreinfo="none">mli</literal>s in <xref linkend="files-modules-and-programs"/>.</para>

      <sect3 id="explicit-passing-of-an-optional-argument">
        <title>Explicit passing of an optional argument</title>

        <para>Under the covers, a function with an optional argument receives
        <literal moreinfo="none">None</literal> when the caller doesn't
        provide the argument, and <literal moreinfo="none">Some</literal> when
        it does. But the <literal moreinfo="none">Some</literal> and <literal moreinfo="none">None</literal> are normally not explicitly passed in
        by the caller.</para>

        <para>But sometimes, passing in <literal moreinfo="none">Some</literal> or <literal moreinfo="none">None</literal> explicitly is exactly what you want.
        OCaml lets you do this by using <literal moreinfo="none">?</literal>
        instead of <literal moreinfo="none">~</literal> to mark the argument.
        Thus, the following two lines are equivalent ways of specifying the
        <literal moreinfo="none">sep</literal> argument to
        <literal>concat</literal>:<indexterm class="singular">
            <primary>optional arguments</primary>

            <secondary>explicit passing of</secondary>
          </indexterm></para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variables-and-functions/main.topscript">OCaml utop</ulink>
        (part 51)</para>

        <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">concat ~sep:":" "foo" "bar" (* provide the optional argument *);;</userinput>
<computeroutput moreinfo="none">- : string = "foo:bar"</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">concat ?sep:(Some ":") "foo" "bar" (* pass an explicit [Some] *);;</userinput>
<computeroutput moreinfo="none">- : string = "foo:bar"</computeroutput></programlisting>

        <para>And the following two lines are equivalent ways of calling
        <literal moreinfo="none">concat</literal> without specifying <literal moreinfo="none">sep</literal>:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variables-and-functions/main.topscript">OCaml utop</ulink>
        (part 52)</para>

        <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">concat "foo" "bar" (* don't provide the optional argument *);;</userinput>
<computeroutput moreinfo="none">- : string = "foobar"</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">concat ?sep:None "foo" "bar" (* explicitly pass `None` *);;</userinput>
<computeroutput moreinfo="none">- : string = "foobar"</computeroutput></programlisting>

        <para>One use case for this is when you want to define a wrapper
        function that mimics the optional arguments of the function it's
        wrapping. For example, imagine we wanted to create a function called
        <literal moreinfo="none">uppercase_concat</literal>, which is the same
        as <literal moreinfo="none">concat</literal> except that it converts
        the first string that it's passed to uppercase. We could write the
        function as follows:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variables-and-functions/main.topscript">OCaml utop</ulink>
        (part 53)</para>

        <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let uppercase_concat ?(sep="") a b = concat ~sep (String.uppercase a) b ;;</userinput>
<computeroutput moreinfo="none">val uppercase_concat : ?sep:string -&gt; string -&gt; string -&gt; string = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">uppercase_concat "foo" "bar";;</userinput>
<computeroutput moreinfo="none">- : string = "FOObar"</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">uppercase_concat "foo" "bar" ~sep:":";;</userinput>
<computeroutput moreinfo="none">- : string = "FOO:bar"</computeroutput></programlisting>

        <para>In the way we've written it, we've been forced to separately
        make the decision as to what the default separator is. Thus, if we
        later change <literal moreinfo="none">concat</literal>'s default
        behavior, we'll need to remember to change <literal moreinfo="none">uppercase_concat</literal> to match it.</para>

        <para>Instead, we can have <literal moreinfo="none">uppercase_concat</literal> simply pass through the
        optional argument to <literal moreinfo="none">concat</literal> using
        the <literal moreinfo="none">?</literal> syntax:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variables-and-functions/main.topscript">OCaml utop</ulink>
        (part 54)</para>

        <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let uppercase_concat ?sep a b = concat ?sep (String.uppercase a) b ;;</userinput>
<computeroutput moreinfo="none">val uppercase_concat : ?sep:string -&gt; string -&gt; string -&gt; string = &lt;fun&gt;</computeroutput></programlisting>

        <para>Now, if someone calls <literal moreinfo="none">uppercase_concat</literal> without an argument, an
        explicit <literal moreinfo="none">None</literal> will be passed to
        <literal moreinfo="none">concat</literal>, leaving <literal moreinfo="none">concat</literal> to decide what the default behavior
        should be.</para>
      </sect3>

      <sect3 id="inference-of-labeled-and-optional-arguments">
        <title>Inference of labeled and optional arguments</title>

        <para>One subtle aspect of labeled and optional arguments is how they
        are inferred by the type system. Consider the following example for
        computing numerical derivatives of a function of two real variables.
        The function takes an argument <literal moreinfo="none">delta</literal>, which determines the scale at which
        to compute the derivative; values <literal moreinfo="none">x</literal>
        and <literal moreinfo="none">y</literal>, which determine at which
        point to compute the derivative; and the function <literal moreinfo="none">f</literal>, whose derivative is being computed. The
        function <literal moreinfo="none">f</literal> itself takes two labeled
        arguments, <literal moreinfo="none">x</literal> and <literal moreinfo="none">y</literal>. Note that you can use an apostrophe as
        part of a variable name, so <literal moreinfo="none">x'</literal> and
        <literal moreinfo="none">y'</literal> are just ordinary
        variables:<indexterm class="singular">
            <primary>functions</primary>

            <secondary>argument inference</secondary>
          </indexterm><indexterm class="singular">
            <primary>labeled arguments</primary>
          </indexterm><indexterm class="singular">
            <primary>arguments</primary>

            <secondary>inference of</secondary>
          </indexterm><indexterm class="singular">
            <primary>optional arguments</primary>

            <secondary>inference of</secondary>
          </indexterm></para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variables-and-functions/main.topscript">OCaml utop</ulink>
        (part 55)</para>

        <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let numeric_deriv ~delta ~x ~y ~f =</userinput>
<userinput moreinfo="none">    let x' = x +. delta in</userinput>
<userinput moreinfo="none">    let y' = y +. delta in</userinput>
<userinput moreinfo="none">    let base = f ~x ~y in</userinput>
<userinput moreinfo="none">    let dx = (f ~x:x' ~y -. base) /. delta in</userinput>
<userinput moreinfo="none">    let dy = (f ~x ~y:y' -. base) /. delta in</userinput>
<userinput moreinfo="none">    (dx,dy)</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val numeric_deriv :</computeroutput>
<computeroutput moreinfo="none">  delta:float -&gt;</computeroutput>
<computeroutput moreinfo="none">  x:float -&gt; y:float -&gt; f:(x:float -&gt; y:float -&gt; float) -&gt; float * float =</computeroutput>
<computeroutput moreinfo="none">  &lt;fun&gt;</computeroutput></programlisting>

        <para>In principle, it's not obvious how the order of the arguments to
        <literal moreinfo="none">f</literal> should be chosen. Since labeled
        arguments can be passed in arbitrary order, it seems like it could as
        well be <literal moreinfo="none">y:float -&gt; x:float -&gt;
        float</literal> as it is <literal moreinfo="none">x:float -&gt;
        y:float -&gt; float</literal>.</para>

        <para>Even worse, it would be perfectly consistent for <literal moreinfo="none">f</literal> to take an optional argument instead of a
        labeled one, which could lead to this type signature for <literal moreinfo="none">numeric_deriv</literal>:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variables-and-functions/numerical_deriv_alt_sig.mli">OCaml</ulink></para>

        <programlisting format="linespecific" language="ocaml">val numeric_deriv :
  delta:float -&gt;
  x:float -&gt; y:float -&gt; f:(?x:float -&gt; y:float -&gt; float) -&gt; float * float</programlisting>

        <para>Since there are multiple plausible types to choose from, OCaml
        needs some heuristic for choosing between them. The heuristic the
        compiler uses is to prefer labels to options and to choose the order
        of arguments that shows up in the source code.</para>

        <para>Note that these heuristics might at different points in the
        source suggest different types. Here's a version of <literal moreinfo="none">numeric_deriv</literal> where different invocations of
        <literal moreinfo="none">f</literal> list the arguments in different
        orders:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variables-and-functions/main.topscript">OCaml utop</ulink>
        (part 56)</para>

        <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let numeric_deriv ~delta ~x ~y ~f =</userinput>
<userinput moreinfo="none">    let x' = x +. delta in</userinput>
<userinput moreinfo="none">    let y' = y +. delta in</userinput>
<userinput moreinfo="none">    let base = f ~x ~y in</userinput>
<userinput moreinfo="none">    let dx = (f ~y ~x:x' -. base) /. delta in</userinput>
<userinput moreinfo="none">    let dy = (f ~x ~y:y' -. base) /. delta in</userinput>
<userinput moreinfo="none">    (dx,dy)</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">Characters 130-131:</computeroutput>
<computeroutput moreinfo="none">Error: This function is applied to arguments</computeroutput>
<computeroutput moreinfo="none">in an order different from other calls.</computeroutput>
<computeroutput moreinfo="none">This is only allowed when the real type is known.</computeroutput></programlisting>

        <para>As suggested by the error message, we can get OCaml to accept
        the fact that <literal moreinfo="none">f</literal> is used with
        different argument orders if we provide explicit type information.
        Thus, the following code compiles without error, due to the type
        annotation on <literal moreinfo="none">f</literal>:<indexterm class="singular">
          <primary>type annotations</primary>
        </indexterm></para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variables-and-functions/main.topscript">OCaml utop</ulink>
        (part 57)</para>

        <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let numeric_deriv ~delta ~x ~y ~(f: x:float -&gt; y:float -&gt; float) =</userinput>
<userinput moreinfo="none">    let x' = x +. delta in</userinput>
<userinput moreinfo="none">    let y' = y +. delta in</userinput>
<userinput moreinfo="none">    let base = f ~x ~y in</userinput>
<userinput moreinfo="none">    let dx = (f ~y ~x:x' -. base) /. delta in</userinput>
<userinput moreinfo="none">    let dy = (f ~x ~y:y' -. base) /. delta in</userinput>
<userinput moreinfo="none">    (dx,dy)</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val numeric_deriv :</computeroutput>
<computeroutput moreinfo="none">  delta:float -&gt;</computeroutput>
<computeroutput moreinfo="none">  x:float -&gt; y:float -&gt; f:(x:float -&gt; y:float -&gt; float) -&gt; float * float =</computeroutput>
<computeroutput moreinfo="none">  &lt;fun&gt;</computeroutput></programlisting>
      </sect3>

      <sect3 id="optional-arguments-and-partial-application">
        <title>Optional arguments and partial application</title>

        <para>Optional arguments can be tricky to think about in the presence
        of partial application. We can of course partially apply the optional
        argument itself:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variables-and-functions/main.topscript">OCaml utop</ulink>
        (part 58)</para>

        <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let colon_concat = concat ~sep:":";;</userinput>
<computeroutput moreinfo="none">val colon_concat : string -&gt; string -&gt; string = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">colon_concat "a" "b";;</userinput>
<computeroutput moreinfo="none">- : string = "a:b"</computeroutput></programlisting>

        <para>But what happens if we partially apply just the first
        argument?</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variables-and-functions/main.topscript">OCaml utop</ulink>
        (part 59)</para>

        <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let prepend_pound = concat "# ";;</userinput>
<computeroutput moreinfo="none">val prepend_pound : string -&gt; string = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">prepend_pound "a BASH comment";;</userinput>
<computeroutput moreinfo="none">- : string = "# a BASH comment"</computeroutput></programlisting>

        <para>The optional argument <literal moreinfo="none">?sep</literal>
        has now disappeared, or been <emphasis>erased</emphasis>. Indeed, if
        we try to pass in that optional argument now, it will be
        rejected:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variables-and-functions/main.topscript">OCaml utop</ulink>
        (part 60)</para>

        <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">prepend_pound "a BASH comment" ~sep:":";;</userinput>
<computeroutput moreinfo="none">Characters -1-13:</computeroutput>
<computeroutput moreinfo="none">Error: This function has type string -&gt; string</computeroutput>
<computeroutput moreinfo="none">       It is applied to too many arguments; maybe you forgot a `;'.</computeroutput></programlisting>

        <para>So when does OCaml decide to erase an optional argument?</para>

        <para>The rule is: an optional argument is erased as soon as the first
        positional (i.e., neither labeled nor optional) argument defined
        <emphasis>after</emphasis> the optional argument is passed in. That
        explains the behavior of <literal moreinfo="none">prepend_pound</literal>. But if we had instead defined
        <literal moreinfo="none">concat</literal> with the optional argument
        in the second position:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variables-and-functions/main.topscript">OCaml utop</ulink>
        (part 61)</para>

        <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let concat x ?(sep="") y = x ^ sep ^ y ;;</userinput>
<computeroutput moreinfo="none">val concat : string -&gt; ?sep:string -&gt; string -&gt; string = &lt;fun&gt;</computeroutput></programlisting>

        <para>then application of the first argument would not cause the
        optional argument to be erased.</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variables-and-functions/main.topscript">OCaml utop</ulink>
        (part 62)</para>

        <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let prepend_pound = concat "# ";;</userinput>
<computeroutput moreinfo="none">val prepend_pound : ?sep:string -&gt; string -&gt; string = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">prepend_pound "a BASH comment";;</userinput>
<computeroutput moreinfo="none">- : string = "# a BASH comment"</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">prepend_pound "a BASH comment" ~sep:"--- ";;</userinput>
<computeroutput moreinfo="none">- : string = "# --- a BASH comment"</computeroutput></programlisting>

        <para>However, if all arguments to a function are presented at once,
        then erasure of optional arguments isn't applied until all of the
        arguments are passed in. This preserves our ability to pass in
        optional arguments anywhere on the argument list. Thus, we can
        write:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variables-and-functions/main.topscript">OCaml utop</ulink>
        (part 63)</para>

        <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">concat "a" "b" ~sep:"=";;</userinput>
<computeroutput moreinfo="none">- : string = "a=b"</computeroutput></programlisting>

        <para>An optional argument that doesn't have any following positional
        arguments can't be erased at all, which leads to a compiler
        warning:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variables-and-functions/main.topscript">OCaml utop</ulink>
        (part 64)</para>

        <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let concat x y ?(sep="") = x ^ sep ^ y ;;</userinput>
<computeroutput moreinfo="none">Characters 15-38:</computeroutput>
<computeroutput moreinfo="none">Warning 16: this optional argument cannot be erased.</computeroutput>
<computeroutput moreinfo="none">val concat : string -&gt; string -&gt; ?sep:string -&gt; string = &lt;fun&gt;</computeroutput></programlisting>

        <para>And indeed, when we provide the two positional arguments, the
        <literal moreinfo="none">sep</literal> argument is not erased, instead
        returning a function that expects the <literal moreinfo="none">sep</literal> argument to be provided:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variables-and-functions/main.topscript">OCaml utop</ulink>
        (part 65)</para>

        <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">concat "a" "b";;</userinput>
<computeroutput moreinfo="none">- : ?sep:string -&gt; string = &lt;fun&gt;</computeroutput></programlisting>

        <para>As you can see, OCaml's support for labeled and optional
        arguments is not without its complexities. But don't let these
        complexities obscure the usefulness of these features. Labels and
        optional arguments are very effective tools for making your APIs both
        more convenient and safer, and it's worth the effort of learning how
        to use them effectively.<indexterm class="endofrange" startref="ARGopt"/><indexterm class="endofrange" startref="FNCopt"/></para>
      </sect3>
    </sect2>
  </sect1>
</chapter>

  <chapter id="lists-and-patterns">
  <title>Lists and Patterns</title>

  <para>This chapter will focus on two common elements of programming in
  OCaml: lists and pattern matching. Both of these were discussed in <xref linkend="a-guided-tour"/>, but we'll go into more depth here, presenting
  the two topics together and using one to help illustrate the other.</para>

  <sect1 id="list-basics">
    <title>List Basics</title>

    <para>An OCaml list is an immutable, finite sequence of elements of the
    same type. As we've seen, OCaml lists can be generated using a
    bracket-and-semicolon notation:<indexterm class="singular">
        <primary>lists</primary>

        <secondary>generation of</secondary>
      </indexterm></para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/lists-and-patterns/main.topscript">OCaml utop</ulink></para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">[1;2;3];;</userinput>
<computeroutput moreinfo="none">- : int list = [1; 2; 3]</computeroutput></programlisting>

    <para>And they can also be generated using the equivalent <literal moreinfo="none">::</literal> notation:<indexterm class="singular">
        <primary>operators</primary>

        <secondary>: : operator</secondary>
      </indexterm><indexterm class="singular">
        <primary>lists</primary>

        <secondary>operator : :</secondary>
      </indexterm></para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/lists-and-patterns/main.topscript">OCaml utop</ulink>
    (part 1)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">1 :: (2 :: (3 :: [])) ;;</userinput>
<computeroutput moreinfo="none">- : int list = [1; 2; 3]</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">1 :: 2 :: 3 :: [] ;;</userinput>
<computeroutput moreinfo="none">- : int list = [1; 2; 3]</computeroutput></programlisting>

    <para>As you can see, the <literal moreinfo="none">::</literal> operator
    is right-associative, which means that we can build up lists without
    parentheses. The empty list <literal moreinfo="none">[]</literal> is used
    to terminate a list. Note that the empty list is polymorphic, meaning it
    can be used with elements of any type, as you can see here:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/lists-and-patterns/main.topscript">OCaml utop</ulink>
    (part 2)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let empty = [];;</userinput>
<computeroutput moreinfo="none">val empty : 'a list = []</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">3 :: empty;;</userinput>
<computeroutput moreinfo="none">- : int list = [3]</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">"three" :: empty;;</userinput>
<computeroutput moreinfo="none">- : string list = ["three"]</computeroutput></programlisting>

    <para>The way in which the <literal moreinfo="none">::</literal> operator
    attaches elements to the front of a list reflects the fact that OCaml's
    lists are in fact singly linked lists. The figure below is a
    rough graphical representation of how the list <literal moreinfo="none">1
    :: 2 :: 3 :: []</literal> is laid out as a data structure. The final arrow
    (from the box containing <literal moreinfo="none">3</literal>) points to
    the empty list.<indexterm class="singular">
        <primary>lists</primary>

        <secondary>structure of</secondary>
      </indexterm></para>
    
    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/lists-and-patterns/lists_layout.ascii">Diagram</ulink></para>
    
    <informalfigure>
      <mediaobject>
        <imageobject role="web">
          <imagedata fileref="images/rwoc_0301.png" format="PNG"/>
        </imageobject>
      </mediaobject>
    </informalfigure>

    <para>Each <literal moreinfo="none">::</literal> essentially adds a new block to the proceding
      picture. Such a block contains two things: a reference to the data in that list element, and a
      reference to the remainder of the list. This is why <literal moreinfo="none">::</literal> can
      extend a list without modifying it; extension allocates a new list element but change any of
      the existing ones, as you can see:<indexterm class="singular">
        <primary>lists</primary>
        <secondary>extension of</secondary>
      </indexterm></para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/lists-and-patterns/main.topscript">OCaml utop</ulink>
    (part 3)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let l = 1 :: 2 :: 3 :: [];;</userinput>
<computeroutput moreinfo="none">val l : int list = [1; 2; 3]</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let m = 0 :: l;;</userinput>
<computeroutput moreinfo="none">val m : int list = [0; 1; 2; 3]</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">l;;</userinput>
<computeroutput moreinfo="none">- : int list = [1; 2; 3]</computeroutput></programlisting>
  </sect1>

  <sect1 id="using-patterns-to-extract-data-from-a-list">
    <title>Using Patterns to Extract Data from a List</title>

    <para>We can read data out of a list using a <literal>match</literal>
    statement. Here's a simple example of a recursive function that computes
    the sum of all elements of a list:<indexterm class="singular">
        <primary>match statements</primary>
      </indexterm><indexterm class="startofrange" id="PATMAT">
        <primary>pattern matching</primary>

        <secondary>extracting data with</secondary>
      </indexterm><indexterm class="singular">
        <primary>lists</primary>

        <secondary>extracting data from</secondary>
      </indexterm></para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/lists-and-patterns/main.topscript">OCaml utop</ulink>
    (part 4)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let rec sum l =</userinput>
<userinput moreinfo="none">    match l with</userinput>
<userinput moreinfo="none">    | [] -&gt; 0</userinput>
<userinput moreinfo="none">    | hd :: tl -&gt; hd + sum tl</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val sum : int list -&gt; int = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">sum [1;2;3];;</userinput>
<computeroutput moreinfo="none">- : int = 6</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">sum [];;</userinput>
<computeroutput moreinfo="none">- : int = 0</computeroutput></programlisting>

    <para>This code follows the convention of using <literal moreinfo="none">hd</literal> to represent the first element (or head) of
    the list, and <literal moreinfo="none">tl</literal> to represent the
    remainder (or tail).</para>

    <para>The <literal>match</literal> statement in <literal moreinfo="none">sum</literal> is really doing two things: first, it's
    acting as a case-analysis tool, breaking down the possibilities into a
    pattern-indexed list of cases. Second, it lets you name substructures
    within the data structure being matched. In this case, the variables
    <literal moreinfo="none">hd</literal> and <literal moreinfo="none">tl</literal> are bound by the pattern that defines the
    second case of the match statement. Variables that are bound in this way
    can be used in the expression to the right of the arrow for the pattern in
    question.</para>

    <para>The fact that <literal>match</literal> statements can be used to
    bind new variables can be a source of confusion. To see how, imagine we
    wanted to write a function that filtered out from a list all elements
    equal to a particular value. You might be tempted to write that code as
    follows, but when you do, the compiler will immediately warn you that
    something is wrong:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/lists-and-patterns/main.topscript">OCaml utop</ulink>
    (part 5)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let rec drop_value l to_drop =</userinput>
<userinput moreinfo="none">    match l with</userinput>
<userinput moreinfo="none">    | [] -&gt; []</userinput>
<userinput moreinfo="none">    | to_drop :: tl -&gt; drop_value tl to_drop</userinput>
<userinput moreinfo="none">    | hd :: tl -&gt; hd :: drop_value tl to_drop</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">Characters 114-122:</computeroutput>
<computeroutput moreinfo="none">Warning 11: this match case is unused.</computeroutput>
<computeroutput moreinfo="none">val drop_value : 'a list -&gt; 'a -&gt; 'a list = &lt;fun&gt;</computeroutput></programlisting>

    <para>Moreover, the function clearly does the wrong thing, filtering out
    all elements of the list rather than just those equal to the provided
    value, as you can see here:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/lists-and-patterns/main.topscript">OCaml utop</ulink>
    (part 6)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">drop_value [1;2;3] 2;;</userinput>
<computeroutput moreinfo="none">- : int list = []</computeroutput></programlisting>

    <para>So, what's going on?</para>

    <para>The key observation is that the appearance of <literal moreinfo="none">to_drop</literal> in the second case doesn't imply a check
    that the first element is equal to the value <literal moreinfo="none">to_drop</literal> passed in as an argument to <literal moreinfo="none">drop_value</literal>. Instead, it just causes a new
    variable <literal moreinfo="none">to_drop</literal> to be bound to
    whatever happens to be in the first element of the list, shadowing the
    earlier definition of <literal moreinfo="none">to_drop</literal>. The
    third case is unused because it is essentially the same pattern as we had
    in the second case.</para>

    <para>A better way to write this code is not to use pattern matching for
    determining whether the first element is equal to <literal moreinfo="none">to_drop</literal>, but to instead use an ordinary
    <literal>if</literal> statement:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/lists-and-patterns/main.topscript">OCaml utop</ulink>
    (part 7)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let rec drop_value l to_drop =</userinput>
<userinput moreinfo="none">    match l with</userinput>
<userinput moreinfo="none">    | [] -&gt; []</userinput>
<userinput moreinfo="none">    | hd :: tl -&gt;</userinput>
<userinput moreinfo="none">      let new_tl = drop_value tl to_drop in</userinput>
<userinput moreinfo="none">      if hd = to_drop then new_tl else hd :: new_tl</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val drop_value : 'a list -&gt; 'a -&gt; 'a list = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">drop_value [1;2;3] 2;;</userinput>
<computeroutput moreinfo="none">- : int list = [1; 3]</computeroutput></programlisting>

    <para>Note that if we wanted to drop a particular literal value (rather
    than a value that was passed in), we could do this using something like
    our original implementation of <literal moreinfo="none">drop_value</literal>:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/lists-and-patterns/main.topscript">OCaml utop</ulink>
    (part 8)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let rec drop_zero l =</userinput>
<userinput moreinfo="none">    match l with</userinput>
<userinput moreinfo="none">    | [] -&gt; []</userinput>
<userinput moreinfo="none">    | 0  :: tl -&gt; drop_zero tl</userinput>
<userinput moreinfo="none">    | hd :: tl -&gt; hd :: drop_zero tl</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val drop_zero : int list -&gt; int list = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">drop_zero [1;2;0;3];;</userinput>
<computeroutput moreinfo="none">- : int list = [1; 2; 3]</computeroutput></programlisting>
  </sect1>

  <sect1 id="limitations-and-blessings-of-pattern-matching">
    <title>Limitations (and Blessings) of Pattern Matching</title>

    <para>The preceding example highlights an important fact about patterns,
    which is that they can't be used to express arbitrary conditions. Patterns
    can characterize the layout of a data structure and can even include
    literals, as in the <literal moreinfo="none">drop_zero</literal> example,
    but that's where they stop. A pattern can check if a list has two
    elements, but it can't check if the first two elements are equal to each
    other.<indexterm class="singular">
        <primary>data structures</primary>

        <secondary>pattern matching and</secondary>
      </indexterm></para>

    <para>You can think of patterns as a specialized sublanguage that can
    express a limited (though still quite rich) set of conditions. The fact
    that the pattern language is limited turns out to be a very good thing,
    making it possible to build better support for patterns in the compiler.
    In particular, both the efficiency of <literal>match</literal> statements
    and the ability of the compiler to detect errors in matches depend on the
    constrained nature of patterns.</para>

    <sect2 id="performance">
      <title>Performance</title>

      <para>Naively, you might think that it would be necessary to check each
      case in a <literal moreinfo="none">match</literal> in sequence to figure
      out which one fires. If the cases of a match were guarded by arbitrary
      code, that would be the case. But OCaml is often able to generate
      machine code that jumps directly to the matched case based on an
      efficiently chosen set of runtime checks.</para>

      <para>As an example, consider the following rather silly functions for
      incrementing an integer by one. The first is implemented with a
      <literal>match</literal> statement, and the second with a sequence of
      <literal>if</literal> statements:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/lists-and-patterns/main.topscript">OCaml utop</ulink>
      (part 9)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let plus_one_match x =</userinput>
<userinput moreinfo="none">    match x with</userinput>
<userinput moreinfo="none">    | 0 -&gt; 1</userinput>
<userinput moreinfo="none">    | 1 -&gt; 2</userinput>
<userinput moreinfo="none">    | 2 -&gt; 3</userinput>
<userinput moreinfo="none">    | _ -&gt; x + 1</userinput>
<userinput moreinfo="none"/>
<userinput moreinfo="none">  let plus_one_if x =</userinput>
<userinput moreinfo="none">    if      x = 0 then 1</userinput>
<userinput moreinfo="none">    else if x = 1 then 2</userinput>
<userinput moreinfo="none">    else if x = 2 then 3</userinput>
<userinput moreinfo="none">    else x + 1</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val plus_one_match : int -&gt; int = &lt;fun&gt;</computeroutput>
<computeroutput moreinfo="none">val plus_one_if : int -&gt; int = &lt;fun&gt;</computeroutput></programlisting>

      <para>Note the use of <literal moreinfo="none">_</literal> in the above
      match. This is a wildcard pattern that matches any value, but without
      binding a variable name to the value in question.</para>

      <para>If you benchmark these functions, you'll see that <literal moreinfo="none">plus_one_if</literal> is considerably slower than
      <literal moreinfo="none">plus_one_match</literal>, and the advantage
      gets larger as the number of cases increases. Here, we'll benchmark
      these functions using the <literal moreinfo="none">core_bench</literal>
      library, which can be installed by running <literal moreinfo="none">opam
      install core_bench</literal> from the command line:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/lists-and-patterns/main.topscript">OCaml utop</ulink>
      (part 10)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">#require "core_bench";;</userinput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">open Core_bench.Std;;</userinput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let run_bench tests =</userinput>
<userinput moreinfo="none">  Bench.bench</userinput>
<userinput moreinfo="none">    ~ascii_table:true</userinput>
<userinput moreinfo="none">    ~display:Textutils.Ascii_table.Display.column_titles</userinput>
<userinput moreinfo="none">    tests</userinput>
<userinput moreinfo="none">;;</userinput>
<computeroutput moreinfo="none">val run_bench : Bench.Test.t list -&gt; unit = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">[ Bench.Test.create ~name:"plus_one_match" (fun () -&gt;</userinput>
<userinput moreinfo="none">      ignore (plus_one_match 10))</userinput>
<userinput moreinfo="none">  ; Bench.Test.create ~name:"plus_one_if" (fun () -&gt;</userinput>
<userinput moreinfo="none">      ignore (plus_one_if 10)) ]</userinput>
<userinput moreinfo="none">  |&gt; run_bench</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">Estimated testing time 20s (change using -quota SECS).</computeroutput>
<computeroutput moreinfo="none">                                         </computeroutput>
<computeroutput moreinfo="none">  Name             Time (ns)   % of max  </computeroutput>
<computeroutput moreinfo="none"> ---------------- ----------- ---------- </computeroutput>
<computeroutput moreinfo="none">  plus_one_match       46.81      68.21  </computeroutput>
<computeroutput moreinfo="none">  plus_one_if          68.63     100.00  </computeroutput>
<computeroutput moreinfo="none">                                         </computeroutput>
<computeroutput moreinfo="none">- : unit = ()</computeroutput></programlisting>

      <para>Here's another, less artificial example. We can rewrite the
      <literal moreinfo="none">sum</literal> function we described earlier in
      the chapter using an <literal moreinfo="none">if</literal> statement
      rather than a match. We can then use the functions <literal moreinfo="none">is_empty</literal>, <literal moreinfo="none">hd_exn</literal>, and <literal moreinfo="none">tl_exn</literal> from the <literal moreinfo="none">List</literal> module to deconstruct the list, allowing
      us to implement the entire function without pattern matching:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/lists-and-patterns/main.topscript">OCaml utop</ulink>
      (part 11)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let rec sum_if l =</userinput>
<userinput moreinfo="none">    if List.is_empty l then 0</userinput>
<userinput moreinfo="none">    else List.hd_exn l + sum_if (List.tl_exn l)</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val sum_if : int list -&gt; int = &lt;fun&gt;</computeroutput></programlisting>

      <para>Again, we can benchmark these to see the difference:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/lists-and-patterns/main.topscript">OCaml utop</ulink>
      (part 12)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let numbers = List.range 0 1000 in</userinput>
<userinput moreinfo="none">  [ Bench.Test.create ~name:"sum_if" (fun () -&gt; ignore (sum_if numbers))</userinput>
<userinput moreinfo="none">  ; Bench.Test.create ~name:"sum"    (fun () -&gt; ignore (sum numbers)) ]</userinput>
<userinput moreinfo="none">  |&gt; run_bench</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">Estimated testing time 20s (change using -quota SECS).</computeroutput>
<computeroutput moreinfo="none">                                 </computeroutput>
<computeroutput moreinfo="none">  Name     Time (ns)   % of max  </computeroutput>
<computeroutput moreinfo="none"> -------- ----------- ---------- </computeroutput>
<computeroutput moreinfo="none">  sum_if     110_535     100.00  </computeroutput>
<computeroutput moreinfo="none">  sum         22_361      20.23  </computeroutput>
<computeroutput moreinfo="none">                                 </computeroutput>
<computeroutput moreinfo="none">- : unit = ()</computeroutput></programlisting>

      <para>In this case, the <literal moreinfo="none">match</literal>-based
      implementation is many times faster than the <literal moreinfo="none">if</literal>-based implementation. The difference comes
      because we need to effectively do the same work multiple times, since
      each function we call has to reexamine the first element of the list to
      determine whether or not it's the empty cell. With a
      <literal>match</literal> statement, this work happens exactly once per
      list element.</para>

      <para>Generally, pattern matching is more efficient than the
      alternatives you might code by hand. One notable exception is matches
      over strings, which are in fact tested sequentially, so matches
      containing a long sequence of strings can be outperformed by a hash
      table. But most of the time, pattern matching is a clear performance
      win.</para>
    </sect2>

    <sect2 id="detecting-errors">
      <title>Detecting Errors</title>

      <para>The error-detecting capabilities of <literal>match</literal>
      statements are if anything more important than their performance. We've
      already seen one example of OCaml's ability to find problems in a
      pattern match: in our broken implementation of <literal moreinfo="none">drop_value</literal>, OCaml warned us that the final
      case was redundant. There are no algorithms for determining if a
      predicate written in a general-purpose language is redundant, but it can
      be solved reliably in the context of patterns.<indexterm class="singular">
          <primary>match statements</primary>
        </indexterm><indexterm class="singular">
          <primary>errors</primary>

          <secondary>detecting with match statements</secondary>
        </indexterm></para>

      <para>OCaml also checks <literal>match</literal> statements for
      exhaustiveness. Consider what happens if we modify <literal moreinfo="none">drop_zero</literal> by deleting the handler for one of
      the cases. As you can see, the compiler will produce a warning that
      we've missed a case, along with an example of an unmatched
      pattern:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/lists-and-patterns/main.topscript">OCaml utop</ulink>
      (part 13)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let rec drop_zero l =</userinput>
<userinput moreinfo="none">    match l with</userinput>
<userinput moreinfo="none">    | [] -&gt; []</userinput>
<userinput moreinfo="none">    | 0  :: tl -&gt; drop_zero tl</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">Characters 26-84:</computeroutput>
<computeroutput moreinfo="none">Warning 8: this pattern-matching is not exhaustive.</computeroutput>
<computeroutput moreinfo="none">Here is an example of a value that is not matched:</computeroutput>
<computeroutput moreinfo="none">1::_</computeroutput>
<computeroutput moreinfo="none">val drop_zero : int list -&gt; 'a list = &lt;fun&gt;</computeroutput></programlisting>

      <para>Even for simple examples like this, exhaustiveness checks are
      pretty useful. But as we'll see in <xref linkend="variants"/>, they
      become yet more valuable as you get to more complicated examples,
      especially those involving user-defined types. In addition to catching
      outright errors, they act as a sort of refactoring tool, guiding you to
      the locations where you need to adapt your code to deal with changing
      types.<indexterm class="endofrange" startref="PATMAT"/></para>
    </sect2>
  </sect1>

  <sect1 id="using-the-list-module-effectively">
    <title>Using the List Module Effectively</title>

    <para>We've so far written a fair amount of list-munging code using
    pattern matching and recursive functions. But in real life, you're usually
    better off using the <literal moreinfo="none">List</literal> module, which
    is full of reusable functions that abstract out common patterns for
    computing with lists.<indexterm class="singular">
        <primary>tables, creating with List module</primary>
      </indexterm><indexterm class="singular">
        <primary>List module</primary>

        <secondary>creating tables with</secondary>
      </indexterm><indexterm class="startofrange" id="Llistmod">
        <primary>lists</primary>

        <secondary>List module</secondary>
      </indexterm></para>

    <para>Let's work through a concrete example to see this in action. We'll
    write a function <literal moreinfo="none">render_table</literal> that,
    given a list of column headers and a list of rows, prints them out in a
    well-formatted text table, as follows:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/lists-and-patterns/main.topscript">OCaml utop</ulink>
    (part 69)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">printf "%s\n"</userinput>
<userinput moreinfo="none">   (render_table</userinput>
<userinput moreinfo="none">     ["language";"architect";"first release"]</userinput>
<userinput moreinfo="none">     [ ["Lisp" ;"John McCarthy" ;"1958"] ;</userinput>
<userinput moreinfo="none">       ["C"    ;"Dennis Ritchie";"1969"] ;</userinput>
<userinput moreinfo="none">       ["ML"   ;"Robin Milner"  ;"1973"] ;</userinput>
<userinput moreinfo="none">       ["OCaml";"Xavier Leroy"  ;"1996"] ;</userinput>
<userinput moreinfo="none">     ]);;</userinput>
<computeroutput moreinfo="none">| language | architect      | first release |</computeroutput>
<computeroutput moreinfo="none">|----------+----------------+---------------|</computeroutput>
<computeroutput moreinfo="none">| Lisp     | John McCarthy  | 1958          |</computeroutput>
<computeroutput moreinfo="none">| C        | Dennis Ritchie | 1969          |</computeroutput>
<computeroutput moreinfo="none">| ML       | Robin Milner   | 1973          |</computeroutput>
<computeroutput moreinfo="none">| OCaml    | Xavier Leroy   | 1996          |</computeroutput>
<computeroutput moreinfo="none">- : unit = ()</computeroutput></programlisting>

    <para>The first step is to write a function to compute the maximum width
    of each column of data. We can do this by converting the header and each
    row into a list of integer lengths, and then taking the element-wise max
    of those lists of lengths. Writing the code for all of this directly would
    be a bit of a chore, but we can do it quite concisely by making use of
    three functions from the <literal moreinfo="none">List</literal> module:
    <literal moreinfo="none">map</literal>, <literal moreinfo="none">map2_exn</literal>, and <literal moreinfo="none">fold</literal>.</para>

    <para><literal moreinfo="none">List.map</literal> is the simplest to
    explain. It takes a list and a function for transforming elements of that
    list, and returns a new list with the transformed elements. Thus, we can
    write:<indexterm class="singular">
        <primary>List module</primary>

        <secondary>List.map</secondary>
      </indexterm></para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/lists-and-patterns/main.topscript">OCaml utop</ulink>
    (part 14)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">List.map ~f:String.length ["Hello"; "World!"];;</userinput>
<computeroutput moreinfo="none">- : int list = [5; 6]</computeroutput></programlisting>

    <para><literal moreinfo="none">List.map2_exn</literal> is similar to
    <literal moreinfo="none">List.map</literal>, except that it takes two
    lists and a function for combining them. Thus, we might write:<indexterm class="singular">
        <primary>List module</primary>

        <secondary>List.map2_exn</secondary>
      </indexterm></para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/lists-and-patterns/main.topscript">OCaml utop</ulink>
    (part 15)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">List.map2_exn ~f:Int.max [1;2;3] [3;2;1];;</userinput>
<computeroutput moreinfo="none">- : int list = [3; 2; 3]</computeroutput></programlisting>

    <para>The <literal moreinfo="none">_exn</literal> is there because the
    function throws an exception if the lists are of mismatched length:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/lists-and-patterns/main.topscript">OCaml utop</ulink>
    (part 16)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">List.map2_exn ~f:Int.max [1;2;3] [3;2;1;0];;</userinput>
<computeroutput moreinfo="none">Exception: (Invalid_argument "length mismatch in rev_map2_exn: 3 &lt;&gt; 4 ").</computeroutput></programlisting>

    <para><literal moreinfo="none">List.fold</literal> is the most complicated of the three, taking
      three arguments: a list to process, an initial accumulator value, and a function for updating
      the accumulator. <literal moreinfo="none">List.fold</literal> walks over the list from left to
      right, updating the accumulator at each step and returning the final value of the accumulator
      when it's done. You can see some of this by looking at the type-signature for <literal moreinfo="none">fold</literal>:<indexterm class="singular">
        <primary>List module</primary>
        <secondary>List.fold</secondary>
      </indexterm></para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/lists-and-patterns/main.topscript">OCaml utop</ulink>
    (part 17)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">List.fold;;</userinput>
<computeroutput moreinfo="none">- : 'a list -&gt; init:'accum -&gt; f:('accum -&gt; 'a -&gt; 'accum) -&gt; 'accum = &lt;fun&gt;</computeroutput></programlisting>

    <para>We can use <literal moreinfo="none">List.fold</literal> for
    something as simple as summing up a list:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/lists-and-patterns/main.topscript">OCaml utop</ulink>
    (part 18)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">List.fold ~init:0 ~f:(+) [1;2;3;4];;</userinput>
<computeroutput moreinfo="none">- : int = 10</computeroutput></programlisting>

    <para>This example is particularly simple because the accumulator and the
    list elements are of the same type. But <literal moreinfo="none">fold</literal> is not limited to such cases. We can for
    example use <literal moreinfo="none">fold</literal> to reverse a list, in
    which case the accumulator is itself a list:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/lists-and-patterns/main.topscript">OCaml utop</ulink>
    (part 19)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">List.fold ~init:[] ~f:(fun list x -&gt; x :: list) [1;2;3;4];;</userinput>
<computeroutput moreinfo="none">- : int list = [4; 3; 2; 1]</computeroutput></programlisting>

    <para>Let's bring our three functions together to compute the maximum
    column widths:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/lists-and-patterns/main.topscript">OCaml utop</ulink>
    (part 20)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let max_widths header rows =</userinput>
<userinput moreinfo="none">    let lengths l = List.map ~f:String.length l in</userinput>
<userinput moreinfo="none">    List.fold rows</userinput>
<userinput moreinfo="none">      ~init:(lengths header)</userinput>
<userinput moreinfo="none">      ~f:(fun acc row -&gt;</userinput>
<userinput moreinfo="none">        List.map2_exn ~f:Int.max acc (lengths row))</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val max_widths : string list -&gt; string list list -&gt; int list = &lt;fun&gt;</computeroutput></programlisting>

    <para>Using <literal moreinfo="none">List.map</literal> we define the
    function <literal moreinfo="none">lengths</literal>, which converts a list
    of strings to a list of integer lengths. <literal moreinfo="none">List.fold</literal> is then used to iterate over the rows,
    using <literal moreinfo="none">map2_exn</literal> to take the max of the
    accumulator with the lengths of the strings in each row of the table, with
    the accumulator initialized to the lengths of the header row.</para>

    <para>Now that we know how to compute column widths, we can write the code
    to generate the line that separates the header from the rest of the text
    table. We'll do this in part by mapping <literal moreinfo="none">String.make</literal> over the lengths of the columns to
    generate a string of dashes of the appropriate length. We'll then join
    these sequences of dashes together using <literal moreinfo="none">String.concat</literal>, which concatenates a list of
    strings with an optional separator string, and <literal moreinfo="none">^</literal>, which is a pairwise string concatenation
    function, to add the delimiters on the outside:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/lists-and-patterns/main.topscript">OCaml utop</ulink>
    (part 21)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let render_separator widths =</userinput>
<userinput moreinfo="none">    let pieces = List.map widths</userinput>
<userinput moreinfo="none">      ~f:(fun w -&gt; String.make (w + 2) '-')</userinput>
<userinput moreinfo="none">    in</userinput>
<userinput moreinfo="none">    "|" ^ String.concat ~sep:"+" pieces ^ "|"</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val render_separator : int list -&gt; string = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">render_separator [3;6;2];;</userinput>
<computeroutput moreinfo="none">- : string = "|-----+--------+----|"</computeroutput></programlisting>

    <para>Note that we make the line of dashes two larger than the provided
    width to provide some whitespace around each entry in the table.<indexterm class="singular">
        <primary>strings</primary>

        <secondary>concatenation of</secondary>
      </indexterm><indexterm class="singular">
        <primary>String.concat</primary>
      </indexterm><indexterm class="singular">
        <primary>List module</primary>

        <secondary>String.concat and</secondary>
      </indexterm></para>

    <note>
      <title>Performance of String.concat and ^</title>

      <para>In the preceding code we’ve concatenated strings two different
      ways: <literal moreinfo="none">String.concat</literal>, which operates
      on lists of strings; and <literal moreinfo="none">^</literal>, which is
      a pairwise operator. You should avoid <literal moreinfo="none">^</literal> for joining long numbers of strings, since
      it allocates a new string every time it runs. Thus, the following
      code</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/lists-and-patterns/main.topscript">OCaml utop</ulink>
      (part 22)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let s = "." ^ "."  ^ "."  ^ "."  ^ "."  ^ "."  ^ ".";;</userinput>
<computeroutput moreinfo="none">val s : string = "......."</computeroutput></programlisting>

      <para>will allocate strings of length 2, 3, 4, 5, 6 and 7, whereas this
      code</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/lists-and-patterns/main.topscript">OCaml utop</ulink>
      (part 23)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let s = String.concat [".";".";".";".";".";".";"."];;</userinput>
<computeroutput moreinfo="none">val s : string = "......."</computeroutput></programlisting>

      <para>allocates one string of size 7, as well as a list of length 7. At
      these small sizes, the differences don't amount to much, but for
      assembling large strings, it can be a serious performance issue.</para>
    </note>

    <para>Now we need code for rendering a row with data in it. We'll first write a function called
        <literal moreinfo="none">pad</literal>, for padding out a string to a specified length plus
      one blank space on both sides:<indexterm class="singular">
        <primary>strings</primary>
        <secondary>padding of</secondary>
      </indexterm></para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/lists-and-patterns/main.topscript">OCaml utop</ulink>
    (part 24)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let pad s length =</userinput>
<userinput moreinfo="none">    " " ^ s ^ String.make (length - String.length s + 1) ' '</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val pad : string -&gt; int -&gt; string = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">pad "hello" 10;;</userinput>
<computeroutput moreinfo="none">- : string = " hello      "</computeroutput></programlisting>

    <para>We can render a row of data by merging together the padded strings.
    Again, we'll use <literal moreinfo="none">List.map2_exn</literal> for
    combining the list of data in the row with the list of widths:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/lists-and-patterns/main.topscript">OCaml utop</ulink>
    (part 25)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let render_row row widths =</userinput>
<userinput moreinfo="none">    let padded = List.map2_exn row widths ~f:pad in</userinput>
<userinput moreinfo="none">    "|" ^ String.concat ~sep:"|" padded ^ "|"</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val render_row : string list -&gt; int list -&gt; string = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">render_row ["Hello";"World"] [10;15];;</userinput>
<computeroutput moreinfo="none">- : string = "| Hello      | World           |"</computeroutput></programlisting>

    <para>Now we can bring this all together in a single function that renders
    the table:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/lists-and-patterns/main.topscript">OCaml utop</ulink>
    (part 26)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let render_table header rows =</userinput>
<userinput moreinfo="none">    let widths = max_widths header rows in</userinput>
<userinput moreinfo="none">    String.concat ~sep:"\n"</userinput>
<userinput moreinfo="none">      (render_row header widths</userinput>
<userinput moreinfo="none">       :: render_separator widths</userinput>
<userinput moreinfo="none">       :: List.map rows ~f:(fun row -&gt; render_row row widths)</userinput>
<userinput moreinfo="none">      )</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val render_table : string list -&gt; string list list -&gt; string = &lt;fun&gt;</computeroutput></programlisting>

    <sect2 id="more-useful-list-functions">
      <title>More Useful List Functions</title>

      <para>The previous example we worked through touched on only three of
      the functions in <literal moreinfo="none">List</literal>. We won't cover
      the entire interface (for that you should look at the <ulink url="http://realworldocaml.org/doc">online docs</ulink>), but a few more
      functions are useful enough to mention here.</para>

      <sect3 id="combining-list-elements-with-list.reduce">
        <title>Combining list elements with List.reduce</title>

        <para><literal moreinfo="none">List.fold</literal>, which we described
        earlier, is a very general and powerful function. Sometimes, however,
        you want something simpler and easier to use. One such function is
        <literal moreinfo="none">List.reduce</literal>, which is essentially a
        specialized version of <literal moreinfo="none">List.fold</literal>
        that doesn't require an explicit starting value, and whose accumulator
        has to consume and produce values of the same type as the elements of
        the list it applies to.<indexterm class="singular">
            <primary>elements</primary>

            <secondary>combining with List.reduce</secondary>
          </indexterm><indexterm class="singular">
            <primary>List module</primary>

            <secondary>List.reduce</secondary>
          </indexterm><indexterm class="singular">
            <primary>lists</primary>

            <secondary>combining elements in</secondary>
          </indexterm></para>

        <para>Here's the type signature:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/lists-and-patterns/main.topscript">OCaml utop</ulink>
        (part 27)</para>

        <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">List.reduce;;</userinput>
<computeroutput moreinfo="none">- : 'a list -&gt; f:('a -&gt; 'a -&gt; 'a) -&gt; 'a option = &lt;fun&gt;</computeroutput></programlisting>

        <para><literal moreinfo="none">reduce</literal> returns an optional
        result, returning <literal moreinfo="none">None</literal> when the
        input list is empty.</para>

        <para>Now we can see <literal>reduce</literal> in action:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/lists-and-patterns/main.topscript">OCaml utop</ulink>
        (part 28)</para>

        <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">List.reduce ~f:(+) [1;2;3;4;5];;</userinput>
<computeroutput moreinfo="none">- : int option = Some 15</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">List.reduce ~f:(+) [];;</userinput>
<computeroutput moreinfo="none">- : int option = None</computeroutput></programlisting>
      </sect3>

      <sect3 id="filtering-with-list.filter-and-list.filter_map">
        <title>Filtering with List.filter and List.filter_map</title>

        <para>Very often when processing lists, you wants to restrict your attention to a subset of
          the values on your list. The <literal moreinfo="none">List.filter</literal> function is
          one way of doing that:<indexterm class="singular">
            <primary>lists</primary>
            <secondary>filtering values in</secondary>
          </indexterm><indexterm class="singular">
            <primary>values</primary>
            <secondary>filtering with List.filter</secondary>
          </indexterm><indexterm class="singular">
            <primary>List module</primary>
            <secondary>List.filter</secondary>
          </indexterm></para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/lists-and-patterns/main.topscript">OCaml utop</ulink>
        (part 29)</para>

        <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">List.filter ~f:(fun x -&gt; x mod 2 = 0) [1;2;3;4;5];;</userinput>
<computeroutput moreinfo="none">- : int list = [2; 4]</computeroutput></programlisting>

        <para>Note that the <literal moreinfo="none">mod</literal> used above
        is an infix operator, as described in <xref linkend="variables-and-functions"/>.</para>

        <para>Sometimes, you want to both transform and filter as part of the
        same computation. In that case, <literal moreinfo="none">List.filter_map</literal> is what you need. The
        function passed to <literal moreinfo="none">List.filter_map</literal>
        returns an optional value, and <literal moreinfo="none">List.filter_map</literal> drops all elements for which
        <literal moreinfo="none">None</literal> is returned.</para>

        <para>Here's an example. The following expression computes the list of
        file extensions in the current directory, piping the results through
        <literal moreinfo="none">List.dedup</literal> to remove duplicates.
        Note that this example also uses some functions from other modules,
        including <literal moreinfo="none">Sys.ls_dir</literal> to get a
        directory listing, and <literal moreinfo="none">String.rsplit2</literal> to split a string on the
        rightmost appearance of a given character:<indexterm class="singular">
            <primary>lists</primary>

            <secondary>duplicate removal</secondary>
          </indexterm><indexterm class="singular">
            <primary>duplicates, removing</primary>
          </indexterm></para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/lists-and-patterns/main.topscript">OCaml utop</ulink>
        (part 30)</para>

        <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">List.filter_map (Sys.ls_dir ".") ~f:(fun fname -&gt;</userinput>
<userinput moreinfo="none">    match String.rsplit2 ~on:'.' fname with</userinput>
<userinput moreinfo="none">    | None  | Some ("",_) -&gt; None</userinput>
<userinput moreinfo="none">    | Some (_,ext) -&gt;</userinput>
<userinput moreinfo="none">      Some ext)</userinput>
<userinput moreinfo="none">  |&gt; List.dedup</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">- : string list = ["ascii"; "ml"; "mli"; "topscript"]</computeroutput></programlisting>

        <para>The preceding code is also an example of an Or pattern, which
        allows you to have multiple subpatterns within a larger pattern. In
        this case, <literal moreinfo="none">None | Some ("",_)</literal> is an
        Or pattern. As we'll see later, Or patterns can be nested anywhere
        within larger patterns.</para>
      </sect3>

      <sect3 id="partitioning-with-list.partition_tf">
        <title>Partitioning with List.partition_tf</title>

        <para>Another useful operation that's closely related to filtering is
        partitioning. The function <literal moreinfo="none">List.partition_tf</literal> takes a list and a
        function for computing a Boolean condition on the list elements, and
        returns two lists. The <literal moreinfo="none">tf</literal> in the
        name is a mnemonic to remind the user that <literal moreinfo="none">true</literal> elements go to the first list and
        <literal moreinfo="none">false</literal> ones go to the second. Here's
        an example:<indexterm class="singular">
            <primary>elements</primary>

            <secondary>partitioning with List.partition_tf</secondary>
          </indexterm><indexterm class="singular">
            <primary>lists</primary>

            <secondary>partitioning elements in</secondary>
          </indexterm><indexterm class="singular">
            <primary>List module</primary>

            <secondary>List.partition_tf</secondary>
          </indexterm></para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/lists-and-patterns/main.topscript">OCaml utop</ulink>
        (part 31)</para>

        <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let is_ocaml_source s =</userinput>
<userinput moreinfo="none">    match String.rsplit2 s ~on:'.' with</userinput>
<userinput moreinfo="none">    | Some (_,("ml"|"mli")) -&gt; true</userinput>
<userinput moreinfo="none">    | _ -&gt; false</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val is_ocaml_source : string -&gt; bool = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let (ml_files,other_files) =</userinput>
<userinput moreinfo="none">    List.partition_tf (Sys.ls_dir ".")  ~f:is_ocaml_source;;</userinput>
<computeroutput moreinfo="none">val ml_files : string list = ["example.mli"; "example.ml"]</computeroutput>
<computeroutput moreinfo="none">val other_files : string list = ["main.topscript"; "lists_layout.ascii"]</computeroutput></programlisting>
      </sect3>

      <sect3 id="combining-lists">
        <title>Combining lists</title>

        <para>Another very common operation on lists is concatenation. The
        list module actually comes with a few different ways of doing this.
        First, there's <literal moreinfo="none">List.append</literal>, for
        concatenating a pair of lists:<indexterm class="singular">
            <primary>lists</primary>

            <secondary>combining</secondary>
          </indexterm><indexterm class="singular">
            <primary>List module</primary>

            <secondary>List.append</secondary>
          </indexterm></para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/lists-and-patterns/main.topscript">OCaml utop</ulink>
        (part 32)</para>

        <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">List.append [1;2;3] [4;5;6];;</userinput>
<computeroutput moreinfo="none">- : int list = [1; 2; 3; 4; 5; 6]</computeroutput></programlisting>

        <para>There's also <literal moreinfo="none">@</literal>, an operator
        equivalent of <literal moreinfo="none">List.append</literal>:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/lists-and-patterns/main.topscript">OCaml utop</ulink>
        (part 33)</para>

        <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">[1;2;3] @ [4;5;6];;</userinput>
<computeroutput moreinfo="none">- : int list = [1; 2; 3; 4; 5; 6]</computeroutput></programlisting>

        <para>In addition, there is <literal moreinfo="none">List.concat</literal>, for concatenating a list of
        lists:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/lists-and-patterns/main.topscript">OCaml utop</ulink>
        (part 34)</para>

        <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">List.concat [[1;2];[3;4;5];[6];[]];;</userinput>
<computeroutput moreinfo="none">- : int list = [1; 2; 3; 4; 5; 6]</computeroutput></programlisting>

        <para>Here's an example of using <literal moreinfo="none">List.concat</literal> along with <literal moreinfo="none">List.map</literal> to compute a recursive listing of a
        directory tree:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/lists-and-patterns/main.topscript">OCaml utop</ulink>
        (part 35)</para>

        <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let rec ls_rec s =</userinput>
<userinput moreinfo="none">    if Sys.is_file_exn ~follow_symlinks:true s</userinput>
<userinput moreinfo="none">    then [s]</userinput>
<userinput moreinfo="none">    else</userinput>
<userinput moreinfo="none">      Sys.ls_dir s</userinput>
<userinput moreinfo="none">      |&gt; List.map ~f:(fun sub -&gt; ls_rec (s ^/ sub))</userinput>
<userinput moreinfo="none">      |&gt; List.concat</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val ls_rec : string -&gt; string list = &lt;fun&gt;</computeroutput></programlisting>

        <para>Note that <literal moreinfo="none">^/</literal> is an infix
        operator provided by Core for adding a new element to a string
        representing a file path. It is equivalent to Core's <literal moreinfo="none">Filename.concat</literal>.</para>

        <para>The preceding combination of <literal moreinfo="none">List.map</literal> and <literal moreinfo="none">List.concat</literal> is common enough that there is a
        function <literal moreinfo="none">List.concat_map</literal> that
        combines these into one, more efficient operation:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/lists-and-patterns/main.topscript">OCaml utop</ulink>
        (part 36)<indexterm class="endofrange" startref="Llistmod"/></para>

        <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let rec ls_rec s =</userinput>
<userinput moreinfo="none">    if Sys.is_file_exn ~follow_symlinks:true s</userinput>
<userinput moreinfo="none">    then [s]</userinput>
<userinput moreinfo="none">    else</userinput>
<userinput moreinfo="none">      Sys.ls_dir s</userinput>
<userinput moreinfo="none">      |&gt; List.concat_map ~f:(fun sub -&gt; ls_rec (s ^/ sub))</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val ls_rec : string -&gt; string list = &lt;fun&gt;</computeroutput></programlisting>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="tail-recursion">
    <title>Tail Recursion</title>

    <para>The only way to compute the length of an OCaml list is to walk the
    list from beginning to end. As a result, computing the length of a list
    takes time linear in the size of the list. Here's a simple function for
    doing so:<indexterm class="singular">
        <primary>List module</primary>

        <secondary>List.init</secondary>
      </indexterm><indexterm class="singular">
        <primary>lists</primary>

        <secondary>computing length of</secondary>
      </indexterm><indexterm class="singular">
        <primary>tail recursion</primary>
      </indexterm>
      <indexterm>
        <primary>recursion</primary>
        
        <secondary>tail recursion</secondary>
      </indexterm>
    </para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/lists-and-patterns/main.topscript">OCaml utop</ulink>
    (part 37)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let rec length = function</userinput>
<userinput moreinfo="none">    | [] -&gt; 0</userinput>
<userinput moreinfo="none">    | _ :: tl -&gt; 1 + length tl</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val length : 'a list -&gt; int = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">length [1;2;3];;</userinput>
<computeroutput moreinfo="none">- : int = 3</computeroutput></programlisting>

    <para>This looks simple enough, but you'll discover that this
    implementation runs into problems on very large lists, as we'll show in
    the following code:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/lists-and-patterns/main.topscript">OCaml utop</ulink>
    (part 38)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let make_list n = List.init n ~f:(fun x -&gt; x);;</userinput>
<computeroutput moreinfo="none">val make_list : int -&gt; int list = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">length (make_list 10);;</userinput>
<computeroutput moreinfo="none">- : int = 10</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">length (make_list 10_000_000);;</userinput>
<computeroutput moreinfo="none">Stack overflow during evaluation (looping recursion?).</computeroutput></programlisting>

    <para>The preceding example creates lists using <literal moreinfo="none">List.init</literal>, which takes an integer <literal moreinfo="none">n</literal> and a function <literal moreinfo="none">f</literal> and creates a list of length <literal moreinfo="none">n</literal>, where the data for each element is created by
    calling <literal moreinfo="none">f</literal> on the index of that
    element.</para>

    <para>To understand where the error in the above example comes from, you
    need to learn a bit more about how function calls work. Typically, a
    function call needs some space to keep track of information associated
    with the call, such as the arguments passed to the function, or the
    location of the code that needs to start executing when the function call
    is complete. To allow for nested function calls, this information is
    typically organized in a stack, where a new <emphasis>stack
    frame</emphasis> is allocated for each nested function call, and then
    deallocated when the function call is complete.<indexterm class="singular">
        <primary>stack frames</primary>
      </indexterm></para>

    <para>And that's the problem with our call to <literal moreinfo="none">length</literal>: it tried to allocate 10 million stack
    frames, which exhausted the available stack space. Happily, there's a way
    around this problem. Consider the following alternative
    implementation:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/lists-and-patterns/main.topscript">OCaml utop</ulink>
    (part 39)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let rec length_plus_n l n =</userinput>
<userinput moreinfo="none">    match l with</userinput>
<userinput moreinfo="none">    | [] -&gt; n</userinput>
<userinput moreinfo="none">    | _ :: tl -&gt; length_plus_n tl (n + 1)</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val length_plus_n : 'a list -&gt; int -&gt; int = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let length l = length_plus_n l 0 ;;</userinput>
<computeroutput moreinfo="none">val length : 'a list -&gt; int = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">length [1;2;3;4];;</userinput>
<computeroutput moreinfo="none">- : int = 4</computeroutput></programlisting>

    <para>This implementation depends on a helper function, <literal moreinfo="none">length_plus_n</literal>, that computes the length of a
    given list plus a given <literal moreinfo="none">n</literal>. In practice,
    <literal moreinfo="none">n</literal> acts as an accumulator in which the
    answer is built up, step by step. As a result, we can do the additions
    along the way rather than doing them as we unwind the nested sequence of
    function calls, as we did in our first implementation of <literal moreinfo="none">length</literal>.</para>

    <para>The advantage of this approach is that the recursive call in
    <literal moreinfo="none">length_plus_n</literal> is a <emphasis>tail
    call</emphasis>. We'll explain more precisely what it means to be a tail
    call shortly, but the reason it's important is that tail calls don't
    require the allocation of a new stack frame, due to what is called the
    <emphasis>tail-call optimization</emphasis>. A recursive function is said
    to be <emphasis>tail recursive</emphasis> if all of its recursive calls
    are tail calls. <literal moreinfo="none">length_plus_n</literal> is indeed
    tail recursive, and as a result, <literal moreinfo="none">length</literal>
    can take a long list as input without blowing the stack:<indexterm class="singular">
        <primary>tail calls</primary>
      </indexterm></para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/lists-and-patterns/main.topscript">OCaml utop</ulink>
    (part 40)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">length (make_list 10_000_000);;</userinput>
<computeroutput moreinfo="none">- : int = 10000000</computeroutput></programlisting>

    <para>So when is a call a tail call? Let's think about the situation where one function (the
        <emphasis>caller</emphasis>) invokes another (the <emphasis>callee</emphasis>). The
      invocation is considered a tail call when the caller doesn't do anything with the value
      returned by the callee except to return it. The tail-call optimization makes sense because,
      when a caller makes a tail call, the caller's stack frame need never be used again, and so you
      don't need to keep it around. Thus, instead of allocating a new stack frame for the callee,
      the compiler is free to reuse the caller's stack frame.</para>

    <para>Tail recursion is important for more than just lists. Ordinary nontail recursive calls are
      reasonable when dealing with data structures like binary trees, where the depth of the tree is
      logarithmic in the size of your data. But when dealing with situations where the depth of the
      sequence of nested calls is on the order of the size of your data, tail recursion is usually
      the right approach.</para>
  </sect1>

  <sect1 id="terser-and-faster-patterns">
    <title>Terser and Faster Patterns</title>

    <para>Now that we know more about how lists and patterns work, let's
    consider how we can improve on an example from <xref linkend="recursive-list-functions"/>: the function <literal moreinfo="none">destutter</literal>, which removes sequential duplicates
    from a list. Here's the implementation that was described
    earlier:<indexterm class="singular">
        <primary>destutter function</primary>
      </indexterm><indexterm class="startofrange" id="PTTRNMAT">
        <primary>pattern matching</primary>

        <secondary>terser and faster patterns</secondary>
      </indexterm><indexterm class="singular">
        <primary>lists</primary>

        <secondary>duplicate removal</secondary>
      </indexterm><indexterm class="singular">
        <primary>duplicates, removing</primary>
      </indexterm></para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/lists-and-patterns/main.topscript">OCaml utop</ulink>
    (part 41)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let rec destutter list =</userinput>
<userinput moreinfo="none">    match list with</userinput>
<userinput moreinfo="none">    | [] -&gt; []</userinput>
<userinput moreinfo="none">    | [hd] -&gt; [hd]</userinput>
<userinput moreinfo="none">    | hd :: hd' :: tl -&gt;</userinput>
<userinput moreinfo="none">      if hd = hd' then destutter (hd' :: tl)</userinput>
<userinput moreinfo="none">      else hd :: destutter (hd' :: tl)</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val destutter : 'a list -&gt; 'a list = &lt;fun&gt;</computeroutput></programlisting>

    <para>We'll consider some ways of making this code more concise and more
    efficient.</para>

    <para>First, let's consider efficiency. One problem with the <literal moreinfo="none">destutter</literal> code above is that it in some cases
    re-creates on the righthand side of the arrow a value that already existed
    on the lefthand side. Thus, the pattern <literal moreinfo="none">[hd]
    -&gt; [hd]</literal> actually allocates a new list element, when really,
    it should be able to just return the list being matched. We can reduce
    allocation here by using an <literal moreinfo="none">as</literal> pattern,
    which allows us to declare a name for the thing matched by a pattern or
    subpattern. While we're at it, we'll use the <literal moreinfo="none">function</literal> keyword to eliminate the need for an
    explicit match:<indexterm class="singular">
        <primary>function keyword</primary>
      </indexterm></para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/lists-and-patterns/main.topscript">OCaml utop</ulink>
    (part 42)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let rec destutter = function</userinput>
<userinput moreinfo="none">    | [] as l -&gt; l</userinput>
<userinput moreinfo="none">    | [_] as l -&gt; l</userinput>
<userinput moreinfo="none">    | hd :: (hd' :: _ as tl) -&gt;</userinput>
<userinput moreinfo="none">      if hd = hd' then destutter tl</userinput>
<userinput moreinfo="none">      else hd :: destutter tl</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val destutter : 'a list -&gt; 'a list = &lt;fun&gt;</computeroutput></programlisting>

    <para>We can further collapse this by combining the first two cases into
    one, using an Or pattern:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/lists-and-patterns/main.topscript">OCaml utop</ulink>
    (part 43)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let rec destutter = function</userinput>
<userinput moreinfo="none">    | [] | [_] as l -&gt; l</userinput>
<userinput moreinfo="none">    | hd :: (hd' :: _ as tl) -&gt;</userinput>
<userinput moreinfo="none">      if hd = hd' then destutter tl</userinput>
<userinput moreinfo="none">      else hd :: destutter tl</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val destutter : 'a list -&gt; 'a list = &lt;fun&gt;</computeroutput></programlisting>

    <para>We can make the code slightly terser now by using a <literal moreinfo="none">when</literal> clause. A <literal moreinfo="none">when</literal> clause allows us to add an extra
    precondition to a pattern in the form of an arbitrary OCaml expression. In
    this case, we can use it to include the check on whether the first two
    elements are equal:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/lists-and-patterns/main.topscript">OCaml utop</ulink>
    (part 44)<indexterm class="singular">
        <primary>operators</primary>

        <secondary>polymorphic comparison operators</secondary>
      </indexterm><indexterm class="singular">
        <primary>polymorphic comparisons</primary>
      </indexterm></para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let rec destutter = function</userinput>
<userinput moreinfo="none">    | [] | [_] as l -&gt; l</userinput>
<userinput moreinfo="none">    | hd :: (hd' :: _ as tl) when hd = hd' -&gt; destutter tl</userinput>
<userinput moreinfo="none">    | hd :: tl -&gt; hd :: destutter tl</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val destutter : 'a list -&gt; 'a list = &lt;fun&gt;</computeroutput></programlisting>

    <sidebar>
      <title>Polymorphic Compare</title>

      <para>In the preceding <literal moreinfo="none">destutter</literal>
      example, we made use of the fact that OCaml lets us test equality
      between values of any type, using the <literal moreinfo="none">=</literal> operator. Thus, we can write:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/lists-and-patterns/main.topscript">OCaml utop</ulink>
      (part 45)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">3 = 4;;</userinput>
<computeroutput moreinfo="none">- : bool = false</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">[3;4;5] = [3;4;5];;</userinput>
<computeroutput moreinfo="none">- : bool = true</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">[Some 3; None] = [None; Some 3];;</userinput>
<computeroutput moreinfo="none">- : bool = false</computeroutput></programlisting>

      <para>Indeed, if we look at the type of the equality operator, we'll see
      that it is polymorphic:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/lists-and-patterns/main.topscript">OCaml utop</ulink>
      (part 46)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">(=);;</userinput>
<computeroutput moreinfo="none">- : 'a -&gt; 'a -&gt; bool = &lt;fun&gt;</computeroutput></programlisting>

      <para>OCaml comes with a whole family of polymorphic comparison operators, including the
        standard infix comparators, <literal moreinfo="none">&lt;</literal>, <literal moreinfo="none">&gt;=</literal>, etc., as well as the function <literal moreinfo="none">compare</literal> that returns <literal moreinfo="none">-1</literal>, <literal moreinfo="none">0</literal>, or <literal moreinfo="none">1</literal> to flag whether the
        first operand is smaller than, equal to, or greater than the second, respectively.</para>

      <para>You might wonder how you could build functions like these yourself if OCaml didn't come
        with them built in. It turns out that you <emphasis>can't</emphasis> build these functions
        on your own. OCaml's polymorphic comparison functions are built into the runtime to a low
        level. These comparisons are polymorphic on the basis of ignoring almost everything about
        the types of the values that are being compared, paying attention only to the structure of
        the values as they're laid out in memory.</para>

      <para>Polymorphic compare does have some limitations. For example, it
      will fail at runtime if it encounters a function value:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/lists-and-patterns/main.topscript">OCaml utop</ulink>
      (part 47)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">(fun x -&gt; x + 1) = (fun x -&gt; x + 1);;</userinput>
<computeroutput moreinfo="none">Exception: (Invalid_argument "equal: functional value").</computeroutput></programlisting>

      <para>Similarly, it will fail on values that come from outside the OCaml
      heap, like values from C bindings. But it will work in a reasonable way
      for other kinds of values.</para>

      <para>For simple atomic types, polymorphic compare has the semantics you
      would expect: for floating-point numbers and integers, polymorphic
      compare corresponds to the expected numerical comparison functions. For
      strings, it's a lexicographic comparison.</para>

      <para>Sometimes, however, the type-ignoring nature of polymorphic
      compare is a problem, particularly when you have your own notion of
      equality and ordering that you want to impose. We'll discuss this issue
      more, as well as some of the other downsides of polymorphic compare, in
      <xref linkend="maps-and-hash-tables"/>.</para>
    </sidebar>

    <para>Note that <literal moreinfo="none">when</literal> clauses have some
    downsides. As we noted earlier, the static checks associated with pattern
    matches rely on the fact that patterns are restricted in what they can
    express. Once we add the ability to add an arbitrary condition to a
    pattern, something will be lost. In particular, the ability of the
    compiler to determine if a match is exhaustive, or if some case is
    redundant, is compromised.</para>

    <para>Consider the following function, which takes a list of optional
    values, and returns the number of those values that are <literal moreinfo="none">Some</literal>. Because this implementation uses <literal moreinfo="none">when</literal> clauses, the compiler can't tell that the
    code is exhaustive:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/lists-and-patterns/main.topscript">OCaml utop</ulink>
    (part 48)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let rec count_some list =</userinput>
<userinput moreinfo="none">    match list with</userinput>
<userinput moreinfo="none">    | [] -&gt; 0</userinput>
<userinput moreinfo="none">    | x :: tl when Option.is_none x -&gt; count_some tl</userinput>
<userinput moreinfo="none">    | x :: tl when Option.is_some x -&gt; 1 + count_some tl</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">Characters 30-169:</computeroutput>
<computeroutput moreinfo="none">Warning 8: this pattern-matching is not exhaustive.</computeroutput>
<computeroutput moreinfo="none">Here is an example of a value that is not matched:</computeroutput>
<computeroutput moreinfo="none">_::_</computeroutput>
<computeroutput moreinfo="none">(However, some guarded clause may match this value.)</computeroutput>
<computeroutput moreinfo="none">val count_some : 'a option list -&gt; int = &lt;fun&gt;</computeroutput></programlisting>

    <para>Despite the warning, the function does work fine:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/lists-and-patterns/main.topscript">OCaml utop</ulink>
    (part 49)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">count_some [Some 3; None; Some 4];;</userinput>
<computeroutput moreinfo="none">- : int = 2</computeroutput></programlisting>

    <para>If we add another redundant case without a <literal moreinfo="none">when</literal> clause, the compiler will stop complaining
    about exhaustiveness and won't produce a warning about the
    redundancy.</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/lists-and-patterns/main.topscript">OCaml utop</ulink>
    (part 50)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let rec count_some list =</userinput>
<userinput moreinfo="none">    match list with</userinput>
<userinput moreinfo="none">    | [] -&gt; 0</userinput>
<userinput moreinfo="none">    | x :: tl when Option.is_none x -&gt; count_some tl</userinput>
<userinput moreinfo="none">    | x :: tl when Option.is_some x -&gt; 1 + count_some tl</userinput>
<userinput moreinfo="none">    | x :: tl -&gt; -1 (* unreachable *)</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val count_some : 'a option list -&gt; int = &lt;fun&gt;</computeroutput></programlisting>

    <para>Probably a better approach is to simply drop the second <literal moreinfo="none">when</literal> clause:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/lists-and-patterns/main.topscript">OCaml utop</ulink>
    (part 51)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let rec count_some list =</userinput>
<userinput moreinfo="none">    match list with</userinput>
<userinput moreinfo="none">    | [] -&gt; 0</userinput>
<userinput moreinfo="none">    | x :: tl when Option.is_none x -&gt; count_some tl</userinput>
<userinput moreinfo="none">    | _ :: tl -&gt; 1 + count_some tl</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val count_some : 'a option list -&gt; int = &lt;fun&gt;</computeroutput></programlisting>

    <para>This is a little less clear, however, than the direct
    pattern-matching solution, where the meaning of each pattern is clearer on
    its own:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/lists-and-patterns/main.topscript">OCaml utop</ulink>
    (part 52)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let rec count_some list =</userinput>
<userinput moreinfo="none">    match list with</userinput>
<userinput moreinfo="none">    | [] -&gt; 0</userinput>
<userinput moreinfo="none">    | None   :: tl -&gt; count_some tl</userinput>
<userinput moreinfo="none">    | Some _ :: tl -&gt; 1 + count_some tl</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val count_some : 'a option list -&gt; int = &lt;fun&gt;</computeroutput></programlisting>

    <para>The takeaway from all of this is although <literal moreinfo="none">when</literal> clauses can be useful, we should prefer
    patterns wherever they are sufficient.</para>

    <para>As a side note, the above implementation of <literal moreinfo="none">count_some</literal> is longer than necessary; even worse,
    it is not tail recursive. In real life, you would probably just use the
    <literal moreinfo="none">List.count</literal> function from <literal moreinfo="none">Core</literal>:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/lists-and-patterns/main.topscript">OCaml utop</ulink>
    (part 53)<indexterm class="endofrange" startref="PTTRNMAT"/></para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let count_some l = List.count ~f:Option.is_some l;;</userinput>
<computeroutput moreinfo="none">val count_some : 'a option list -&gt; int = &lt;fun&gt;</computeroutput></programlisting>
  </sect1>
</chapter>

  <chapter id="files-modules-and-programs">
  <title>Files, Modules, and Programs</title>

  <para>We've so far experienced OCaml largely through the toplevel. As you move from exercises to
    real-world programs, you'll need to leave the toplevel behind and start building programs from
    files. Files are more than just a convenient way to store and manage your code; in OCaml, they
    also correspond to modules, which act as boundaries that divide your program into conceptual
    units.</para>

  <para>In this chapter, we'll show you how to build an OCaml program from a
  collection of files, as well as the basics of working with modules and
  module signatures.</para>

  <sect1 id="single-file-programs">
    <title>Single-File Programs</title>

    <para>We'll start with an example: a utility that reads lines from <literal moreinfo="none">stdin</literal> and computes a frequency count of the lines. At the end, the 10 lines with
      the highest frequency counts are written out. We'll start with a simple implementation, which
      we'll save as the file <emphasis>freq.ml</emphasis>.<indexterm class="startofrange" id="FILEsnglprog">
        <primary>files</primary>
        <secondary>single-file programs</secondary>
      </indexterm><indexterm class="startofrange" id="Psingfil">
        <primary>programs</primary>
        <secondary>single-file programs</secondary>
      </indexterm></para>

    <para>This implementation will use two functions from the <literal moreinfo="none">List.Assoc</literal> module, which provides utility
    functions for interacting with association lists, i.e., lists of key/value
    pairs. In particular, we use the function <literal moreinfo="none">List.Assoc.find</literal>, which looks up a key in an
    association list; and <literal moreinfo="none">List.Assoc.add</literal>,
    which adds a new binding to an association list, as shown here:<indexterm class="singular">
        <primary>List.Assoc module</primary>

        <secondary>List.Assoc.add</secondary>
      </indexterm><indexterm class="singular">
        <primary>List.Assoc module</primary>

        <secondary>List.Assoc.find</secondary>
      </indexterm><indexterm class="singular">
        <primary>lists</primary>

        <secondary>adding new bindings in</secondary>
      </indexterm><indexterm class="singular">
        <primary>lists</primary>

        <secondary>finding key associations in</secondary>
      </indexterm></para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/files-modules-and-programs/intro.topscript">OCaml utop</ulink></para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let assoc = [("one", 1); ("two",2); ("three",3)] ;;</userinput>
<computeroutput moreinfo="none">val assoc : (string * int) list = [("one", 1); ("two", 2); ("three", 3)]</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">List.Assoc.find assoc "two" ;;</userinput>
<computeroutput moreinfo="none">- : int option = Some 2</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">List.Assoc.add assoc "four" 4 (* add a new key *) ;;</userinput>
<computeroutput moreinfo="none">- : (string, int) List.Assoc.t =</computeroutput>
<computeroutput moreinfo="none">[("four", 4); ("one", 1); ("two", 2); ("three", 3)]</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">List.Assoc.add assoc "two"  4 (* overwrite an existing key *) ;;</userinput>
<computeroutput moreinfo="none">- : (string, int) List.Assoc.t = [("two", 4); ("one", 1); ("three", 3)]</computeroutput></programlisting>

    <para>Note that <literal moreinfo="none">List.Assoc.add</literal> doesn't
    modify the original list, but instead allocates a new list with the
    requisite key/value pair added.</para>

    <para>Now we can write <literal moreinfo="none">freq.ml</literal>:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/files-modules-and-programs-freq/freq.ml">OCaml</ulink></para>

    <programlisting format="linespecific" language="ocaml">open Core.Std

let build_counts () =
  In_channel.fold_lines stdin ~init:[] ~f:(fun counts line -&gt;
    let count =
      match List.Assoc.find counts line with
      | None -&gt; 0
      | Some x -&gt; x
    in
    List.Assoc.add counts line (count + 1)
  )

let () =
  build_counts ()
  |&gt; List.sort ~cmp:(fun (_,x) (_,y) -&gt; Int.descending x y)
  |&gt; (fun l -&gt; List.take l 10)
  |&gt; List.iter ~f:(fun (line,count) -&gt; printf "%3d: %s\n" count line)</programlisting>

    <para>The function <literal moreinfo="none">build_counts</literal> reads
    in lines from <literal moreinfo="none">stdin</literal>, constructing from
    those lines an association list with the frequencies of each line. It does
    this by invoking <literal moreinfo="none">In_channel.fold_lines</literal>
    (similar to the function <literal moreinfo="none">List.fold</literal>
    described in <xref linkend="lists-and-patterns"/>), which reads through
    the lines one by one, calling the provided <literal>fold</literal>
    function for each line to update the accumulator. That accumulator is
    initialized to the empty list.</para>

    <para>With <literal moreinfo="none">build_counts</literal> defined, we
    then call the function to build the association list, sort that list by
    frequency in descending order, grab the first 10 elements off the list,
    and then iterate over those 10 elements and print them to the screen.
    These operations are tied together using the <literal moreinfo="none">|&gt;</literal> operator described in <xref linkend="variables-and-functions"/>.<indexterm class="singular">
        <primary>let ( ) declaration</primary>
      </indexterm><indexterm class="singular">
        <primary>main function</primary>
      </indexterm></para>

    <note role="allow_break">
      <title>Where Is the Main Function?</title>

      <para>Unlike C, programs in OCaml do not have a unique <literal moreinfo="none">main</literal> function. When an OCaml program is
      evaluated, all the statements in the implementation files are evaluated
      in the order in which they were linked together. These implementation
      files can contain arbitrary expressions, not just function definitions.
      In this example, the declaration starting with <literal moreinfo="none">let () =</literal> plays the role of the <literal moreinfo="none">main</literal> function, kicking off the processing. But
      really the entire file is evaluated at startup, and so in some sense the
      full codebase is one big <literal moreinfo="none">main</literal>
      function.</para>

      <para>The idiom of writing <literal moreinfo="none">let () =</literal>
      may seem a bit odd, but it has a purpose. The <literal>let</literal>
      binding here is a pattern-match to a value of type <literal moreinfo="none">unit</literal>, which is there to ensure that the
      expression on the righthand side returns <literal moreinfo="none">unit</literal>, as is common for functions that operate
      primarily by side effect.</para>
    </note>

    <para>If we weren't using Core or any other external libraries, we could
    build the executable like this:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/files-modules-and-programs-freq/simple_build_fail.out">Terminal</ulink></para>

    <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">ocamlc freq.ml -o freq.byte</userinput>
<computeroutput moreinfo="none">File "freq.ml", line 1, characters 0-13:</computeroutput>
<computeroutput moreinfo="none">Error: Unbound module Core</computeroutput></programlisting>

    <para>But as you can see, it fails because it can't find Core. We need a
    somewhat more complex invocation to get Core linked in:<indexterm class="singular">
        <primary>OCaml toolchain</primary>

        <secondary>ocamlc</secondary>
      </indexterm><indexterm class="singular">
        <primary>OCaml toolchain</primary>

        <secondary>ocamlfind</secondary>
      </indexterm><indexterm class="singular">
        <primary>Core standard library</primary>

        <secondary>finding with ocamlfind</secondary>
      </indexterm></para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/files-modules-and-programs-freq/simple_build.out">Terminal</ulink></para>

    <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">ocamlfind ocamlc -linkpkg -thread -package core freq.ml -o freq.byte</userinput>
</programlisting>

    <para>This uses <command moreinfo="none">ocamlfind</command>, a tool which
    itself invokes other parts of the OCaml toolchain (in this case, <command moreinfo="none">ocamlc</command>) with the appropriate flags to link in
    particular libraries and packages. Here, <literal moreinfo="none">-package
    core</literal> is asking <command moreinfo="none">ocamlfind</command> to
    link in the Core library; <literal moreinfo="none">-linkpkg</literal> asks
    ocamlfind to link in the packages as is necessary for building an
    executable, while <literal moreinfo="none" role="keep-together">-thread</literal> turns on threading support (which
    is required for Core).<indexterm class="singular">
        <primary>threads</primary>

        <secondary>turning on with -thread</secondary>
      </indexterm><indexterm class="singular">
        <primary sortas="linkpkg">-linkpkg</primary>
      </indexterm></para>

    <para>While this works well enough for a one-file project, more
    complicated projects require a tool to orchestrate the build. One good
    tool for this task is <command moreinfo="none">ocamlbuild</command>, which
    is shipped with the OCaml compiler. We'll talk more about <command moreinfo="none">ocamlbuild</command> in <xref linkend="the-compiler-frontend-parsing-and-type-checking"/>, but for now,
    we'll just use a simple wrapper around <command moreinfo="none">ocamlbuild</command> called <command moreinfo="none">corebuild</command> that sets build parameters
    appropriately for building against Core and its related
    libraries:<indexterm class="singular">
        <primary>corebuild</primary>
      </indexterm></para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/files-modules-and-programs-freq-obuild/build.out">Terminal</ulink></para>

    <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">corebuild freq.byte</userinput>
</programlisting>

    <para>If we'd invoked <command moreinfo="none">corebuild</command> with a
    target of <literal moreinfo="none">freq.native</literal> instead of
    <literal moreinfo="none">freq.byte</literal>, we would have gotten native
    code instead.</para>

    <para>We can run the resulting executable from the command line. The
    following line extracts strings from the <command moreinfo="none">ocamlopt</command> binary, reporting the most frequently
    occurring ones. Note that the specific results will vary from platform to
    platform, since the binary itself will differ between platforms:<indexterm class="singular">
        <primary>OCaml toolchain</primary>

        <secondary>ocamlbuild</secondary>
      </indexterm><indexterm class="singular">
        <primary>native-code compiler</primary>

        <secondary sortas="bytecode">vs. bytecode compiler</secondary>
      </indexterm><indexterm class="singular">
        <primary>bytecode compiler</primary>

        <secondary sortas="native-code">vs. native-code compiler</secondary>
      </indexterm><indexterm class="singular">
        <primary>OCaml toolchain</primary>

        <secondary>ocamlopt</secondary>
      </indexterm><indexterm class="singular">
        <primary>OCaml toolchain</primary>

        <secondary>ocamlc</secondary>
      </indexterm><indexterm class="singular">
        <primary>code compilers</primary>

        <secondary>bytecode vs. native code</secondary>
      </indexterm><indexterm class="endofrange" startref="FILEsnglprog"/><indexterm class="endofrange" startref="Psingfil"/></para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/files-modules-and-programs-freq-obuild/test.out">Terminal</ulink></para>

    <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">strings `which ocamlopt` | ./freq.byte</userinput>
<computeroutput moreinfo="none">  6: +pci_expr =</computeroutput>
<computeroutput moreinfo="none">  6: -pci_params =</computeroutput>
<computeroutput moreinfo="none">  6: .pci_virt = %a</computeroutput>
<computeroutput moreinfo="none">  4: #lsr</computeroutput>
<computeroutput moreinfo="none">  4: #lsl</computeroutput>
<computeroutput moreinfo="none">  4: $lxor</computeroutput>
<computeroutput moreinfo="none">  4: #lor</computeroutput>
<computeroutput moreinfo="none">  4: $land</computeroutput>
<computeroutput moreinfo="none">  4: #mod</computeroutput>
<computeroutput moreinfo="none">  3: 6	.section .rdata,"dr"</computeroutput></programlisting>

    <note>
      <title>Bytecode Versus Native Code</title>

      <para>OCaml ships with two compilers: the <command moreinfo="none">ocamlc</command> bytecode compiler and the <command moreinfo="none">ocamlopt</command> native-code compiler. Programs
      compiled with <command moreinfo="none">ocamlc</command> are interpreted
      by a virtual machine, while programs compiled with <command moreinfo="none">ocamlopt</command> are compiled to native machine code
      to be run on a specific operating system and processor architecture.
      With <command moreinfo="none">ocamlbuild</command>, targets ending with
      <literal moreinfo="none">.byte</literal> are build as bytecode
      executables, and those ending with <literal moreinfo="none">.native</literal> are built as native code.</para>

      <para>Aside from performance, executables generated by the two compilers
      have nearly identical behavior. There are a few things to be aware of.
      First, the bytecode compiler can be used on more architectures, and has
      some tools that are not available for native code. For example, the
      OCaml debugger only works with bytecode (although <command moreinfo="none">gdb</command>, the GNU Debugger, works with OCaml
      native-code applications). The bytecode compiler is also quicker than
      the native-code compiler. In addition, in order to run a bytecode
      executable, you typically need to have OCaml installed on the system in
      question. That's not strictly required, though, since you can build a
      bytecode executable with an embedded runtime, using the <literal moreinfo="none">-custom</literal> compiler flag.</para>

      <para>As a general matter, production executables should usually be
      built using the native-code compiler, but it sometimes makes sense to
      use bytecode for development builds. And, of course, bytecode makes
      sense when targeting a platform not supported by the native-code
      compiler. We'll cover both compilers in more detail in <xref linkend="the-compiler-backend-byte-code-and-native-code"/>.</para>
    </note>
  </sect1>

  <sect1 id="multi-file-programs-and-modules">
    <title>Multifile Programs and Modules</title>

    <para>Source files in OCaml are tied into the module system, with each
    file compiling down into a module whose name is derived from the name of
    the file. We've encountered modules before, such as when we used functions
    like <literal moreinfo="none">find</literal> and <literal moreinfo="none">add</literal> from the <literal moreinfo="none">List.Assoc</literal> module. At its simplest, you can
    think of a module as a collection of definitions that are stored within a
    namespace.<indexterm class="singular">
        <primary>modules</primary>

        <secondary>basics of</secondary>
      </indexterm><indexterm class="singular">
        <primary>files</primary>

        <secondary>multi-file programs</secondary>
      </indexterm><indexterm class="singular">
        <primary>programs</primary>

        <secondary>multi-file programs</secondary>
      </indexterm></para>

    <para>Let's consider how we can use modules to refactor the implementation
    of <literal moreinfo="none">freq.ml</literal>. Remember that the variable
    <literal moreinfo="none">counts</literal> contains an association list
    representing the counts of the lines seen so far. But updating an
    association list takes time linear in the length of the list, meaning that
    the time complexity of processing a file is quadratic in the number of
    distinct lines in the file.</para>

    <para>We can fix this problem by replacing association lists with a more
    efficient data structure. To do that, we'll first factor out the key
    functionality into a separate module with an explicit interface. We can
    consider alternative (and more efficient) implementations once we have a
    clear interface to program against.</para>

    <para>We'll start by creating a file, <literal moreinfo="none">counter.ml</literal>, that contains the logic for
    maintaining the association list used to represent the frequency counts.
    The key function, called <literal moreinfo="none">touch</literal>, bumps
    the frequency count of a given line by one:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/files-modules-and-programs-freq-with-counter/counter.ml">OCaml</ulink></para>

    <programlisting format="linespecific" language="ocaml">open Core.Std

let touch t s =
  let count =
    match List.Assoc.find t s with
    | None -&gt; 0
    | Some x -&gt; x
  in
  List.Assoc.add t s (count + 1)</programlisting>

    <para>The file <emphasis>counter.ml</emphasis> will be compiled into a
    module named <literal moreinfo="none">Counter</literal>, where the name of
    the module is derived automatically from the filename. The module name is
    capitalized even if the file is not. Indeed, module names are always
    capitalized.<indexterm class="singular">
        <primary>modules</primary>

        <secondary>naming of</secondary>
      </indexterm></para>

    <para>We can now rewrite <literal moreinfo="none">freq.ml</literal> to use
    <literal moreinfo="none">Counter</literal>. Note that the resulting code
    can still be built with <command moreinfo="none">ocamlbuild</command>,
    which will discover dependencies and realize that <literal moreinfo="none">counter.ml</literal> needs to be compiled:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/files-modules-and-programs-freq-with-counter/freq.ml">OCaml</ulink></para>

    <programlisting format="linespecific" language="ocaml">open Core.Std

let build_counts () =
  In_channel.fold_lines stdin ~init:[] ~f:Counter.touch

let () =
  build_counts ()
  |&gt; List.sort ~cmp:(fun (_,x) (_,y) -&gt; Int.descending x y)
  |&gt; (fun l -&gt; List.take l 10)
  |&gt; List.iter ~f:(fun (line,count) -&gt; printf "%3d: %s\n" count line)</programlisting>
  </sect1>

  <sect1 id="signatures-and-abstract-types">
    <title>Signatures and Abstract Types</title>

    <para>While we've pushed some of the logic to the <literal moreinfo="none">Counter</literal> module, the code in <literal moreinfo="none">freq.ml</literal> can still depend on the details of the
    implementation of <literal moreinfo="none">Counter</literal>. Indeed, if
    you look at the definition of <literal moreinfo="none">build_counts</literal>, you'll see that it depends on the
    fact that the empty set of frequency counts is represented as an empty
    list. We'd like to prevent this kind of dependency, so we can change the
    implementation of <literal moreinfo="none">Counter</literal> without
    needing to change client code like that in <literal moreinfo="none">freq.ml</literal>.<indexterm class="singular">
        <primary>abstract types</primary>
      </indexterm><indexterm class="singular">
        <primary>modules</primary>

        <secondary>module type</secondary>
      </indexterm><indexterm class="singular">
        <primary>signatures</primary>

        <secondary>abstract types</secondary>
      </indexterm><indexterm class="singular">
        <primary>interfaces</primary>

        <secondary>hiding implementation details with</secondary>
      </indexterm><indexterm class="singular">
        <primary>modules</primary>

        <secondary>hiding implementation details</secondary>
      </indexterm></para>

    <para>The implementation details of a module can be hidden by attaching an
    <emphasis>interface</emphasis>. (Note that in the context of OCaml, the
    terms <emphasis>interface</emphasis>, <emphasis>signature</emphasis>, and
    <emphasis>module type</emphasis> are all used interchangeably.) A module
    defined by a file <literal moreinfo="none">filename.ml</literal> can be
    constrained by a signature placed in a file called <literal moreinfo="none">filename.mli</literal>.<indexterm class="singular">
        <primary>interfaces</primary>

        <secondary>synonyms for</secondary>
      </indexterm></para>

    <para>For <literal moreinfo="none">counter.mli</literal>, we'll start by
    writing down an interface that describes what's currently available in
    <literal moreinfo="none">counter.ml</literal>, without hiding anything.
    <literal moreinfo="none">val</literal> declarations are used to specify
    values in a signature. The syntax of a <literal moreinfo="none">val</literal> declaration is as follows:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/files-modules-and-programs/val.syntax">Syntax</ulink></para>

    <programlisting format="linespecific">val &lt;identifier&gt; : &lt;type&gt;</programlisting>

    <para>Using this syntax, we can write the signature of <literal moreinfo="none">counter.ml</literal> as follows:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/files-modules-and-programs-freq-with-sig/counter.mli">OCaml</ulink></para>

    <programlisting format="linespecific" language="ocaml">open Core.Std

(** Bump the frequency count for the given string. *)
val touch : (string * int) list -&gt; string -&gt; (string * int) list</programlisting>

    <para>Note that <command moreinfo="none">ocamlbuild</command> will detect
    the presence of the <literal moreinfo="none">mli</literal> file
    automatically and include it in the build.</para>

    <note>
      <title>Autogenerating mli Files</title>

      <para>If you don't want to construct an <literal>mli</literal> entirely
      by hand, you can ask OCaml to autogenerate one for you from the source,
      which you can then adjust to fit your needs. Here's how you can do that
      using <emphasis>corebuild</emphasis>:<indexterm class="singular">
          <primary>files</primary>

          <secondary>mli files</secondary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/files-modules-and-programs-freq-with-counter/infer_mli.out">Terminal</ulink></para>

      <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">corebuild counter.inferred.mli</userinput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">cat _build/counter.inferred.mli</userinput>
<computeroutput moreinfo="none">val touch :</computeroutput>
<computeroutput moreinfo="none">  ('a, int) Core.Std.List.Assoc.t -&gt; 'a -&gt; ('a, int) Core.Std.List.Assoc.t</computeroutput></programlisting>

      <para>The generated code is basically equivalent to the <literal moreinfo="none">mli</literal> that we wrote by hand but is a bit uglier
      and more verbose and, of course, has no comments. In general,
      autogenerated <literal moreinfo="none">mli</literal>s are only useful as
      a starting point. In OCaml, the <literal moreinfo="none">mli</literal>
      is the key place where you present and document your interface, and
      there's no replacement for careful human editing and
      organization.</para>
    </note>

    <para>To hide the fact that frequency counts are represented as
    association lists, we'll need to make the type of frequency counts
    <emphasis>abstract</emphasis>. A type is abstract if its name is exposed
    in the interface, but its definition is not. Here's an abstract interface
    for <literal moreinfo="none">Counter</literal>:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/files-modules-and-programs-freq-with-sig-abstract/counter.mli">OCaml</ulink></para>

    <programlisting format="linespecific" language="ocaml">open Core.Std

(** A collection of string frequency counts *)
type t

(** The empty set of frequency counts  *)
val empty : t

(** Bump the frequency count for the given string. *)
val touch : t -&gt; string -&gt; t

(** Converts the set of frequency counts to an association list.  A string shows
    up at most once, and the counts are &gt;= 1. *)
val to_list : t -&gt; (string * int) list</programlisting>

    <para>Note that we needed to add <literal moreinfo="none">empty</literal>
    and <literal moreinfo="none">to_list</literal> to <literal moreinfo="none">Counter</literal>, since otherwise there would be no way
    to create a <literal moreinfo="none">Counter.t</literal> or get data out
    of one.</para>

    <para>We also used this opportunity to document the module. The <literal moreinfo="none">mli</literal> file is the place where you specify your module's interface, and as such is a
      natural place to put documentation. We started our comments with a double asterisk to cause
      them to be picked up by the <command moreinfo="none">ocamldoc</command> tool when generating
      API documentation. We'll discuss <command moreinfo="none">ocamldoc</command> more in <xref linkend="the-compiler-frontend-parsing-and-type-checking"/>.</para>

    <para>Here's a rewrite of <literal moreinfo="none">counter.ml</literal> to
    match the new <literal moreinfo="none">counter.mli</literal>:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/files-modules-and-programs-freq-with-sig-abstract/counter.ml">OCaml</ulink></para>

    <programlisting format="linespecific" language="ocaml">open Core.Std

type t = (string * int) list

let empty = []

let to_list x = x

let touch t s =
  let count =
    match List.Assoc.find t s with
    | None -&gt; 0
    | Some x -&gt; x
  in
  List.Assoc.add t s (count + 1)</programlisting>

    <para>If we now try to compile <literal moreinfo="none">freq.ml</literal>,
    we'll get the following error:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/files-modules-and-programs-freq-with-sig-abstract/build.out">Terminal</ulink></para>

    <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">corebuild freq.byte</userinput>
<computeroutput moreinfo="none">File "freq.ml", line 4, characters 42-55:</computeroutput>
<computeroutput moreinfo="none">Error: This expression has type Counter.t -&gt; string -&gt; Counter.t</computeroutput>
<computeroutput moreinfo="none">       but an expression was expected of type 'a list -&gt; string -&gt; 'a list</computeroutput>
<computeroutput moreinfo="none">       Type Counter.t is not compatible with type 'a list </computeroutput>
<computeroutput moreinfo="none">Command exited with code 2.</computeroutput></programlisting>

    <para>This is because <literal moreinfo="none">freq.ml</literal> depends
    on the fact that frequency counts are represented as association lists, a
    fact that we've just hidden. We just need to fix <literal moreinfo="none">build_counts</literal> to use <literal moreinfo="none">Counter.empty</literal> instead of <literal moreinfo="none">[]</literal> and <literal moreinfo="none">Counter.to_list</literal> to get the association list out
    at the end for processing and printing. The resulting implementation is
    shown below:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/files-modules-and-programs-freq-with-sig-abstract-fixed/freq.ml">OCaml</ulink></para>

    <programlisting format="linespecific" language="ocaml">open Core.Std

let build_counts () =
  In_channel.fold_lines stdin ~init:Counter.empty ~f:Counter.touch

let () =
  build_counts ()
  |&gt; Counter.to_list
  |&gt; List.sort ~cmp:(fun (_,x) (_,y) -&gt; Int.descending x y)
  |&gt; (fun counts -&gt; List.take counts 10)
  |&gt; List.iter ~f:(fun (line,count) -&gt; printf "%3d: %s\n" count line)</programlisting>

    <para>Now we can turn to optimizing the implementation of <literal moreinfo="none">Counter</literal>. Here's an alternate and far more
    efficient implementation, based on the <literal moreinfo="none">Map</literal> data structure in Core:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/files-modules-and-programs-freq-fast/counter.ml">OCaml</ulink></para>

    <programlisting format="linespecific" language="ocaml">open Core.Std

type t = int String.Map.t

let empty = String.Map.empty

let to_list t = Map.to_alist t

let touch t s =
  let count =
    match Map.find t s with
    | None -&gt; 0
    | Some x -&gt; x
  in
  Map.add t ~key:s ~data:(count + 1)</programlisting>

    <para>Note that in the preceding example we use <literal moreinfo="none">String.Map</literal> in some places and simply <literal moreinfo="none">Map</literal> in others. This has to do with the fact that
    for some operations, like creating a <literal moreinfo="none">Map.t</literal>, you need access to type-specialized
    information, and for others, like looking something up in <literal moreinfo="none">Map.t</literal>, you don't. This is covered in more detail
    in <xref linkend="maps-and-hash-tables"/>.</para>
  </sect1>

  <sect1 id="concrete-types-in-signatures">
    <title>Concrete Types in Signatures</title>

    <para>In our frequency-count example, the module <literal moreinfo="none">Counter</literal> had an abstract type <literal moreinfo="none">Counter.t</literal> for representing a collection of
    frequency counts. Sometimes, you'll want to make a type in your interface
    <emphasis>concrete</emphasis>, by including the type definition in the
    interface.<indexterm class="singular">
        <primary>concrete types</primary>
      </indexterm><indexterm class="singular">
        <primary>signatures</primary>

        <secondary>concrete types</secondary>
      </indexterm></para>

    <para>For example, imagine we wanted to add a function to <literal moreinfo="none">Counter</literal> for returning the line with the median
    frequency count. If the number of lines is even, then there is no precise
    median, and the function would return the lines before and after the
    median instead. We'll use a custom type to represent the fact that there
    are two possible return values. Here's a possible implementation:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/files-modules-and-programs-freq-median/counter.ml">OCaml</ulink>
    (part 1)</para>

    <programlisting format="linespecific" language="ocaml">type median = | Median of string
              | Before_and_after of string * string

let median t =
  let sorted_strings = List.sort (Map.to_alist t)
                         ~cmp:(fun (_,x) (_,y) -&gt; Int.descending x y)
  in
  let len = List.length sorted_strings in
  if len = 0 then failwith "median: empty frequency count";
  let nth n = fst (List.nth_exn sorted_strings n) in
  if len mod 2 = 1
  then Median (nth (len/2))
  else Before_and_after (nth (len/2 - 1), nth (len/2));;</programlisting>

    <para>In the preceding implementation, we use <literal moreinfo="none">failwith</literal> to throw an exception for the case of
    the empty list. We'll discuss exceptions more in <xref linkend="error-handling"/>. Note also that the function <literal moreinfo="none">fst</literal> simply returns the first element of any
    two-tuple.</para>

    <para>Now, to expose this usefully in the interface, we need to expose
    both the function and the type <literal moreinfo="none">median</literal>
    with its definition. Note that values (of which functions are an example)
    and types have distinct namespaces, so there's no name clash here. Adding
    the following two lines added to <literal moreinfo="none">counter.mli</literal> does the trick:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/files-modules-and-programs-freq-median/counter.mli">OCaml</ulink>
    (part 1)</para>

    <programlisting format="linespecific" language="ocaml">(** Represents the median computed from a set of strings.  In the case where
    there is an even number of choices, the one before and after the median is
    returned.  *)
type median = | Median of string
              | Before_and_after of string * string

val median : t -&gt; median</programlisting>

    <para>The decision of whether a given type should be abstract or concrete
    is an important one. Abstract types give you more control over how values
    are created and accessed, and make it easier to enforce invariants beyond
    what is enforced by the type itself; concrete types let you expose more
    detail and structure to client code in a lightweight way. The right choice
    depends very much on the context.</para>
  </sect1>

  <sect1 id="nested-modules">
    <title>Nested Modules</title>

    <para>Up until now, we've only considered modules that correspond to
    files, like <literal moreinfo="none">counter.ml</literal>. But modules
    (and module signatures) can be nested inside other modules. As a simple
    example, consider a program that needs to deal with multiple identifiers
    like usernames and hostnames. If you just represent these as strings, then
    it becomes easy to confuse one with the other.<indexterm class="singular">
        <primary>identifiers</primary>

        <secondary>dealing with multiple</secondary>
      </indexterm><indexterm class="singular">
        <primary>nested modules</primary>
      </indexterm><indexterm class="singular">
        <primary>modules</primary>

        <secondary>nested modules</secondary>
      </indexterm></para>

    <para>A better approach is to mint new abstract types for each identifier,
    where those types are under the covers just implemented as strings. That
    way, the type system will prevent you from confusing a username with a
    hostname, and if you do need to convert, you can do so using explicit
    conversions to and from the string type.</para>

    <para>Here's how you might create such an abstract type, within a
    submodule:<indexterm class="singular">
        <primary>abstract types</primary>
      </indexterm></para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/files-modules-and-programs/abstract_username.ml">OCaml</ulink></para>

    <programlisting format="linespecific" language="ocaml">open Core.Std

module Username : sig
  type t
  val of_string : string -&gt; t
  val to_string : t -&gt; string
end = struct
  type t = string
  let of_string x = x
  let to_string x = x
end</programlisting>

    <para>Note that the <literal moreinfo="none">to_string</literal> and
    <literal moreinfo="none">of_string</literal> functions above are
    implemented simply as the identity function, which means they have no
    runtime effect. They are there purely as part of the discipline that they
    enforce on the code through the type system.</para>

    <para>The basic structure of a module declaration like this is:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/files-modules-and-programs/module.syntax">Syntax</ulink></para>

    <programlisting format="linespecific" language="ocaml">module <emphasis>&lt;name&gt;</emphasis> : <emphasis>&lt;signature&gt;</emphasis> = <emphasis>&lt;implementation&gt;</emphasis></programlisting>
    
    <para>We could have written this slightly differently, by giving the
    signature its own top-level <literal moreinfo="none">module type</literal>
    declaration, making it possible to create multiple distinct types with the
    same underlying implementation in a lightweight way:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/files-modules-and-programs/session_info.ml">OCaml</ulink></para>

    <programlisting format="linespecific" language="ocaml">open Core.Std

module type ID = sig
  type t
  val of_string : string -&gt; t
  val to_string : t -&gt; string
end

module String_id = struct
  type t = string
  let of_string x = x
  let to_string x = x
end

module Username : ID = String_id
module Hostname : ID = String_id

type session_info = { user: Username.t;
                      host: Hostname.t;
                      when_started: Time.t;
                    }

let sessions_have_same_user s1 s2 =
  s1.user = s2.host</programlisting>

    <para>The preceding code has a bug: it compares the username in one
    session to the host in the other session, when it should be comparing the
    usernames in both cases. Because of how we defined our types, however, the
    compiler will flag this bug for us:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/files-modules-and-programs/build_session_info.out">Terminal</ulink></para>

    <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">corebuild session_info.native</userinput>
<computeroutput moreinfo="none">File "session_info.ml", line 24, characters 12-19:</computeroutput>
<computeroutput moreinfo="none">Error: This expression has type Hostname.t</computeroutput>
<computeroutput moreinfo="none">       but an expression was expected of type Username.t</computeroutput>
<computeroutput moreinfo="none">Command exited with code 2.</computeroutput></programlisting>

    <para>This is a trivial example, but confusing different kinds of
    identifiers is a very real source of bugs, and the approach of minting
    abstract types for different classes of identifiers is an effective way of
    avoiding such issues.</para>
  </sect1>

  <sect1 id="opening-modules">
    <title>Opening Modules</title>

    <para>Most of the time, you refer to values and types within a module by
    using the module name as an explicit qualifier. For example, you write
    <literal moreinfo="none">List.map</literal> to refer to the <literal moreinfo="none">map</literal> function in the <literal moreinfo="none">List</literal> module. Sometimes, though, you want to be
    able to refer to the contents of a module without this explicit
    qualification. That's what the <literal moreinfo="none">open</literal>
    statement is for.<indexterm class="singular">
        <primary>identifiers</primary>

        <secondary>open modules and</secondary>
      </indexterm><indexterm class="singular">
        <primary>modules</primary>

        <secondary>opening</secondary>
      </indexterm></para>

    <para>We've encountered <literal moreinfo="none">open</literal> already,
    specifically where we've written <literal moreinfo="none">open
    Core.Std</literal> to get access to the standard definitions in the Core
    library. In general, opening a module adds the contents of that module to
    the environment that the compiler looks at to find the definition of
    various identifiers. Here's an example:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/files-modules-and-programs/main.topscript">OCaml utop</ulink></para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">module M = struct let foo = 3 end;;</userinput>
<computeroutput moreinfo="none">module M : sig val foo : int end</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">foo;;</userinput>
<computeroutput moreinfo="none">Characters -1-3:</computeroutput>
<computeroutput moreinfo="none">Error: Unbound value foo</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">open M;;</userinput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">foo;;</userinput>
<computeroutput moreinfo="none">- : int = 3</computeroutput></programlisting>

    <para><literal moreinfo="none">open</literal> is essential when you want
    to modify your environment for a standard library like Core, but it's
    generally good style to keep the opening of modules to a minimum. Opening
    a module is basically a trade-off between terseness and explicitness—the
    more modules you open, the fewer module qualifications you need, and the
    harder it is to look at an identifier and figure out where it comes
    from.</para>

    <para>Here's some general advice on how to deal with
    <literal>open</literal>s:<indexterm class="singular">
        <primary>local opens</primary>
      </indexterm></para>

    <itemizedlist>
      <listitem>
        <para>Opening modules at the toplevel of a module should be done quite
        sparingly, and generally only with modules that have been specifically
        designed to be opened, like <literal moreinfo="none">Core.Std</literal> or <literal moreinfo="none">Option.Monad_infix</literal>.</para>
      </listitem>

      <listitem>
        <para>If you do need to do an open, it's better to do a
        <emphasis>local open</emphasis>. There are two syntaxes for local
        opens. For example, you can write:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/files-modules-and-programs/main.topscript">OCaml utop</ulink>
        (part 1)</para>

        <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let average x y =</userinput>
<userinput moreinfo="none">    let open Int64 in</userinput>
<userinput moreinfo="none">    x + y / of_int 2;;</userinput>
<computeroutput moreinfo="none">val average : int64 -&gt; int64 -&gt; int64 = &lt;fun&gt;</computeroutput></programlisting>

        <para>Here, <literal moreinfo="none">of_int</literal> and the infix
        operators are the ones from the <literal moreinfo="none">Int64</literal> module.</para>

        <para>There's another, even more lightweight syntax for local
        <literal>open</literal>s, which is particularly useful for small
        expressions:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/files-modules-and-programs/main.topscript">OCaml utop</ulink>
        (part 2)</para>

        <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let average x y =</userinput>
<userinput moreinfo="none">    Int64.(x + y / of_int 2);;</userinput>
<computeroutput moreinfo="none">val average : int64 -&gt; int64 -&gt; int64 = &lt;fun&gt;</computeroutput></programlisting>
      </listitem>

      <listitem>
        <para>An alternative to local <literal>open</literal>s that makes your
        code terser without giving up on explicitness is to locally rebind the
        name of a module. So, when using the <literal moreinfo="none">Counter.median</literal> type, instead of
        writing:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/files-modules-and-programs-freq-median/use_median_1.ml">OCaml</ulink>
        (part 1)</para>

        <programlisting format="linespecific" language="ocaml">let print_median m =
  match m with
  | Counter.Median string -&gt; printf "True median:\n   %s\n" string
  | Counter.Before_and_after (before, after) -&gt;
    printf "Before and after median:\n   %s\n   %s\n" before after</programlisting>

        <para>you could write:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/files-modules-and-programs-freq-median/use_median_2.ml">OCaml</ulink>
        (part 1)</para>

        <programlisting format="linespecific" language="ocaml">let print_median m =
  let module C = Counter in
  match m with
  | C.Median string -&gt; printf "True median:\n   %s\n" string
  | C.Before_and_after (before, after) -&gt;
    printf "Before and after median:\n   %s\n   %s\n" before after</programlisting>

        <para>Because the module name <literal moreinfo="none">C</literal>
        only exists for a short scope, it's easy to read and remember what
        <literal moreinfo="none">C</literal> stands for. Rebinding modules to
        very short names at the top level of your module is usually a
        mistake.</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 id="including-modules">
    <title>Including Modules</title>

    <para>While opening a module affects the environment used to search for identifiers,
        <emphasis>including</emphasis> a module is a way of actually adding new identifiers to a
      module proper. Consider the following simple module for representing a range of integer
        values:<indexterm class="singular">
        <primary>modules</primary>
        <secondary>including</secondary>
      </indexterm><indexterm class="singular">
        <primary>identifiers</primary>
        <secondary>adding to modules</secondary>
      </indexterm></para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/files-modules-and-programs/main.topscript">OCaml utop</ulink>
    (part 3)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">module Interval = struct</userinput>
<userinput moreinfo="none">    type t = | Interval of int * int</userinput>
<userinput moreinfo="none">             | Empty</userinput>
<userinput moreinfo="none"/>
<userinput moreinfo="none">    let create low high =</userinput>
<userinput moreinfo="none">      if high &lt; low then Empty else Interval (low,high)</userinput>
<userinput moreinfo="none">  end;;</userinput>
<computeroutput moreinfo="none">module Interval :</computeroutput>
<computeroutput moreinfo="none">  sig type t = Interval of int * int | Empty val create : int -&gt; int -&gt; t end</computeroutput></programlisting>

    <para>We can use the <literal moreinfo="none">include</literal> directive
    to create a new, extended version of the <literal moreinfo="none">Interval</literal> module:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/files-modules-and-programs/main.topscript">OCaml utop</ulink>
    (part 4)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">module Extended_interval = struct</userinput>
<userinput moreinfo="none">    include Interval</userinput>
<userinput moreinfo="none"/>
<userinput moreinfo="none">    let contains t x =</userinput>
<userinput moreinfo="none">      match t with</userinput>
<userinput moreinfo="none">      | Empty -&gt; false</userinput>
<userinput moreinfo="none">      | Interval (low,high) -&gt; x &gt;= low &amp;&amp; x &lt;= high</userinput>
<userinput moreinfo="none">  end;;</userinput>
<computeroutput moreinfo="none">module Extended_interval :</computeroutput>
<computeroutput moreinfo="none">  sig</computeroutput>
<computeroutput moreinfo="none">    type t = Interval.t = Interval of int * int | Empty</computeroutput>
<computeroutput moreinfo="none">    val create : int -&gt; int -&gt; t</computeroutput>
<computeroutput moreinfo="none">    val contains : t -&gt; int -&gt; bool</computeroutput>
<computeroutput moreinfo="none">  end</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Extended_interval.contains (Extended_interval.create 3 10) 4;;</userinput>
<computeroutput moreinfo="none">- : bool = true</computeroutput></programlisting>

    <para>The difference between <literal moreinfo="none">include</literal>
    and <literal moreinfo="none">open</literal> is that we've done more than
    change how identifiers are searched for: we've changed what's in the
    module. If we'd used <literal moreinfo="none">open</literal>, we'd have
    gotten a quite different result:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/files-modules-and-programs/main.topscript">OCaml utop</ulink>
    (part 5)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">module Extended_interval = struct</userinput>
<userinput moreinfo="none">    open Interval</userinput>
<userinput moreinfo="none"/>
<userinput moreinfo="none">    let contains t x =</userinput>
<userinput moreinfo="none">      match t with</userinput>
<userinput moreinfo="none">      | Empty -&gt; false</userinput>
<userinput moreinfo="none">      | Interval (low,high) -&gt; x &gt;= low &amp;&amp; x &lt;= high</userinput>
<userinput moreinfo="none">  end;;</userinput>
<computeroutput moreinfo="none">module Extended_interval :</computeroutput>
<computeroutput moreinfo="none">  sig val contains : Extended_interval.t -&gt; int -&gt; bool end</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Extended_interval.contains (Extended_interval.create 3 10) 4;;</userinput>
<computeroutput moreinfo="none">Characters 28-52:</computeroutput>
<computeroutput moreinfo="none">Error: Unbound value Extended_interval.create</computeroutput></programlisting>

    <para>To consider a more realistic example, imagine you wanted to build an
    extended version of the <literal moreinfo="none">List</literal> module,
    where you've added some functionality not present in the module as
    distributed in Core. <literal moreinfo="none">include</literal> allows us
    to do just that:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/files-modules-and-programs/ext_list.ml">OCaml</ulink></para>

    <programlisting format="linespecific" language="ocaml">open Core.Std

(* The new function we're going to add *)
let rec intersperse list el =
  match list with
  | [] | [ _ ]   -&gt; list
  | x :: y :: tl -&gt; x :: el :: intersperse (y::tl) el

(* The remainder of the list module *)
include List</programlisting>

    <para>Now, how do we write an interface for this new module? It turns out
    that <literal moreinfo="none">include</literal> works on signatures as
    well, so we can pull essentially the same trick to write our <literal moreinfo="none">mli</literal>. The only issues is that we need to get our
    hands on the signature for the <literal moreinfo="none">List</literal>
    module. This can be done using <literal moreinfo="none">module type
    of</literal>, which computes a signature from a module:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/files-modules-and-programs/ext_list.mli">OCaml</ulink></para>

    <programlisting format="linespecific" language="ocaml">open Core.Std

(* Include the interface of the list module from Core *)
include (module type of List)

(* Signature of function we're adding *)
val intersperse : 'a list -&gt; 'a -&gt; 'a list</programlisting>

    <para>Note that the order of declarations in the <literal moreinfo="none">mli</literal> does not need to match the order of
    declarations in the <literal moreinfo="none">ml</literal>. The order of
    declarations in the <literal moreinfo="none">ml</literal> mostly matters
    insofar as it affects which values are shadowed. If we wanted to replace a
    function in <literal moreinfo="none">List</literal> with a new function of
    the same name, the declaration of that function in the <literal moreinfo="none">ml</literal> would have to come after the <literal moreinfo="none">include List</literal> declaration.</para>

    <para>We can now use <literal moreinfo="none">Ext_list</literal> as a
    replacement for <literal moreinfo="none">List</literal>. If we want to use
    <literal moreinfo="none">Ext_list</literal> in preference to <literal moreinfo="none">List</literal> in our project, we can create a file of
    common definitions:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/files-modules-and-programs/common.ml">OCaml</ulink></para>

    <programlisting format="linespecific" language="ocaml">module List = Ext_list</programlisting>

    <para>And if we then put <literal moreinfo="none">open Common</literal>
    after <literal moreinfo="none">open Core.Std</literal> at the top of each
    file in our project, then references to <literal moreinfo="none">List</literal> will automatically go to <literal moreinfo="none">Ext_list</literal> instead.</para>
  </sect1>

  <sect1 id="common-errors-with-modules">
    <title>Common Errors with Modules</title>

    <para>When OCaml compiles a program with an <literal moreinfo="none">ml</literal> and an <literal moreinfo="none">mli</literal>, it will complain if it detects a mismatch
    between the two. Here are some of the common errors you'll run
    into.</para>

    <sect2 id="type-mismatches">
      <title>Type Mismatches</title>

      <para>The simplest kind of error is where the type specified in the signature does not match
        the type in the implementation of the module. As an example, if we replace the <literal moreinfo="none">val</literal> declaration in <literal moreinfo="none">counter.mli</literal> by swapping the types of the first two arguments:<indexterm class="singular">
          <primary>errors</primary>
          <secondary>module type mismatches</secondary>
        </indexterm><indexterm class="singular">
          <primary>type mismatches</primary>
        </indexterm><indexterm class="singular">
          <primary>modules</primary>
          <secondary>type mismatches in</secondary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/files-modules-and-programs-freq-with-sig-mismatch/counter.mli">OCaml</ulink>
      (part 1)</para>

      <programlisting format="linespecific" language="ocaml">(** Bump the frequency count for the given string. *)
val touch : string -&gt; t -&gt; t</programlisting>

      <para>and we try to compile, we'll get the following error:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/files-modules-and-programs-freq-with-sig-mismatch/build.out">Terminal</ulink></para>

      <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">corebuild freq.byte</userinput>
<computeroutput moreinfo="none">File "freq.ml", line 4, characters 53-66:</computeroutput>
<computeroutput moreinfo="none">Error: This expression has type string -&gt; Counter.t -&gt; Counter.t</computeroutput>
<computeroutput moreinfo="none">       but an expression was expected of type</computeroutput>
<computeroutput moreinfo="none">         Counter.t -&gt; string -&gt; Counter.t</computeroutput>
<computeroutput moreinfo="none">       Type string is not compatible with type Counter.t </computeroutput>
<computeroutput moreinfo="none">Command exited with code 2.</computeroutput></programlisting>
    </sect2>

    <sect2 id="missing-definitions">
      <title>Missing Definitions</title>

      <para>We might decide that we want a new function in <literal moreinfo="none">Counter</literal> for pulling out the frequency count of
      a given string. We can update the <literal moreinfo="none">mli</literal>
      by adding the following line:<indexterm class="singular">
          <primary>errors</primary>

          <secondary>missing module definitions</secondary>
        </indexterm><indexterm class="singular">
          <primary>modules</primary>

          <secondary>missing definitions in</secondary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/files-modules-and-programs-freq-with-missing-def/counter.mli">OCaml</ulink>
      (part 1)</para>

      <programlisting format="linespecific" language="ocaml">val count : t -&gt; string -&gt; int</programlisting>

      <para>Now, if we try to compile without actually adding the
      implementation, we'll get this error:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/files-modules-and-programs-freq-with-missing-def/build.out">Terminal</ulink></para>

      <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">corebuild freq.byte</userinput>
<computeroutput moreinfo="none">File "counter.ml", line 1:</computeroutput>
<computeroutput moreinfo="none">Error: The implementation counter.ml</computeroutput>
<computeroutput moreinfo="none">       does not match the interface counter.cmi:</computeroutput>
<computeroutput moreinfo="none">       The field `count' is required but not provided</computeroutput>
<computeroutput moreinfo="none">Command exited with code 2.</computeroutput></programlisting>

      <para>A missing type definition will lead to a similar error.</para>
    </sect2>

    <sect2 id="type-definition-mismatches">
      <title>Type Definition Mismatches</title>

      <para>Type definitions that show up in an <literal moreinfo="none">mli</literal> need to match up with corresponding
      definitions in the <literal moreinfo="none">ml</literal>. Consider again
      the example of the type <literal moreinfo="none">median</literal>. The
      order of the declaration of variants matters to the OCaml compiler, so
      the definition of <literal moreinfo="none">median</literal> in the
      implementation listing those options in a different order:<indexterm class="singular">
          <primary>type definition mismatches</primary>
        </indexterm><indexterm class="singular">
          <primary>errors</primary>

          <secondary>module type definition mismatches</secondary>
        </indexterm><indexterm class="singular">
          <primary>modules</primary>

          <secondary>type definition mismatches</secondary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/files-modules-and-programs-freq-with-type-mismatch/counter.mli">OCaml</ulink>
      (part 1)</para>

      <programlisting format="linespecific" language="ocaml">(** Represents the median computed from a set of strings.  In the case where
    there is an even number of choices, the one before and after the median is
    returned.  *)
type median = | Before_and_after of string * string
              | Median of string</programlisting>

      <para>will lead to a compilation error:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/files-modules-and-programs-freq-with-type-mismatch/build.out">Terminal</ulink></para>

      <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">corebuild freq.byte</userinput>
<computeroutput moreinfo="none">File "counter.ml", line 1:</computeroutput>
<computeroutput moreinfo="none">Error: The implementation counter.ml</computeroutput>
<computeroutput moreinfo="none">       does not match the interface counter.cmi:</computeroutput>
<computeroutput moreinfo="none">       Type declarations do not match:</computeroutput>
<computeroutput moreinfo="none">         type median = Median of string | Before_and_after of string * string</computeroutput>
<computeroutput moreinfo="none">       is not included in</computeroutput>
<computeroutput moreinfo="none">         type median = Before_and_after of string * string | Median of string</computeroutput>
<computeroutput moreinfo="none">       File "counter.ml", line 18, characters 5-84: Actual declaration</computeroutput>
<computeroutput moreinfo="none">       Fields number 1 have different names, Median and Before_and_after.</computeroutput>
<computeroutput moreinfo="none">Command exited with code 2.</computeroutput></programlisting>

      <para>Order is similarly important to other type declarations, including
      the order in which record fields are declared and the order of arguments
      (including labeled and optional arguments) to a function.</para>
    </sect2>

    <sect2 id="cyclic-dependencies">
      <title>Cyclic Dependencies</title>

      <para>In most cases, OCaml doesn't allow cyclic dependencies, i.e., a
      collection of definitions that all refer to one another. If you want to
      create such definitions, you typically have to mark them specially. For
      example, when defining a set of mutually recursive values (like the
      definition of <literal moreinfo="none">is_even</literal> and <literal moreinfo="none">is_odd</literal> in <xref linkend="recursive-functions"/>), you need to define them using
      <literal moreinfo="none">let rec</literal> rather than ordinary <literal moreinfo="none">let</literal>.<indexterm class="singular">
          <primary>dependencies, cyclic</primary>
        </indexterm><indexterm class="singular">
          <primary>cyclic dependencies</primary>
        </indexterm><indexterm class="singular">
          <primary>errors</primary>

          <secondary>cyclic dependencies</secondary>
        </indexterm><indexterm class="singular">
          <primary>modules</primary>

          <secondary>cyclic dependencies</secondary>
        </indexterm></para>

      <para>The same is true at the module level. By default, cyclic
      dependencies between modules are not allowed, and cyclic dependencies
      among files are never allowed. Recursive modules are possible but are a
      rare case, and we won't discuss them further here.</para>

      <para>The simplest example of a forbidden circular reference is a module
      referring to its own module name. So, if we tried to add a reference to
      <literal moreinfo="none">Counter</literal> from within <literal moreinfo="none">counter.ml</literal>:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/files-modules-and-programs-freq-cyclic1/counter.ml">OCaml</ulink>
      (part 1)</para>

      <programlisting format="linespecific" language="ocaml">let singleton l = Counter.touch Counter.empty</programlisting>

      <para>we'll see this error when we try to build:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/files-modules-and-programs-freq-cyclic1/build.out">Terminal</ulink></para>

      <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">corebuild freq.byte</userinput>
<computeroutput moreinfo="none">File "counter.ml", line 18, characters 18-31:</computeroutput>
<computeroutput moreinfo="none">Error: Unbound module Counter</computeroutput>
<computeroutput moreinfo="none">Command exited with code 2.</computeroutput></programlisting>

      <para>The problem manifests in a different way if we create cyclic
      references between files. We could create such a situation by adding a
      reference to <literal moreinfo="none">Freq</literal> from <literal moreinfo="none">counter.ml</literal>, e.g., by adding the following
      line:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/files-modules-and-programs-freq-cyclic2/counter.ml">OCaml</ulink>
      (part 1)</para>

      <programlisting format="linespecific" language="ocaml">let _build_counts = Freq.build_counts</programlisting>

      <para>In this case, <command moreinfo="none">ocamlbuild</command> (which
      is invoked by the <command moreinfo="none">corebuild</command> script)
      will notice the error and complain explicitly about the cycle:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/files-modules-and-programs-freq-cyclic2/build.out">Terminal</ulink></para>

      <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">corebuild freq.byte</userinput>
<computeroutput moreinfo="none">Circular dependencies: "freq.cmo" already seen in</computeroutput>
<computeroutput moreinfo="none">  [ "counter.cmo"; "freq.cmo" ]</computeroutput>
<computeroutput moreinfo="none"> </computeroutput></programlisting>
    </sect2>
  </sect1>
  <sect1>
    <title>Designing with Modules</title>
    <para>The module system is a key part of how an OCaml program is structured. As such, we'll
      close this chapter with some advice on how to think about designing that structure
      effectively.</para>
    <sect2>
      <title>Expose Concrete Types Rarely</title>
      <para>When designing an <literal>mli</literal>, one choice that you need to make is whether to
        expose the concrete definition of your types or leave them abstract. Most of the time,
        abstraction is the right choice, for two reasons: it enhances the flexibility of your
        design, and it makes it possible to enforce invariants on the use of your module.</para>
      <para>Abstraction enhances flexibility by restricting how users can interact with your types,
        thus reducing the ways in which users can depend on the details of your implementation. If
        you expose types explicitly, then users can depend on any and every detail of the types you
        choose. If they're abstract, then only the specific operations you want to expose are
        available. This means that you can freely change the implementation without affecting
        clients, as long as you preserve the semantics of those operations.</para>
      <para>In a similar way, abstraction allows you to enforce invariants on your types. If your
        types are exposed, then users of the module can create new instances of that type (or if
        mutable, modify existing instances) in any way allowed by the underlying type. That may
        violate a desired invariant <emphasis>i.e.</emphasis>, a property about your type that is
        always supposed to be true. Abstract types allow you to protect invariants by making sure
        that you only expose functions that preserves your invariants. </para>
      <para>Despite these benefits, there is a trade-off here. In particular, exposing types
        concretely makes it possible to use pattern-matching with those types, which as we saw in
        <phrase role="keep-together"><xref linkend="lists-and-patterns"/> </phrase>is a powerful and important tool. You should generally only
        expose the concrete implementation of your types when there's significant value in the
        ability to pattern match, and when the invariants that you care about are already enforced
        by the data type itself.</para>
    </sect2>
    <sect2>
      <title>Design for the Call Site</title>
      <para>When writing an interface, you should think not just about how easy it is to understand
        the interface for someone who reads your carefully documented <literal>mli</literal> file,
        but more importantly, you want the call to be as obvious as possible for someone who is
        reading it at the call site.</para>
      <para>The reason for this is that most of the time, people interacting with your API will be
        doing so by reading and modifying code that uses the API, not by reading the interface
        definition. By making your API as obvious as possible from that perspective, you simplify
        the lives of your users.</para>
      <para>There are many ways of improving readability at the call site. One example is labeled
        arguments (discussed in <xref linkend="labeled-arguments"/>), which act as documentation
        that is available at the call site. </para>
      <para>You can also improve readability simply by choosing good names for your functions,
        variant tags and record fields. Good names aren't always long, to be clear. If you wanted to
        write an anonymous function for doubling a number: <literal>(fun x -&gt; x * 2)</literal>, a
        short variable name like <literal>x</literal> is best. A good rule of thumb is that names
        that have a small scope should be short, whereas names that have a large scope, like the
        name of a function in an a module interface, should be longer and more explicit.</para>
      <para>There is of course a tradeoff here, in that making your APIs more explicit tends to make
        them more verbose as well. Another useful rule of thumb is that more rarely used names
        should be longer and more explicit, since the cost of concision and the benefit of
        explicitness become more important the more often a name is used.</para>
    </sect2>
    <sect2>
      <title>Create Uniform Interfaces</title>
      <para>Designing the interface of a module is a task that should not be thought of in
        isolation. The interfaces that appear in your codebase should play together harmoniously.
        Part of achieving that is standardizing aspects of those interfaces.</para>
      <para>Core itself is a library that works hard to create uniform interfaces. Here are some of
        the guidelines that are used in Core.</para>
      <itemizedlist>
        <listitem>
          <para><emphasis>A module for (almost) every type.</emphasis> You should mint a module for
            almost every type in your program, and the primary type of a given module should be
            called <literal>t</literal>.</para>
        </listitem>
        <listitem><para><emphasis>Put <literal>t</literal> first</emphasis>. If you have a module <literal>M</literal>
            whose primary type is <literal>M.t</literal>, the functions in <literal>M</literal> that
            take a value of <literal>M.t</literal> should take it as their first argument.</para></listitem>
        <listitem><para>Functions that routinely throw an exception should end in <literal>_exn</literal>. Otherwise,
            errors should be signaled by returning an <literal>option</literal> or an
          <literal>Or_error.t</literal> (both of which are discussed in <xref linkend="error-handling"/> ).</para></listitem>
       
      </itemizedlist>
      <para>There are also standards in Core about what the type signature for specific functions
        should be. For example, the signature for <literal>map</literal> is always essentially the
        same, no matter what the underlying type it is applied to. This kind of function-by-function
        API uniformity is achieved through the use of <emphasis>signature includes</emphasis>, which
        allow for different modules to share components of their interface. This approach is
        described in <xref linkend="using-multiple-interfaces"/>. </para>
      <para>Core's standards may or may not fit your projects, but you can improve the usability of
        your codebase by finding some consistent set of standards to apply.</para>
    </sect2>
    <sect2>
      <title>Interfaces before implementations</title>
      <para>OCaml's concise and flexible type language enables a type-oriented
        approach to software design.  Such an approach involves thinking
        through and writing out the types you're going to use before embarking
        on the implementation itself.</para>
      <para>This is a good approach both when working in the core language, where you would write
        your type definitions before writing the logic of your computations, as well as at the
        module level, where you would write a first draft of your <literal>mli</literal> before
        working on the <literal>ml</literal>.</para>
      <para>Of course, the design process goes in both directions. You'll often find yourself going
        back and modifying your types in response to things you learn by working on the
        implementation. But types and signatures provide a lightweight tool for constructing a
        skeleton of your design in a way that helps clarify your goals and intent, before you spend
        a lot of time and effort fleshing it out.</para>
    </sect2>
  </sect1>
</chapter>

  <chapter id="records">
  <title>Records</title>

  <para>One of OCaml's best features is its concise and expressive system for
  declaring new data types, and records are a key element of that system. We
  discussed records briefly in <xref linkend="a-guided-tour"/>, but this
  chapter will go into more depth, covering the details of how records work,
  as well as advice on how to use them effectively in your software
  designs.</para>

  <para>A record represents a collection of values stored together as one,
  where each component is identified by a different field name. The basic
  syntax for a record type declaration is as follows:<indexterm class="singular">
      <primary>records</primary>

      <secondary>basic syntax for</secondary>
    </indexterm></para>

  <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/records/record.syntax">Syntax</ulink></para>

  <programlisting format="linespecific" language="ocaml">type <emphasis>&lt;record-name&gt;</emphasis> =
    {<emphasis> &lt;field&gt;</emphasis> : <emphasis>&lt;type&gt;</emphasis> ;
    <emphasis>&lt;field&gt;</emphasis> : <emphasis>&lt;type&gt;</emphasis> ;
    ...
    }</programlisting>

  <para>Note that record field names must start with a lowercase
  letter.</para>

  <para>Here's a simple example, a <literal moreinfo="none">host_info</literal> record that summarizes information about
  a given computer:</para>

  <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/records/main.topscript">OCaml utop</ulink></para>

  <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">type host_info =</userinput>
<userinput moreinfo="none">    { hostname   : string;</userinput>
<userinput moreinfo="none">      os_name    : string;</userinput>
<userinput moreinfo="none">      cpu_arch   : string;</userinput>
<userinput moreinfo="none">      timestamp  : Time.t;</userinput>
<userinput moreinfo="none">    };;</userinput>
<computeroutput moreinfo="none">type host_info = {</computeroutput>
<computeroutput moreinfo="none">  hostname : string;</computeroutput>
<computeroutput moreinfo="none">  os_name : string;</computeroutput>
<computeroutput moreinfo="none">  cpu_arch : string;</computeroutput>
<computeroutput moreinfo="none">  timestamp : Time.t;</computeroutput>
<computeroutput moreinfo="none">}</computeroutput></programlisting>

  <para>We can construct a <literal moreinfo="none">host_info</literal> just
  as easily. The following code uses the <literal moreinfo="none">Shell</literal> module from <literal moreinfo="none">Core_extended</literal> to dispatch commands to the shell to
  extract the information we need about the computer we're running on. It also
  uses the <literal moreinfo="none">Time.now</literal> call from Core's
  <literal moreinfo="none">Time</literal> module:</para>

  <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/records/main.topscript">OCaml utop</ulink>
  (part 1)</para>

  <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">#require "core_extended";;</userinput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">open Core_extended.Std;;</userinput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let my_host =</userinput>
<userinput moreinfo="none">    let sh = Shell.sh_one_exn in</userinput>
<userinput moreinfo="none">    { hostname   = sh "hostname";</userinput>
<userinput moreinfo="none">      os_name    = sh "uname -s";</userinput>
<userinput moreinfo="none">      cpu_arch   = sh "uname -p";</userinput>
<userinput moreinfo="none">      timestamp  = Time.now ();</userinput>
<userinput moreinfo="none">    };;</userinput>
<computeroutput moreinfo="none">val my_host : host_info =</computeroutput>
<computeroutput moreinfo="none">  {hostname = "ocaml-www1"; os_name = "Linux"; cpu_arch = "unknown";</computeroutput>
<computeroutput moreinfo="none">   timestamp = 2013-08-18 14:50:48.986085+01:00}</computeroutput></programlisting>

  <para>You might wonder how the compiler inferred that <literal moreinfo="none">my_host</literal> is of type <literal moreinfo="none">host_info</literal>. The hook that the compiler uses in this
  case to figure out the type is the record field name. Later in the chapter,
  we'll talk about what happens when there is more than one record type in
  scope with the same field name.</para>

  <para>Once we have a record value in hand, we can extract elements from the
  record field using dot notation:</para>

  <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/records/main.topscript">OCaml utop</ulink>
  (part 2)</para>

  <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">my_host.cpu_arch;;</userinput>
<computeroutput moreinfo="none">- : string = "unknown"</computeroutput></programlisting>

  <para>When declaring an OCaml type, you always have the option of
  parameterizing it by a polymorphic type. Records are no different in this
  regard. So, for example, here's a type one might use to timestamp arbitrary
  items:</para>

  <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/records/main.topscript">OCaml utop</ulink>
  (part 3)</para>

  <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">type 'a timestamped = { item: 'a; time: Time.t };;</userinput>
<computeroutput moreinfo="none">type 'a timestamped = { item : 'a; time : Time.t; }</computeroutput></programlisting>

  <para>We can then write polymorphic functions that operate over this
  parameterized type:</para>

  <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/records/main.topscript">OCaml utop</ulink>
  (part 4)</para>

  <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let first_timestamped list =</userinput>
<userinput moreinfo="none">    List.reduce list ~f:(fun a b -&gt; if a.time &lt; b.time then a else b)</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val first_timestamped : 'a timestamped list -&gt; 'a timestamped option = &lt;fun&gt;</computeroutput></programlisting>

  <sect1 id="patterns-and-exhaustiveness">
    <title>Patterns and Exhaustiveness</title>

    <para>Another way of getting information out of a record is by using a
    pattern match, as in the definition of <literal moreinfo="none">host_info_to_string</literal>:<indexterm class="singular">
        <primary>pattern matching</primary>

        <secondary sortas="exhaustiveness">and exhaustiveness</secondary>
      </indexterm><indexterm class="singular">
        <primary>records</primary>

        <secondary>patterns and exhaustiveness in</secondary>
      </indexterm></para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/records/main.topscript">OCaml utop</ulink>
    (part 5)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let host_info_to_string { hostname = h; os_name = os;</userinput>
<userinput moreinfo="none">                            cpu_arch = c; timestamp = ts;</userinput>
<userinput moreinfo="none">                          } =</userinput>
<userinput moreinfo="none">       sprintf "%s (%s / %s, on %s)" h os c (Time.to_sec_string ts);;</userinput>
<computeroutput moreinfo="none">val host_info_to_string : host_info -&gt; string = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">host_info_to_string my_host;;</userinput>
<computeroutput moreinfo="none">- : string = "ocaml-www1 (Linux / unknown, on 2013-08-18 14:50:48)"</computeroutput></programlisting>

    <para>Note that the pattern we used had only a single case, rather than
    using several cases separated by <literal moreinfo="none">|</literal>'s.
    We needed only one pattern because record patterns are
    <emphasis>irrefutable</emphasis>, meaning that a record pattern match will
    never fail at runtime. This makes sense, because the set of fields
    available in a record is always the same. In general, patterns for types
    with a fixed structure, like records and tuples, are irrefutable, unlike
    types with variable structures like lists and variants.<indexterm class="singular">
        <primary>irrefutable patterns</primary>
      </indexterm><indexterm class="singular">
        <primary>datatypes</primary>

        <secondary>fixed vs. variable structure of</secondary>
      </indexterm></para>

    <para>Another important characteristic of record patterns is that they
    don't need to be complete; a pattern can mention only a subset of the
    fields in the record. This can be convenient, but it can also be error
    prone. In particular, this means that when new fields are added to the
    record, code that should be updated to react to the presence of those new
    fields will not be flagged by the compiler.</para>

    <para>As an example, imagine that we wanted to add a new field to our
    <literal moreinfo="none">host_info</literal> record called <literal moreinfo="none">os_release</literal>:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/records/main.topscript">OCaml utop</ulink>
    (part 6)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">type host_info =</userinput>
<userinput moreinfo="none">    { hostname   : string;</userinput>
<userinput moreinfo="none">      os_name    : string;</userinput>
<userinput moreinfo="none">      cpu_arch   : string;</userinput>
<userinput moreinfo="none">      os_release : string;</userinput>
<userinput moreinfo="none">      timestamp  : Time.t;</userinput>
<userinput moreinfo="none">    } ;;</userinput>
<computeroutput moreinfo="none">type host_info = {</computeroutput>
<computeroutput moreinfo="none">  hostname : string;</computeroutput>
<computeroutput moreinfo="none">  os_name : string;</computeroutput>
<computeroutput moreinfo="none">  cpu_arch : string;</computeroutput>
<computeroutput moreinfo="none">  os_release : string;</computeroutput>
<computeroutput moreinfo="none">  timestamp : Time.t;</computeroutput>
<computeroutput moreinfo="none">}</computeroutput></programlisting>

    <para>The code for <literal moreinfo="none">host_info_to_string</literal>
    would continue to compile without change. In this particular case, it's
    pretty clear that you might want to update <literal moreinfo="none">host_info_to_string</literal> in order to include <literal moreinfo="none">os_release</literal>, and it would be nice if the type
    system would give you a warning about the change.</para>

    <para>Happily, OCaml does offer an optional warning for missing fields in
    a record pattern. With that warning turned on (which you can do in the
    toplevel by typing <literal moreinfo="none">#warnings "+9"</literal>), the
    compiler will warn about the missing field:<indexterm class="singular">
        <primary>errors</primary>

        <secondary>compiler warnings</secondary>
      </indexterm><indexterm class="singular">
        <primary>code compilers</primary>

        <secondary>warning enable/disable</secondary>
      </indexterm><indexterm class="singular">
        <primary>errors</primary>

        <secondary>missing field warnings</secondary>
      </indexterm><indexterm class="singular">
        <primary>records</primary>

        <secondary>missing field warnings</secondary>
      </indexterm></para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/records/main.topscript">OCaml utop</ulink>
    (part 7)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">#warnings "+9";;</userinput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let host_info_to_string { hostname = h; os_name = os;</userinput>
<userinput moreinfo="none">                            cpu_arch = c; timestamp = ts;</userinput>
<userinput moreinfo="none">                          } =</userinput>
<userinput moreinfo="none">    sprintf "%s (%s / %s, on %s)" h os c (Time.to_sec_string ts);;</userinput>
<computeroutput moreinfo="none">Characters 24-139:</computeroutput>
<computeroutput moreinfo="none">Warning 9: the following labels are not bound in this record pattern:</computeroutput>
<computeroutput moreinfo="none">os_release</computeroutput>
<computeroutput moreinfo="none">Either bind these labels explicitly or add '; _' to the pattern.</computeroutput>
<computeroutput moreinfo="none">val host_info_to_string : host_info -&gt; string = &lt;fun&gt;</computeroutput></programlisting>

    <para>We can disable the warning for a given pattern by explicitly
    acknowledging that we are ignoring extra fields. This is done by adding an
    underscore to the pattern:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/records/main.topscript">OCaml utop</ulink>
    (part 8)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let host_info_to_string { hostname = h; os_name = os;</userinput>
<userinput moreinfo="none">                            cpu_arch = c; timestamp = ts; _</userinput>
<userinput moreinfo="none">                          } =</userinput>
<userinput moreinfo="none">    sprintf "%s (%s / %s, on %s)" h os c (Time.to_sec_string ts);;</userinput>
<computeroutput moreinfo="none">val host_info_to_string : host_info -&gt; string = &lt;fun&gt;</computeroutput></programlisting>

    <para>It's a good idea to enable the warning for incomplete record matches
    and to explicitly disable it with an <literal moreinfo="none">_</literal>
    where necessary.</para>

    <note role="allow_break">
      <title>Compiler Warnings</title>

      <para>The OCaml compiler is packed full of useful warnings that can be
      enabled and disabled separately. These are documented in the compiler
      itself, so we could have found out about warning 9 as follows:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/records/warn_help.out">Terminal</ulink></para>

      <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">ocaml -warn-help | egrep '\b9\b'</userinput>
<computeroutput moreinfo="none">  9 Missing fields in a record pattern.</computeroutput>
<computeroutput moreinfo="none">  R Synonym for warning 9.</computeroutput></programlisting>

      <para>You should think of OCaml's warnings as a powerful set of optional
      static analysis tools, and you should eagerly enable them in your build
      environment. You don't typically enable all warnings, but the defaults
      that ship with the compiler are pretty good.</para>

      <para>The warnings used for building the examples in this book are
      specified with the following flag: <literal moreinfo="none">-w
      @A-4-33-41-42-43-34-44</literal>.</para>

      <para>The syntax of this can be found by running <literal moreinfo="none">ocaml -help</literal>, but this particular invocation
      turns on all warnings as errors, disabling only the numbers listed
      explicitly after the <literal moreinfo="none">A</literal>.</para>

      <para>Treating warnings as errors (i.e., making OCaml fail to compile
      any code that triggers a warning) is good practice, since without it,
      warnings are too often ignored during development. When preparing a
      package for distribution, however, this is a bad idea, since the list of
      warnings may grow from one release of the compiler to another, and so
      this may lead your package to fail to compile on newer compiler
      releases.</para>
    </note>
  </sect1>

  <sect1 id="field-punning">
    <title>Field Punning</title>

    <para>When the name of a variable coincides with the name of a record
    field, OCaml provides some handy syntactic shortcuts. For example, the
    pattern in the following function binds all of the fields in question to
    variables of the same name. This is called <emphasis>field
    punning</emphasis>:<indexterm class="singular">
        <primary>fields</primary>

        <secondary>field punning</secondary>
      </indexterm><indexterm class="singular">
        <primary>records</primary>

        <secondary>field punning in</secondary>
      </indexterm></para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/records/main.topscript">OCaml utop</ulink>
    (part 9)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let host_info_to_string { hostname; os_name; cpu_arch; timestamp; _ } =</userinput>
<userinput moreinfo="none">     sprintf "%s (%s / %s) &lt;%s&gt;" hostname os_name cpu_arch</userinput>
<userinput moreinfo="none">       (Time.to_string timestamp);;</userinput>
<computeroutput moreinfo="none">val host_info_to_string : host_info -&gt; string = &lt;fun&gt;</computeroutput></programlisting>

    <para>Field punning can also be used to construct a record. Consider the
    following code for generating a <literal moreinfo="none">host_info</literal> record:<indexterm class="singular">
        <primary>records</primary>

        <secondary>construction of</secondary>
      </indexterm></para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/records/main.topscript">OCaml utop</ulink>
    (part 10)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let my_host =</userinput>
<userinput moreinfo="none">    let sh cmd = Shell.sh_one_exn cmd in</userinput>
<userinput moreinfo="none">    let hostname   = sh "hostname" in</userinput>
<userinput moreinfo="none">    let os_name    = sh "uname -s" in</userinput>
<userinput moreinfo="none">    let cpu_arch   = sh "uname -p" in</userinput>
<userinput moreinfo="none">    let os_release = sh "uname -r" in</userinput>
<userinput moreinfo="none">    let timestamp  = Time.now () in</userinput>
<userinput moreinfo="none">    { hostname; os_name; cpu_arch; os_release; timestamp };;</userinput>
<computeroutput moreinfo="none">val my_host : host_info =</computeroutput>
<computeroutput moreinfo="none">  {hostname = "ocaml-www1"; os_name = "Linux"; cpu_arch = "unknown";</computeroutput>
<computeroutput moreinfo="none">   os_release = "3.2.0-1-amd64";</computeroutput>
<computeroutput moreinfo="none">   timestamp = 2013-08-18 14:50:55.287342+01:00}</computeroutput></programlisting>

    <para>In the preceding code, we defined variables corresponding to the
    record fields first, and then the record declaration itself simply listed
    the fields that needed to be included.</para>

    <para>You can take advantage of both field punning and label punning when
    writing a function for constructing a record from labeled
    arguments:<indexterm class="singular">
        <primary>label punning</primary>
      </indexterm><indexterm class="singular">
        <primary>records</primary>

        <secondary>label punning in</secondary>
      </indexterm></para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/records/main.topscript">OCaml utop</ulink>
    (part 11)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let create_host_info ~hostname ~os_name ~cpu_arch ~os_release =</userinput>
<userinput moreinfo="none">    { os_name; cpu_arch; os_release;</userinput>
<userinput moreinfo="none">      hostname = String.lowercase hostname;</userinput>
<userinput moreinfo="none">      timestamp = Time.now () };;</userinput>
<computeroutput moreinfo="none">val create_host_info :</computeroutput>
<computeroutput moreinfo="none">  hostname:string -&gt;</computeroutput>
<computeroutput moreinfo="none">  os_name:string -&gt; cpu_arch:string -&gt; os_release:string -&gt; host_info = &lt;fun&gt;</computeroutput></programlisting>

    <para>This is considerably more concise than what you would get without
    punning:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/records/main.topscript">OCaml utop</ulink>
    (part 12)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let create_host_info</userinput>
<userinput moreinfo="none">    ~hostname:hostname ~os_name:os_name</userinput>
<userinput moreinfo="none">    ~cpu_arch:cpu_arch ~os_release:os_release =</userinput>
<userinput moreinfo="none">    { os_name = os_name;</userinput>
<userinput moreinfo="none">      cpu_arch = cpu_arch;</userinput>
<userinput moreinfo="none">      os_release = os_release;</userinput>
<userinput moreinfo="none">      hostname = String.lowercase hostname;</userinput>
<userinput moreinfo="none">      timestamp = Time.now () };;</userinput>
<computeroutput moreinfo="none">val create_host_info :</computeroutput>
<computeroutput moreinfo="none">  hostname:string -&gt;</computeroutput>
<computeroutput moreinfo="none">  os_name:string -&gt; cpu_arch:string -&gt; os_release:string -&gt; host_info = &lt;fun&gt;</computeroutput></programlisting>

    <para>Together, labeled arguments, field names, and field and label
    punning encourage a style where you propagate the same names throughout
    your codebase. This is generally good practice, since it encourages
    consistent naming, which makes it easier to navigate the source.</para>
  </sect1>

  <sect1 id="reusing-field-names">
    <title>Reusing Field Names</title>

    <para>Defining records with the same field names can be problematic. Let's
    consider a simple example: building types to represent the protocol used
    for a logging server.<indexterm class="startofrange" id="FNreus">
        <primary>fields</primary>

        <secondary>reusing field names</secondary>
      </indexterm><indexterm class="startofrange" id="RECreusfn">
        <primary>records</primary>

        <secondary>reusing field names</secondary>
      </indexterm></para>

    <para>We'll describe three message types: <literal moreinfo="none">log_entry</literal>, <literal moreinfo="none">heartbeat</literal>, and <literal moreinfo="none">logon</literal>. The <literal moreinfo="none">log_entry</literal> message is used to deliver a log entry
    to the server; the <literal moreinfo="none">logon</literal> message is
    sent to initiate a connection and includes the identity of the user
    connecting and credentials used for authentication; and the <literal moreinfo="none">heartbeat</literal> message is periodically sent by the
    client to demonstrate to the server that the client is alive and
    connected. All of these messages include a session ID and the time the
    message was generated:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/records/main.topscript">OCaml utop</ulink>
    (part 13)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">type log_entry =</userinput>
<userinput moreinfo="none">    { session_id: string;</userinput>
<userinput moreinfo="none">      time: Time.t;</userinput>
<userinput moreinfo="none">      important: bool;</userinput>
<userinput moreinfo="none">      message: string;</userinput>
<userinput moreinfo="none">    }</userinput>
<userinput moreinfo="none">  type heartbeat =</userinput>
<userinput moreinfo="none">    { session_id: string;</userinput>
<userinput moreinfo="none">      time: Time.t;</userinput>
<userinput moreinfo="none">      status_message: string;</userinput>
<userinput moreinfo="none">    }</userinput>
<userinput moreinfo="none">  type logon =</userinput>
<userinput moreinfo="none">    { session_id: string;</userinput>
<userinput moreinfo="none">      time: Time.t;</userinput>
<userinput moreinfo="none">      user: string;</userinput>
<userinput moreinfo="none">      credentials: string;</userinput>
<userinput moreinfo="none">    }</userinput>
<userinput moreinfo="none">;;</userinput>
<computeroutput moreinfo="none">type log_entry = {</computeroutput>
<computeroutput moreinfo="none">  session_id : string;</computeroutput>
<computeroutput moreinfo="none">  time : Time.t;</computeroutput>
<computeroutput moreinfo="none">  important : bool;</computeroutput>
<computeroutput moreinfo="none">  message : string;</computeroutput>
<computeroutput moreinfo="none">}</computeroutput>
<computeroutput moreinfo="none">type heartbeat = {</computeroutput>
<computeroutput moreinfo="none">  session_id : string;</computeroutput>
<computeroutput moreinfo="none">  time : Time.t;</computeroutput>
<computeroutput moreinfo="none">  status_message : string;</computeroutput>
<computeroutput moreinfo="none">}</computeroutput>
<computeroutput moreinfo="none">type logon = {</computeroutput>
<computeroutput moreinfo="none">  session_id : string;</computeroutput>
<computeroutput moreinfo="none">  time : Time.t;</computeroutput>
<computeroutput moreinfo="none">  user : string;</computeroutput>
<computeroutput moreinfo="none">  credentials : string;</computeroutput>
<computeroutput moreinfo="none">}</computeroutput></programlisting>

    <para>Reusing field names can lead to some ambiguity. For example, if we
    want to write a function to grab the <literal>session_id</literal> from a
    record, what type will it have?</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/records/main.topscript">OCaml utop</ulink>
    (part 14)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let get_session_id t = t.session_id;;</userinput>
<computeroutput moreinfo="none">val get_session_id : logon -&gt; string = &lt;fun&gt;</computeroutput></programlisting>

    <para>In this case, OCaml just picks the most recent definition of that
    record field. We can force OCaml to assume we're dealing with a different
    type (say, a <literal moreinfo="none">heartbeat</literal>) using a type
    annotation:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/records/main.topscript">OCaml utop</ulink>
    (part 15)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let get_heartbeat_session_id (t:heartbeat) = t.session_id;;</userinput>
<computeroutput moreinfo="none">val get_heartbeat_session_id : heartbeat -&gt; string = &lt;fun&gt;</computeroutput></programlisting>

    <para>While it's possible to resolve ambiguous field names using type
    annotations, the ambiguity can be a bit confusing. Consider the following
    functions for grabbing the session ID and status from a heartbeat:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/records/main.topscript">OCaml utop</ulink>
    (part 16)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let status_and_session t = (t.status_message, t.session_id);;</userinput>
<computeroutput moreinfo="none">val status_and_session : heartbeat -&gt; string * string = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let session_and_status t = (t.session_id, t.status_message);;</userinput>
<computeroutput moreinfo="none">Characters 44-58:</computeroutput>
<computeroutput moreinfo="none">Error: The record type logon has no field status_message</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let session_and_status (t:heartbeat) = (t.session_id, t.status_message);;</userinput>
<computeroutput moreinfo="none">val session_and_status : heartbeat -&gt; string * string = &lt;fun&gt;</computeroutput></programlisting>

    <para>Why did the first definition succeed without a type annotation and
    the second one fail? The difference is that in the first case, the
    type-checker considered the <literal moreinfo="none">status_message</literal> field first and thus concluded
    that the record was a <literal moreinfo="none">heartbeat</literal>. When
    the order was switched, the <literal moreinfo="none">session_id</literal>
    field was considered first, and so that drove the type to be considered to
    be a <literal moreinfo="none">logon</literal>, at which point <literal moreinfo="none">t.status_message</literal> no longer made sense.</para>

    <para>We can avoid this ambiguity altogether, either by using
    nonoverlapping field names or, more generally, by minting a module for
    each type. Packing types into modules is a broadly useful idiom (and one
    used quite extensively by Core), providing for each type a namespace
    within which to put related values. When using this style, it is standard
    practice to name the type associated with the module <literal moreinfo="none">t</literal>. Using this style we would write:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/records/main.topscript">OCaml utop</ulink>
    (part 17)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">module Log_entry = struct</userinput>
<userinput moreinfo="none">    type t =</userinput>
<userinput moreinfo="none">      { session_id: string;</userinput>
<userinput moreinfo="none">        time: Time.t;</userinput>
<userinput moreinfo="none">        important: bool;</userinput>
<userinput moreinfo="none">        message: string;</userinput>
<userinput moreinfo="none">      }</userinput>
<userinput moreinfo="none">  end</userinput>
<userinput moreinfo="none">  module Heartbeat = struct</userinput>
<userinput moreinfo="none">    type t =</userinput>
<userinput moreinfo="none">      { session_id: string;</userinput>
<userinput moreinfo="none">        time: Time.t;</userinput>
<userinput moreinfo="none">        status_message: string;</userinput>
<userinput moreinfo="none">      }</userinput>
<userinput moreinfo="none">  end</userinput>
<userinput moreinfo="none">  module Logon = struct</userinput>
<userinput moreinfo="none">    type t =</userinput>
<userinput moreinfo="none">      { session_id: string;</userinput>
<userinput moreinfo="none">        time: Time.t;</userinput>
<userinput moreinfo="none">        user: string;</userinput>
<userinput moreinfo="none">        credentials: string;</userinput>
<userinput moreinfo="none">      }</userinput>
<userinput moreinfo="none">  end;;</userinput>
<computeroutput moreinfo="none">module Log_entry :</computeroutput>
<computeroutput moreinfo="none">  sig</computeroutput>
<computeroutput moreinfo="none">    type t = {</computeroutput>
<computeroutput moreinfo="none">      session_id : string;</computeroutput>
<computeroutput moreinfo="none">      time : Time.t;</computeroutput>
<computeroutput moreinfo="none">      important : bool;</computeroutput>
<computeroutput moreinfo="none">      message : string;</computeroutput>
<computeroutput moreinfo="none">    }</computeroutput>
<computeroutput moreinfo="none">  end</computeroutput>
<computeroutput moreinfo="none">module Heartbeat :</computeroutput>
<computeroutput moreinfo="none">  sig</computeroutput>
<computeroutput moreinfo="none">    type t = { session_id : string; time : Time.t; status_message : string; }</computeroutput>
<computeroutput moreinfo="none">  end</computeroutput>
<computeroutput moreinfo="none">module Logon :</computeroutput>
<computeroutput moreinfo="none">  sig</computeroutput>
<computeroutput moreinfo="none">    type t = {</computeroutput>
<computeroutput moreinfo="none">      session_id : string;</computeroutput>
<computeroutput moreinfo="none">      time : Time.t;</computeroutput>
<computeroutput moreinfo="none">      user : string;</computeroutput>
<computeroutput moreinfo="none">      credentials : string;</computeroutput>
<computeroutput moreinfo="none">    }</computeroutput>
<computeroutput moreinfo="none">  end</computeroutput></programlisting>

    <para>Now, our log-entry-creation function can be rendered as
    follows:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/records/main.topscript">OCaml utop</ulink>
    (part 18)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let create_log_entry ~session_id ~important message =</userinput>
<userinput moreinfo="none">     { Log_entry.time = Time.now (); Log_entry.session_id;</userinput>
<userinput moreinfo="none">       Log_entry.important; Log_entry.message }</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val create_log_entry :</computeroutput>
<computeroutput moreinfo="none">  session_id:string -&gt; important:bool -&gt; string -&gt; Log_entry.t = &lt;fun&gt;</computeroutput></programlisting>

    <para>The module name <literal moreinfo="none">Log_entry</literal> is
    required to qualify the fields, because this function is outside of the
    <literal moreinfo="none">Log_entry</literal> module where the record was
    defined. OCaml only requires the module qualification for one record
    field, however, so we can write this more concisely. Note that we are
    allowed to insert whitespace between the module path and the field
    name:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/records/main.topscript">OCaml utop</ulink>
    (part 19)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let create_log_entry ~session_id ~important message =</userinput>
<userinput moreinfo="none">     { Log_entry.</userinput>
<userinput moreinfo="none">       time = Time.now (); session_id; important; message }</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val create_log_entry :</computeroutput>
<computeroutput moreinfo="none">  session_id:string -&gt; important:bool -&gt; string -&gt; Log_entry.t = &lt;fun&gt;</computeroutput></programlisting>

    <para>This is not restricted to constructing a record; we can use the same
    trick when pattern matching:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/records/main.topscript">OCaml utop</ulink>
    (part 20)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let message_to_string { Log_entry.important; message; _ } =</userinput>
<userinput moreinfo="none">    if important then String.uppercase message else message</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val message_to_string : Log_entry.t -&gt; string = &lt;fun&gt;</computeroutput></programlisting>

    <para>When using dot notation for accessing record fields, we can qualify
    the field by the module directly:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/records/main.topscript">OCaml utop</ulink>
    (part 21)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let is_important t = t.Log_entry.important;;</userinput>
<computeroutput moreinfo="none">val is_important : Log_entry.t -&gt; bool = &lt;fun&gt;</computeroutput></programlisting>

    <para>The syntax here is a little surprising when you first encounter it.
    The thing to keep in mind is that the dot is being used in two ways: the
    first dot is a record field access, with everything to the right of the
    dot being interpreted as a field name; the second dot is accessing the
    contents of a module, referring to the record field <literal moreinfo="none">important</literal> from within the module <literal moreinfo="none">Log_entry</literal>. The fact that <literal moreinfo="none">Log_entry</literal> is capitalized and so can't be a field
    name is what disambiguates the two uses.</para>

    <para>For functions defined within the module where a given record is
    defined, the module qualification goes away entirely.<indexterm class="endofrange" startref="RECreusfn"/><indexterm class="endofrange" startref="FNreus"/></para>
  </sect1>

  <sect1 id="functional-updates">
    <title>Functional Updates</title>

    <para>Fairly often, you will find yourself wanting to create a new record
    that differs from an existing record in only a subset of the fields. For
    example, imagine our logging server had a record type for representing the
    state of a given client, including when the last heartbeat was received
    from that client. The following defines a type for representing this
    information, as well as a function for updating the client information
    when a new heartbeat arrives:<indexterm class="singular">
        <primary>functional updates</primary>
      </indexterm><indexterm class="singular">
        <primary>records</primary>

        <secondary>functional updates to</secondary>
      </indexterm></para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/records/main.topscript">OCaml utop</ulink>
    (part 22)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">type client_info =</userinput>
<userinput moreinfo="none">   { addr: Unix.Inet_addr.t;</userinput>
<userinput moreinfo="none">     port: int;</userinput>
<userinput moreinfo="none">     user: string;</userinput>
<userinput moreinfo="none">     credentials: string;</userinput>
<userinput moreinfo="none">     last_heartbeat_time: Time.t;</userinput>
<userinput moreinfo="none">   };;</userinput>
<computeroutput moreinfo="none">type client_info = {</computeroutput>
<computeroutput moreinfo="none">  addr : UnixLabels.inet_addr;</computeroutput>
<computeroutput moreinfo="none">  port : int;</computeroutput>
<computeroutput moreinfo="none">  user : string;</computeroutput>
<computeroutput moreinfo="none">  credentials : string;</computeroutput>
<computeroutput moreinfo="none">  last_heartbeat_time : Time.t;</computeroutput>
<computeroutput moreinfo="none">}</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let register_heartbeat t hb =</userinput>
<userinput moreinfo="none">      { addr = t.addr;</userinput>
<userinput moreinfo="none">        port = t.port;</userinput>
<userinput moreinfo="none">        user = t.user;</userinput>
<userinput moreinfo="none">        credentials = t.credentials;</userinput>
<userinput moreinfo="none">        last_heartbeat_time = hb.Heartbeat.time;</userinput>
<userinput moreinfo="none">      };;</userinput>
<computeroutput moreinfo="none">val register_heartbeat : client_info -&gt; Heartbeat.t -&gt; client_info = &lt;fun&gt;</computeroutput></programlisting>

    <para>This is fairly verbose, given that there's only one field that we
    actually want to change, and all the others are just being copied over
    from <literal moreinfo="none">t</literal>. We can use OCaml's
    <emphasis>functional update</emphasis> syntax to do this more tersely. The
    syntax of a functional update is as follows:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/records/functional_update.syntax">Syntax</ulink></para>

    <programlisting format="linespecific" language="ocaml">{ <emphasis>&lt;record&gt;</emphasis> with <emphasis>&lt;field&gt;</emphasis> = <emphasis>&lt;value&gt;</emphasis>;
      <emphasis>&lt;field&gt;</emphasis> = <emphasis>&lt;value&gt;</emphasis>;
      ...
}</programlisting>

    <para>The purpose of the functional update is to create a new record based
    on an existing one, with a set of field changes layered on top.</para>

    <para>Given this, we can rewrite <literal moreinfo="none">register_heartbeat</literal> more concisely:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/records/main.topscript">OCaml utop</ulink>
    (part 23)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let register_heartbeat t hb =</userinput>
<userinput moreinfo="none">    { t with last_heartbeat_time = hb.Heartbeat.time };;</userinput>
<computeroutput moreinfo="none">val register_heartbeat : client_info -&gt; Heartbeat.t -&gt; client_info = &lt;fun&gt;</computeroutput></programlisting>

    <para>Functional updates make your code independent of the identity of the
    fields in the record that are not changing. This is often what you want,
    but it has downsides as well. In particular, if you change the definition
    of your record to have more fields, the type system will not prompt you to
    reconsider whether your code needs to change to accommodate the new
    fields. Consider what happens if we decided to add a field for the status
    message received on the last heartbeat:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/records/main.topscript">OCaml utop</ulink>
    (part 24)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">type client_info =</userinput>
<userinput moreinfo="none">   { addr: Unix.Inet_addr.t;</userinput>
<userinput moreinfo="none">     port: int;</userinput>
<userinput moreinfo="none">     user: string;</userinput>
<userinput moreinfo="none">     credentials: string;</userinput>
<userinput moreinfo="none">     last_heartbeat_time: Time.t;</userinput>
<userinput moreinfo="none">     last_heartbeat_status: string;</userinput>
<userinput moreinfo="none">   };;</userinput>
<computeroutput moreinfo="none">type client_info = {</computeroutput>
<computeroutput moreinfo="none">  addr : UnixLabels.inet_addr;</computeroutput>
<computeroutput moreinfo="none">  port : int;</computeroutput>
<computeroutput moreinfo="none">  user : string;</computeroutput>
<computeroutput moreinfo="none">  credentials : string;</computeroutput>
<computeroutput moreinfo="none">  last_heartbeat_time : Time.t;</computeroutput>
<computeroutput moreinfo="none">  last_heartbeat_status : string;</computeroutput>
<computeroutput moreinfo="none">}</computeroutput></programlisting>

    <para>The original implementation of <literal moreinfo="none">register_heartbeat</literal> would now be invalid, and
    thus the compiler would effectively warn us to think about how to handle
    this new field. But the version using a functional update continues to
    compile as is, even though it incorrectly ignores the new field. The
    correct thing to do would be to update the code as follows:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/records/main.topscript">OCaml utop</ulink>
    (part 25)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let register_heartbeat t hb =</userinput>
<userinput moreinfo="none">    { t with last_heartbeat_time   = hb.Heartbeat.time;</userinput>
<userinput moreinfo="none">             last_heartbeat_status = hb.Heartbeat.status_message;</userinput>
<userinput moreinfo="none">    };;</userinput>
<computeroutput moreinfo="none">val register_heartbeat : client_info -&gt; Heartbeat.t -&gt; client_info = &lt;fun&gt;</computeroutput></programlisting>
  </sect1>

  <sect1 id="mutable-fields">
    <title>Mutable Fields</title>

    <para>Like most OCaml values, records are immutable by default. You can,
    however, declare individual record fields as mutable. In the following
    code, we've made the last two fields of <literal moreinfo="none">client_info</literal> mutable:<indexterm class="singular">
        <primary>mutable record fields</primary>
      </indexterm><indexterm class="singular">
        <primary>records</primary>

        <secondary>mutable fields in</secondary>
      </indexterm></para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/records/main.topscript">OCaml utop</ulink>
    (part 26)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">type client_info =</userinput>
<userinput moreinfo="none">   { addr: Unix.Inet_addr.t;</userinput>
<userinput moreinfo="none">     port: int;</userinput>
<userinput moreinfo="none">     user: string;</userinput>
<userinput moreinfo="none">     credentials: string;</userinput>
<userinput moreinfo="none">     mutable last_heartbeat_time: Time.t;</userinput>
<userinput moreinfo="none">     mutable last_heartbeat_status: string;</userinput>
<userinput moreinfo="none">   };;</userinput>
<computeroutput moreinfo="none">type client_info = {</computeroutput>
<computeroutput moreinfo="none">  addr : UnixLabels.inet_addr;</computeroutput>
<computeroutput moreinfo="none">  port : int;</computeroutput>
<computeroutput moreinfo="none">  user : string;</computeroutput>
<computeroutput moreinfo="none">  credentials : string;</computeroutput>
<computeroutput moreinfo="none">  mutable last_heartbeat_time : Time.t;</computeroutput>
<computeroutput moreinfo="none">  mutable last_heartbeat_status : string;</computeroutput>
<computeroutput moreinfo="none">}</computeroutput></programlisting>

    <para>The <literal moreinfo="none">&lt;-</literal> operator is used for setting a mutable field.
      The side-effecting version of <literal moreinfo="none">register_heartbeat</literal> would be
      written as follows:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/records/main.topscript">OCaml utop</ulink>
    (part 27)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let register_heartbeat t hb =</userinput>
<userinput moreinfo="none">    t.last_heartbeat_time   &lt;- hb.Heartbeat.time;</userinput>
<userinput moreinfo="none">    t.last_heartbeat_status &lt;- hb.Heartbeat.status_message</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val register_heartbeat : client_info -&gt; Heartbeat.t -&gt; unit = &lt;fun&gt;</computeroutput></programlisting>

    <para>Note that mutable assignment, and thus the <literal moreinfo="none">&lt;-</literal> operator, is not needed for initialization
    because all fields of a record, including mutable ones, are specified when
    the record is created.</para>

    <para>OCaml's policy of immutable-by-default is a good one, but imperative
    programming is an important part of programming in OCaml. We go into more
    depth about how (and when) to use OCaml's imperative features in <xref linkend="imperative-programming"/>.</para>
  </sect1>

  <sect1 id="first-class-fields">
    <title>First-Class Fields</title>

    <para>Consider the following function for extracting the usernames from a
    list of <literal moreinfo="none">Logon</literal> messages:<indexterm class="startofrange" id="Ffc">
        <primary>fields</primary>

        <secondary>first-class fields</secondary>
      </indexterm><indexterm class="startofrange" id="firstclass">
        <primary>first-class fields</primary>
      </indexterm><indexterm class="startofrange" id="RECfirstclass">
        <primary>records</primary>

        <secondary>first-class fields in</secondary>
      </indexterm></para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/records/main.topscript">OCaml utop</ulink>
    (part 28)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let get_users logons =</userinput>
<userinput moreinfo="none">     List.dedup (List.map logons ~f:(fun x -&gt; x.Logon.user));;</userinput>
<computeroutput moreinfo="none">val get_users : Logon.t list -&gt; string list = &lt;fun&gt;</computeroutput></programlisting>

    <para>Here, we wrote a small function <literal moreinfo="none">(fun x
    -&gt; x.Logon.user)</literal> to access the <literal moreinfo="none">user</literal> field. This kind of accessor function is a
    common enough pattern that it would be convenient to generate it
    automatically. The <literal moreinfo="none">fieldslib</literal> syntax
    extension that ships with Core does just that.<indexterm class="singular">
        <primary>record field accessor functions</primary>
      </indexterm></para>

    <para>The <literal moreinfo="none">with fields</literal> annotation at the
    end of the declaration of a record type will cause the extension to be
    applied to a given type declaration. So, for example, we could have
    defined <literal moreinfo="none">Logon</literal> as follows:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/records/main-29.rawscript">OCaml utop</ulink></para>

    <programlisting format="linespecific" language="ocaml"><userinput moreinfo="none"># module Logon = struct
    type t =
      { session_id: string;
        time: Time.t;
        user: string;
        credentials: string;
      }
    with fields
  end;;</userinput>
<computeroutput moreinfo="none">module Logon :
  sig
    type t = {
      session_id : string;
      time : Time.t;
      user : string;
      credentials : string;
    }
    val credentials : t -&gt; string
    val user : t -&gt; string
    val time : t -&gt; Time.t
    val session_id : t -&gt; string
    module Fields :
      sig
        val names : string list
        val credentials :
          ([&lt; `Read | `Set_and_create ], t, string) Field.t_with_perm
        val user :
          ([&lt; `Read | `Set_and_create ], t, string) Field.t_with_perm
        val time :
          ([&lt; `Read | `Set_and_create ], t, Time.t) Field.t_with_perm
        val session_id :
          ([&lt; `Read | `Set_and_create ], t, string) Field.t_with_perm

        [ ... many definitions omitted ... ]

      end
  end</computeroutput></programlisting>

    <para>Note that this will generate <emphasis>a lot</emphasis> of output
    because <literal moreinfo="none">fieldslib</literal> generates a large
    collection of helper functions for working with record fields. We'll only
    discuss a few of these; you can learn about the remainder from the
    documentation that comes with <literal moreinfo="none">fieldslib</literal>.</para>

    <para>One of the functions we obtain is <literal moreinfo="none">Logon.user</literal>, which we can use to extract the user
    field from a logon message:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/records/main.topscript">OCaml utop</ulink>
    (part 30)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let get_users logons = List.dedup (List.map logons ~f:Logon.user);;</userinput>
<computeroutput moreinfo="none">val get_users : Logon.t list -&gt; string list = &lt;fun&gt;</computeroutput></programlisting>

    <para>In addition to generating field accessor functions, <literal moreinfo="none">fieldslib</literal> also creates a submodule called
    <literal moreinfo="none">Fields</literal> that contains a first-class
    representative of each field, in the form of a value of type <literal moreinfo="none">Field.t</literal>. The <literal moreinfo="none">Field</literal> module provides the following
    functions:<indexterm class="singular">
        <primary>Field module</primary>

        <secondary>Field.setter</secondary>
      </indexterm><indexterm class="singular">
        <primary>Field module</primary>

        <secondary>Field.fset</secondary>
      </indexterm><indexterm class="singular">
        <primary>Field module</primary>

        <secondary>Field.get</secondary>
      </indexterm><indexterm class="singular">
        <primary>Field module</primary>

        <secondary>Field.name</secondary>
      </indexterm><indexterm class="singular">
        <primary>fieldslib</primary>
      </indexterm></para>

    <variablelist>
      <varlistentry>
        <term><literal moreinfo="none">Field.name</literal></term>

        <listitem>
          <para>Returns the name of a field</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal moreinfo="none">Field.get</literal></term>

        <listitem>
          <para>Returns the content of a field</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal moreinfo="none">Field.fset</literal></term>

        <listitem>
          <para>Does a functional update of a field</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal moreinfo="none">Field.setter</literal></term>

        <listitem>
          <para>Returns <literal moreinfo="none">None</literal> if the field
          is not mutable or <literal moreinfo="none">Some f</literal> if it
          is, where <literal moreinfo="none">f</literal> is a function for
          mutating that field</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <para>A <literal moreinfo="none">Field.t</literal> has two type
    parameters: the first for the type of the record, and the second for the
    type of the field in question. Thus, the type of <literal moreinfo="none">Logon.Fields.session_id</literal> is <literal moreinfo="none">(Logon.t, string) Field.t</literal>, whereas the type of
    <literal moreinfo="none">Logon.Fields.time</literal> is <literal moreinfo="none">(Logon.t, Time.t) Field.t</literal>. Thus, if you call
    <literal moreinfo="none">Field.get</literal> on <literal moreinfo="none">Logon.Fields.user</literal>, you'll get a function for
    extracting the <literal moreinfo="none">user</literal> field from a
    <literal moreinfo="none">Logon.t</literal>:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/records/main.topscript">OCaml utop</ulink>
    (part 31)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">Field.get Logon.Fields.user;;</userinput>
<computeroutput moreinfo="none">- : Logon.t -&gt; string = &lt;fun&gt;</computeroutput></programlisting>

    <para>Thus, the first parameter of the <literal moreinfo="none">Field.t</literal> corresponds to
      the record you pass to <literal moreinfo="none">get</literal>, and the second parameter
      corresponds to the value contained in the field, which is also the return type of <literal moreinfo="none">get</literal>.</para>

    <para>The type of <literal moreinfo="none">Field.get</literal> is a little
    more complicated than you might naively expect from the preceding
    one:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/records/main.topscript">OCaml utop</ulink>
    (part 32)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">Field.get;;</userinput>
<computeroutput moreinfo="none">- : ('b, 'r, 'a) Field.t_with_perm -&gt; 'r -&gt; 'a = &lt;fun&gt;</computeroutput></programlisting>

    <para>The type is <literal moreinfo="none">Field.t_with_perm</literal>
    rather than <literal moreinfo="none">Field.t</literal> because fields have
    a notion of access control that comes up in some special cases where we
    expose the ability to read a field from a record, but not the ability to
    create new records, and so we can't expose functional updates.</para>

    <para>We can use first-class fields to do things like write a generic
    function for displaying a record field:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/records/main.topscript">OCaml utop</ulink>
    (part 33)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let show_field field to_string record =</userinput>
<userinput moreinfo="none">    let name = Field.name field in</userinput>
<userinput moreinfo="none">    let field_string = to_string (Field.get field record) in</userinput>
<userinput moreinfo="none">    name ^ ": " ^ field_string</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val show_field :</computeroutput>
<computeroutput moreinfo="none">  ('a, 'b, 'c) Field.t_with_perm -&gt; ('c -&gt; string) -&gt; 'b -&gt; string = &lt;fun&gt;</computeroutput></programlisting>

    <para>This takes three arguments: the <literal moreinfo="none">Field.t</literal>, a function for converting the contents
    of the field in question to a string, and a record from which the field
    can be grabbed.</para>

    <para>Here's an example of <literal moreinfo="none">show_field</literal>
    in action:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/records/main.topscript">OCaml utop</ulink>
    (part 34)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let logon = { Logon.</userinput>
<userinput moreinfo="none">                session_id = "26685";</userinput>
<userinput moreinfo="none">                time = Time.now ();</userinput>
<userinput moreinfo="none">                user = "yminsky";</userinput>
<userinput moreinfo="none">                credentials = "Xy2d9W"; }</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val logon : Logon.t =</computeroutput>
<computeroutput moreinfo="none">  {Logon.session_id = "26685"; time = 2013-08-18 14:51:00.509463+01:00;</computeroutput>
<computeroutput moreinfo="none">   user = "yminsky"; credentials = "Xy2d9W"}</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">show_field Logon.Fields.user Fn.id logon;;</userinput>
<computeroutput moreinfo="none">- : string = "user: yminsky"</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">show_field Logon.Fields.time Time.to_string logon;;</userinput>
<computeroutput moreinfo="none">- : string = "time: 2013-08-18 14:51:00.509463+01:00"</computeroutput></programlisting>

    <para>As a side note, the preceding example is our first use of the
    <literal moreinfo="none">Fn</literal> module (short for "function"), which
    provides a collection of useful primitives for dealing with functions.
    <literal moreinfo="none">Fn.id</literal> is the identity function.</para>

    <para><literal moreinfo="none">fieldslib</literal> also provides
    higher-level operators, like <literal moreinfo="none">Fields.fold</literal> and <literal moreinfo="none">Fields.iter</literal>, which let you walk over the fields
    of a record. So, for example, in the case of <literal moreinfo="none">Logon.t</literal>, the field iterator has the following
    type:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/records/main.topscript">OCaml utop</ulink>
    (part 35)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">Logon.Fields.iter;;</userinput>
<computeroutput moreinfo="none">- : session_id:(([&lt; `Read | `Set_and_create ], Logon.t, string)</computeroutput>
<computeroutput moreinfo="none">                Field.t_with_perm -&gt; 'a) -&gt;</computeroutput>
<computeroutput moreinfo="none">    time:(([&lt; `Read | `Set_and_create ], Logon.t, Time.t) Field.t_with_perm -&gt;</computeroutput>
<computeroutput moreinfo="none">          'b) -&gt;</computeroutput>
<computeroutput moreinfo="none">    user:(([&lt; `Read | `Set_and_create ], Logon.t, string) Field.t_with_perm -&gt;</computeroutput>
<computeroutput moreinfo="none">          'c) -&gt;</computeroutput>
<computeroutput moreinfo="none">    credentials:(([&lt; `Read | `Set_and_create ], Logon.t, string)</computeroutput>
<computeroutput moreinfo="none">                 Field.t_with_perm -&gt; 'd) -&gt;</computeroutput>
<computeroutput moreinfo="none">    'd</computeroutput>
<computeroutput moreinfo="none">= &lt;fun&gt;</computeroutput></programlisting>

    <para>This is a bit daunting to look at, largely because of the access
    control markers, but the structure is actually pretty simple. Each labeled
    argument is a function that takes a first-class field of the necessary
    type as an argument. Note that <literal moreinfo="none">iter</literal>
    passes each of these callbacks the <literal moreinfo="none">Field.t</literal>, not the contents of the specific record
    field. The contents of the field, though, can be looked up using the
    combination of the record and the <literal moreinfo="none">Field.t</literal>.</para>

    <para>Now, let's use <literal moreinfo="none">Logon.Fields.iter</literal>
    and <literal moreinfo="none">show_field</literal> to print out all the
    fields of a <literal moreinfo="none">Logon</literal> record:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/records/main.topscript">OCaml utop</ulink>
    (part 36)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let print_logon logon =</userinput>
<userinput moreinfo="none">    let print to_string field =</userinput>
<userinput moreinfo="none">      printf "%s\n" (show_field field to_string logon)</userinput>
<userinput moreinfo="none">    in</userinput>
<userinput moreinfo="none">    Logon.Fields.iter</userinput>
<userinput moreinfo="none">      ~session_id:(print Fn.id)</userinput>
<userinput moreinfo="none">      ~time:(print Time.to_string)</userinput>
<userinput moreinfo="none">      ~user:(print Fn.id)</userinput>
<userinput moreinfo="none">      ~credentials:(print Fn.id)</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val print_logon : Logon.t -&gt; unit = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">print_logon logon;;</userinput>
<computeroutput moreinfo="none">session_id: 26685</computeroutput>
<computeroutput moreinfo="none">time: 2013-08-18 14:51:00.509463+01:00</computeroutput>
<computeroutput moreinfo="none">user: yminsky</computeroutput>
<computeroutput moreinfo="none">credentials: Xy2d9W</computeroutput>
<computeroutput moreinfo="none">- : unit = ()</computeroutput></programlisting>

    <para>One nice side effect of this approach is that it helps you adapt
    your code when the fields of a record change. If you were to add a field
    to <literal moreinfo="none">Logon.t</literal>, the type of <literal moreinfo="none">Logon.Fields.iter</literal> would change along with it,
    acquiring a new argument. Any code using <literal moreinfo="none">Logon.Fields.iter</literal> won't compile until it's fixed
    to take this new argument into account.</para>

    <para>Field iterators are useful for a variety of record-related tasks,
    from building record-validation functions to scaffolding the definition of
    a web form from a record type. Such applications can benefit from the
    guarantee that all fields of the record type in question have been
    considered.<indexterm class="endofrange" startref="Ffc"/><indexterm class="endofrange" startref="firstclass"/><indexterm class="endofrange" startref="RECfirstclass"/></para>
  </sect1>
</chapter>

  <chapter id="variants">
  <title>Variants</title>

  <para>Variant types are one of the most useful features of OCaml and also
  one of the most unusual. They let you represent data that may take on
  multiple different forms, where each form is marked by an explicit tag. As
  we'll see, when combined with pattern matching, variants give you a powerful
  way of representing complex data and of organizing the case-analysis on that
  information.<indexterm class="singular">
      <primary>variant types</primary>

      <secondary>usefulness of</secondary>
    </indexterm><indexterm class="startofrange" id="DTvar">
      <primary>datatypes</primary>

      <secondary>variant types</secondary>
    </indexterm></para>

  <para>The basic syntax of a variant type declaration is as
  follows:<indexterm class="singular">
      <primary>variant types</primary>

      <secondary>basic syntax of</secondary>
    </indexterm></para>

  <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variants/variant.syntax">Syntax</ulink></para>

  <programlisting format="linespecific" language="ocaml">type <emphasis>&lt;variant&gt;</emphasis> =
  | <emphasis>&lt;Tag&gt;</emphasis> [ of <emphasis>&lt;type&gt;</emphasis> [* <emphasis>&lt;type&gt;</emphasis>]... ]
  | <emphasis>&lt;Tag&gt;</emphasis> [ of <emphasis>&lt;type&gt;</emphasis> [* <emphasis>&lt;type&gt;</emphasis>]... ]
  | ...</programlisting>

  <para>Each row essentially represents a case of the variant. Each case has an associated tag and
    may optionally have a sequence of fields, where each field has a specified type.</para>

  <para>Let's consider a concrete example of how variants can be useful.
  Almost all terminals support a set of eight basic colors, and we can
  represent those colors using a variant. Each color is declared as a simple
  tag, with pipes used to separate the different cases. Note that variant tags
  must be capitalized:</para>

  <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variants/main.topscript">OCaml utop</ulink></para>

  <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">type basic_color =</userinput>
<userinput moreinfo="none">   | Black | Red | Green | Yellow | Blue | Magenta | Cyan | White ;;</userinput>
<computeroutput moreinfo="none">type basic_color =</computeroutput>
<computeroutput moreinfo="none">    Black</computeroutput>
<computeroutput moreinfo="none">  | Red</computeroutput>
<computeroutput moreinfo="none">  | Green</computeroutput>
<computeroutput moreinfo="none">  | Yellow</computeroutput>
<computeroutput moreinfo="none">  | Blue</computeroutput>
<computeroutput moreinfo="none">  | Magenta</computeroutput>
<computeroutput moreinfo="none">  | Cyan</computeroutput>
<computeroutput moreinfo="none">  | White</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Cyan ;;</userinput>
<computeroutput moreinfo="none">- : basic_color = Cyan</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">[Blue; Magenta; Red] ;;</userinput>
<computeroutput moreinfo="none">- : basic_color list = [Blue; Magenta; Red]</computeroutput></programlisting>

  <para>The following function uses pattern matching to convert a <literal moreinfo="none">basic_color</literal> to a corresponding integer. The
  exhaustiveness checking on pattern matches means that the compiler will warn
  us if we miss a color:</para>

  <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variants/main.topscript">OCaml utop</ulink>
  (part 1)</para>

  <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let basic_color_to_int = function</userinput>
<userinput moreinfo="none">  | Black -&gt; 0 | Red     -&gt; 1 | Green -&gt; 2 | Yellow -&gt; 3</userinput>
<userinput moreinfo="none">  | Blue  -&gt; 4 | Magenta -&gt; 5 | Cyan  -&gt; 6 | White  -&gt; 7 ;;</userinput>
<computeroutput moreinfo="none">val basic_color_to_int : basic_color -&gt; int = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">List.map ~f:basic_color_to_int [Blue;Red];;</userinput>
<computeroutput moreinfo="none">- : int list = [4; 1]</computeroutput></programlisting>

  <para>Using the preceding function, we can generate escape codes to change
  the color of a given string displayed in a terminal:</para>

  <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variants/main-2.rawscript">OCaml utop</ulink></para>

  <programlisting format="linespecific" language="ocaml"><userinput moreinfo="none"># let color_by_number number text =
    sprintf "\027[38;5;%dm%s\027[0m" number text;;</userinput>
<computeroutput moreinfo="none">val color_by_number : int -&gt; string -&gt; string = &lt;fun&gt;</computeroutput>
<userinput moreinfo="none"># let blue = color_by_number (basic_color_to_int Blue) "Blue";;</userinput>
<computeroutput moreinfo="none">val blue : string = "\027[38;5;4mBlue\027[0m"</computeroutput>
<userinput moreinfo="none"># printf "Hello %s World!\n" blue;;</userinput>
<computeroutput moreinfo="none">Hello Blue World!</computeroutput></programlisting>

  <para>On most terminals, that word "Blue" will be rendered in blue.</para>

  <para>In this example, the cases of the variant are simple tags with no
  associated data. This is substantively the same as the enumerations found in
  languages like C and Java. But as we'll see, variants can do considerably
  more than represent a simple enumeration. As it happens, an enumeration
  isn't enough to effectively describe the full set of colors that a modern
  terminal can display. Many terminals, including the venerable <literal moreinfo="none">xterm</literal>, support 256 different colors, broken up
  into the following groups:</para>

  <itemizedlist>
    <listitem>
      <para>The eight basic colors, in regular and bold versions</para>
    </listitem>

    <listitem>
      <para>A 6 × 6 × 6 RGB color cube</para>
    </listitem>

    <listitem>
      <para>A 24-level grayscale ramp</para>
    </listitem>
  </itemizedlist>

  <para>We'll also represent this more complicated color space as a variant,
  but this time, the different tags will have arguments that describe the data
  available in each case. Note that variants can have multiple arguments,
  which are separated by <literal moreinfo="none">*</literal>s:</para>

  <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variants/main.topscript">OCaml utop</ulink>
  (part 3)</para>

  <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">type weight = Regular | Bold</userinput>
<userinput moreinfo="none">  type color =</userinput>
<userinput moreinfo="none">  | Basic of basic_color * weight (* basic colors, regular and bold *)</userinput>
<userinput moreinfo="none">  | RGB   of int * int * int       (* 6x6x6 color cube *)</userinput>
<userinput moreinfo="none">  | Gray  of int                   (* 24 grayscale levels *)</userinput>
<userinput moreinfo="none">;;</userinput>
<computeroutput moreinfo="none">type weight = Regular | Bold</computeroutput>
<computeroutput moreinfo="none">type color =</computeroutput>
<computeroutput moreinfo="none">    Basic of basic_color * weight</computeroutput>
<computeroutput moreinfo="none">  | RGB of int * int * int</computeroutput>
<computeroutput moreinfo="none">  | Gray of int</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">[RGB (250,70,70); Basic (Green, Regular)];;</userinput>
<computeroutput moreinfo="none">- : color list = [RGB (250, 70, 70); Basic (Green, Regular)]</computeroutput></programlisting>

  <para>Once again, we'll use pattern matching to convert a color to a
  corresponding integer. But in this case, the pattern matching does more than
  separate out the different cases; it also allows us to extract the data
  associated with each tag:</para>

  <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variants/main.topscript">OCaml utop</ulink>
  (part 4)</para>

  <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let color_to_int = function</userinput>
<userinput moreinfo="none">    | Basic (basic_color,weight) -&gt;</userinput>
<userinput moreinfo="none">      let base = match weight with Bold -&gt; 8 | Regular -&gt; 0 in</userinput>
<userinput moreinfo="none">      base + basic_color_to_int basic_color</userinput>
<userinput moreinfo="none">    | RGB (r,g,b) -&gt; 16 + b + g * 6 + r * 36</userinput>
<userinput moreinfo="none">    | Gray i -&gt; 232 + i ;;</userinput>
<computeroutput moreinfo="none">val color_to_int : color -&gt; int = &lt;fun&gt;</computeroutput></programlisting>

  <para>Now, we can print text using the full set of available colors:</para>

  <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variants/main-5.rawscript">OCaml utop</ulink></para>

  <programlisting format="linespecific" language="ocaml"><userinput moreinfo="none"># let color_print color s =
     printf "%s\n" (color_by_number (color_to_int color) s);;</userinput>
<computeroutput moreinfo="none">val color_print : color -&gt; string -&gt; unit = &lt;fun&gt;</computeroutput>
<userinput moreinfo="none"># color_print (Basic (Red,Bold)) "A bold red!";;</userinput>
<computeroutput moreinfo="none">A bold red!</computeroutput>
<userinput moreinfo="none"># color_print (Gray 4) "A muted gray...";;</userinput>
<computeroutput moreinfo="none">A muted gray...</computeroutput></programlisting>

  <sect1 id="catch-all-cases-and-refactoring">
    <title>Catch-All Cases and Refactoring</title>

    <para>OCaml's type system can act as a refactoring tool, warning you of
    places where your code needs to be updated to match an interface change.
    This is particularly valuable in the context of variants.<indexterm class="singular">
        <primary>errors</primary>

        <secondary>catch-all cases and refactoring</secondary>
      </indexterm><indexterm class="singular">
        <primary>pattern matching</primary>

        <secondary>catch-all cases</secondary>
      </indexterm><indexterm class="singular">
        <primary>functional updates</primary>
      </indexterm><indexterm class="singular">
        <primary>refactoring</primary>
      </indexterm><indexterm class="singular">
        <primary>variant types</primary>

        <secondary>catch-all cases and refactoring</secondary>
      </indexterm></para>

    <para>Consider what would happen if we were to change the definition of
    <literal moreinfo="none">color</literal> to the following:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variants/catch_all.topscript">OCaml utop</ulink>
    (part 1)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">type color =</userinput>
<userinput moreinfo="none">  | Basic of basic_color     (* basic colors *)</userinput>
<userinput moreinfo="none">  | Bold  of basic_color     (* bold basic colors *)</userinput>
<userinput moreinfo="none">  | RGB   of int * int * int (* 6x6x6 color cube *)</userinput>
<userinput moreinfo="none">  | Gray  of int             (* 24 grayscale levels *)</userinput>
<userinput moreinfo="none">;;</userinput>
<computeroutput moreinfo="none">type color =</computeroutput>
<computeroutput moreinfo="none">    Basic of basic_color</computeroutput>
<computeroutput moreinfo="none">  | Bold of basic_color</computeroutput>
<computeroutput moreinfo="none">  | RGB of int * int * int</computeroutput>
<computeroutput moreinfo="none">  | Gray of int</computeroutput></programlisting>

    <para>We've essentially broken out the <literal moreinfo="none">Basic</literal> case into two cases, <literal moreinfo="none">Basic</literal> and <literal moreinfo="none">Bold</literal>, and <literal moreinfo="none">Basic</literal> has changed from having two arguments to
    one. <literal moreinfo="none">color_to_int</literal> as we wrote it still
    expects the old structure of the variant, and if we try to compile that
    same code again, the compiler will notice the discrepancy:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variants/catch_all.topscript">OCaml utop</ulink>
    (part 2)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let color_to_int = function</userinput>
<userinput moreinfo="none">    | Basic (basic_color,weight) -&gt;</userinput>
<userinput moreinfo="none">      let base = match weight with Bold -&gt; 8 | Regular -&gt; 0 in</userinput>
<userinput moreinfo="none">      base + basic_color_to_int basic_color</userinput>
<userinput moreinfo="none">    | RGB (r,g,b) -&gt; 16 + b + g * 6 + r * 36</userinput>
<userinput moreinfo="none">    | Gray i -&gt; 232 + i ;;</userinput>
<computeroutput moreinfo="none">Characters 34-60:</computeroutput>
<computeroutput moreinfo="none">Error: This pattern matches values of type 'a * 'b</computeroutput>
<computeroutput moreinfo="none">       but a pattern was expected which matches values of type basic_color</computeroutput></programlisting>

    <para>Here, the compiler is complaining that the <literal moreinfo="none">Basic</literal> tag is used with the wrong number of
    arguments. If we fix that, however, the compiler flag will flag a second
    problem, which is that we haven't handled the new <literal moreinfo="none">Bold</literal> tag:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variants/catch_all.topscript">OCaml utop</ulink>
    (part 3)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let color_to_int = function</userinput>
<userinput moreinfo="none">    | Basic basic_color -&gt; basic_color_to_int basic_color</userinput>
<userinput moreinfo="none">    | RGB (r,g,b) -&gt; 16 + b + g * 6 + r * 36</userinput>
<userinput moreinfo="none">    | Gray i -&gt; 232 + i ;;</userinput>
<computeroutput moreinfo="none">Characters 19-154:</computeroutput>
<computeroutput moreinfo="none">Warning 8: this pattern-matching is not exhaustive.</computeroutput>
<computeroutput moreinfo="none">Here is an example of a value that is not matched:</computeroutput>
<computeroutput moreinfo="none">Bold _</computeroutput>
<computeroutput moreinfo="none">val color_to_int : color -&gt; int = &lt;fun&gt;</computeroutput></programlisting>

    <para>Fixing this now leads us to the correct implementation:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variants/catch_all.topscript">OCaml utop</ulink>
    (part 4)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let color_to_int = function</userinput>
<userinput moreinfo="none">    | Basic basic_color -&gt; basic_color_to_int basic_color</userinput>
<userinput moreinfo="none">    | Bold  basic_color -&gt; 8 + basic_color_to_int basic_color</userinput>
<userinput moreinfo="none">    | RGB (r,g,b) -&gt; 16 + b + g * 6 + r * 36</userinput>
<userinput moreinfo="none">    | Gray i -&gt; 232 + i ;;</userinput>
<computeroutput moreinfo="none">val color_to_int : color -&gt; int = &lt;fun&gt;</computeroutput></programlisting>

    <para>As we've seen, the type errors identified the things that needed to
    be fixed to complete the refactoring of the code. This is fantastically
    useful, but for it to work well and reliably, you need to write your code
    in a way that maximizes the compiler's chances of helping you find the
    bugs. To this end, a useful rule of thumb is to avoid catch-all cases in
    pattern matches.</para>

    <para>Here's an example that illustrates how catch-all cases interact with
    exhaustion checks. Imagine we wanted a version of <literal moreinfo="none">color_to_int</literal> that works on older terminals by
    rendering the first 16 colors (the eight <literal moreinfo="none">basic_color</literal>s in regular and bold) in the normal
    way, but renders everything else as white. We might have written the
    function as follows:<indexterm class="singular">
        <primary>exhaustion checks</primary>
      </indexterm></para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variants/catch_all.topscript">OCaml utop</ulink>
    (part 5)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let oldschool_color_to_int = function</userinput>
<userinput moreinfo="none">    | Basic (basic_color,weight) -&gt;</userinput>
<userinput moreinfo="none">      let base = match weight with Bold -&gt; 8 | Regular -&gt; 0 in</userinput>
<userinput moreinfo="none">      base + basic_color_to_int basic_color</userinput>
<userinput moreinfo="none">    | _ -&gt; basic_color_to_int White;;</userinput>
<computeroutput moreinfo="none">Characters 44-70:</computeroutput>
<computeroutput moreinfo="none">Error: This pattern matches values of type 'a * 'b</computeroutput>
<computeroutput moreinfo="none">       but a pattern was expected which matches values of type basic_color</computeroutput></programlisting>

    <para>But because the catch-all case encompasses all possibilities, the
    type system will no longer warn us that we have missed the new <literal moreinfo="none">Bold</literal> case when we change the type to include it.
    We can get this check back by avoiding the catch-all case, and instead
    being explicit about the tags that are ignored.</para>
  </sect1>

  <sect1 id="combining-records-and-variants">
    <title>Combining Records and Variants</title>

    <para>The term <emphasis>algebraic data types</emphasis> is often used to
    describe a collection of types that includes variants, records, and
    tuples. Algebraic data types act as a peculiarly useful and powerful
    language for describing data. At the heart of their utility is the fact
    that they combine two different kinds of types: <emphasis>product
    types</emphasis>, like tuples and records, which combine multiple
    different types together and are mathematically similar to Cartesian
    products; and <emphasis>sum types</emphasis>, like variants, which let you
    combine multiple different possibilities into one type, and are
    mathematically similar to disjoint unions.<indexterm class="startofrange" id="RECvartyp">
        <primary>records</primary>

        <secondary sortas="variant types">and variant types</secondary>
      </indexterm><indexterm class="singular">
        <primary>sum types</primary>
      </indexterm><indexterm class="singular">
        <primary>product types</primary>
      </indexterm><indexterm class="singular">
        <primary>datatypes</primary>

        <secondary>algebraic types</secondary>
      </indexterm><indexterm class="singular">
        <primary>algebraic data types</primary>
      </indexterm><indexterm class="startofrange" id="VARTYPrec">
        <primary>variant types</primary>

        <secondary sortas="records">and records</secondary>
      </indexterm></para>

    <para>Algebraic data types gain much of their power from the ability to
    construct layered combinations of sums and products. Let's see what we can
    achieve with this by revisiting the logging server types that were
    described in <xref linkend="records"/>. We'll start by reminding
    ourselves of the definition of <literal moreinfo="none">Log_entry.t</literal>:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variants/logger.topscript">OCaml utop</ulink>
    (part 1)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">module Log_entry = struct</userinput>
<userinput moreinfo="none">    type t =</userinput>
<userinput moreinfo="none">      { session_id: string;</userinput>
<userinput moreinfo="none">        time: Time.t;</userinput>
<userinput moreinfo="none">        important: bool;</userinput>
<userinput moreinfo="none">        message: string;</userinput>
<userinput moreinfo="none">      }</userinput>
<userinput moreinfo="none">  end</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">module Log_entry :</computeroutput>
<computeroutput moreinfo="none">  sig</computeroutput>
<computeroutput moreinfo="none">    type t = {</computeroutput>
<computeroutput moreinfo="none">      session_id : string;</computeroutput>
<computeroutput moreinfo="none">      time : Time.t;</computeroutput>
<computeroutput moreinfo="none">      important : bool;</computeroutput>
<computeroutput moreinfo="none">      message : string;</computeroutput>
<computeroutput moreinfo="none">    }</computeroutput>
<computeroutput moreinfo="none">  end</computeroutput></programlisting>

    <para>This record type combines multiple pieces of data into one value. In particular, a single
        <literal moreinfo="none">Log_entry.t</literal> has a <literal moreinfo="none">session_id</literal>
      <emphasis>and</emphasis> a <literal moreinfo="none">time</literal>
      <emphasis>and</emphasis> an <literal moreinfo="none">important</literal> flag
        <emphasis>and</emphasis> a <literal moreinfo="none">message</literal>. More generally, you
      can think of record types as conjunctions. Variants, on the other hand, are disjunctions,
      letting you represent multiple possibilities, as in the following example:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variants/logger.topscript">OCaml utop</ulink>
    (part 2)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">type client_message = | Logon of Logon.t</userinput>
<userinput moreinfo="none">                        | Heartbeat of Heartbeat.t</userinput>
<userinput moreinfo="none">                        | Log_entry of Log_entry.t</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">type client_message =</computeroutput>
<computeroutput moreinfo="none">    Logon of Logon.t</computeroutput>
<computeroutput moreinfo="none">  | Heartbeat of Heartbeat.t</computeroutput>
<computeroutput moreinfo="none">  | Log_entry of Log_entry.t</computeroutput></programlisting>

    <para>A <literal moreinfo="none">client_message</literal> is a <literal moreinfo="none">Logon</literal> <emphasis>or</emphasis> a <literal moreinfo="none">Heartbeat</literal> <emphasis>or</emphasis> a <literal moreinfo="none">Log_entry</literal>. If we want to write code that
    processes messages generically, rather than code specialized to a fixed
    message type, we need something like <literal moreinfo="none">client_message</literal> to act as one overarching type
    for the different possible messages. We can then match on the <literal moreinfo="none">client_message</literal> to determine the type of the
    particular message being dealt with.</para>

    <para>You can increase the precision of your types by using variants to
    represent differences between types, and records to represent shared
    structure. Consider the following function that takes a list of <literal moreinfo="none">client_message</literal>s and returns all messages
    generated by a given user. The code in question is implemented by folding
    over the list of messages, where the accumulator is a pair of:</para>

    <itemizedlist>
      <listitem>
        <para>The set of session identifiers for the user that have been seen
        thus far</para>
      </listitem>

      <listitem>
        <para>The set of messages so far that are associated with the
        user</para>
      </listitem>
    </itemizedlist>

    <para>Here's the concrete code:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variants/logger.topscript">OCaml utop</ulink>
    (part 3)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let messages_for_user user messages =</userinput>
<userinput moreinfo="none">    let (user_messages,_) =</userinput>
<userinput moreinfo="none">      List.fold messages ~init:([],String.Set.empty)</userinput>
<userinput moreinfo="none">        ~f:(fun ((messages,user_sessions) as acc) message -&gt;</userinput>
<userinput moreinfo="none">          match message with</userinput>
<userinput moreinfo="none">          | Logon m -&gt;</userinput>
<userinput moreinfo="none">            if m.Logon.user = user then</userinput>
<userinput moreinfo="none">              (message::messages, Set.add user_sessions m.Logon.session_id)</userinput>
<userinput moreinfo="none">            else acc</userinput>
<userinput moreinfo="none">          | Heartbeat _ | Log_entry _ -&gt;</userinput>
<userinput moreinfo="none">            let session_id = match message with</userinput>
<userinput moreinfo="none">              | Logon     m -&gt; m.Logon.session_id</userinput>
<userinput moreinfo="none">              | Heartbeat m -&gt; m.Heartbeat.session_id</userinput>
<userinput moreinfo="none">              | Log_entry m -&gt; m.Log_entry.session_id</userinput>
<userinput moreinfo="none">            in</userinput>
<userinput moreinfo="none">            if Set.mem user_sessions session_id then</userinput>
<userinput moreinfo="none">              (message::messages,user_sessions)</userinput>
<userinput moreinfo="none">            else acc</userinput>
<userinput moreinfo="none">        )</userinput>
<userinput moreinfo="none">    in</userinput>
<userinput moreinfo="none">    List.rev user_messages</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val messages_for_user : string -&gt; client_message list -&gt; client_message list =</computeroutput>
<computeroutput moreinfo="none">  &lt;fun&gt;</computeroutput></programlisting>

    <para>There's one awkward part of the preceding code, which is the logic
    that determines the session ID. The code is somewhat repetitive,
    contemplating each of the possible message types (including the <literal moreinfo="none">Logon</literal> case, which isn't actually possible at
    that point in the code) and extracting the session ID in each case. This
    per-message-type handling seems unnecessary, since the session ID works
    the same way for all of the message types.</para>

    <para>We can improve the code by refactoring our types to explicitly
    reflect the information that's shared between the different messages. The
    first step is to cut down the definitions of each per-message record to
    contain just the information unique to that record:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variants/logger.topscript">OCaml utop</ulink>
    (part 4)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">module Log_entry = struct</userinput>
<userinput moreinfo="none">    type t = { important: bool;</userinput>
<userinput moreinfo="none">               message: string;</userinput>
<userinput moreinfo="none">             }</userinput>
<userinput moreinfo="none">  end</userinput>
<userinput moreinfo="none">  module Heartbeat = struct</userinput>
<userinput moreinfo="none">    type t = { status_message: string; }</userinput>
<userinput moreinfo="none">  end</userinput>
<userinput moreinfo="none">  module Logon = struct</userinput>
<userinput moreinfo="none">    type t = { user: string;</userinput>
<userinput moreinfo="none">               credentials: string;</userinput>
<userinput moreinfo="none">             }</userinput>
<userinput moreinfo="none">  end ;;</userinput>
<computeroutput moreinfo="none">module Log_entry : sig type t = { important : bool; message : string; } end</computeroutput>
<computeroutput moreinfo="none">module Heartbeat : sig type t = { status_message : string; } end</computeroutput>
<computeroutput moreinfo="none">module Logon : sig type t = { user : string; credentials : string; } end</computeroutput></programlisting>

    <para>We can then define a variant type that combines these types:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variants/logger.topscript">OCaml utop</ulink>
    (part 5)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">type details =</userinput>
<userinput moreinfo="none">    | Logon of Logon.t</userinput>
<userinput moreinfo="none">    | Heartbeat of Heartbeat.t</userinput>
<userinput moreinfo="none">    | Log_entry of Log_entry.t</userinput>
<userinput moreinfo="none"> ;;</userinput>
<computeroutput moreinfo="none">type details =</computeroutput>
<computeroutput moreinfo="none">    Logon of Logon.t</computeroutput>
<computeroutput moreinfo="none">  | Heartbeat of Heartbeat.t</computeroutput>
<computeroutput moreinfo="none">  | Log_entry of Log_entry.t</computeroutput></programlisting>

    <para>Separately, we need a record that contains the fields that are
    common across all messages:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variants/logger.topscript">OCaml utop</ulink>
    (part 6)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">module Common = struct</userinput>
<userinput moreinfo="none">    type t = { session_id: string;</userinput>
<userinput moreinfo="none">               time: Time.t;</userinput>
<userinput moreinfo="none">             }</userinput>
<userinput moreinfo="none">  end ;;</userinput>
<computeroutput moreinfo="none">module Common : sig type t = { session_id : string; time : Time.t; } end</computeroutput></programlisting>

    <para>A full message can then be represented as a pair of a <literal moreinfo="none">Common.t</literal> and a <literal moreinfo="none">details</literal>. Using this, we can rewrite our
    preceding example as follows:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variants/logger.topscript">OCaml utop</ulink>
    (part 7)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let messages_for_user user messages =</userinput>
<userinput moreinfo="none">    let (user_messages,_) =</userinput>
<userinput moreinfo="none">      List.fold messages ~init:([],String.Set.empty)</userinput>
<userinput moreinfo="none">        ~f:(fun ((messages,user_sessions) as acc) ((common,details) as message) -&gt;</userinput>
<userinput moreinfo="none">          let session_id = common.Common.session_id in</userinput>
<userinput moreinfo="none">          match details with</userinput>
<userinput moreinfo="none">          | Logon m -&gt;</userinput>
<userinput moreinfo="none">            if m.Logon.user = user then</userinput>
<userinput moreinfo="none">              (message::messages, Set.add user_sessions session_id)</userinput>
<userinput moreinfo="none">            else acc</userinput>
<userinput moreinfo="none">          | Heartbeat _ | Log_entry _ -&gt;</userinput>
<userinput moreinfo="none">            if Set.mem user_sessions session_id then</userinput>
<userinput moreinfo="none">              (message::messages,user_sessions)</userinput>
<userinput moreinfo="none">            else acc</userinput>
<userinput moreinfo="none">        )</userinput>
<userinput moreinfo="none">    in</userinput>
<userinput moreinfo="none">    List.rev user_messages</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val messages_for_user :</computeroutput>
<computeroutput moreinfo="none">  string -&gt; (Common.t * details) list -&gt; (Common.t * details) list = &lt;fun&gt;</computeroutput></programlisting>

    <para>As you can see, the code for extracting the session ID has been
    replaced with the simple expression <literal moreinfo="none">common.Common.session_id</literal>.</para>

    <para>In addition, this design allows us to essentially downcast to the
    specific message type once we know what it is and then dispatch code to
    handle just that message type. In particular, while we use the type
    <literal moreinfo="none">Common.t * details</literal> to represent an
    arbitrary message, we can use <literal moreinfo="none">Common.t *
    Logon.t</literal> to represent a logon message. Thus, if we had functions
    for handling individual message types, we could write a dispatch function
    as follows:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variants/logger.topscript">OCaml utop</ulink>
    (part 8)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let handle_message server_state (common,details) =</userinput>
<userinput moreinfo="none">    match details with</userinput>
<userinput moreinfo="none">    | Log_entry m -&gt; handle_log_entry server_state (common,m)</userinput>
<userinput moreinfo="none">    | Logon     m -&gt; handle_logon     server_state (common,m)</userinput>
<userinput moreinfo="none">    | Heartbeat m -&gt; handle_heartbeat server_state (common,m)</userinput>
<userinput moreinfo="none">  ;;</userinput></programlisting>

    <para>And it's explicit at the type level that <literal moreinfo="none">handle_log_entry</literal> sees only <literal moreinfo="none">Log_entry</literal> messages, <literal moreinfo="none">handle_logon</literal> sees only <literal moreinfo="none">Logon</literal> messages, etc.<indexterm class="endofrange" startref="RECvartyp"/><indexterm class="endofrange" startref="VARTYPrec"/></para>
  </sect1>

  <sect1 id="variants-and-recursive-data-structures">
    <title>Variants and Recursive Data Structures</title>

    <para>Another common application of variants is to represent tree-like
    recursive data structures. We'll show how this can be done by walking
    through the design of a simple Boolean expression language. Such a
    language can be useful anywhere you need to specify filters, which are
    used in everything from packet analyzers to mail clients.<indexterm class="singular">
        <primary>recursive data structures</primary>
      </indexterm><indexterm class="singular">
        <primary>data structures</primary>

        <secondary>recursive</secondary>
      </indexterm><indexterm class="singular">
        <primary>variant types</primary>

        <secondary sortas="recursive">and recursive data
        structures</secondary>
      </indexterm></para>

    <para>An expression in this language will be defined by the variant
    <literal moreinfo="none">expr</literal>, with one tag for each kind of
    expression we want to support:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variants/blang.topscript">OCaml utop</ulink></para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">type 'a expr =</userinput>
<userinput moreinfo="none">    | Base  of 'a</userinput>
<userinput moreinfo="none">    | Const of bool</userinput>
<userinput moreinfo="none">    | And   of 'a expr list</userinput>
<userinput moreinfo="none">    | Or    of 'a expr list</userinput>
<userinput moreinfo="none">    | Not   of 'a expr</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">type 'a expr =</computeroutput>
<computeroutput moreinfo="none">    Base of 'a</computeroutput>
<computeroutput moreinfo="none">  | Const of bool</computeroutput>
<computeroutput moreinfo="none">  | And of 'a expr list</computeroutput>
<computeroutput moreinfo="none">  | Or of 'a expr list</computeroutput>
<computeroutput moreinfo="none">  | Not of 'a expr</computeroutput></programlisting>

    <para>Note that the definition of the type <literal moreinfo="none">expr</literal> is recursive, meaning that a <literal moreinfo="none">expr</literal> may contain other <literal moreinfo="none">expr</literal>s. Also, <literal moreinfo="none">expr</literal> is parameterized by a polymorphic type
    <literal moreinfo="none">'a</literal> which is used for specifying the
    type of the value that goes under the <literal moreinfo="none">Base</literal> tag.</para>

    <para>The purpose of each tag is pretty straightforward. <literal moreinfo="none">And</literal>, <literal moreinfo="none">Or</literal>, and
    <literal moreinfo="none">Not</literal> are the basic operators for
    building up Boolean expressions, and <literal moreinfo="none">Const</literal> lets you enter the constants <literal moreinfo="none">true</literal> and <literal moreinfo="none">false</literal>.</para>

    <para>The <literal moreinfo="none">Base</literal> tag is what allows you
    to tie the <literal moreinfo="none">expr</literal> to your application, by
    letting you specify an element of some base predicate type, whose truth or
    falsehood is determined by your application. If you were writing a filter
    language for an email processor, your base predicates might specify the
    tests you would run against an email, as in the following example:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variants/blang.topscript">OCaml utop</ulink>
    (part 1)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">type mail_field = To | From | CC | Date | Subject</userinput>
<userinput moreinfo="none">  type mail_predicate = { field: mail_field;</userinput>
<userinput moreinfo="none">                          contains: string }</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">type mail_field = To | From | CC | Date | Subject</computeroutput>
<computeroutput moreinfo="none">type mail_predicate = { field : mail_field; contains : string; }</computeroutput></programlisting>

    <para>Using the preceding code, we can construct a simple expression with
    <literal moreinfo="none">mail_predicate</literal> as its base
    predicate:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variants/blang.topscript">OCaml utop</ulink>
    (part 2)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let test field contains = Base { field; contains };;</userinput>
<computeroutput moreinfo="none">val test : mail_field -&gt; string -&gt; mail_predicate expr = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">And [ Or [ test To "doligez"; test CC "doligez" ];</userinput>
<userinput moreinfo="none">        test Subject "runtime";</userinput>
<userinput moreinfo="none">      ]</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">- : mail_predicate expr =</computeroutput>
<computeroutput moreinfo="none">And</computeroutput>
<computeroutput moreinfo="none"> [Or</computeroutput>
<computeroutput moreinfo="none">   [Base {field = To; contains = "doligez"};</computeroutput>
<computeroutput moreinfo="none">    Base {field = CC; contains = "doligez"}];</computeroutput>
<computeroutput moreinfo="none">  Base {field = Subject; contains = "runtime"}]</computeroutput></programlisting>

    <para>Being able to construct such expressions isn't enough; we also need
    to be able to evaluate them. Here's a function for doing just that:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variants/blang.topscript">OCaml utop</ulink>
    (part 3)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let rec eval expr base_eval =</userinput>
<userinput moreinfo="none">    (* a shortcut, so we don't need to repeatedly pass [base_eval]
        explicitly to [eval] *)</userinput>
<userinput moreinfo="none">    let eval' expr = eval expr base_eval in</userinput>
<userinput moreinfo="none">    match expr with</userinput>
<userinput moreinfo="none">    | Base  base   -&gt; base_eval base</userinput>
<userinput moreinfo="none">    | Const bool   -&gt; bool</userinput>
<userinput moreinfo="none">    | And   exprs -&gt; List.for_all exprs ~f:eval'</userinput>
<userinput moreinfo="none">    | Or    exprs -&gt; List.exists  exprs ~f:eval'</userinput>
<userinput moreinfo="none">    | Not   expr  -&gt; not (eval' expr)</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val eval : 'a expr -&gt; ('a -&gt; bool) -&gt; bool = &lt;fun&gt;</computeroutput></programlisting>

    <para>The structure of the code is pretty straightforward—we're just
    pattern matching over the structure of the data, doing the appropriate
    calculation based on which tag we see. To use this evaluator on a concrete
    example, we just need to write the <literal moreinfo="none">base_eval</literal> function, which is capable of
    evaluating a base predicate.</para>

    <para>Another useful operation on expressions is simplification. The
    following is a set of simplifying construction functions that mirror the
    tags of an <literal moreinfo="none">expr</literal>:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variants/blang.topscript">OCaml utop</ulink>
    (part 4)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let and_ l =</userinput>
<userinput moreinfo="none">    if List.mem l (Const false) then Const false</userinput>
<userinput moreinfo="none">    else</userinput>
<userinput moreinfo="none">      match List.filter l ~f:((&lt;&gt;) (Const true)) with</userinput>
<userinput moreinfo="none">      | [] -&gt; Const true</userinput>
<userinput moreinfo="none">      | [ x ] -&gt; x</userinput>
<userinput moreinfo="none">      | l -&gt; And l</userinput>
<userinput moreinfo="none"/>
<userinput moreinfo="none">  let or_ l =</userinput>
<userinput moreinfo="none">    if List.mem l (Const true) then Const true</userinput>
<userinput moreinfo="none">    else</userinput>
<userinput moreinfo="none">      match List.filter l ~f:((&lt;&gt;) (Const false)) with</userinput>
<userinput moreinfo="none">      | [] -&gt; Const false</userinput>
<userinput moreinfo="none">      | [x] -&gt; x</userinput>
<userinput moreinfo="none">      | l -&gt; Or l</userinput>
<userinput moreinfo="none"/>
<userinput moreinfo="none">  let not_ = function</userinput>
<userinput moreinfo="none">    | Const b -&gt; Const (not b)</userinput>
<userinput moreinfo="none">    | e -&gt; Not e</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val and_ : 'a expr list -&gt; 'a expr = &lt;fun&gt;</computeroutput>
<computeroutput moreinfo="none">val or_ : 'a expr list -&gt; 'a expr = &lt;fun&gt;</computeroutput>
<computeroutput moreinfo="none">val not_ : 'a expr -&gt; 'a expr = &lt;fun&gt;</computeroutput></programlisting>

    <para>We can now write a simplification routine that is based on the
    preceding functions.</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variants/blang.topscript">OCaml utop</ulink>
    (part 5)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let rec simplify = function</userinput>
<userinput moreinfo="none">    | Base _ | Const _ as x -&gt; x</userinput>
<userinput moreinfo="none">    | And l -&gt; and_ (List.map ~f:simplify l)</userinput>
<userinput moreinfo="none">    | Or l  -&gt; or_  (List.map ~f:simplify l)</userinput>
<userinput moreinfo="none">    | Not e -&gt; not_ (simplify e)</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val simplify : 'a expr -&gt; 'a expr = &lt;fun&gt;</computeroutput></programlisting>

    <para>We can apply this to a Boolean expression and see how good a job it
    does at simplifying it:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variants/blang.topscript">OCaml utop</ulink>
    (part 6)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">simplify (Not (And [ Or [Base "it's snowing"; Const true];</userinput>
<userinput moreinfo="none">                       Base "it's raining"]));;</userinput>
<computeroutput moreinfo="none">- : string expr = Not (Base "it's raining")</computeroutput></programlisting>

    <para>Here, it correctly converted the <literal moreinfo="none">Or</literal> branch to <literal moreinfo="none">Const
    true</literal> and then eliminated the <literal moreinfo="none">And</literal> entirely, since the <literal moreinfo="none">And</literal> then had only one nontrivial
    component.</para>

    <para>There are some simplifications it misses, however. In particular,
    see what happens if we add a double negation in:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variants/blang.topscript">OCaml utop</ulink>
    (part 7)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">simplify (Not (And [ Or [Base "it's snowing"; Const true];</userinput>
<userinput moreinfo="none">                       Not (Not (Base "it's raining"))]));;</userinput>
<computeroutput moreinfo="none">- : string expr = Not (Not (Not (Base "it's raining")))</computeroutput></programlisting>

    <para>It fails to remove the double negation, and it's easy to see why.
    The <literal moreinfo="none">not_</literal> function has a catch-all case,
    so it ignores everything but the one case it explicitly considers, that of
    the negation of a constant. Catch-all cases are generally a bad idea, and
    if we make the code more explicit, we see that the missing of the double
    negation is more obvious:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variants/blang.topscript">OCaml utop</ulink>
    (part 8)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let not_ = function</userinput>
<userinput moreinfo="none">    | Const b -&gt; Const (not b)</userinput>
<userinput moreinfo="none">    | (Base _ | And _ | Or _ | Not _) as e -&gt; Not e</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val not_ : 'a expr -&gt; 'a expr = &lt;fun&gt;</computeroutput></programlisting>

    <para>We can of course fix this by simply adding an explicit case for
    double negation:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variants/blang.topscript">OCaml utop</ulink>
    (part 9)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let not_ = function</userinput>
<userinput moreinfo="none">    | Const b -&gt; Const (not b)</userinput>
<userinput moreinfo="none">    | Not e -&gt; e</userinput>
<userinput moreinfo="none">    | (Base _ | And _ | Or _ ) as e -&gt; Not e</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val not_ : 'a expr -&gt; 'a expr = &lt;fun&gt;</computeroutput></programlisting>

    <para>The example of a Boolean expression language is more than a toy.
    There's a module very much in this spirit in Core called <literal moreinfo="none">Blang</literal> (short for "Boolean language"), and it
    gets a lot of practical use in a variety of applications. The
    simplification algorithm in particular is useful when you want to use it
    to specialize the evaluation of expressions for which the evaluation of
    some of the base predicates is already known.</para>

    <para>More generally, using variants to build recursive data structures is
    a common technique, and shows up everywhere from designing little
    languages to building complex data structures.</para>
  </sect1>

  <sect1 id="polymorphic-variants">
    <title>Polymorphic Variants</title>

    <para>In addition to the ordinary variants we've seen so far, OCaml also
    supports so-called <emphasis>polymorphic variants</emphasis>. As we'll
    see, polymorphic variants are more flexible and syntactically more
    lightweight than ordinary variants, but that extra power comes at a
    cost.<indexterm class="singular">
        <primary>polymorphic variant types</primary>

        <secondary>basic syntax of</secondary>
      </indexterm><indexterm class="startofrange" id="VARTYPpoly">
        <primary>variant types</primary>

        <secondary>polymorphic</secondary>
      </indexterm></para>

    <para>Syntactically, polymorphic variants are distinguished from ordinary
    variants by the leading backtick. And unlike ordinary variants,
    polymorphic variants can be used without an explicit type
    declaration:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variants/main.topscript">OCaml utop</ulink>
    (part 6)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let three = `Int 3;;</userinput>
<computeroutput moreinfo="none">val three : [&gt; `Int of int ] = `Int 3</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let four = `Float 4.;;</userinput>
<computeroutput moreinfo="none">val four : [&gt; `Float of float ] = `Float 4.</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let nan = `Not_a_number;;</userinput>
<computeroutput moreinfo="none">val nan : [&gt; `Not_a_number ] = `Not_a_number</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">[three; four; nan];;</userinput>
<computeroutput moreinfo="none">- : [&gt; `Float of float | `Int of int | `Not_a_number ] list =</computeroutput>
<computeroutput moreinfo="none">[`Int 3; `Float 4.; `Not_a_number]</computeroutput></programlisting>

    <para>As you can see, polymorphic variant types are inferred
    automatically, and when we combine variants with different tags, the
    compiler infers a new type that knows about all of those tags. Note that
    in the preceding example, the tag name (e.g., <literal moreinfo="none">`Int</literal>) matches the type name (<literal moreinfo="none">int</literal>). This is a common convention in
    OCaml.<indexterm class="singular">
        <primary>polymorphic variant types</primary>

        <secondary>automatic inference of</secondary>
      </indexterm></para>

    <para>The type system will complain if it sees incompatible uses of the
    same tag:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variants/main.topscript">OCaml utop</ulink>
    (part 7)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let five = `Int "five";;</userinput>
<computeroutput moreinfo="none">val five : [&gt; `Int of string ] = `Int "five"</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">[three; four; five];;</userinput>
<computeroutput moreinfo="none">Characters 14-18:</computeroutput>
<computeroutput moreinfo="none">Error: This expression has type [&gt; `Int of string ]</computeroutput>
<computeroutput moreinfo="none">       but an expression was expected of type</computeroutput>
<computeroutput moreinfo="none">         [&gt; `Float of float | `Int of int ]</computeroutput>
<computeroutput moreinfo="none">       Types for tag `Int are incompatible</computeroutput></programlisting>

    <para>The <literal moreinfo="none">&gt;</literal> at the beginning of the
    variant types above is critical because it marks the types as being open
    to combination with other variant types. We can read the type <literal moreinfo="none">[&gt; `Int of string | `Float of float]</literal> as
    describing a variant whose tags include <literal moreinfo="none">`Int of
    string</literal> and <literal moreinfo="none">`Float of float</literal>,
    but may include more tags as well. In other words, you can roughly
    translate <literal moreinfo="none">&gt;</literal> to mean: "these tags or
    more."</para>

    <para>OCaml will in some cases infer a variant type with <literal moreinfo="none">&lt;</literal>, to indicate "these tags or less," as in
    the following example:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variants/main.topscript">OCaml utop</ulink>
    (part 8)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let is_positive = function</userinput>
<userinput moreinfo="none">     | `Int   x -&gt; x &gt; 0</userinput>
<userinput moreinfo="none">     | `Float x -&gt; x &gt; 0.</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val is_positive : [&lt; `Float of float | `Int of int ] -&gt; bool = &lt;fun&gt;</computeroutput></programlisting>

    <para>The <literal moreinfo="none">&lt;</literal> is there because
    <literal moreinfo="none">is_positive</literal> has no way of dealing with
    values that have tags other than <literal moreinfo="none">`Float of
    float</literal> or <literal moreinfo="none">`Int of int</literal>.</para>

    <para>We can think of these <literal moreinfo="none">&lt;</literal> and
    <literal moreinfo="none">&gt;</literal> markers as indications of upper
    and lower bounds on the tags involved. If the same set of tags are both an
    upper and a lower bound, we end up with an <emphasis>exact</emphasis>
    polymorphic variant type, which has neither marker. For example:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variants/main.topscript">OCaml utop</ulink>
    (part 9)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let exact = List.filter ~f:is_positive [three;four];;</userinput>
<computeroutput moreinfo="none">val exact : [ `Float of float | `Int of int ] list = [`Int 3; `Float 4.]</computeroutput></programlisting>

    <para>Perhaps surprisingly, we can also create polymorphic variant types
    that have different upper and lower bounds. Note that <literal moreinfo="none">Ok</literal> and <literal moreinfo="none">Error</literal>
    in the following example come from the <literal moreinfo="none">Result.t</literal> type from Core:<indexterm class="singular">
        <primary>polymorphic variant types</primary>

        <secondary>upper/lower bounds of</secondary>
      </indexterm></para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variants/main.topscript">OCaml utop</ulink>
    (part 10)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let is_positive = function</userinput>
<userinput moreinfo="none">     | `Int   x -&gt; Ok (x &gt; 0)</userinput>
<userinput moreinfo="none">     | `Float x -&gt; Ok (x &gt; 0.)</userinput>
<userinput moreinfo="none">     | `Not_a_number -&gt; Error "not a number";;</userinput>
<computeroutput moreinfo="none">val is_positive :</computeroutput>
<computeroutput moreinfo="none">  [&lt; `Float of float | `Int of int | `Not_a_number ] -&gt;</computeroutput>
<computeroutput moreinfo="none">  (bool, string) Result.t = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">List.filter [three; four] ~f:(fun x -&gt;</userinput>
<userinput moreinfo="none">     match is_positive x with Error _ -&gt; false | Ok b -&gt; b);;</userinput>
<computeroutput moreinfo="none">- : [&lt; `Float of float | `Int of int | `Not_a_number &gt; `Float `Int ] list =</computeroutput>
<computeroutput moreinfo="none">[`Int 3; `Float 4.]</computeroutput></programlisting>

    <para>Here, the inferred type states that the tags can be no more than
    <literal moreinfo="none">`Float</literal>, <literal moreinfo="none">`Int</literal>, and <literal moreinfo="none">`Not_a_number</literal>, and must contain at least
    <literal moreinfo="none">`Float</literal> and <literal moreinfo="none">`Int</literal>. As you can already start to see,
    polymorphic variants can lead to fairly complex inferred types.</para>

    <sect2 id="example-terminal-colors-redux">
      <title>Example: Terminal Colors Redux</title>

      <para>To see how to use polymorphic variants in practice, we'll return
      to terminal colors. Imagine that we have a new terminal type that adds
      yet more colors, say, by adding an alpha channel so you can specify
      translucent colors. We could model this extended set of colors as
      follows, using an ordinary variant:<indexterm class="singular">
          <primary>polymorphic variant types</primary>

          <secondary sortas="ordinary">vs. ordinary variants</secondary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variants/main.topscript">OCaml utop</ulink>
      (part 11)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">type extended_color =</userinput>
<userinput moreinfo="none">    | Basic of basic_color * weight  (* basic colors, regular and bold *)</userinput>
<userinput moreinfo="none">    | RGB   of int * int * int       (* 6x6x6 color space *)</userinput>
<userinput moreinfo="none">    | Gray  of int                   (* 24 grayscale levels *)</userinput>
<userinput moreinfo="none">    | RGBA  of int * int * int * int (* 6x6x6x6 color space *)</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">type extended_color =</computeroutput>
<computeroutput moreinfo="none">    Basic of basic_color * weight</computeroutput>
<computeroutput moreinfo="none">  | RGB of int * int * int</computeroutput>
<computeroutput moreinfo="none">  | Gray of int</computeroutput>
<computeroutput moreinfo="none">  | RGBA of int * int * int * int</computeroutput></programlisting>

      <para>We want to write a function <literal moreinfo="none">extended_color_to_int</literal>, that works like
      <literal moreinfo="none">color_to_int</literal> for all of the old kinds
      of colors, with new logic only for handling colors that include an alpha
      channel. One might try to write such a function as follows.</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variants/main.topscript">OCaml utop</ulink>
      (part 12)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let extended_color_to_int = function</userinput>
<userinput moreinfo="none">    | RGBA (r,g,b,a) -&gt; 256 + a + b * 6 + g * 36 + r * 216</userinput>
<userinput moreinfo="none">    | (Basic _ | RGB _ | Gray _) as color -&gt; color_to_int color</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">Characters 154-159:</computeroutput>
<computeroutput moreinfo="none">Error: This expression has type extended_color</computeroutput>
<computeroutput moreinfo="none">       but an expression was expected of type color</computeroutput></programlisting>

      <para>The code looks reasonable enough, but it leads to a type error
      because <literal moreinfo="none">extended_color</literal> and <literal moreinfo="none">color</literal> are in the compiler's view distinct and
      unrelated types. The compiler doesn't, for example, recognize any
      equality between the <literal moreinfo="none">Basic</literal> tag in the
      two types.</para>

      <para>What we want to do is to share tags between two different variant
      types, and polymorphic variants let us do this in a natural way. First,
      let's rewrite <literal moreinfo="none">basic_color_to_int</literal> and
      <literal moreinfo="none">color_to_int</literal> using polymorphic
      variants. The translation here is pretty straightforward:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variants/main.topscript">OCaml utop</ulink>
      (part 13)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let basic_color_to_int = function</userinput>
<userinput moreinfo="none">    | `Black -&gt; 0 | `Red     -&gt; 1 | `Green -&gt; 2 | `Yellow -&gt; 3</userinput>
<userinput moreinfo="none">    | `Blue  -&gt; 4 | `Magenta -&gt; 5 | `Cyan  -&gt; 6 | `White  -&gt; 7</userinput>
<userinput moreinfo="none"/>
<userinput moreinfo="none">  let color_to_int = function</userinput>
<userinput moreinfo="none">    | `Basic (basic_color,weight) -&gt;</userinput>
<userinput moreinfo="none">      let base = match weight with `Bold -&gt; 8 | `Regular -&gt; 0 in</userinput>
<userinput moreinfo="none">      base + basic_color_to_int basic_color</userinput>
<userinput moreinfo="none">    | `RGB (r,g,b) -&gt; 16 + b + g * 6 + r * 36</userinput>
<userinput moreinfo="none">    | `Gray i -&gt; 232 + i</userinput>
<userinput moreinfo="none"> ;;</userinput>
<computeroutput moreinfo="none">val basic_color_to_int :</computeroutput>
<computeroutput moreinfo="none">  [&lt; `Black | `Blue | `Cyan | `Green | `Magenta | `Red | `White | `Yellow ] -&gt;</computeroutput>
<computeroutput moreinfo="none">  int = &lt;fun&gt;</computeroutput>
<computeroutput moreinfo="none">val color_to_int :</computeroutput>
<computeroutput moreinfo="none">  [&lt; `Basic of</computeroutput>
<computeroutput moreinfo="none">       [&lt; `Black</computeroutput>
<computeroutput moreinfo="none">        | `Blue</computeroutput>
<computeroutput moreinfo="none">        | `Cyan</computeroutput>
<computeroutput moreinfo="none">        | `Green</computeroutput>
<computeroutput moreinfo="none">        | `Magenta</computeroutput>
<computeroutput moreinfo="none">        | `Red</computeroutput>
<computeroutput moreinfo="none">        | `White</computeroutput>
<computeroutput moreinfo="none">        | `Yellow ] *</computeroutput>
<computeroutput moreinfo="none">       [&lt; `Bold | `Regular ]</computeroutput>
<computeroutput moreinfo="none">   | `Gray of int</computeroutput>
<computeroutput moreinfo="none">   | `RGB of int * int * int ] -&gt;</computeroutput>
<computeroutput moreinfo="none">  int = &lt;fun&gt;</computeroutput></programlisting>

      <para>Now we can try writing <literal moreinfo="none">extended_color_to_int</literal>. The key issue with this
      code is that <literal moreinfo="none">extended_color_to_int</literal>
      needs to invoke <literal moreinfo="none">color_to_int</literal> with a
      narrower type, i.e., one that includes fewer tags. Written properly,
      this narrowing can be done via a pattern match. In particular, in the
      following code, the type of the variable <literal moreinfo="none">color</literal> includes only the tags <literal moreinfo="none">`Basic</literal>, <literal moreinfo="none">`RGB</literal>, and <literal moreinfo="none">`Gray</literal>, and not <literal moreinfo="none">`RGBA</literal>:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variants/main.topscript">OCaml utop</ulink>
      (part 14)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let extended_color_to_int = function</userinput>
<userinput moreinfo="none">    | `RGBA (r,g,b,a) -&gt; 256 + a + b * 6 + g * 36 + r * 216</userinput>
<userinput moreinfo="none">    | (`Basic _ | `RGB _ | `Gray _) as color -&gt; color_to_int color</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val extended_color_to_int :</computeroutput>
<computeroutput moreinfo="none">  [&lt; `Basic of</computeroutput>
<computeroutput moreinfo="none">       [&lt; `Black</computeroutput>
<computeroutput moreinfo="none">        | `Blue</computeroutput>
<computeroutput moreinfo="none">        | `Cyan</computeroutput>
<computeroutput moreinfo="none">        | `Green</computeroutput>
<computeroutput moreinfo="none">        | `Magenta</computeroutput>
<computeroutput moreinfo="none">        | `Red</computeroutput>
<computeroutput moreinfo="none">        | `White</computeroutput>
<computeroutput moreinfo="none">        | `Yellow ] *</computeroutput>
<computeroutput moreinfo="none">       [&lt; `Bold | `Regular ]</computeroutput>
<computeroutput moreinfo="none">   | `Gray of int</computeroutput>
<computeroutput moreinfo="none">   | `RGB of int * int * int</computeroutput>
<computeroutput moreinfo="none">   | `RGBA of int * int * int * int ] -&gt;</computeroutput>
<computeroutput moreinfo="none">  int = &lt;fun&gt;</computeroutput></programlisting>

      <para>The preceding code is more delicately balanced than one might
      imagine. In particular, if we use a catch-all case instead of an
      explicit enumeration of the cases, the type is no longer narrowed, and
      so compilation fails:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variants/main.topscript">OCaml utop</ulink>
      (part 15)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let extended_color_to_int = function</userinput>
<userinput moreinfo="none">    | `RGBA (r,g,b,a) -&gt; 256 + a + b * 6 + g * 36 + r * 216</userinput>
<userinput moreinfo="none">    | color -&gt; color_to_int color</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">Characters 125-130:</computeroutput>
<computeroutput moreinfo="none">Error: This expression has type [&gt; `RGBA of int * int * int * int ]</computeroutput>
<computeroutput moreinfo="none">       but an expression was expected of type</computeroutput>
<computeroutput moreinfo="none">         [&lt; `Basic of</computeroutput>
<computeroutput moreinfo="none">              [&lt; `Black</computeroutput>
<computeroutput moreinfo="none">               | `Blue</computeroutput>
<computeroutput moreinfo="none">               | `Cyan</computeroutput>
<computeroutput moreinfo="none">               | `Green</computeroutput>
<computeroutput moreinfo="none">               | `Magenta</computeroutput>
<computeroutput moreinfo="none">               | `Red</computeroutput>
<computeroutput moreinfo="none">               | `White</computeroutput>
<computeroutput moreinfo="none">               | `Yellow ] *</computeroutput>
<computeroutput moreinfo="none">              [&lt; `Bold | `Regular ]</computeroutput>
<computeroutput moreinfo="none">          | `Gray of int</computeroutput>
<computeroutput moreinfo="none">          | `RGB of int * int * int ]</computeroutput>
<computeroutput moreinfo="none">       The second variant type does not allow tag(s) `RGBA</computeroutput></programlisting>

      <note role="allow_break">
        <title>Polymorphic Variants and Catch-all Cases</title>

        <para>As we saw with the definition of <literal moreinfo="none">is_positive</literal>, a <literal>match</literal>
        statement can lead to the inference of an upper bound on a variant
        type, limiting the possible tags to those that can be handled by the
        match. If we add a catch-all case to our <literal>match</literal>
        statement, we end up with a type with a lower bound:<indexterm class="singular">
            <primary>pattern matching</primary>

            <secondary>catch-all cases</secondary>
          </indexterm><indexterm class="singular">
            <primary>catch-all cases</primary>
          </indexterm><indexterm class="singular">
            <primary>polymorphic variant types</primary>

            <secondary sortas="catch-all cases">and catch-all
            cases</secondary>
          </indexterm></para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variants/main.topscript">OCaml utop</ulink>
        (part 16)</para>

        <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let is_positive_permissive = function</userinput>
<userinput moreinfo="none">     | `Int   x -&gt; Ok (x &gt; 0)</userinput>
<userinput moreinfo="none">     | `Float x -&gt; Ok (x &gt; 0.)</userinput>
<userinput moreinfo="none">     | _ -&gt; Error "Unknown number type"</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val is_positive_permissive :</computeroutput>
<computeroutput moreinfo="none">  [&gt; `Float of float | `Int of int ] -&gt; (bool, string) Result.t = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">is_positive_permissive (`Int 0);;</userinput>
<computeroutput moreinfo="none">- : (bool, string) Result.t = Ok false</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">is_positive_permissive (`Ratio (3,4));;</userinput>
<computeroutput moreinfo="none">- : (bool, string) Result.t = Error "Unknown number type"</computeroutput></programlisting>

        <para>Catch-all cases are error-prone even with ordinary variants, but
        they are especially so with polymorphic variants. That's because you
        have no way of bounding what tags your function might have to deal
        with. Such code is particularly vulnerable to typos. For instance, if
        code that uses <literal moreinfo="none">is_positive_permissive</literal> passes in <literal moreinfo="none">Float</literal> misspelled as <literal moreinfo="none">Floot</literal>, the erroneous code will compile
        without complaint:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variants/main.topscript">OCaml utop</ulink>
        (part 17)</para>

        <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">is_positive_permissive (`Floot 3.5);;</userinput>
<computeroutput moreinfo="none">- : (bool, string) Result.t = Error "Unknown number type"</computeroutput></programlisting>

        <para>With ordinary variants, such a typo would have been caught as an
        unknown tag. As a general matter, one should be wary about mixing
        catch-all cases and polymorphic variants.</para>
      </note>

      <para>Let's consider how we might turn our code into a proper library
      with an implementation in an <literal moreinfo="none">ml</literal> file
      and an interface in a separate <literal moreinfo="none">mli</literal>,
      as we saw in <xref linkend="files-modules-and-programs"/>. Let's start
      with the <literal moreinfo="none">mli</literal>:</para>

      <para role="sourcecode">OCaml: <ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variants-termcol/terminal_color.mli">OCaml</ulink></para>

      <programlisting format="linespecific" language="ocaml">open Core.Std

type basic_color =
  [ `Black   | `Blue | `Cyan  | `Green
  | `Magenta | `Red  | `White | `Yellow ]

type color =
  [ `Basic of basic_color * [ `Bold | `Regular ]
  | `Gray of int
  | `RGB  of int * int * int ]

type extended_color =
  [ color
  | `RGBA of int * int * int * int ]

val color_to_int          : color -&gt; int
val extended_color_to_int : extended_color -&gt; int</programlisting>

      <para>Here, <literal moreinfo="none">extended_color</literal> is defined
      as an explicit extension of <literal moreinfo="none">color</literal>.
      Also, notice that we defined all of these types as exact variants. We
      can implement this library as follows:</para>

      <para role="sourcecode">OCaml: <ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variants-termcol/terminal_color.ml">OCaml</ulink></para>

      <programlisting format="linespecific" language="ocaml">open Core.Std

type basic_color =
  [ `Black   | `Blue | `Cyan  | `Green
  | `Magenta | `Red  | `White | `Yellow ]

type color =
  [ `Basic of basic_color * [ `Bold | `Regular ]
  | `Gray of int
  | `RGB  of int * int * int ]

type extended_color =
  [ color
  | `RGBA of int * int * int * int ]

let basic_color_to_int = function
  | `Black -&gt; 0 | `Red     -&gt; 1 | `Green -&gt; 2 | `Yellow -&gt; 3
  | `Blue  -&gt; 4 | `Magenta -&gt; 5 | `Cyan  -&gt; 6 | `White  -&gt; 7

let color_to_int = function
  | `Basic (basic_color,weight) -&gt;
    let base = match weight with `Bold -&gt; 8 | `Regular -&gt; 0 in
    base + basic_color_to_int basic_color
  | `RGB (r,g,b) -&gt; 16 + b + g * 6 + r * 36
  | `Gray i -&gt; 232 + i

let extended_color_to_int = function
  | `RGBA (r,g,b,a) -&gt; 256 + a + b * 6 + g * 36 + r * 216
  | `Grey x -&gt; 2000 + x
  | (`Basic _ | `RGB _ | `Gray _) as color -&gt; color_to_int color</programlisting>

      <para>In the preceding code, we did something funny to the definition of
      <literal moreinfo="none">extended_color_to_int</literal> that underlines
      some of the downsides of polymorphic variants. In particular, we added
      some special-case handling for the color gray, rather than using
      <literal moreinfo="none">color_to_int</literal>. Unfortunately, we
      misspelled <literal moreinfo="none">Gray</literal> as <literal moreinfo="none">Grey</literal>. This is exactly the kind of error that
      the compiler would catch with ordinary variants, but with polymorphic
      variants, this compiles without issue. All that happened was that the
      compiler inferred a wider type for <literal moreinfo="none">extended_color_to_int</literal>, which happens to be
      compatible with the narrower type that was listed in the <literal moreinfo="none">mli</literal>.</para>

      <para>If we add an explicit type annotation to the code itself (rather
      than just in the <literal moreinfo="none">mli</literal>), then the
      compiler has enough information to warn us:</para>

      <para role="sourcecode">OCaml: <ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variants-termcol-annotated/terminal_color.ml">OCaml</ulink>
      (part 1)</para>

      <programlisting format="linespecific" language="ocaml">let extended_color_to_int : extended_color -&gt; int = function
  | `RGBA (r,g,b,a) -&gt; 256 + a + b * 6 + g * 36 + r * 216
  | `Grey x -&gt; 2000 + x
  | (`Basic _ | `RGB _ | `Gray _) as color -&gt; color_to_int color</programlisting>

      <para>In particular, the compiler will complain that the <literal moreinfo="none">`Grey</literal> case is unused:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variants-termcol-annotated/build.out">Terminal</ulink></para>

      <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">corebuild terminal_color.native</userinput>
<computeroutput moreinfo="none">File "terminal_color.ml", line 30, characters 4-11:</computeroutput>
<computeroutput moreinfo="none">Error: This pattern matches values of type [? `Grey of 'a ]</computeroutput>
<computeroutput moreinfo="none">       but a pattern was expected which matches values of type extended_color</computeroutput>
<computeroutput moreinfo="none">       The second variant type does not allow tag(s) `Grey</computeroutput>
<computeroutput moreinfo="none">Command exited with code 2.</computeroutput></programlisting>
<?hard-pagebreak?>
      <para>Once we have type definitions at our disposal, we can revisit the
      question of how we write the pattern match that narrows the type. In
      particular, we can explicitly use the type name as part of the pattern
      match, by prefixing it with a <literal moreinfo="none">#</literal>:</para>

      <para role="sourcecode">OCaml: <ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/variants-termcol-fixed/terminal_color.ml">OCaml</ulink>
      (part 1)</para>

      <programlisting format="linespecific" language="ocaml">let extended_color_to_int : extended_color -&gt; int = function
  | `RGBA (r,g,b,a) -&gt; 256 + a + b * 6 + g * 36 + r * 216
  | #color as color -&gt; color_to_int color</programlisting>

      <para>This is useful when you want to narrow down to a type whose
      definition is long, and you don't want the verbosity of writing the tags
      down explicitly in the match.</para>
    </sect2>

    <sect2 id="when-to-use-polymorphic-variants">
      <title>When to Use Polymorphic Variants</title>

      <para>At first glance, polymorphic variants look like a strict
      improvement over ordinary variants. You can do everything that ordinary
      variants can do, plus it's more flexible and more concise. What's not to
      like?<indexterm class="singular">
          <primary>polymorphic variant types</primary>

          <secondary sortas="ordinary">vs. ordinary variants</secondary>
        </indexterm><indexterm class="singular">
          <primary>polymorphic variant types</primary>

          <secondary>drawbacks of</secondary>
        </indexterm></para>

      <para>In reality, regular variants are the more pragmatic choice most of
      the time. That's because the flexibility of polymorphic variants comes
      at a price. Here are some of the downsides:</para>

      <variablelist>
        <varlistentry>
          <term>Complexity</term>

          <listitem>
            <para>As we've seen, the typing rules for polymorphic variants are
            a lot more complicated than they are for regular variants. This
            means that heavy use of polymorphic variants can leave you
            scratching your head trying to figure out why a given piece of
            code did or didn't compile. It can also lead to absurdly long and
            hard to decode error messages. Indeed, concision at the value
            level is often balanced out by more verbosity at the type
            level.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Error-finding</term>

          <listitem>
            <para>Polymorphic variants are type-safe, but the typing
            discipline that they impose is, by dint of its flexibility, less
            likely to catch bugs in your program.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Efficiency</term>

          <listitem>
            <para>This isn't a huge effect, but polymorphic variants are
            somewhat heavier than regular variants, and OCaml can't generate
            code for matching on polymorphic variants that is quite as
            efficient as what it generated for regular variants.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>All that said, polymorphic variants are still a useful and
      powerful feature, but it's worth understanding their limitations and how
      to use them sensibly and modestly.</para>

      <para>Probably the safest and most common use case for polymorphic
      variants is where ordinary variants would be sufficient but are
      syntactically too heavyweight. For example, you often want to create a
      variant type for encoding the inputs or outputs to a function, where
      it's not worth declaring a separate type for it. Polymorphic variants
      are very useful here, and as long as there are type annotations that
      constrain these to have explicit, exact types, this tends to work
      well.</para>
<?hard-pagebreak?>
      <para>Variants are most problematic exactly where you take full
      advantage of their power; in particular, when you take advantage of the
      ability of polymorphic variant types to overlap in the tags they
      support. This ties into OCaml's support for subtyping. As we'll discuss
      further when we cover objects in <xref linkend="objects"/>, subtyping
      brings in a lot of complexity, and most of the time, that's complexity
      you want to avoid.<indexterm class="endofrange" startref="VARTYPpoly"/><indexterm class="endofrange" startref="DTvar"/></para>
    </sect2>
  </sect1>
</chapter>

  <chapter id="error-handling">
  <title>Error Handling</title>

  <para>Nobody likes dealing with errors. It's tedious, it's easy to get wrong, and it's usually
    just not as fun as planning out how your program is going to succeed. But error handling is
    important, and however much you don't like thinking about it, having your software fail due to
    poor error handling is worse.</para>

  <para>Thankfully, OCaml has powerful tools for handling errors reliably and
  with a minimum of pain. In this chapter we'll discuss some of the different
  approaches in OCaml to handling errors, and give some advice on how to
  design interfaces that make error handling easier.</para>

  <para>We'll start by describing the two basic approaches for reporting
  errors in OCaml: error-aware return types and exceptions.<indexterm class="startofrange" id="erraware">
      <primary>error-aware return types</primary>
    </indexterm><indexterm class="startofrange" id="EHeraware">
      <primary>error handling</primary>

      <secondary>error-aware return types</secondary>
    </indexterm></para>

  <sect1 id="error-aware-return-types">
    <title>Error-Aware Return Types</title>

    <para>The best way in OCaml to signal an error is to include that error in
    your return value. Consider the type of the <literal moreinfo="none">find</literal> function in the <literal moreinfo="none">List</literal> module:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/error-handling/main.topscript">OCaml utop</ulink></para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">List.find;;</userinput>
<computeroutput moreinfo="none">- : 'a list -&gt; f:('a -&gt; bool) -&gt; 'a option = &lt;fun&gt;</computeroutput></programlisting>

    <para>The option in the return type indicates that the function may not
    succeed in finding a suitable element:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/error-handling/main.topscript">OCaml utop</ulink>
    (part 1)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">List.find [1;2;3] ~f:(fun x -&gt; x &gt;= 2) ;;</userinput>
<computeroutput moreinfo="none">- : int option = Some 2</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">List.find [1;2;3] ~f:(fun x -&gt; x &gt;= 10) ;;</userinput>
<computeroutput moreinfo="none">- : int option = None</computeroutput></programlisting>

    <para>Including errors in the return values of your functions requires the
    caller to handle the error explicitly, allowing the caller to make the
    choice of whether to recover from the error or propagate it onward.</para>

    <para>Consider the <literal moreinfo="none">compute_bounds</literal>
    function. The function takes a list and a comparison function and returns
    upper and lower bounds for the list by finding the smallest and largest
    element on the list. <literal moreinfo="none">List.hd</literal> and
    <literal moreinfo="none">List.last</literal>, which return <literal moreinfo="none">None</literal> when they encounter an empty list, are used
    to extract the largest and smallest element of the list:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/error-handling/main.topscript">OCaml utop</ulink>
    (part 2)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let compute_bounds ~cmp list =</userinput>
<userinput moreinfo="none">    let sorted = List.sort ~cmp list in</userinput>
<userinput moreinfo="none">    match List.hd sorted, List.last sorted with</userinput>
<userinput moreinfo="none">    | None,_ | _, None -&gt; None</userinput>
<userinput moreinfo="none">    | Some x, Some y -&gt; Some (x,y)</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val compute_bounds : cmp:('a -&gt; 'a -&gt; int) -&gt; 'a list -&gt; ('a * 'a) option =</computeroutput>
<computeroutput moreinfo="none">  &lt;fun&gt;</computeroutput></programlisting>

    <para>The <literal>match</literal> statement is used to handle the error
    cases, propagating a <literal moreinfo="none">None</literal> in <literal moreinfo="none">hd</literal> or <literal moreinfo="none">last</literal>
    into the return value of <literal moreinfo="none">compute_bounds</literal>.</para>

    <para>On the other hand, in the <literal moreinfo="none">find_mismatches</literal> that follows, errors encountered
    during the computation do not propagate to the return value of the
    function. <literal moreinfo="none">find_mismatches</literal> takes two
    hash tables as arguments and searches for keys that have different data in
    one table than in the other. As such, the failure to find a key in one
    table isn't a failure of any sort:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/error-handling/main.topscript">OCaml utop</ulink>
    (part 3)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let find_mismatches table1 table2 =</userinput>
<userinput moreinfo="none">     Hashtbl.fold table1 ~init:[] ~f:(fun ~key ~data mismatches -&gt;</userinput>
<userinput moreinfo="none">        match Hashtbl.find table2 key with</userinput>
<userinput moreinfo="none">        | Some data' when data' &lt;&gt; data -&gt; key :: mismatches</userinput>
<userinput moreinfo="none">        | _ -&gt; mismatches</userinput>
<userinput moreinfo="none">     )</userinput>
<userinput moreinfo="none"> ;;</userinput>
<computeroutput moreinfo="none">val find_mismatches : ('a, 'b) Hashtbl.t -&gt; ('a, 'b) Hashtbl.t -&gt; 'a list =</computeroutput>
<computeroutput moreinfo="none">  &lt;fun&gt;</computeroutput></programlisting>

    <para>The use of options to encode errors underlines the fact that it's
    not clear whether a particular outcome, like not finding something on a
    list, is an error or is just another valid outcome. This depends on the
    larger context of your program, and thus is not something that a
    general-purpose library can know in advance. One of the advantages of
    error-aware return types is that they work well in both situations.</para>

    <sect2 id="encoding-errors-with-result">
      <title>Encoding Errors with Result</title>

      <para>Options aren't always a sufficiently expressive way to report
      errors. Specifically, when you encode an error as <literal moreinfo="none">None</literal>, there's nowhere to say anything about
      the nature of the error.</para>

      <para><literal moreinfo="none">Result.t</literal> is meant to address
      this deficiency. The type is defined as follows:<indexterm class="singular">
          <primary>Result.t option</primary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/error-handling/result.mli">OCaml</ulink></para>

      <programlisting format="linespecific" language="ocaml">module Result : sig
   type ('a,'b) t = | Ok of 'a
                    | Error of 'b
end</programlisting>

      <para>A <literal moreinfo="none">Result.t</literal> is essentially an
      option augmented with the ability to store other information in the
      error case. Like <literal moreinfo="none">Some</literal> and <literal moreinfo="none">None</literal> for options, the constructors <literal moreinfo="none">Ok</literal> and <literal moreinfo="none">Error</literal> are promoted to the toplevel by <literal moreinfo="none">Core.Std</literal>. As such, we can write:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/error-handling/main.topscript">OCaml utop</ulink>
      (part 4)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">[ Ok 3; Error "abject failure"; Ok 4 ];;</userinput>
<computeroutput moreinfo="none">- : (int, string) Result.t list = [Ok 3; Error "abject failure"; Ok 4]</computeroutput></programlisting>

      <para>without first opening the <literal moreinfo="none">Result</literal> module.</para>
    </sect2>

    <sect2 id="error-and-or_error">
      <title>Error and Or_error</title>

      <para><literal moreinfo="none">Result.t</literal> gives you complete
      freedom to choose the type of value you use to represent errors, but
      it's often useful to standardize on an error type. Among other things,
      this makes it easier to write utility functions to automate common error
      handling patterns.<indexterm class="singular">
          <primary>Error.t type</primary>
        </indexterm></para>

      <para>But which type to choose? Is it better to represent errors as
      strings? Some more structured representation like XML? Or something else
      entirely?</para>

      <para>Core's answer to this question is the <literal moreinfo="none">Error.t</literal> type, which tries to forge a good
      compromise between efficiency, convenience, and control over the
      presentation of errors.</para>

      <para>It might not be obvious at first why efficiency is an issue at
      all. But generating error messages is an expensive business. An ASCII
      representation of a value can be quite time-consuming to construct,
      particularly if it includes expensive-to-convert numerical data.</para>

      <para><literal moreinfo="none">Error</literal> gets around this issue
      through laziness. In particular, an <literal moreinfo="none">Error.t</literal> allows you to put off generation of
      the error string until and unless you need it, which means a lot of the
      time you never have to construct it at all. You can of course construct
      an error directly from a string:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/error-handling/main.topscript">OCaml utop</ulink>
      (part 5)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">Error.of_string "something went wrong";;</userinput>
<computeroutput moreinfo="none">- : Error.t = something went wrong</computeroutput></programlisting>

      <para>But you can also construct an <literal moreinfo="none">Error.t</literal> from a <emphasis>thunk</emphasis>,
      i.e., a function that takes a single argument of type <literal moreinfo="none">unit</literal>:<indexterm class="singular">
          <primary>thunks</primary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/error-handling/main.topscript">OCaml utop</ulink>
      (part 6)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">Error.of_thunk (fun () -&gt;</userinput>
<userinput moreinfo="none">    sprintf "something went wrong: %f" 32.3343);;</userinput>
<computeroutput moreinfo="none">- : Error.t = something went wrong: 32.334300</computeroutput></programlisting>

      <para>In this case, we can benefit from the laziness of <literal moreinfo="none">Error</literal>, since the thunk won't be called unless
      the <literal moreinfo="none">Error.t</literal> is converted to a
      string.</para>

      <para>The most common way to create <literal moreinfo="none">Error.t</literal>s is using
      <emphasis>s-expressions</emphasis>. An s-expression is a balanced
      parenthetical expression where the leaves of the expressions are
      strings. Here's a simple example:<indexterm class="singular">
          <primary>s-expressions</primary>

          <secondary>example of</secondary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/error-handling/sexpr.scm">Scheme</ulink></para>

      <programlisting format="linespecific" language="scheme">(This (is an) (s expression))</programlisting>

      <para>S-expressions are supported by the Sexplib package that is
      distributed with Core and is the most common serialization format used
      in Core. Indeed, most types in Core come with built-in s-expression
      converters. Here's an example of creating an error using the sexp
      converter for times, <literal moreinfo="none">Time.sexp_of_t</literal>:<indexterm class="singular">
          <primary>Sexplib package</primary>

          <secondary>sexp converter</secondary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/error-handling/main.topscript">OCaml utop</ulink>
      (part 7)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">Error.create "Something failed a long time ago" Time.epoch Time.sexp_of_t;;</userinput>
<computeroutput moreinfo="none">- : Error.t =</computeroutput>
<computeroutput moreinfo="none">Something failed a long time ago: (1970-01-01 01:00:00.000000+01:00)</computeroutput></programlisting>

      <para>Note that the time isn't actually serialized into an s-expression
      until the error is printed out.</para>

      <para>We're not restricted to doing this kind of error reporting with
      built-in types. This will be discussed in more detail in <xref linkend="data-serialization-with-s-expressions"/>, but Sexplib comes
      with a language extension that can autogenerate sexp converters for
      newly generated types:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/error-handling/main.topscript">OCaml utop</ulink>
      (part 8)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let custom_to_sexp = &lt;:sexp_of&lt;float * string list * int&gt;&gt;;;</userinput>
<computeroutput moreinfo="none">val custom_to_sexp : float * string list * int -&gt; Sexp.t = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">custom_to_sexp (3.5, ["a";"b";"c"], 6034);;</userinput>
<computeroutput moreinfo="none">- : Sexp.t = (3.5 (a b c) 6034)</computeroutput></programlisting>

      <para>We can use this same idiom for generating an error:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/error-handling/main.topscript">OCaml utop</ulink>
      (part 9)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">Error.create "Something went terribly wrong"</userinput>
<userinput moreinfo="none">    (3.5, ["a";"b";"c"], 6034)</userinput>
<userinput moreinfo="none">    &lt;:sexp_of&lt;float * string list * int&gt;&gt; ;;</userinput>
<computeroutput moreinfo="none">- : Error.t = Something went terribly wrong: (3.5(a b c)6034)</computeroutput></programlisting>

      <para><literal moreinfo="none">Error</literal> also supports operations
      for transforming errors. For example, it's often useful to augment an
      error with information about the context of the error or to combine
      multiple errors together. <literal moreinfo="none">Error.tag</literal>
      and <literal moreinfo="none">Error.of_list</literal> fulfill these
      roles:<indexterm class="singular">
          <primary>Error.of_list</primary>
        </indexterm><indexterm class="singular">
          <primary>Error.tag</primary>
        </indexterm><indexterm class="singular">
          <primary>errors</primary>

          <secondary>transformation of</secondary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/error-handling/main.topscript">OCaml utop</ulink>
      (part 10)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">Error.tag</userinput>
<userinput moreinfo="none">    (Error.of_list [ Error.of_string "Your tires were slashed";</userinput>
<userinput moreinfo="none">                     Error.of_string "Your windshield was smashed" ])</userinput>
<userinput moreinfo="none">    "over the weekend"</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">- : Error.t =</computeroutput>
<computeroutput moreinfo="none">over the weekend: Your tires were slashed; Your windshield was smashed</computeroutput></programlisting>

      <para>The type <literal moreinfo="none">'a Or_error.t</literal> is just
      a shorthand for <literal moreinfo="none">('a,Error.t)
      Result.t</literal>, and it is, after <literal moreinfo="none">option</literal>, the most common way of returning
      errors in Core.</para>
    </sect2>

    <sect2 id="bind-and-other-error-handling-idioms">
      <title>bind and Other Error Handling Idioms</title>

      <para>As you write more error handling code in OCaml, you'll discover
      that certain patterns start to emerge. A number of these common patterns
      have been codified by functions in modules like <literal moreinfo="none">Option</literal> and <literal moreinfo="none">Result</literal>. One particularly useful pattern is
      built around the function <literal moreinfo="none">bind</literal>, which
      is both an ordinary function and an infix operator <literal moreinfo="none">&gt;&gt;=</literal>. Here's the definition of <literal moreinfo="none">bind</literal> for options:<indexterm class="singular">
          <primary>bind function</primary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/error-handling/main.topscript">OCaml utop</ulink>
      (part 11)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let bind option f =</userinput>
<userinput moreinfo="none">    match option with</userinput>
<userinput moreinfo="none">    | None -&gt; None</userinput>
<userinput moreinfo="none">    | Some x -&gt; f x</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val bind : 'a option -&gt; ('a -&gt; 'b option) -&gt; 'b option = &lt;fun&gt;</computeroutput></programlisting>

      <para>As you can see, <literal moreinfo="none">bind None f</literal> returns <literal moreinfo="none">None</literal> without calling <literal moreinfo="none">f</literal>, and
          <literal moreinfo="none">bind (Some x) f</literal> returns <literal moreinfo="none">f
          x</literal>.  <literal moreinfo="none">bind</literal> can be used as a way of sequencing
        together error-producing functions so that the first one to produce an error terminates the
        computation. Here's a rewrite of <literal moreinfo="none">compute_bounds</literal> to use a
        nested series of <literal moreinfo="none">bind</literal>s:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/error-handling/main.topscript">OCaml utop</ulink>
      (part 12)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let compute_bounds ~cmp list =</userinput>
<userinput moreinfo="none">    let sorted = List.sort ~cmp list in</userinput>
<userinput moreinfo="none">    Option.bind (List.hd sorted) (fun first -&gt;</userinput>
<userinput moreinfo="none">      Option.bind (List.last sorted) (fun last -&gt;</userinput>
<userinput moreinfo="none">        Some (first,last)))</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val compute_bounds : cmp:('a -&gt; 'a -&gt; int) -&gt; 'a list -&gt; ('a * 'a) option =</computeroutput>
<computeroutput moreinfo="none">  &lt;fun&gt;</computeroutput></programlisting>

      <para>The preceding code is a little bit hard to swallow, however, on a
      syntactic level. We can make it easier to read and drop some of the
      parentheses, by using the infix operator form of
      <literal>bind</literal>, which we get access to by locally opening
      <literal moreinfo="none">Option.Monad_infix</literal>. The module is
      called <literal moreinfo="none">Monad_infix</literal> because the
      <literal>bind</literal> operator is part of a subinterface called
      <literal moreinfo="none">Monad</literal>, which we'll see again in <xref linkend="concurrent-programming-with-async"/>:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/error-handling/main.topscript">OCaml utop</ulink>
      (part 13)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let compute_bounds ~cmp list =</userinput>
<userinput moreinfo="none">    let open Option.Monad_infix in</userinput>
<userinput moreinfo="none">    let sorted = List.sort ~cmp list in</userinput>
<userinput moreinfo="none">    List.hd sorted   &gt;&gt;= fun first -&gt;</userinput>
<userinput moreinfo="none">    List.last sorted &gt;&gt;= fun last  -&gt;</userinput>
<userinput moreinfo="none">    Some (first,last)</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val compute_bounds : cmp:('a -&gt; 'a -&gt; int) -&gt; 'a list -&gt; ('a * 'a) option =</computeroutput>
<computeroutput moreinfo="none">  &lt;fun&gt;</computeroutput></programlisting>

      <para>This use of <literal moreinfo="none">bind</literal> isn't really
      materially better than the one we started with, and indeed, for small
      examples like this, direct matching of options is generally better than
      using <literal moreinfo="none">bind</literal>. But for large, complex
      examples with many stages of error handling, the <literal>bind</literal>
      idiom becomes clearer and easier to manage.</para>

      <para>There are other useful idioms encoded in the functions in <literal moreinfo="none">Option</literal>. One example is <literal moreinfo="none">Option.both</literal>, which takes two optional values
      and produces a new optional pair that is <literal moreinfo="none">None</literal> if either of its arguments are <literal moreinfo="none">None</literal>. Using <literal moreinfo="none">Option.both</literal>, we can make <literal moreinfo="none">compute_bounds</literal> even shorter:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/error-handling/main.topscript">OCaml utop</ulink>
      (part 14)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let compute_bounds ~cmp list =</userinput>
<userinput moreinfo="none">    let sorted = List.sort ~cmp list in</userinput>
<userinput moreinfo="none">    Option.both (List.hd sorted) (List.last sorted)</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val compute_bounds : cmp:('a -&gt; 'a -&gt; int) -&gt; 'a list -&gt; ('a * 'a) option =</computeroutput>
<computeroutput moreinfo="none">  &lt;fun&gt;</computeroutput></programlisting>

      <para>These error-handling functions are valuable because they let you
      express your error handling both explicitly and concisely. We've only
      discussed these functions in the context of the <literal moreinfo="none">Option</literal> module, but more functionality of this
      kind can be found in the <literal moreinfo="none">Result</literal> and
      <literal moreinfo="none">Or_error</literal> modules.<indexterm class="endofrange" startref="erraware"/><indexterm class="endofrange" startref="EHeraware"/></para>
    </sect2>
  </sect1>

  <sect1 id="exceptions">
    <title>Exceptions</title>

    <para>Exceptions in OCaml are not that different from exceptions in many
    other languages, like Java, C#, and Python. Exceptions are a way to
    terminate a computation and report an error, while providing a mechanism
    to catch and handle (and possibly recover from) exceptions that are
    triggered by subcomputations.<indexterm class="singular">
        <primary>exceptions</primary>

        <secondary>usefulness of</secondary>
      </indexterm><indexterm class="singular">
        <primary>error handling</primary>

        <secondary>exceptions</secondary>
      </indexterm></para>

    <para>You can trigger an exception by, for example, dividing an integer by
    zero:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/error-handling/main.topscript">OCaml utop</ulink>
    (part 15)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">3 / 0;;</userinput>
<computeroutput moreinfo="none">Exception: Division_by_zero.</computeroutput></programlisting>

    <para>And an exception can terminate a computation even if it happens
    nested somewhere deep within it:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/error-handling/main.topscript">OCaml utop</ulink>
    (part 16)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">List.map ~f:(fun x -&gt; 100 / x) [1;3;0;4];;</userinput>
<computeroutput moreinfo="none">Exception: Division_by_zero.</computeroutput></programlisting>

    <para>If we put a <literal moreinfo="none">printf</literal> in the middle
    of the computation, we can see that <literal moreinfo="none">List.map</literal> is interrupted partway through its
    execution, never getting to the end of the list:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/error-handling/main.topscript">OCaml utop</ulink>
    (part 17)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">List.map ~f:(fun x -&gt; printf "%d\n%!" x; 100 / x) [1;3;0;4];;</userinput>
<computeroutput moreinfo="none">1</computeroutput>
<computeroutput moreinfo="none">3</computeroutput>
<computeroutput moreinfo="none">0</computeroutput>
<computeroutput moreinfo="none">Exception: Division_by_zero.</computeroutput></programlisting>

    <para>In addition to built-in exceptions like <literal moreinfo="none">Divide_by_zero</literal>, OCaml lets you define your
    own:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/error-handling/main.topscript">OCaml utop</ulink>
    (part 18)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">exception Key_not_found of string;;</userinput>
<computeroutput moreinfo="none">exception Key_not_found of string</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">raise (Key_not_found "a");;</userinput>
<computeroutput moreinfo="none">Exception: Key_not_found("a").</computeroutput></programlisting>

    <para>Exceptions are ordinary values and can be manipulated just like
    other OCaml values:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/error-handling/main.topscript">OCaml utop</ulink>
    (part 19)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let exceptions = [ Not_found; Division_by_zero; Key_not_found "b" ];;</userinput>
<computeroutput moreinfo="none">val exceptions : exn list = [Not_found; Division_by_zero; Key_not_found("b")]</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">List.filter exceptions  ~f:(function</userinput>
<userinput moreinfo="none">    | Key_not_found _ | Not_found -&gt; true</userinput>
<userinput moreinfo="none">    | _ -&gt; false);;</userinput>
<computeroutput moreinfo="none">- : exn list = [Not_found; Key_not_found("b")]</computeroutput></programlisting>

    <para>Exceptions are all of the same type, <literal moreinfo="none">exn</literal>. The <literal moreinfo="none">exn</literal>
    type is something of a special case in the OCaml type system. It is
    similar to the variant types we encountered in <xref linkend="variants"/>, except that it is <emphasis>open</emphasis>,
    meaning that it's not fully defined in any one place. In particular, new
    tags (specifically, new exceptions) can be added to it by different parts
    of the program. This is in contrast to ordinary variants, which are
    defined with a closed universe of available tags. One result of this is
    that you can never have an exhaustive match on an <literal moreinfo="none">exn</literal>, since the full set of possible exceptions
    is not known.<indexterm class="singular">
        <primary>exn type</primary>
      </indexterm></para>

    <para>The following function uses the <literal moreinfo="none">Key_not_found</literal> exception we defined above to
    signal an error:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/error-handling/main.topscript">OCaml utop</ulink>
    (part 20)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let rec find_exn alist key = match alist with</userinput>
<userinput moreinfo="none">    | [] -&gt; raise (Key_not_found key)</userinput>
<userinput moreinfo="none">    | (key',data) :: tl -&gt; if key = key' then data else find_exn tl key</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val find_exn : (string * 'a) list -&gt; string -&gt; 'a = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let alist = [("a",1); ("b",2)];;</userinput>
<computeroutput moreinfo="none">val alist : (string * int) list = [("a", 1); ("b", 2)]</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">find_exn alist "a";;</userinput>
<computeroutput moreinfo="none">- : int = 1</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">find_exn alist "c";;</userinput>
<computeroutput moreinfo="none">Exception: Key_not_found("c").</computeroutput></programlisting>

    <para>Note that we named the function <literal moreinfo="none">find_exn</literal> to warn the user that the function
    routinely throws exceptions, a convention that is used heavily in
    Core.<indexterm class="singular">
        <primary>functions</primary>

        <secondary>exception warnings for</secondary>
      </indexterm><indexterm class="singular">
        <primary>find_exn function</primary>
      </indexterm></para>

    <para>In the preceding example, <literal moreinfo="none">raise</literal>
    throws the exception, thus terminating the computation. The type of raise
    is a bit surprising when you first see it:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/error-handling/main.topscript">OCaml utop</ulink>
    (part 21)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">raise;;</userinput>
<computeroutput moreinfo="none">- : exn -&gt; 'a = &lt;fun&gt;</computeroutput></programlisting>

    <para>The return type of <literal moreinfo="none">'a</literal> makes it
    look like <literal moreinfo="none">raise</literal> manufactures a value to
    return that is completely unconstrained in its type. That seems
    impossible, and it is. Really, <literal moreinfo="none">raise</literal>
    has a return type of <literal moreinfo="none">'a</literal> because it
    never returns at all. This behavior isn't restricted to functions like
    <literal moreinfo="none">raise</literal> that terminate by throwing
    exceptions. Here's another example of a function that doesn't return a
    value:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/error-handling/main.topscript">OCaml utop</ulink>
    (part 22)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let rec forever () = forever ();;</userinput>
<computeroutput moreinfo="none">val forever : unit -&gt; 'a = &lt;fun&gt;</computeroutput></programlisting>

    <para><literal moreinfo="none">forever</literal> doesn't return a value
    for a different reason: it's an infinite loop.</para>

    <para>This all matters because it means that the return type of <literal moreinfo="none">raise</literal> can be whatever it needs to be to fit into
    the context it is called in. Thus, the type system will let us throw an
    exception anywhere in a program.<indexterm class="singular">
        <primary>sexp declaration</primary>
      </indexterm><indexterm class="singular">
        <primary>exceptions</primary>

        <secondary>textual representation of</secondary>
      </indexterm></para>

    <note role="allow_break">
      <title>Declaring Exceptions Using with sexp</title>

      <para>OCaml can't always generate a useful textual representation of an
      exception. For example:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/error-handling/main.topscript">OCaml utop</ulink>
      (part 23)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">exception Wrong_date of Date.t;;</userinput>
<computeroutput moreinfo="none">exception Wrong_date of Date.t</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Wrong_date (Date.of_string "2011-02-23");;</userinput>
<computeroutput moreinfo="none">- : exn = Wrong_date(_)</computeroutput></programlisting>

      <para>But if we declare the exception using <literal moreinfo="none">with sexp</literal> (and the constituent types have sexp
      converters), we'll get something with more information:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/error-handling/main.topscript">OCaml utop</ulink>
      (part 24)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">exception Wrong_date of Date.t with sexp;;</userinput>
<computeroutput moreinfo="none">exception Wrong_date of Date.t</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Wrong_date (Date.of_string "2011-02-23");;</userinput>
<computeroutput moreinfo="none">- : exn = (//toplevel//.Wrong_date 2011-02-23)</computeroutput></programlisting>

      <para>The period in front of <literal moreinfo="none">Wrong_date</literal> is there because the representation
      generated by <literal moreinfo="none">with sexp</literal> includes the
      full module path of the module where the exception in question is
      defined. In this case, the string <literal moreinfo="none">//toplevel//</literal> is used to indicate that this was
      declared at the toplevel, rather than in a module.</para>

      <para>This is all part of the support for s-expressions provided by the
      Sexplib library and syntax extension, which is described in more detail
      in <xref linkend="data-serialization-with-s-expressions"/>.</para>
    </note>

    <sect2 id="helper-functions-for-throwing-exceptions">
      <title>Helper Functions for Throwing Exceptions</title>

      <para>OCaml and Core provide a number of helper functions to simplify
      the task of throwing exceptions. The simplest one is <literal moreinfo="none">failwith</literal>, which could be defined as
      follows:<indexterm class="singular">
          <primary>exceptions</primary>

          <secondary>helper functions for</secondary>
        </indexterm><indexterm class="singular">
          <primary>error handling</primary>

          <secondary>exception helper functions</secondary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/error-handling/main.topscript">OCaml utop</ulink>
      (part 25)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let failwith msg = raise (Failure msg);;</userinput>
<computeroutput moreinfo="none">val failwith : string -&gt; 'a = &lt;fun&gt;</computeroutput></programlisting>

      <para>There are several other useful functions for raising exceptions,
      which can be found in the API documentation for the <literal moreinfo="none">Common</literal> and <literal moreinfo="none">Exn</literal> modules in Core.</para>

      <para>Another important way of throwing an exception is the <literal moreinfo="none">assert</literal> directive. <literal moreinfo="none">assert</literal> is used for situations where a
      violation of the condition in question indicates a bug. Consider the
      following piece of code for zipping together two lists:<indexterm class="singular">
          <primary>assert directive</primary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/error-handling/main.topscript">OCaml utop</ulink>
      (part 26)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let merge_lists xs ys ~f =</userinput>
<userinput moreinfo="none">    if List.length xs &lt;&gt; List.length ys then None</userinput>
<userinput moreinfo="none">    else</userinput>
<userinput moreinfo="none">      let rec loop xs ys =</userinput>
<userinput moreinfo="none">        match xs,ys with</userinput>
<userinput moreinfo="none">        | [],[] -&gt; []</userinput>
<userinput moreinfo="none">        | x::xs, y::ys -&gt; f x y :: loop xs ys</userinput>
<userinput moreinfo="none">        | _ -&gt; assert false</userinput>
<userinput moreinfo="none">      in</userinput>
<userinput moreinfo="none">      Some (loop xs ys)</userinput>
<userinput moreinfo="none">   ;;</userinput>
<computeroutput moreinfo="none">val merge_lists : 'a list -&gt; 'b list -&gt; f:('a -&gt; 'b -&gt; 'c) -&gt; 'c list option =</computeroutput>
<computeroutput moreinfo="none">  &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">merge_lists [1;2;3] [-1;1;2] ~f:(+);;</userinput>
<computeroutput moreinfo="none">- : int list option = Some [0; 3; 5]</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">merge_lists [1;2;3] [-1;1] ~f:(+);;</userinput>
<computeroutput moreinfo="none">- : int list option = None</computeroutput></programlisting>

      <para>Here we use <literal moreinfo="none">assert false</literal>, which
      means that the <literal>assert</literal> is guaranteed to trigger. In
      general, one can put an arbitrary condition in the assertion.</para>

      <para>In this case, the <literal>assert</literal> can never be triggered
      because we have a check that makes sure that the lists are of the same
      length before we call <literal moreinfo="none">loop</literal>. If we
      change the code so that we drop this test, then we can trigger the
      <literal>assert</literal>:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/error-handling/main.topscript">OCaml utop</ulink>
      (part 27)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let merge_lists xs ys ~f =</userinput>
<userinput moreinfo="none">    let rec loop xs ys =</userinput>
<userinput moreinfo="none">      match xs,ys with</userinput>
<userinput moreinfo="none">      | [],[] -&gt; []</userinput>
<userinput moreinfo="none">      | x::xs, y::ys -&gt; f x y :: loop xs ys</userinput>
<userinput moreinfo="none">      | _ -&gt; assert false</userinput>
<userinput moreinfo="none">    in</userinput>
<userinput moreinfo="none">    loop xs ys</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val merge_lists : 'a list -&gt; 'b list -&gt; f:('a -&gt; 'b -&gt; 'c) -&gt; 'c list = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">merge_lists [1;2;3] [-1] ~f:(+);;</userinput>
<computeroutput moreinfo="none">Exception: (Assert_failure //toplevel// 5 13).</computeroutput></programlisting>

      <para>This shows what's special about <literal moreinfo="none">assert</literal>: it captures the line number and
      character offset of the source location from which the assertion was
      made.</para>
    </sect2>

    <sect2 id="exception-handlers">
      <title>Exception Handlers</title>

      <para>So far, we've only seen exceptions fully terminate the execution
      of a computation. But often, we want a program to be able to respond to
      and recover from an exception. This is achieved through the use of
      <emphasis>exception handlers</emphasis>.<indexterm class="singular">
          <primary>exceptions</primary>

          <secondary>exception handlers</secondary>
        </indexterm><indexterm class="singular">
          <primary>error handling</primary>

          <secondary>exception handlers</secondary>
        </indexterm></para>

      <para>In OCaml, an exception handler is declared using a <literal moreinfo="none">try</literal>/<literal moreinfo="none">with</literal>
      statement. Here's the basic syntax.</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/error-handling/try_with.syntax">Syntax</ulink></para>

      <programlisting format="linespecific" language="ocaml">try <emphasis>&lt;expr&gt;</emphasis> with
| <emphasis>&lt;pat1&gt;</emphasis> -&gt; <emphasis>&lt;expr1&gt;</emphasis>
| <emphasis>&lt;pat2&gt;</emphasis> -&gt; <emphasis>&lt;expr2&gt;</emphasis>
...</programlisting>

      <para>A <literal moreinfo="none">try/with</literal> clause first evaluates its body,
            <emphasis><literal moreinfo="none">expr</literal></emphasis>. If no exception is thrown,
        then the result of evaluating the body is what the entire <literal moreinfo="none">try/with</literal> clause evaluates to.</para>

      <para>But if the evaluation of the body throws an exception, then the
      exception will be fed to the pattern-match statements following the
      <literal moreinfo="none">with</literal>. If the exception matches a
      pattern, then we consider the exception caught, and the <literal moreinfo="none">try/with</literal> clause evaluates to the expression on
      the righthand side of the matching pattern.</para>

      <para>Otherwise, the original exception continues up the stack of
      function calls, to be handled by the next outer exception handler. If
      the exception is never caught, it terminates the program.</para>
    </sect2>

    <sect2 id="cleaning-up-in-the-presence-of-exceptions">
      <title>Cleaning Up in the Presence of Exceptions</title>

      <para>One headache with exceptions is that they can terminate your
      execution at unexpected places, leaving your program in an awkward
      state. Consider the following function for loading a file full of
      reminders, formatted as s-expressions:<indexterm class="singular">
          <primary>exceptions</primary>

          <secondary>exception clean up</secondary>
        </indexterm><indexterm class="singular">
          <primary>error handling</primary>

          <secondary>exception clean up</secondary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/error-handling/main.topscript">OCaml utop</ulink>
      (part 28)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let reminders_of_sexp =</userinput>
<userinput moreinfo="none">    &lt;:of_sexp&lt;(Time.t * string) list&gt;&gt;</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val reminders_of_sexp : Sexp.t -&gt; (Time.t * string) list = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let load_reminders filename =</userinput>
<userinput moreinfo="none">    let inc = In_channel.create filename in</userinput>
<userinput moreinfo="none">    let reminders = reminders_of_sexp (Sexp.input_sexp inc) in</userinput>
<userinput moreinfo="none">    In_channel.close inc;</userinput>
<userinput moreinfo="none">    reminders</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val load_reminders : string -&gt; (Time.t * string) list = &lt;fun&gt;</computeroutput></programlisting>

      <para>The problem with this code is that the function that loads the
      s-expression and parses it into a list of <literal moreinfo="none">Time.t</literal>/<literal moreinfo="none">string</literal> pairs might throw an exception if the
      file in question is malformed. Unfortunately, that means that the
      <literal moreinfo="none">In_channel.t</literal> that was opened will
      never be closed, leading to a file-descriptor leak.</para>

      <para>We can fix this using Core's <literal moreinfo="none">protect</literal> function, which takes two arguments: a
      thunk <literal moreinfo="none">f</literal>, which is the main body of
      the computation to be run; and a thunk <literal moreinfo="none">finally</literal>, which is to be called when <literal moreinfo="none">f</literal> exits, whether it exits normally or with an
      exception. This is similar to the <literal moreinfo="none">try/finally</literal> construct available in many
      programming languages, but it is implemented in a library, rather than
      being a built-in primitive. Here's how it could be used to fix <literal moreinfo="none">load_reminders</literal>:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/error-handling/main.topscript">OCaml utop</ulink>
      (part 29)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let load_reminders filename =</userinput>
<userinput moreinfo="none">    let inc = In_channel.create filename in</userinput>
<userinput moreinfo="none">    protect ~f:(fun () -&gt; reminders_of_sexp (Sexp.input_sexp inc))</userinput>
<userinput moreinfo="none">      ~finally:(fun () -&gt; In_channel.close inc)</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val load_reminders : string -&gt; (Time.t * string) list = &lt;fun&gt;</computeroutput></programlisting>

      <para>This is a common enough problem that <literal moreinfo="none">In_channel</literal> has a function called <literal moreinfo="none">with_file</literal> that automates this pattern:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/error-handling/main.topscript">OCaml utop</ulink>
      (part 30)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let reminders_of_sexp filename =</userinput>
<userinput moreinfo="none">    In_channel.with_file filename ~f:(fun inc -&gt;</userinput>
<userinput moreinfo="none">      reminders_of_sexp (Sexp.input_sexp inc))</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val reminders_of_sexp : string -&gt; (Time.t * string) list = &lt;fun&gt;</computeroutput></programlisting>

      <para><literal moreinfo="none">In_channel.with_file</literal> is built
      on top of <literal moreinfo="none">protect</literal> so that it can
      clean up after itself in the presence of exceptions.</para>
    </sect2>

    <sect2 id="catching-specific-exceptions">
      <title>Catching Specific Exceptions</title>

      <para>OCaml's exception-handling system allows you to tune your
      error-recovery logic to the particular error that was thrown. For
      example, <literal moreinfo="none">List.find_exn</literal> throws
      <literal moreinfo="none">Not_found</literal> when the element in
      question can't be found. Let's look at an example of how you could take
      advantage of this. In particular, consider the following
      function:<indexterm class="singular">
          <primary>exceptions</primary>

          <secondary>catching specific</secondary>
        </indexterm><indexterm class="singular">
          <primary>error handling</primary>

          <secondary>exception detection</secondary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/error-handling/main.topscript">OCaml utop</ulink>
      (part 31)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let lookup_weight ~compute_weight alist key =</userinput>
<userinput moreinfo="none">    try</userinput>
<userinput moreinfo="none">      let data = List.Assoc.find_exn alist key in</userinput>
<userinput moreinfo="none">      compute_weight data</userinput>
<userinput moreinfo="none">    with</userinput>
<userinput moreinfo="none">      Not_found -&gt; 0. ;;</userinput>
<computeroutput moreinfo="none">val lookup_weight :</computeroutput>
<computeroutput moreinfo="none">  compute_weight:('a -&gt; float) -&gt; ('b, 'a) List.Assoc.t -&gt; 'b -&gt; float =</computeroutput>
<computeroutput moreinfo="none">  &lt;fun&gt;</computeroutput></programlisting>

      <para>As you can see from the type, <literal moreinfo="none">lookup_weight</literal> takes an association list, a key
      for looking up a corresponding value in that list, and a function for
      computing a floating-point weight from the looked-up value. If no value
      is found, then a weight of <literal moreinfo="none">0.</literal> should
      be returned.</para>

      <para>The use of exceptions in this code, however, presents some
      problems. In particular, what happens if <literal moreinfo="none">compute_weight</literal> throws an exception? Ideally,
      <literal moreinfo="none">lookup_weight</literal> should propagate that
      exception on, but if the exception happens to be <literal moreinfo="none">Not_found</literal>, then that's not what will
      happen:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/error-handling/main.topscript">OCaml utop</ulink>
      (part 32)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">lookup_weight ~compute_weight:(fun _ -&gt; raise Not_found)</userinput>
<userinput moreinfo="none">    ["a",3; "b",4] "a" ;;</userinput>
<computeroutput moreinfo="none">- : float = 0.</computeroutput></programlisting>

      <para>This kind of problem is hard to detect in advance because the type
      system doesn't tell you what exceptions a given function might throw.
      For this reason, it's generally better to avoid relying on the identity
      of the exception to determine the nature of a failure. A better approach
      is to narrow the scope of the exception handler, so that when it fires
      it's very clear what part of the code failed:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/error-handling/main.topscript">OCaml utop</ulink>
      (part 33)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let lookup_weight ~compute_weight alist key =</userinput>
<userinput moreinfo="none">    match</userinput>
<userinput moreinfo="none">      try Some (List.Assoc.find_exn alist key)</userinput>
<userinput moreinfo="none">      with _ -&gt; None</userinput>
<userinput moreinfo="none">    with</userinput>
<userinput moreinfo="none">    | None -&gt; 0.</userinput>
<userinput moreinfo="none">    | Some data -&gt; compute_weight data ;;</userinput>
<computeroutput moreinfo="none">val lookup_weight :</computeroutput>
<computeroutput moreinfo="none">  compute_weight:('a -&gt; float) -&gt; ('b, 'a) List.Assoc.t -&gt; 'b -&gt; float =</computeroutput>
<computeroutput moreinfo="none">  &lt;fun&gt;</computeroutput></programlisting>

      <para>At this point, it makes sense to simply use the
      nonexception-throwing function, <literal moreinfo="none">List.Assoc.find</literal>, instead:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/error-handling/main.topscript">OCaml utop</ulink>
      (part 34)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let lookup_weight ~compute_weight alist key =</userinput>
<userinput moreinfo="none">    match List.Assoc.find alist key with</userinput>
<userinput moreinfo="none">    | None -&gt; 0.</userinput>
<userinput moreinfo="none">    | Some data -&gt; compute_weight data ;;</userinput>
<computeroutput moreinfo="none">val lookup_weight :</computeroutput>
<computeroutput moreinfo="none">  compute_weight:('a -&gt; float) -&gt; ('b, 'a) List.Assoc.t -&gt; 'b -&gt; float =</computeroutput>
<computeroutput moreinfo="none">  &lt;fun&gt;</computeroutput></programlisting>
    </sect2>

    <sect2 id="backtraces">
      <title>Backtraces</title>

      <para>A big part of the value of exceptions is that they provide useful
      debugging information in the form of a stack backtrace. Consider the
      following simple program<indexterm class="singular">
          <primary>debugging</primary>

          <secondary>stack backtraces</secondary>
        </indexterm><indexterm class="singular">
          <primary>stack backtraces</primary>
        </indexterm><indexterm class="singular">
          <primary>backtraces</primary>
        </indexterm>:<indexterm class="singular">
          <primary>exceptions</primary>

          <secondary>stack backtraces for</secondary>
        </indexterm><indexterm class="singular">
          <primary>error handling</primary>

          <secondary>exception backtracing</secondary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/error-handling/blow_up.ml">OCaml</ulink></para>

      <programlisting format="linespecific" language="ocaml">open Core.Std
exception Empty_list

let list_max = function
  | [] -&gt; raise Empty_list
  | hd :: tl -&gt; List.fold tl ~init:hd ~f:(Int.max)

let () =
  printf "%d\n" (list_max [1;2;3]);
  printf "%d\n" (list_max [])</programlisting>

      <para>If we build and run this program, we'll get a stack backtrace that
      will provide some information about where the error occurred and the
      stack of function calls that were in place at the time of the
      error:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/error-handling/build_blow_up.out">Terminal</ulink></para>

      <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">corebuild blow_up.byte</userinput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">./blow_up.byte</userinput>
<computeroutput moreinfo="none">3</computeroutput>
<computeroutput moreinfo="none">Fatal error: exception Blow_up.Empty_list</computeroutput>
<computeroutput moreinfo="none">Raised at file "blow_up.ml", line 5, characters 16-26</computeroutput>
<computeroutput moreinfo="none">Called from file "blow_up.ml", line 10, characters 17-28</computeroutput></programlisting>

      <para>You can also capture a backtrace within your program by calling
      <literal moreinfo="none">Exn.backtrace</literal>, which returns the
      backtrace of the most recently thrown exception. This is useful for
      reporting detailed information on errors that did not cause your program
      to fail.<indexterm class="singular">
          <primary>Exn module</primary>

          <secondary>Exn.backtrace</secondary>
        </indexterm></para>

      <para>This works well if you have backtraces enabled, but that isn't
      always the case. In fact, by default, OCaml has backtraces turned off,
      and even if you have them turned on at runtime, you can't get backtraces
      unless you have compiled with debugging symbols. Core reverses the
      default, so if you're linking in Core, you will have backtraces enabled
      by default.</para>

      <para>Even using Core and compiling with debugging symbols, you can turn
      backtraces off by setting the <literal moreinfo="none">OCAMLRUNPARAM</literal> environment variable to be
      empty:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/error-handling/build_blow_up_notrace.out">Terminal</ulink></para>

      <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">corebuild blow_up.byte</userinput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">OCAMLRUNPARAM= ./blow_up.byte</userinput>
<computeroutput moreinfo="none">3</computeroutput>
<computeroutput moreinfo="none">Fatal error: exception Blow_up.Empty_list</computeroutput></programlisting>

      <para>The resulting error message is considerably less informative. You
      can also turn backtraces off in your code by calling <literal moreinfo="none">Backtrace.Exn.set_recording false</literal>.<indexterm class="singular">
          <primary>Exn module</primary>

          <secondary>Backtrace.Exn.set_recording false</secondary>
        </indexterm></para>

      <para>There is a legitimate reasons to run without backtraces: speed.
      OCaml's exceptions are fairly fast, but they're even faster still if you
      disable backtraces. Here's a simple benchmark that shows the effect,
      using the <literal moreinfo="none">core_bench</literal> package:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/error-handling/exn_cost.ml">OCaml</ulink></para>

      <programlisting format="linespecific" language="ocaml">open Core.Std
open Core_bench.Std

let simple_computation () =
  List.range 0 10
  |&gt; List.fold ~init:0 ~f:(fun sum x -&gt; sum + x * x)
  |&gt; ignore

let simple_with_handler () =
  try simple_computation () with Exit -&gt; ()

let end_with_exn () =
  try
    simple_computation ();
    raise Exit
  with Exit -&gt; ()

let () =
  [ Bench.Test.create ~name:"simple computation"
      (fun () -&gt; simple_computation ());
    Bench.Test.create ~name:"simple computation w/handler"
      (fun () -&gt; simple_with_handler ());
    Bench.Test.create ~name:"end with exn"
      (fun () -&gt; end_with_exn ());
  ]
  |&gt; Bench.make_command
  |&gt; Command.run</programlisting>

      <para>We're testing three cases here: a simple computation with no
      exceptions; the same computation with an exception handler but no thrown
      exceptions; and finally the same computation where we use the exception
      to do the control flow back to the caller.</para>

      <para>If we run this with stacktraces on, the benchmark results look
      like this:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/error-handling/run_exn_cost.out">Terminal</ulink></para>

      <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">corebuild -pkg core_bench exn_cost.native</userinput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">./exn_cost.native -ascii cycles</userinput>
<computeroutput moreinfo="none">Estimated testing time 30s (change using -quota SECS).</computeroutput>
<computeroutput moreinfo="none">                                                                </computeroutput>
<computeroutput moreinfo="none">  Name                           Cycles   Time (ns)   % of max  </computeroutput>
<computeroutput moreinfo="none"> ------------------------------ -------- ----------- ---------- </computeroutput>
<computeroutput moreinfo="none">  simple computation                279         117      76.40  </computeroutput>
<computeroutput moreinfo="none">  simple computation w/handler      308         129      84.36  </computeroutput>
<computeroutput moreinfo="none">  end with exn                      366         153     100.00  </computeroutput>
<computeroutput moreinfo="none">                                                                </computeroutput></programlisting>

      <para>Here, we see that we lose something like 30 cycles to adding an exception handler, and
        60 more to actually throwing and catching an exception. If we turn backtraces off, then the
        results look like this:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/error-handling/run_exn_cost_notrace.out">Terminal</ulink></para>

      <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">OCAMLRUNPARAM= ./exn_cost.native -ascii cycles</userinput>
<computeroutput moreinfo="none">Estimated testing time 30s (change using -quota SECS).</computeroutput>
<computeroutput moreinfo="none">                                                                </computeroutput>
<computeroutput moreinfo="none">  Name                           Cycles   Time (ns)   % of max  </computeroutput>
<computeroutput moreinfo="none"> ------------------------------ -------- ----------- ---------- </computeroutput>
<computeroutput moreinfo="none">  simple computation                279         116      83.50  </computeroutput>
<computeroutput moreinfo="none">  simple computation w/handler      308         128      92.09  </computeroutput>
<computeroutput moreinfo="none">  end with exn                      334         140     100.00  </computeroutput>
<computeroutput moreinfo="none">                                                                </computeroutput></programlisting>

      <para>Here, the handler costs about the same, but the exception itself costs only 25, as
        opposed to 60 additional cycles. All told, this should only matter if you're using
        exceptions routinely as part of your flow control, which is in most cases a stylistic
        mistake anyway.</para>
    </sect2>

    <sect2 id="from-exceptions-to-error-aware-types-and-back-again">
      <title>From Exceptions to Error-Aware Types and Back Again</title>

      <para>Both exceptions and error-aware types are necessary parts of
      programming in OCaml. As such, you often need to move between these two
      worlds. Happily, Core comes with some useful helper functions to help
      you do just that. For example, given a piece of code that can throw an
      exception, you can capture that exception into an option as
      follows:<indexterm class="singular">
          <primary>exceptions</primary>

          <secondary sortas="error">and error-aware types</secondary>
        </indexterm><indexterm class="singular">
          <primary>error-aware return types</primary>
        </indexterm><indexterm class="singular">
          <primary>error handling</primary>

          <secondary>combining exceptions and error-aware types</secondary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/error-handling/main.topscript">OCaml utop</ulink>
      (part 35)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let find alist key =</userinput>
<userinput moreinfo="none">    Option.try_with (fun () -&gt; find_exn alist key) ;;</userinput>
<computeroutput moreinfo="none">val find : (string * 'a) list -&gt; string -&gt; 'a option = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">find ["a",1; "b",2] "c";;</userinput>
<computeroutput moreinfo="none">- : int option = None</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">find ["a",1; "b",2] "b";;</userinput>
<computeroutput moreinfo="none">- : int option = Some 2</computeroutput></programlisting>

      <para>And <literal moreinfo="none">Result</literal> and <literal moreinfo="none">Or_error</literal> have similar <literal moreinfo="none">try_with</literal> functions. So, we could write:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/error-handling/main.topscript">OCaml utop</ulink>
      (part 36)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let find alist key =</userinput>
<userinput moreinfo="none">    Or_error.try_with (fun () -&gt; find_exn alist key) ;;</userinput>
<computeroutput moreinfo="none">val find : (string * 'a) list -&gt; string -&gt; 'a Or_error.t = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">find ["a",1; "b",2] "c";;</userinput>
<computeroutput moreinfo="none">- : int Or_error.t = Core_kernel.Result.Error ("Key_not_found(\"c\")")</computeroutput></programlisting>

      <para>And then we can reraise that exception:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/error-handling/main.topscript">OCaml utop</ulink>
      (part 37)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">Or_error.ok_exn (find ["a",1; "b",2] "b");;</userinput>
<computeroutput moreinfo="none">- : int = 2</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Or_error.ok_exn (find ["a",1; "b",2] "c");;</userinput>
<computeroutput moreinfo="none">Exception: ("Key_not_found(\"c\")").</computeroutput></programlisting>
    </sect2>
  </sect1>

  <sect1 id="choosing-an-error-handling-strategy">
    <title>Choosing an Error-Handling Strategy</title>

    <para>Given that OCaml supports both exceptions and error-aware return
    types, how do you choose between them? The key is to think about the
    trade-off between concision and explicitness.<indexterm class="singular">
        <primary>error handling</primary>

        <secondary>strategy choice</secondary>

        <seealso>errors</seealso>
      </indexterm></para>

    <para>Exceptions are more concise because they allow you to defer the job of error handling to
      some larger scope, and because they don't clutter up your types. But this concision comes at a
      cost: exceptions are all too easy to ignore. Error-aware return types, on the other hand, are
      fully manifest in your type definitions, making the errors that your code might generate
      explicit and impossible to ignore.<indexterm class="singular">
        <primary>exceptions</primary>
        <secondary>benefits and drawbacks of</secondary>
      </indexterm></para>

    <para>The right trade-off depends on your application. If you're writing a
    rough-and-ready program where getting it done quickly is key and failure
    is not that expensive, then using exceptions extensively may be the way to
    go. If, on the other hand, you're writing production software whose
    failure is costly, then you should probably lean in the direction of using
    error-aware return types.</para>

    <para>To be clear, it doesn't make sense to avoid exceptions entirely. The
    maxim of "use exceptions for exceptional conditions" applies. If an error
    occurs sufficiently rarely, then throwing an exception is often the right
    behavior.</para>

    <para>Also, for errors that are omnipresent, error-aware return types may
    be overkill. A good example is out-of-memory errors, which can occur
    anywhere, and so you'd need to use error-aware return types everywhere to
    capture those. Having every operation marked as one that might fail is no
    more explicit than having none of them marked.</para>

    <para>In short, for errors that are a foreseeable and ordinary part of the
    execution of your production code and that are not omnipresent,
    error-aware return types are typically the right solution.</para>
  </sect1>
</chapter>

  <chapter id="imperative-programming-1">
  <title>Imperative Programming</title>

  <para>Most of the code shown so far in this book, and indeed, most OCaml
  code in general, is <emphasis>pure</emphasis>. Pure code works without
  mutating the program's internal state, performing I/O, reading the clock, or
  in any other way interacting with changeable parts of the world. Thus, a
  pure function behaves like a mathematical function, always returning the
  same results when given the same inputs, and never affecting the world
  except insofar as it returns the value of its computation.
  <emphasis>Imperative</emphasis> code, on the other hand, operates by side
  effects that modify a program's internal state or interact with the outside
  world. An imperative function has a new effect, and potentially returns
  different results, every time it's called.<indexterm class="singular">
      <primary>imperative programming</primary>

      <secondary>benefits of</secondary>
    </indexterm><indexterm class="singular">
      <primary>pure code</primary>
    </indexterm><indexterm class="singular">
      <primary>programming</primary>

      <secondary>immutable vs. imperative</secondary>
    </indexterm><indexterm class="startofrange" id="PROGimper">
      <primary>programming</primary>

      <secondary>imperative programming</secondary>
    </indexterm></para>

  <para>Pure code is the default in OCaml, and for good reason—it's generally
  easier to reason about, less error prone and more composable. But imperative
  code is of fundamental importance to any practical programming language,
  because real-world tasks require that you interact with the outside world,
  which is by its nature imperative. Imperative programming can also be
  important for performance. While pure code is quite efficient in OCaml,
  there are many algorithms that can only be implemented efficiently using
  imperative techniques.</para>

  <para>OCaml offers a happy compromise here, making it easy and natural to
  program in a pure style, but also providing great support for imperative
  programming. This chapter will walk you through OCaml's imperative features,
  and help you use them to their fullest.</para>

  <sect1 id="example-imperative-dictionaries">
    <title>Example: Imperative Dictionaries</title>

    <para>We'll start with the implementation of a simple imperative
    dictionary, i.e., a mutable mapping from keys to values. This is really
    for illustration purposes; both Core and the standard library provide
    imperative dictionaries, and for most real-world tasks, you should use one
    of those implementations. There's more advice on using Core's
    implementation in particular in <xref linkend="maps-and-hash-tables"/>.<indexterm class="startofrange" id="DICTimper">
        <primary>dictionaries, imperative</primary>
      </indexterm><indexterm class="singular">
        <primary>Core standard library</primary>

        <secondary>imperative dictionaries in</secondary>
      </indexterm><indexterm class="startofrange" id="IPimpdict">
        <primary>imperative programming</primary>

        <secondary>imperative dictionaries</secondary>
      </indexterm></para>

    <para>The dictionary we'll describe now, like those in Core and the
    standard library, will be implemented as a hash table. In particular,
    we'll use an <emphasis>open hashing</emphasis> scheme, where the hash
    table will be an array of buckets, each bucket containing a list of
    key/value pairs that have been hashed into that bucket.<indexterm class="singular">
        <primary>open hashing</primary>
      </indexterm></para>

    <para>Here's the interface we'll match, provided as an <literal moreinfo="none">mli</literal>. The type <literal moreinfo="none">('a, 'b)
    t</literal> represents a dictionary with keys of type <literal moreinfo="none">'a</literal> and data of type <literal moreinfo="none">'b</literal>:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/dictionary.mli">OCaml</ulink>
    (part 1)</para>

    <programlisting format="linespecific" language="ocaml">(* file: dictionary.mli *)
open Core.Std

type ('a, 'b) t

val create : unit -&gt; ('a, 'b) t
val length : ('a, 'b) t -&gt; int
val add    : ('a, 'b) t -&gt; key:'a -&gt; data:'b -&gt; unit
val find   : ('a, 'b) t -&gt; 'a -&gt; 'b option
val iter   : ('a, 'b) t -&gt; f:(key:'a -&gt; data:'b -&gt; unit) -&gt; unit
val remove : ('a, 'b) t -&gt; 'a -&gt; unit</programlisting>

    <para>The <literal moreinfo="none">mli</literal> also includes a
    collection of helper functions whose purpose and behavior should be
    largely inferrable from their names and type signatures. Notice that a
    number of the functions, in particular, ones like <literal moreinfo="none">add</literal> that modify the dictionary, return
    <literal>unit</literal>. This is typical of functions that act by side
    effect.</para>

    <para>We'll now walk through the implementation (contained in the
    corresponding <literal moreinfo="none">ml</literal> file) piece by piece,
    explaining different imperative constructs as they come up.</para>

    <para>Our first step is to define the type of a dictionary as a record
    with two fields:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/dictionary.ml">OCaml</ulink>
    (part 1)</para>

    <programlisting format="linespecific" language="ocaml">(* file: dictionary.ml *)
open Core.Std

type ('a, 'b) t = { mutable length: int;
                    buckets: ('a * 'b) list array;
                  }</programlisting>

    <para>The first field, <literal moreinfo="none">length</literal>, is
    declared as mutable. In OCaml, records are immutable by default, but
    individual fields are mutable when marked as such. The second field,
    <literal moreinfo="none">buckets</literal>, is immutable but contains an
    array, which is itself a mutable data structure.<indexterm class="singular">
        <primary>fields</primary>

        <secondary>mutability of</secondary>
      </indexterm></para>

    <para>Now we'll start putting together the basic functions for
    manipulating a dictionary:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/dictionary.ml">OCaml</ulink>
    (part 2)</para>

    <programlisting format="linespecific" language="ocaml">let num_buckets = 17

let hash_bucket key = (Hashtbl.hash key) mod num_buckets

let create () =
  { length = 0;
    buckets = Array.create ~len:num_buckets [];
  }

let length t = t.length

let find t key =
  List.find_map t.buckets.(hash_bucket key)
    ~f:(fun (key',data) -&gt; if key' = key then Some data else None)</programlisting>

    <para>Note that <literal moreinfo="none">num_buckets</literal> is a
    constant, which means our bucket array is of fixed length. A practical
    implementation would need to be able to grow the array as the number of
    elements in the dictionary increases, but we'll omit this to simplify the
    presentation.</para>

    <para>The function <literal moreinfo="none">hash_bucket</literal> is used
    throughout the rest of the module to choose the position in the array that
    a given key should be stored at. It is implemented on top of <literal moreinfo="none">Hashtbl.hash</literal>, which is a hash function provided
    by the OCaml runtime that can be applied to values of any type. Thus, its
    own type is polymorphic: <literal moreinfo="none">'a -&gt;
    int</literal>.</para>

    <para>The other functions defined above are fairly straightforward:</para>

    <variablelist>
      <varlistentry>
        <term><literal moreinfo="none">create</literal></term>

        <listitem>
          <para>Creates an empty dictionary.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal moreinfo="none">length</literal></term>

        <listitem>
          <para>Grabs the length from the corresponding record field, thus
          returning the number of entries stored in the dictionary.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal moreinfo="none">find</literal></term>

        <listitem>
          <para>Looks for a matching key in the table and returns the
          corresponding value if found as an option.</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <para>Another important piece of imperative syntax shows up in <literal moreinfo="none">find</literal>: we write <literal moreinfo="none">array.(index)</literal> to grab a value from an array.
    <literal moreinfo="none">find</literal> also uses <literal moreinfo="none">List.find_map</literal>, which you can see the type of by
    typing it into the toplevel:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/examples.topscript">OCaml utop</ulink>
    (part 1)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">List.find_map;;</userinput>
<computeroutput moreinfo="none">- : 'a list -&gt; f:('a -&gt; 'b option) -&gt; 'b option = &lt;fun&gt;</computeroutput></programlisting>

    <para><literal moreinfo="none">List.find_map</literal> iterates over the
    elements of the list, calling <literal moreinfo="none">f</literal> on each
    one until a <literal moreinfo="none">Some</literal> is returned by
    <literal moreinfo="none">f</literal>, at which point that value is
    returned. If <literal moreinfo="none">f</literal> returns <literal moreinfo="none">None</literal> on all values, then <literal moreinfo="none">None</literal> is returned.</para>

    <para>Now let's look at the implementation of <literal moreinfo="none">iter</literal>:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/dictionary.ml">OCaml</ulink>
    (part 3)</para>

    <programlisting format="linespecific" language="ocaml">let iter t ~f =
  for i = 0 to Array.length t.buckets - 1 do
    List.iter t.buckets.(i) ~f:(fun (key, data) -&gt; f ~key ~data)
  done</programlisting>

    <para><literal moreinfo="none">iter</literal> is designed to walk over all
    the entries in the dictionary. In particular, <literal moreinfo="none">iter t ~f</literal> will call <literal moreinfo="none">f</literal> for each key/value pair in dictionary <literal moreinfo="none">t</literal>. Note that <literal moreinfo="none">f</literal> must return <literal moreinfo="none">unit</literal>, since it is expected to work by side
    effect rather than by returning a value, and the overall <literal moreinfo="none">iter</literal> function returns <literal moreinfo="none">unit</literal> as well.</para>

    <para>The code for <literal moreinfo="none">iter</literal> uses two forms of iteration: a
        <literal moreinfo="none">for</literal> loop to walk over the array of buckets; and within
      that loop a call to <literal moreinfo="none">List.iter</literal> to walk over the values in a
      given bucket. We could have done the outer loop with a recursive function instead of a
        <literal moreinfo="none">for</literal> loop, but <literal moreinfo="none">for</literal>
      loops are syntactically convenient, and are more familiar and idiomatic in imperative
      contexts.</para>

    <para>The following code is for adding and removing mappings from the
    dictionary:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/dictionary.ml">OCaml</ulink>
    (part 4)</para>

    <programlisting format="linespecific" language="ocaml">let bucket_has_key t i key =
  List.exists t.buckets.(i) ~f:(fun (key',_) -&gt; key' = key)

let add t ~key ~data =
  let i = hash_bucket key in
  let replace = bucket_has_key t i key in
  let filtered_bucket =
    if replace then
      List.filter t.buckets.(i) ~f:(fun (key',_) -&gt; key' &lt;&gt; key)
    else
      t.buckets.(i)
  in
  t.buckets.(i) &lt;- (key, data) :: filtered_bucket;
  if not replace then t.length &lt;- t.length + 1

let remove t key =
  let i = hash_bucket key in
  if bucket_has_key t i key then (
    let filtered_bucket =
      List.filter t.buckets.(i) ~f:(fun (key',_) -&gt; key' &lt;&gt; key)
    in
    t.buckets.(i) &lt;- filtered_bucket;
    t.length &lt;- t.length - 1
  )</programlisting>

    <para>This preceding code is made more complicated by the fact that we
    need to detect whether we are overwriting or removing an existing binding,
    so we can decide whether <literal moreinfo="none">t.length</literal> needs
    to be changed. The helper function <literal moreinfo="none">bucket_has_key</literal> is used for this purpose.</para>

    <para>Another piece of syntax shows up in both <literal moreinfo="none">add</literal> and <literal moreinfo="none">remove</literal>: the use of the <literal moreinfo="none">&lt;-</literal> operator to update elements of an array
    (<literal moreinfo="none">array.(i) &lt;- expr</literal>) and for updating
    a record field (<literal moreinfo="none">record.field &lt;-
    expression</literal>).</para>

    <para>We also use <literal moreinfo="none">;</literal>, the sequencing
    operator, to express a sequence of imperative actions. We could have done
    the same using <literal>let</literal> bindings:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/dictionary2.ml">OCaml</ulink>
    (part 1)</para>

    <programlisting format="linespecific" language="ocaml">let () = t.buckets.(i) &lt;- (key, data) :: filtered_bucket in
  if not replace then t.length &lt;- t.length + 1</programlisting>

    <para>but <literal moreinfo="none">;</literal> is more concise and
    idiomatic. More generally,</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/semicolon.syntax">Syntax</ulink></para>

    <programlisting format="linespecific">&lt;expr1&gt;;
&lt;expr2&gt;;
...
&lt;exprN&gt;</programlisting>

    <para>is equivalent to</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/let-unit.syntax">Syntax</ulink></para>

    <programlisting format="linespecific">let () = &lt;expr1&gt; in
let () = &lt;expr2&gt; in
...
&lt;exprN&gt;</programlisting>

    <para>When a sequence expression <literal moreinfo="none">expr1;
    expr2</literal> is evaluated, <literal moreinfo="none">expr1</literal> is
    evaluated first, and then <literal moreinfo="none">expr2</literal>. The
    expression <literal moreinfo="none">expr1</literal> should have type
    <literal moreinfo="none">unit</literal> (though this is a warning rather
    than a hard restriction. The <literal moreinfo="none">-strict-sequence</literal> compiler flag makes this a hard
    restriction, which is generally a good idea), and the value of <literal moreinfo="none">expr2</literal> is returned as the value of the entire
    sequence. For example, the sequence <literal moreinfo="none">print_string
    "hello world"; 1 + 2</literal> first prints the string <literal moreinfo="none">"hello world"</literal>, then returns the integer <literal moreinfo="none">3</literal>.</para>

    <para>Note also that we do all of the side-effecting operations at the
    very end of each function. This is good practice because it minimizes the
    chance that such operations will be interrupted with an exception, leaving
    the data structure in an inconsistent state.<indexterm class="endofrange" startref="DICTimper"/><indexterm class="endofrange" startref="IPimpdict"/></para>
  </sect1>

  <sect1 id="primitive-mutable-data">
    <title>Primitive Mutable Data</title>

    <para>Now that we've looked at a complete example, let's take a more
    systematic look at imperative programming in OCaml. We encountered two
    different forms of mutable data above: records with mutable fields and
    arrays. We'll now discuss these in more detail, along with the other
    primitive forms of mutable data that are available in OCaml.<indexterm class="singular">
        <primary>array-like data</primary>
      </indexterm><indexterm class="singular">
        <primary>data structures</primary>

        <secondary>primitive mutable data</secondary>
      </indexterm><indexterm class="singular">
        <primary>mutable data</primary>
      </indexterm><indexterm class="singular">
        <primary>primitive mutable data</primary>

        <secondary>array-like data</secondary>
      </indexterm><indexterm class="singular">
        <primary>imperative programming</primary>

        <secondary>primitive mutable data</secondary>
      </indexterm></para>

    <sect2 id="array-like-data">
      <title>Array-Like Data</title>

      <para>OCaml supports a number of array-like data structures; i.e.,
      mutable integer-indexed containers that provide constant-time access to
      their elements. We'll discuss several of them in this section.</para>

      <sect3 id="ordinary-arrays">
        <title>Ordinary arrays</title>

        <para>The <literal moreinfo="none">array</literal> type is used for
        general-purpose polymorphic arrays. The <literal moreinfo="none">Array</literal> module has a variety of utility
        functions for interacting with arrays, including a number of mutating
        operations. These include <literal moreinfo="none">Array.set</literal>, for setting an individual
        element, and <literal moreinfo="none">Array.blit</literal>, for
        efficiently copying values from one range of indices to
        another.<indexterm class="singular">
            <primary>values</primary>

            <secondary>copying with Array.blit</secondary>
          </indexterm><indexterm class="singular">
            <primary>elements</primary>

            <secondary>setting with Array.set</secondary>
          </indexterm><indexterm class="singular">
            <primary>Array module</primary>

            <secondary>Array.blit</secondary>
          </indexterm><indexterm class="singular">
            <primary>Array module</primary>

            <secondary>Array.set</secondary>
          </indexterm></para>

        <para>Arrays also come with special syntax for retrieving an element
        from an array:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/array-get.syntax">Syntax</ulink></para>

        <programlisting format="linespecific" language="ocaml"><emphasis>&lt;array_expr&gt;</emphasis>.(<emphasis>&lt;index_expr&gt;</emphasis>)</programlisting>

        <para>and for setting an element in an array:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/array-set.syntax">Syntax</ulink></para>

        <programlisting format="linespecific" language="ocaml"><emphasis>&lt;array_expr&gt;</emphasis>.(<emphasis>&lt;index_expr&gt;</emphasis>) &lt;- <emphasis>&lt;value_expr&gt;</emphasis></programlisting>

        <para>Out-of-bounds accesses for arrays (and indeed for all the
        array-like data structures) will lead to an exception being
        thrown.</para>

        <para>Array literals are written using <literal moreinfo="none">[|</literal> and <literal moreinfo="none">|]</literal>
        as delimiters. Thus, <literal moreinfo="none">[| 1; 2; 3 |]</literal>
        is a literal integer array.</para>
      </sect3>

      <sect3 id="strings">
        <title>Strings</title>

        <para>Strings are essentially byte arrays which are often used for
        textual data. The main advantage of using a <literal moreinfo="none">string</literal> in place of a <literal moreinfo="none">Char.t array</literal> (a <literal moreinfo="none">Char.t</literal> is an 8-bit character) is that the
        former is considerably more space-efficient; an array uses one word—8
        bytes on a 64-bit machine—to store a single entry, whereas strings use
        1 byte per character.<indexterm class="singular">
            <primary>byte arrays</primary>
          </indexterm><indexterm class="singular">
            <primary>strings</primary>

            <secondary>vs. Char.t arrays</secondary>
          </indexterm></para>

        <para>Strings also come with their own syntax for getting and setting
        values:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/string.syntax">Syntax</ulink></para>

        <programlisting format="linespecific" language="ocaml"><emphasis>&lt;string_expr&gt;</emphasis>.[<emphasis>&lt;index_expr&gt;</emphasis>]
          <emphasis>&lt;string_expr&gt;</emphasis>.[<emphasis>&lt;index_expr&gt;</emphasis>] &lt;- <emphasis>&lt;char_expr&gt;</emphasis></programlisting>

        <para>And string literals are bounded by quotes. There's also a module
        <literal moreinfo="none">String</literal> where you'll find useful
        functions for working with strings.</para>
      </sect3>

      <sect3 id="bigarrays">
        <title>Bigarrays</title>

        <para>A <literal moreinfo="none">Bigarray.t</literal> is a handle to a
        block of memory stored outside of the OCaml heap. These are mostly
        useful for interacting with C or Fortran libraries, and are discussed
        in <xref linkend="memory-representation-of-values"/>. Bigarrays too
        have their own getting and setting syntax:<indexterm class="singular">
            <primary>bigarrays</primary>
          </indexterm></para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/bigarray.syntax">Syntax</ulink></para>

        <programlisting format="linespecific" language="ocaml"><emphasis>&lt;bigarray_expr&gt;</emphasis>.{<emphasis>&lt;index_expr&gt;</emphasis>}
         <emphasis> &lt;bigarray_expr&gt;</emphasis>.{<emphasis>&lt;index_expr&gt;</emphasis>} &lt;- <emphasis>&lt;value_expr&gt;</emphasis></programlisting>
      </sect3>
    </sect2>

    <sect2 id="mutable-record-and-object-fields-and-ref-cells">
      <title>Mutable Record and Object Fields and Ref Cells</title>

      <para>As we've seen, records are immutable by default, but individual
      record fields can be declared as mutable. These mutable fields can be
      set using the <literal moreinfo="none">&lt;-</literal> operator, i.e.,
      <literal moreinfo="none">record.field &lt;- expr</literal>.<indexterm class="singular">
          <primary>fields</primary>

          <secondary>mutability of</secondary>
        </indexterm></para>

      <para>As we'll see in <xref linkend="objects"/>, fields of an object
      can similarly be declared as mutable, and can then be modified in much
      the same way as record fields.<indexterm class="singular">
          <primary>primitive mutable data</primary>

          <secondary>record/object fields and ref cells</secondary>
        </indexterm></para>

      <sect3 id="ref-cells">
        <title>Ref cells</title>

        <para>Variables in OCaml are never mutable—they can refer to mutable
        data, but what the variable points to can't be changed. Sometimes,
        though, you want to do exactly what you would do with a mutable
        variable in another language: define a single, mutable value. In OCaml
        this is typically achieved using a <literal moreinfo="none">ref</literal>, which is essentially a container with a
        single mutable polymorphic field.<indexterm class="singular">
            <primary>ref cells</primary>
          </indexterm></para>

        <para>The definition for the <literal>ref</literal> type is as
        follows:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/ref.topscript">OCaml utop</ulink>
        (part 1)</para>

        <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">type 'a ref = { mutable contents : 'a };;</userinput>
<computeroutput moreinfo="none">type 'a ref = { mutable contents : 'a; }</computeroutput></programlisting>

        <para>The standard library defines the following operators for working
        with <literal>ref</literal>s.</para>

        <variablelist>
          <varlistentry>
            <term><literal moreinfo="none">ref expr</literal></term>

            <listitem>
              <para>Constructs a reference cell containing the value defined
              by the expression <literal moreinfo="none">expr</literal>.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal moreinfo="none">!refcell</literal></term>

            <listitem>
              <para>Returns the contents of the reference cell.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal moreinfo="none">refcell := expr</literal></term>

            <listitem>
              <para>Replaces the contents of the reference cell.</para>
            </listitem>
          </varlistentry>
        </variablelist>

        <para>You can see these in action:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/ref.topscript">OCaml utop</ulink>
        (part 3)</para>

        <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let x = ref 1;;</userinput>
<computeroutput moreinfo="none">val x : int ref = {contents = 1}</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">  !x;;</userinput>
<computeroutput moreinfo="none">- : int = 1</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">  x := !x + 1;;</userinput>
<computeroutput moreinfo="none">- : unit = ()</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">  !x;;</userinput>
<computeroutput moreinfo="none">- : int = 2</computeroutput></programlisting>

        <para>The preceding are just ordinary OCaml functions, which could be
        defined as follows:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/ref.topscript">OCaml utop</ulink>
        (part 2)</para>

        <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let ref x = { contents = x };;</userinput>
<computeroutput moreinfo="none">val ref : 'a -&gt; 'a ref = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">  let (!) r = r.contents;;</userinput>
<computeroutput moreinfo="none">val ( ! ) : 'a ref -&gt; 'a = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">  let (:=) r x = r.contents &lt;- x;;</userinput>
<computeroutput moreinfo="none">val ( := ) : 'a ref -&gt; 'a -&gt; unit = &lt;fun&gt;</computeroutput></programlisting>
      </sect3>
    </sect2>

    <sect2 id="foreign-functions">
      <title>Foreign Functions</title>

      <para>Another source of imperative operations in OCaml is resources that come from interfacing
        with external libraries through OCaml's foreign function interface (FFI). The FFI opens
        OCaml up to imperative constructs that are exported by system calls or other external
        libraries. Many of these come built in, like access to the <literal moreinfo="none">write</literal> system call or to the <literal moreinfo="none">clock</literal>, while
        others come from user libraries, like LAPACK bindings. OCaml's FFI is discussed in more
        detail in <xref linkend="foreign-function-interface"/>.<indexterm class="singular">
          <primary>libraries</primary>
          <secondary>interfacing with external</secondary>
        </indexterm><indexterm class="singular">
          <primary>external libraries</primary>
          <secondary>interfacing with</secondary>
        </indexterm><indexterm class="singular">
          <primary>LAPACK bindings</primary>
        </indexterm><indexterm class="singular">
          <primary>foreign function interface (FFI)</primary>
          <secondary>imperative operations and</secondary>
        </indexterm><indexterm class="singular">
          <primary>primitive mutable data</primary>
          <secondary>foreign functions</secondary>
        </indexterm></para>
    </sect2>
  </sect1>

  <sect1 id="for-and-while-loops-1">
    <title>for and while Loops</title>

    <para>OCaml provides support for traditional imperative looping
    constructs, in particular, <literal moreinfo="none">for</literal> and
    <literal moreinfo="none">while</literal> loops. Neither of these
    constructs is strictly necessary, since they can be simulated with
    recursive functions. Nonetheless, explicit <literal moreinfo="none">for</literal> and <literal moreinfo="none">while</literal>
    loops are both more concise and more idiomatic when programming
    imperatively.<indexterm class="singular">
        <primary>looping constructs</primary>
      </indexterm><indexterm class="singular">
        <primary>while loops</primary>
      </indexterm><indexterm class="singular">
        <primary>for loops</primary>
      </indexterm></para>

    <para>The <literal moreinfo="none">for</literal> loop is the simpler of
    the two. Indeed, we've already seen the <literal moreinfo="none">for</literal> loop in action—the <literal moreinfo="none">iter</literal> function in <literal moreinfo="none">Dictionary</literal> is built using it. Here's a simple
    example of <literal moreinfo="none">for</literal>:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/for.topscript">OCaml utop</ulink>
    (part 1)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">for i = 0 to 3 do printf "i = %d\n" i done;;</userinput>
<computeroutput moreinfo="none">i = 0</computeroutput>
<computeroutput moreinfo="none">i = 1</computeroutput>
<computeroutput moreinfo="none">i = 2</computeroutput>
<computeroutput moreinfo="none">i = 3</computeroutput>
<computeroutput moreinfo="none">- : unit = ()</computeroutput></programlisting>

    <para>As you can see, the upper and lower bounds are inclusive. We can
    also use <literal moreinfo="none">downto</literal> to iterate in the other
    direction:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/for.topscript">OCaml utop</ulink>
    (part 2)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">for i = 3 downto 0 do printf "i = %d\n" i done;;</userinput>
<computeroutput moreinfo="none">i = 3</computeroutput>
<computeroutput moreinfo="none">i = 2</computeroutput>
<computeroutput moreinfo="none">i = 1</computeroutput>
<computeroutput moreinfo="none">i = 0</computeroutput>
<computeroutput moreinfo="none">- : unit = ()</computeroutput></programlisting>

    <para>Note that the loop variable of a <literal moreinfo="none">for</literal> loop, <literal moreinfo="none">i</literal>
    in this case, is immutable in the scope of the loop and is also local to
    the loop, i.e., it can't be referenced outside of the loop.</para>

    <para>OCaml also supports <literal moreinfo="none">while</literal> loops,
    which include a condition and a body. The loop first evaluates the
    condition, and then, if it evaluates to true, evaluates the body and
    starts the loop again. Here's a simple example of a function for reversing
    an array in place:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/for.topscript">OCaml utop</ulink>
    (part 3)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let rev_inplace ar =</userinput>
<userinput moreinfo="none">    let i = ref 0 in</userinput>
<userinput moreinfo="none">    let j = ref (Array.length ar - 1) in</userinput>
<userinput moreinfo="none">    (* terminate when the upper and lower indices meet *)</userinput>
<userinput moreinfo="none">    while !i &lt; !j do</userinput>
<userinput moreinfo="none">      (* swap the two elements *)</userinput>
<userinput moreinfo="none">      let tmp = ar.(!i) in</userinput>
<userinput moreinfo="none">      ar.(!i) &lt;- ar.(!j);</userinput>
<userinput moreinfo="none">      ar.(!j) &lt;- tmp;</userinput>
<userinput moreinfo="none">      (* bump the indices *)</userinput>
<userinput moreinfo="none">      incr i;</userinput>
<userinput moreinfo="none">      decr j</userinput>
<userinput moreinfo="none">    done</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val rev_inplace : 'a array -&gt; unit = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let nums = [|1;2;3;4;5|];;</userinput>
<computeroutput moreinfo="none">val nums : int array = [|1; 2; 3; 4; 5|]</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">rev_inplace nums;;</userinput>
<computeroutput moreinfo="none">- : unit = ()</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">nums;;</userinput>
<computeroutput moreinfo="none">- : int array = [|5; 4; 3; 2; 1|]</computeroutput></programlisting>

    <para>In the preceding example, we used <literal moreinfo="none">incr</literal> and <literal moreinfo="none">decr</literal>, which are built-in functions for
    incrementing and decrementing an <literal moreinfo="none">int
    ref</literal> by one, respectively.</para>
  </sect1>

  <sect1 id="example-doubly-linked-lists">
    <title>Example: Doubly Linked Lists</title>

    <para>Another common imperative data structure is the doubly linked list.
    Doubly linked lists can be traversed in both directions, and elements can
    be added and removed from the list in constant time. Core defines a doubly
    linked list (the module is called <literal moreinfo="none">Doubly_linked</literal>), but we'll define our own linked
    list library as an illustration.<indexterm class="singular">
        <primary>lists</primary>

        <secondary>doubly-linked lists</secondary>
      </indexterm><indexterm class="singular">
        <primary>doubly-linked lists</primary>
      </indexterm><indexterm class="startofrange" id="IPdoublink">
        <primary>imperative programming</primary>

        <secondary>doubly-linked lists</secondary>
      </indexterm></para>

    <para>Here's the <literal moreinfo="none">mli</literal> of the module
    we'll build:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/dlist.mli">OCaml</ulink></para>

    <programlisting format="linespecific" language="ocaml">(* file: dlist.mli *)
open Core.Std

type 'a t
type 'a element

(** Basic list operations  *)
val create   : unit -&gt; 'a t
val is_empty : 'a t -&gt; bool

(** Navigation using [element]s *)
val first : 'a t -&gt; 'a element option
val next  : 'a element -&gt; 'a element option
val prev  : 'a element -&gt; 'a element option
val value : 'a element -&gt; 'a

(** Whole-data-structure iteration *)
val iter    : 'a t -&gt; f:('a -&gt; unit) -&gt; unit
val find_el : 'a t -&gt; f:('a -&gt; bool) -&gt; 'a element option

(** Mutation *)
val insert_first : 'a t -&gt; 'a -&gt; 'a element
val insert_after : 'a element -&gt; 'a -&gt; 'a element
val remove : 'a t -&gt; 'a element -&gt; unit</programlisting>

    <para>Note that there are two types defined here: <literal moreinfo="none">'a t</literal>, the type of a list; and <literal moreinfo="none">'a element</literal>, the type of an element. Elements act
    as pointers to the interior of a list and allow us to navigate the list
    and give us a point at which to apply mutating operations.</para>

    <para>Now let's look at the implementation. We'll start by defining
    <literal moreinfo="none">'a element</literal> and <literal moreinfo="none">'a t</literal>:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/dlist.ml">OCaml</ulink>
    (part 1)</para>

    <programlisting format="linespecific" language="ocaml">(* file: dlist.ml *)
open Core.Std

type 'a element =
  { value : 'a;
    mutable next : 'a element option;
    mutable prev : 'a element option
  }

type 'a t = 'a element option ref</programlisting>

    <para>An <literal moreinfo="none">'a element</literal> is a record
    containing the value to be stored in that node as well as optional (and
    mutable) fields pointing to the previous and next elements. At the
    beginning of the list, the <literal moreinfo="none">prev</literal> field
    is <literal moreinfo="none">None</literal>, and at the end of the list,
    the <literal moreinfo="none">next</literal> field is <literal moreinfo="none">None</literal>.</para>

    <para>The type of the list itself, <literal moreinfo="none">'a
    t</literal>, is a mutable reference to an optional <literal moreinfo="none">element</literal>. This reference is <literal moreinfo="none">None</literal> if the list is empty, and <literal moreinfo="none">Some</literal> otherwise.</para>

    <para>Now we can define a few basic functions that operate on lists and
    elements:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/dlist.ml">OCaml</ulink>
    (part 2)</para>

    <programlisting format="linespecific" language="ocaml">let create () = ref None
let is_empty t = !t = None

let value elt = elt.value

let first t = !t
let next elt = elt.next
let prev elt = elt.prev</programlisting>

    <para>These all follow relatively straightforwardly from our type
    definitions.</para>

    <note>
      <title>Cyclic Data Structures</title>

      <para>Doubly linked lists are a cyclic data structure, meaning that it
      is possible to follow a nontrivial sequence of pointers that closes in
      on itself. In general, building cyclic data structures requires the use
      of side effects. This is done by constructing the data elements first,
      and then adding cycles using assignment afterward.<indexterm class="singular">
          <primary>let rec</primary>
        </indexterm><indexterm class="singular">
          <primary>data structures</primary>

          <secondary>cyclic</secondary>
        </indexterm><indexterm class="singular">
          <primary>cyclic data structures</primary>
        </indexterm></para>

      <para>There is an exception to this, though: you can construct
      fixed-size cyclic data structures using <literal moreinfo="none">let
      rec</literal>:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/examples.topscript">OCaml utop</ulink>
      (part 2)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let rec endless_loop = 1 :: 2 :: 3 :: endless_loop;;</userinput>
<computeroutput moreinfo="none">val endless_loop : int list =</computeroutput>
<computeroutput moreinfo="none">  [1; 2; 3; 1; 2; 3; 1; 2; 3;
   1; 2; 3; 1; 2; 3; 1; 2; 3;
   1; 2; 3; 1; 2; 3; 1; 2; 3;</computeroutput>
<computeroutput moreinfo="none">   ...]</computeroutput></programlisting>

      <para>This approach is quite limited, however. General-purpose cyclic
      data structures require mutation.</para>
    </note>

    <sect2 id="modifying-the-list">
      <title>Modifying the List</title>

      <para>Now, we'll start considering operations that mutate the list,
      starting with <literal moreinfo="none">insert_first</literal>, which
      inserts an element at the front of the list:<indexterm class="singular">
          <primary>elements</primary>

          <secondary>inserting in lists</secondary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/dlist.ml">OCaml</ulink>
      (part 3)</para>

      <programlisting format="linespecific" language="ocaml">let insert_first t value =
  let new_elt = { prev = None; next = !t; value } in
  begin match !t with
  | Some old_first -&gt; old_first.prev &lt;- Some new_elt
  | None -&gt; ()
  end;
  t := Some new_elt;
  new_elt</programlisting>

      <para><literal moreinfo="none">insert_first</literal> first defines a
      new element <literal moreinfo="none">new_elt</literal>, and then links
      it into the list, finally setting the list itself to point to <literal moreinfo="none">new_elt</literal>. Note that the precedence of a
      <literal moreinfo="none">match</literal> expression is very low, so to
      separate it from the following assignment (<literal moreinfo="none">t :=
      Some new_elt</literal>), we surround the match with <literal moreinfo="none">begin ... end</literal>. We could have used parentheses
      for the same purpose. Without some kind of bracketing, the final
      assignment would incorrectly become part of the <literal moreinfo="none">None</literal> case.<indexterm class="singular">
          <primary>elements</primary>

          <secondary>defining new</secondary>
        </indexterm></para>

      <para>We can use <literal moreinfo="none">insert_after</literal> to
      insert elements later in the list. <literal moreinfo="none">insert_after</literal> takes as arguments both an
      <literal moreinfo="none">element</literal> after which to insert the new
      node and a value to insert:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/dlist.ml">OCaml</ulink>
      (part 4)</para>

      <programlisting format="linespecific" language="ocaml">let insert_after elt value =
  let new_elt = { value; prev = Some elt; next = elt.next } in
  begin match elt.next with
  | Some old_next -&gt; old_next.prev &lt;- Some new_elt
  | None -&gt; ()
  end;
  elt.next &lt;- Some new_elt;
  new_elt</programlisting>

      <para>Finally, we need a <literal moreinfo="none">remove</literal>
      function:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/dlist.ml">OCaml</ulink>
      (part 5)</para>

      <programlisting format="linespecific" language="ocaml">let remove t elt =
  let { prev; next; _ } = elt in
  begin match prev with
  | Some prev -&gt; prev.next &lt;- next
  | None -&gt; t := next
  end;
  begin match next with
  | Some next -&gt; next.prev &lt;- prev;
  | None -&gt; ()
  end;
  elt.prev &lt;- None;
  elt.next &lt;- None</programlisting>

      <para>Note that the preceding code is careful to change the <literal moreinfo="none">prev</literal> pointer of the following element and the
      <literal moreinfo="none">next</literal> pointer of the previous element,
      if they exist. If there's no previous element, then the list pointer
      itself is updated. In any case, the next and previous pointers of the
      element itself are set to <literal moreinfo="none">None</literal>.</para>

      <para>These functions are more fragile than they may seem. In
      particular, misuse of the interface may lead to corrupted data. For
      example, double-removing an element will cause the main list reference
      to be set to <literal moreinfo="none">None</literal>, thus emptying the
      list. Similar problems arise from removing an element from a list it
      doesn't belong to.</para>

      <para>This shouldn't be a big surprise. Complex imperative data
      structures can be quite tricky, considerably trickier than their pure
      equivalents. The issues described previously can be dealt with by more
      careful error detection, and such error correction is taken care of in
      modules like Core's <literal moreinfo="none">Doubly_linked</literal>.
      You should use imperative data structures from a well-designed library
      when you can. And when you can't, you should make sure to put great care
      into your error handling.<indexterm class="singular">
          <primary>imperative programming</primary>

          <secondary>drawbacks of</secondary>
        </indexterm><indexterm class="singular">
          <primary>Doubly-linked module</primary>
        </indexterm><indexterm class="singular">
          <primary>error handling</primary>

          <secondary sortas="imperative">and imperative data
          structures</secondary>
        </indexterm></para>
    </sect2>

    <sect2 id="iteration-functions">
      <title>Iteration Functions</title>

      <para>When defining containers like lists, dictionaries, and trees,
      you'll typically want to define a set of iteration functions like
      <literal moreinfo="none">iter</literal>, <literal moreinfo="none">map</literal>, and <literal moreinfo="none">fold</literal>, which let you concisely express common
      iteration patterns.<indexterm class="singular">
          <primary>functions</primary>

          <secondary>iteration functions</secondary>
        </indexterm><indexterm class="singular">
          <primary>iteration functions</primary>
        </indexterm></para>

      <para><literal moreinfo="none">Dlist</literal> has two such iterators:
      <literal moreinfo="none">iter</literal>, the goal of which is to call a
      <literal moreinfo="none">unit</literal>-producing function on every
      element of the list, in order; and <literal moreinfo="none">find_el</literal>, which runs a provided test function
      on each values stored in the list, returning the first <literal moreinfo="none">element</literal> that passes the test. Both <literal moreinfo="none">iter</literal> and <literal moreinfo="none">find_el</literal> are implemented using simple recursive
      loops that use <literal moreinfo="none">next</literal> to walk from
      element to element and <literal moreinfo="none">value</literal> to
      extract the element from a given node:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/dlist.ml">OCaml</ulink>
      (part 6)</para>

      <programlisting format="linespecific" language="ocaml">let iter t ~f =
  let rec loop = function
    | None -&gt; ()
    | Some el -&gt; f (value el); loop (next el)
  in
  loop !t

let find_el t ~f =
  let rec loop = function
    | None -&gt; None
    | Some elt -&gt;
      if f (value elt) then Some elt
      else loop (next elt)
  in
  loop !t</programlisting>

      <para>This completes our implementation, but there's still considerably
      more work to be done to make a really usable doubly linked list. As
      mentioned earlier, you're probably better off using something like
      Core's <literal moreinfo="none">Doubly_linked</literal> module that has
      a more complete interface and has more of the tricky corner cases worked
      out. Nonetheless, this example should serve to demonstrate some of the
      techniques you can use to build nontrivial imperative data structure in
      OCaml, as well as some of the pitfalls.<indexterm class="endofrange" startref="IPdoublink"/></para>
    </sect2>
  </sect1>

  <sect1 id="laziness-and-other-benign-effects">
    <title>Laziness and Other Benign Effects</title>

    <para>There are many instances where you basically want to program in a
    pure style, but you want to make limited use of side effects to improve
    the performance of your code. Such side effects are sometimes called
    <emphasis>benign effects</emphasis>, and they are a useful way of
    leveraging OCaml's imperative features while still maintaining most of the
    benefits of pure programming.<indexterm class="singular">
        <primary>lazy keyword</primary>
      </indexterm><indexterm class="singular">
        <primary>side effects</primary>
      </indexterm><indexterm class="singular">
        <primary>laziness</primary>
      </indexterm><indexterm class="singular">
        <primary>benign effects</primary>

        <secondary>laziness</secondary>
      </indexterm><indexterm class="singular">
        <primary>imperative programming</primary>

        <secondary>benign effects and</secondary>
      </indexterm></para>

    <para>One of the simplest benign effects is <emphasis>laziness</emphasis>.
    A lazy value is one that is not computed until it is actually needed. In
    OCaml, lazy values are created using the <literal moreinfo="none">lazy</literal> keyword, which can be used to convert any
    expression of type <literal moreinfo="none">s</literal> into a lazy value
    of type <literal moreinfo="none">s Lazy.t</literal>. The evaluation of
    that expression is delayed until forced with <literal moreinfo="none">Lazy.force</literal>:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/lazy.topscript">OCaml utop</ulink>
    (part 1)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let v = lazy (print_string "performing lazy computation\n"; sqrt 16.);;</userinput>
<computeroutput moreinfo="none">val v : float lazy_t = &lt;lazy&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Lazy.force v;;</userinput>
<computeroutput moreinfo="none">performing lazy computation</computeroutput>
<computeroutput moreinfo="none">- : float = 4.</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Lazy.force v;;</userinput>
<computeroutput moreinfo="none">- : float = 4.</computeroutput></programlisting>

    <para>You can see from the <literal>print</literal> statement that the
    actual computation was performed only once, and only after <literal moreinfo="none">force</literal> had been called.</para>

    <para>To better understand how laziness works, let's walk through the
    implementation of our own lazy type. We'll start by declaring types to
    represent a lazy value:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/lazy.topscript">OCaml utop</ulink>
    (part 2)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">type 'a lazy_state =</userinput>
<userinput moreinfo="none">    | Delayed of (unit -&gt; 'a)</userinput>
<userinput moreinfo="none">    | Value of 'a</userinput>
<userinput moreinfo="none">    | Exn of exn</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">type 'a lazy_state = Delayed of (unit -&gt; 'a) | Value of 'a | Exn of exn</computeroutput></programlisting>

    <para>A <literal moreinfo="none">lazy_state</literal> represents the
    possible states of a lazy value. A lazy value is <literal moreinfo="none">Delayed</literal> before it has been run, where <literal moreinfo="none">Delayed</literal> holds a function for computing the value
    in question. A lazy value is in the <literal moreinfo="none">Value</literal> state when it has been forced and the
    computation ended normally. The <literal moreinfo="none">Exn</literal>
    case is for when the lazy value has been forced, but the computation ended
    with an exception. A lazy value is simply a <literal moreinfo="none">ref</literal> containing a <literal moreinfo="none">lazy_state</literal>, where the <literal moreinfo="none">ref</literal> makes it possible to change from being in
    the <literal moreinfo="none">Delayed</literal> state to being in the
    <literal moreinfo="none">Value</literal> or <literal moreinfo="none">Exn</literal> states.</para>

    <para>We can create a lazy value from a thunk, i.e., a function that takes
    a unit argument. Wrapping an expression in a thunk is another way to
    suspend the computation of an expression:<indexterm class="singular">
        <primary>thunks</primary>
      </indexterm></para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/lazy.topscript">OCaml utop</ulink>
    (part 3)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let create_lazy f = ref (Delayed f);;</userinput>
<computeroutput moreinfo="none">val create_lazy : (unit -&gt; 'a) -&gt; 'a lazy_state ref = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let v = create_lazy</userinput>
<userinput moreinfo="none">    (fun () -&gt; print_string "performing lazy computation\n"; sqrt 16.);;</userinput>
<computeroutput moreinfo="none">val v : float lazy_state ref = {contents = Delayed &lt;fun&gt;}</computeroutput></programlisting>

    <para>Now we just need a way to force a lazy value. The following function
    does just that:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/lazy.topscript">OCaml utop</ulink>
    (part 4)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let force v =</userinput>
<userinput moreinfo="none">    match !v with</userinput>
<userinput moreinfo="none">    | Value x -&gt; x</userinput>
<userinput moreinfo="none">    | Exn e -&gt; raise e</userinput>
<userinput moreinfo="none">    | Delayed f -&gt;</userinput>
<userinput moreinfo="none">      try</userinput>
<userinput moreinfo="none">        let x = f () in</userinput>
<userinput moreinfo="none">        v := Value x;</userinput>
<userinput moreinfo="none">        x</userinput>
<userinput moreinfo="none">      with exn -&gt;</userinput>
<userinput moreinfo="none">        v := Exn exn;</userinput>
<userinput moreinfo="none">        raise exn</userinput>
<userinput moreinfo="none">     ;;</userinput>
<computeroutput moreinfo="none">val force : 'a lazy_state ref -&gt; 'a = &lt;fun&gt;</computeroutput></programlisting>

    <para>Which we can use in the same way we used <literal moreinfo="none">Lazy.force</literal>:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/lazy.topscript">OCaml utop</ulink>
    (part 5)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">force v;;</userinput>
<computeroutput moreinfo="none">performing lazy computation</computeroutput>
<computeroutput moreinfo="none">- : float = 4.</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">force v;;</userinput>
<computeroutput moreinfo="none">- : float = 4.</computeroutput></programlisting>

    <para>The main user-visible difference between our implementation of
    laziness and the built-in version is syntax. Rather than writing <literal moreinfo="none">create_lazy (fun () -&gt; sqrt 16.)</literal>, we can
    (with the built-in <literal moreinfo="none">lazy</literal>) just write
    <literal moreinfo="none">lazy (sqrt 16.)</literal>.</para>

    <sect2 id="memoization-and-dynamic-programming">
      <title>Memoization and Dynamic Programming</title>

      <para>Another benign effect is <emphasis>memoization</emphasis>. A
      memoized function remembers the result of previous invocations of the
      function so that they can be returned without further computation when
      the same arguments are presented again.<indexterm class="singular">
          <primary>memoization</primary>

          <secondary>function of</secondary>
        </indexterm><indexterm class="startofrange" id="BEmem">
          <primary>benign effects</primary>

          <secondary>memoization</secondary>
        </indexterm></para>

      <para>Here's a function that takes as an argument an arbitrary
      single-argument function and returns a memoized version of that
      function. Here we'll use Core's <literal moreinfo="none">Hashtbl</literal> module, rather than our toy <literal moreinfo="none">Dictionary</literal>:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/memo.topscript">OCaml utop</ulink>
      (part 1)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let memoize f =</userinput>
<userinput moreinfo="none">    let table = Hashtbl.Poly.create () in</userinput>
<userinput moreinfo="none">    (fun x -&gt;</userinput>
<userinput moreinfo="none">      match Hashtbl.find table x with</userinput>
<userinput moreinfo="none">      | Some y -&gt; y</userinput>
<userinput moreinfo="none">      | None -&gt;</userinput>
<userinput moreinfo="none">        let y = f x in</userinput>
<userinput moreinfo="none">        Hashtbl.add_exn table ~key:x ~data:y;</userinput>
<userinput moreinfo="none">        y</userinput>
<userinput moreinfo="none">    );;</userinput>
<computeroutput moreinfo="none">val memoize : ('a -&gt; 'b) -&gt; 'a -&gt; 'b = &lt;fun&gt;</computeroutput></programlisting>

      <para>The preceding code is a bit tricky. <literal moreinfo="none">memoize</literal> takes as its argument a function
      <literal moreinfo="none">f</literal> and then allocates a hash table
      (called <literal moreinfo="none">table</literal>) and returns a new
      function as the memoized version of <literal moreinfo="none">f</literal>. When called, this new function looks in
      <literal moreinfo="none">table</literal> first, and if it fails to find
      a value, calls <literal moreinfo="none">f</literal> and stashes the
      result in <literal moreinfo="none">table</literal>. Note that <literal moreinfo="none">table</literal> doesn't go out of scope as long as the
      function returned by <literal moreinfo="none">memoize</literal> is in
      scope.<indexterm class="singular">
          <primary>memoization</primary>

          <secondary>benefits and drawbacks of</secondary>
        </indexterm></para>

      <para>Memoization can be useful whenever you have a function that is
      expensive to recompute and you don't mind caching old values
      indefinitely. One important caution: a memoized function by its nature
      leaks memory. As long as you hold on to the memoized function, you're
      holding every result it has returned thus far.</para>

      <para>Memoization is also useful for efficiently implementing some recursive algorithms. One
        good example is the algorithm for computing the <emphasis>edit distance</emphasis> (also
        called the Levenshtein distance) between two strings. The edit distance is the number of
        single-character changes (including letter switches, insertions, and deletions) required to
          <phrase role="keep-together">convert</phrase> one string to the other. This kind of
        distance metric can be useful for a variety of approximate string-matching problems, like
          spellcheckers.<indexterm class="singular">
          <primary>string matching</primary>
        </indexterm><indexterm class="singular">
          <primary>Levenshtein distance</primary>
        </indexterm><indexterm class="singular">
          <primary>edit distance</primary>
        </indexterm></para>

      <para>Consider the following code for computing the edit distance.
      Understanding the algorithm isn't important here, but you should pay
      attention to the structure of the recursive calls:<indexterm class="singular">
          <primary>memoization</primary>

          <secondary>example of</secondary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/memo.topscript">OCaml utop</ulink>
      (part 2)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let rec edit_distance s t =</userinput>
<userinput moreinfo="none">    match String.length s, String.length t with</userinput>
<userinput moreinfo="none">    | (0,x) | (x,0) -&gt; x</userinput>
<userinput moreinfo="none">    | (len_s,len_t) -&gt;</userinput>
<userinput moreinfo="none">      let s' = String.drop_suffix s 1 in</userinput>
<userinput moreinfo="none">      let t' = String.drop_suffix t 1 in</userinput>
<userinput moreinfo="none">      let cost_to_drop_both =</userinput>
<userinput moreinfo="none">        if s.[len_s - 1] = t.[len_t - 1] then 0 else 1</userinput>
<userinput moreinfo="none">      in</userinput>
<userinput moreinfo="none">      List.reduce_exn ~f:Int.min</userinput>
<userinput moreinfo="none">        [ edit_distance s' t  + 1</userinput>
<userinput moreinfo="none">        ; edit_distance s  t' + 1</userinput>
<userinput moreinfo="none">        ; edit_distance s' t' + cost_to_drop_both</userinput>
<userinput moreinfo="none">        ]</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val edit_distance : string -&gt; string -&gt; int = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">edit_distance "OCaml" "ocaml";;</userinput>
<computeroutput moreinfo="none">- : int = 2</computeroutput></programlisting>

      <para>The thing to note is that if you call <literal moreinfo="none">edit_distance "OCaml" "ocaml"</literal>, then that will
      in turn dispatch the following calls:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/edit_distance.ascii">Diagram</ulink></para>

      <informalfigure>
        <mediaobject>
          <imageobject role="web">
            <imagedata fileref="images/rwoc_0801.png" format="PNG"/>
          </imageobject>
        </mediaobject>
      </informalfigure>

      <para>And these calls will in turn dispatch other calls:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/edit_distance2.ascii">Diagram</ulink></para>

      <informalfigure>
        <mediaobject>
          <imageobject role="web">
            <imagedata fileref="images/rwoc_0802.png" format="PNG"/>
          </imageobject>
        </mediaobject>
      </informalfigure>

      <para>As you can see, some of these calls are repeats. For example,
      there are two different calls to <literal moreinfo="none">edit_distance
      "OCam" "oca"</literal>. The number of redundant calls grows
      exponentially with the size of the strings, meaning that our
      implementation of <literal moreinfo="none">edit_distance</literal> is
      brutally slow for large strings. We can see this by writing a small
      timing function:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/memo.topscript">OCaml utop</ulink>
      (part 3)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let time f =</userinput>
<userinput moreinfo="none">    let start = Time.now () in</userinput>
<userinput moreinfo="none">    let x = f () in</userinput>
<userinput moreinfo="none">    let stop = Time.now () in</userinput>
<userinput moreinfo="none">    printf "Time: %s\n" (Time.Span.to_string (Time.diff stop start));</userinput>
<userinput moreinfo="none">    x ;;</userinput>
<computeroutput moreinfo="none">val time : (unit -&gt; 'a) -&gt; 'a = &lt;fun&gt;</computeroutput></programlisting>

      <para>And now we can use this to try out some examples:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/memo.topscript">OCaml utop</ulink>
      (part 4)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">time (fun () -&gt; edit_distance "OCaml" "ocaml");;</userinput>
<computeroutput moreinfo="none">Time: 1.40405ms</computeroutput>
<computeroutput moreinfo="none">- : int = 2</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">time (fun () -&gt; edit_distance "OCaml 4.01" "ocaml 4.01");;</userinput>
<computeroutput moreinfo="none">Time: 6.79065s</computeroutput>
<computeroutput moreinfo="none">- : int = 2</computeroutput></programlisting>

      <para>Just those few extra characters made it thousands of times
      slower!</para>

      <para>Memoization would be a huge help here, but to fix the problem, we
      need to memoize the calls that <literal moreinfo="none">edit_distance</literal> makes to itself. This technique
      is sometimes referred to as <emphasis>dynamic programming</emphasis>. To
      see how to do this, let's step away from <literal moreinfo="none">edit_distance</literal> and instead consider a much
      simpler example: computing the <emphasis>n</emphasis>th element of the
      Fibonacci sequence. The Fibonacci sequence by definition starts out with
      two <literal moreinfo="none">1</literal>s, with every subsequent element
      being the sum of the previous two. The classic recursive definition of
      Fibonacci is as follows:<indexterm class="singular">
          <primary>programming</primary>

          <secondary>dynamic programming</secondary>
        </indexterm><indexterm class="singular">
          <primary>dynamic programming</primary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/fib.topscript">OCaml utop</ulink>
      (part 1)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let rec fib i =</userinput>
<userinput moreinfo="none">    if i &lt;= 1 then 1 else fib (i - 1) + fib (i - 2);;</userinput>
<computeroutput moreinfo="none">val fib : int -&gt; int = &lt;fun&gt;</computeroutput></programlisting>

      <para>This is, however, exponentially slow, for the same reason that
      <literal moreinfo="none">edit_distance</literal> was slow: we end up
      making many redundant calls to <literal moreinfo="none">fib</literal>.
      It shows up quite dramatically in the performance:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/fib.topscript">OCaml utop</ulink>
      (part 2)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">time (fun () -&gt; fib 20);;</userinput>
<computeroutput moreinfo="none">Time: 0.844955ms</computeroutput>
<computeroutput moreinfo="none">- : int = 10946</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">time (fun () -&gt; fib 40);;</userinput>
<computeroutput moreinfo="none">Time: 12.7751s</computeroutput>
<computeroutput moreinfo="none">- : int = 165580141</computeroutput></programlisting>

      <para>As you can see, <literal moreinfo="none">fib 40</literal> takes
      thousands of times longer to compute than <literal moreinfo="none">fib
      20</literal>.</para>

      <para>So, how can we use memoization to make this faster? The tricky bit
      is that we need to insert the memoization before the recursive calls
      within <literal moreinfo="none">fib</literal>. We can't just define
      <literal moreinfo="none">fib</literal> in the ordinary way and memoize
      it after the fact and expect the first call to <literal moreinfo="none">fib</literal> to be improved:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/fib.topscript">OCaml utop</ulink>
      (part 3)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let fib = memoize fib;;</userinput>
<computeroutput moreinfo="none">val fib : int -&gt; int = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">time (fun () -&gt; fib 40);;</userinput>
<computeroutput moreinfo="none">Time: 12.774s</computeroutput>
<computeroutput moreinfo="none">- : int = 165580141</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">time (fun () -&gt; fib 40);;</userinput>
<computeroutput moreinfo="none">Time: 0.00309944ms</computeroutput>
<computeroutput moreinfo="none">- : int = 165580141</computeroutput></programlisting>

      <para>In order to make <literal moreinfo="none">fib</literal> fast, our
      first step will be to rewrite <literal moreinfo="none">fib</literal> in
      a way that unwinds the recursion. The following version expects as its
      first argument a function (called <literal moreinfo="none">fib</literal>) that will be called in lieu of the usual
      recursive call:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/fib.topscript">OCaml utop</ulink>
      (part 4)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let fib_norec fib i =</userinput>
<userinput moreinfo="none">    if i &lt;= 1 then i</userinput>
<userinput moreinfo="none">    else fib (i - 1) + fib (i - 2) ;;</userinput>
<computeroutput moreinfo="none">val fib_norec : (int -&gt; int) -&gt; int -&gt; int = &lt;fun&gt;</computeroutput></programlisting>

      <para>We can now turn this back into an ordinary Fibonacci function by
      tying the recursive knot:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/fib.topscript">OCaml utop</ulink>
      (part 5)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let rec fib i = fib_norec fib i;;</userinput>
<computeroutput moreinfo="none">val fib : int -&gt; int = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">fib 20;;</userinput>
<computeroutput moreinfo="none">- : int = 6765</computeroutput></programlisting>

      <para>We can even write a polymorphic function that we'll call <literal moreinfo="none">make_rec</literal> that can tie the recursive knot for
      any function of this form:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/fib.topscript">OCaml utop</ulink>
      (part 6)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let make_rec f_norec =</userinput>
<userinput moreinfo="none">    let rec f x = f_norec f x in</userinput>
<userinput moreinfo="none">    f</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val make_rec : (('a -&gt; 'b) -&gt; 'a -&gt; 'b) -&gt; 'a -&gt; 'b = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let fib = make_rec fib_norec;;</userinput>
<computeroutput moreinfo="none">val fib : int -&gt; int = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">fib 20;;</userinput>
<computeroutput moreinfo="none">- : int = 6765</computeroutput></programlisting>

      <para>This is a pretty strange piece of code, and it may take a few moments of thought to
        figure out what's going on. Like <literal moreinfo="none">fib_norec</literal>, the function
          <literal moreinfo="none">f_norec</literal> passed into <literal moreinfo="none">make_rec</literal> is a function that isn't recursive but takes as an argument a function
        that it will call. What <literal moreinfo="none">make_rec</literal> does is to essentially
        feed <literal moreinfo="none">f_norec</literal> to itself, thus making it a true recursive
        function.</para>

      <para>This is clever enough, but all we've really done is find a new way
      to implement the same old slow Fibonacci function. To make it faster, we
      need a variant of <literal moreinfo="none">make_rec</literal> that
      inserts memoization when it ties the recursive knot. We'll call that
      function <literal moreinfo="none">memo_rec</literal>:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/fib.topscript">OCaml utop</ulink>
      (part 7)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let memo_rec f_norec x =</userinput>
<userinput moreinfo="none">    let fref = ref (fun _ -&gt; assert false) in</userinput>
<userinput moreinfo="none">    let f = memoize (fun x -&gt; f_norec !fref x) in</userinput>
<userinput moreinfo="none">    fref := f;</userinput>
<userinput moreinfo="none">    f x</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val memo_rec : (('a -&gt; 'b) -&gt; 'a -&gt; 'b) -&gt; 'a -&gt; 'b = &lt;fun&gt;</computeroutput></programlisting>

      <para>Note that <literal moreinfo="none">memo_rec</literal> has the same
      signature as <literal moreinfo="none">make_rec</literal>.</para>

      <para>We're using the reference here as a way of tying the recursive
      knot without using a <literal moreinfo="none">let rec</literal>, which
      for reasons we'll describe later wouldn't work here.</para>

      <para>Using <literal moreinfo="none">memo_rec</literal>, we can now
      build an efficient version of <literal moreinfo="none">fib</literal>:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/fib.topscript">OCaml utop</ulink>
      (part 8)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let fib = memo_rec fib_norec;;</userinput>
<computeroutput moreinfo="none">val fib : int -&gt; int = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">time (fun () -&gt; fib 40);;</userinput>
<computeroutput moreinfo="none">Time: 0.0591278ms</computeroutput>
<computeroutput moreinfo="none">- : int = 102334155</computeroutput></programlisting>

      <para>And as you can see, the exponential time complexity is now
      gone.</para>

      <para>The memory behavior here is important. If you look back at the
      definition of <literal moreinfo="none">memo_rec</literal>, you'll see
      that the call <literal moreinfo="none">memo_rec fib_norec</literal> does
      not trigger a call to <literal moreinfo="none">memoize</literal>. Only
      when <literal moreinfo="none">fib</literal> is called and thereby the
      final argument to <literal moreinfo="none">memo_rec</literal> is
      presented does <literal moreinfo="none">memoize</literal> get called.
      The result of that call falls out of scope when the <literal moreinfo="none">fib</literal> call returns, and so calling <literal moreinfo="none">memo_rec</literal> on a function does not create a
      memory leak—the memoization table is collected after the computation
      completes.</para>

      <para>We can use <literal moreinfo="none">memo_rec</literal> as part of
      a single declaration that makes this look like it's little more than a
      special form of <literal moreinfo="none">let rec</literal>:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/fib.topscript">OCaml utop</ulink>
      (part 9)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let fib = memo_rec (fun fib i -&gt;</userinput>
<userinput moreinfo="none">    if i &lt;= 1 then 1 else fib (i - 1) + fib (i - 2));;</userinput>
<computeroutput moreinfo="none">val fib : int -&gt; int = &lt;fun&gt;</computeroutput></programlisting>

      <para>Memoization is overkill for implementing Fibonacci, and indeed,
      the <literal moreinfo="none">fib</literal> defined above is not
      especially efficient, allocating space linear in the number passed in to
      <literal moreinfo="none">fib</literal>. It's easy enough to write a
      Fibonacci function that takes a constant amount of space.</para>

      <para>But memoization is a good approach for optimizing <literal moreinfo="none">edit_distance</literal>, and we can apply the same
      approach we used on <literal moreinfo="none">fib</literal> here. We will
      need to change <literal moreinfo="none">edit_distance</literal> to take
      a pair of strings as a single argument, since <literal moreinfo="none">memo_rec</literal> only works on single-argument
      functions. (We can always recover the original interface with a wrapper
      function.) With just that change and the addition of the <literal moreinfo="none">memo_rec</literal> call, we can get a memoized version
      of <literal moreinfo="none">edit_distance</literal>:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/memo.topscript">OCaml utop</ulink>
      (part 6)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let edit_distance = memo_rec (fun edit_distance (s,t) -&gt;</userinput>
<userinput moreinfo="none">    match String.length s, String.length t with</userinput>
<userinput moreinfo="none">    | (0,x) | (x,0) -&gt; x</userinput>
<userinput moreinfo="none">    | (len_s,len_t) -&gt;</userinput>
<userinput moreinfo="none">      let s' = String.drop_suffix s 1 in</userinput>
<userinput moreinfo="none">      let t' = String.drop_suffix t 1 in</userinput>
<userinput moreinfo="none">      let cost_to_drop_both =</userinput>
<userinput moreinfo="none">        if s.[len_s - 1] = t.[len_t - 1] then 0 else 1</userinput>
<userinput moreinfo="none">      in</userinput>
<userinput moreinfo="none">      List.reduce_exn ~f:Int.min</userinput>
<userinput moreinfo="none">        [ edit_distance (s',t ) + 1</userinput>
<userinput moreinfo="none">        ; edit_distance (s ,t') + 1</userinput>
<userinput moreinfo="none">        ; edit_distance (s',t') + cost_to_drop_both</userinput>
<userinput moreinfo="none">        ]) ;;</userinput>
<computeroutput moreinfo="none">val edit_distance : string * string -&gt; int = &lt;fun&gt;</computeroutput></programlisting>

      <para>This new version of <literal moreinfo="none">edit_distance</literal> is much more efficient than the
      one we started with; the following call is many thousands of times
      faster than it was without memoization:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/memo.topscript">OCaml utop</ulink>
      (part 7)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">time (fun () -&gt; edit_distance ("OCaml 4.01","ocaml 4.01"));;</userinput>
<computeroutput moreinfo="none">Time: 0.500917ms</computeroutput>
<computeroutput moreinfo="none">- : int = 2</computeroutput></programlisting>

      <note role="allow_break">
        <title>Limitations of let rec</title>

        <para>You might wonder why we didn't tie the recursive knot in
        <literal moreinfo="none">memo_rec</literal> using <literal moreinfo="none">let rec</literal>, as we did for <literal moreinfo="none">make_rec</literal> earlier. Here's code that tries to
        do just that:<indexterm class="singular">
            <primary>let rec</primary>
          </indexterm></para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/letrec.topscript">OCaml utop</ulink>
        (part 1)</para>

        <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let memo_rec f_norec =</userinput>
<userinput moreinfo="none">    let rec f = memoize (fun x -&gt; f_norec f x) in</userinput>
<userinput moreinfo="none">    f</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">Characters 39-69:</computeroutput>
<computeroutput moreinfo="none">Error: This kind of expression is not allowed as right-hand side of `let rec'</computeroutput></programlisting>

        <para>OCaml rejects the definition because OCaml, as a strict
        language, has limits on what it can put on the righthand side of a
        <literal moreinfo="none">let rec</literal>. In particular, imagine how
        the following code snippet would be compiled:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/let_rec.ml">OCaml</ulink></para>

        <programlisting format="linespecific" language="ocaml">let rec x = x + 1</programlisting>

        <para>Note that <literal moreinfo="none">x</literal> is an ordinary
        value, not a function. As such, it's not clear how this definition
        should be handled by the compiler. You could imagine it compiling down
        to an infinite loop, but <literal moreinfo="none">x</literal> is of
        type <literal moreinfo="none">int</literal>, and there's no <literal moreinfo="none">int</literal> that corresponds to an infinite loop. As
        such, this construct is effectively impossible to compile.</para>

        <para>To avoid such impossible cases, the compiler only allows three
        possible constructs to show up on the righthand side of a <literal moreinfo="none">let rec</literal>: a function definition, a
        constructor, or the lazy keyword. This excludes some reasonable
        things, like our definition of <literal moreinfo="none">memo_rec</literal>, but it also blocks things that
        don't make sense, like our definition of <literal moreinfo="none">x</literal>.</para>

        <para>It's worth noting that these restrictions don't show up in a
        lazy language like Haskell. Indeed, we can make something like our
        definition of <literal moreinfo="none">x</literal> work if we use
        OCaml's laziness:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/letrec.topscript">OCaml utop</ulink>
        (part 2)</para>

        <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let rec x = lazy (Lazy.force x + 1);;</userinput>
<computeroutput moreinfo="none">val x : int lazy_t = &lt;lazy&gt;</computeroutput></programlisting>

        <para>Of course, actually trying to compute this will fail. OCaml's
        <literal moreinfo="none">lazy</literal> throws an exception when a
        lazy value tries to force itself as part of its own evaluation.</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/letrec.topscript">OCaml utop</ulink>
        (part 3)</para>

        <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">Lazy.force x;;</userinput>
<computeroutput moreinfo="none">Exception: Lazy.Undefined.</computeroutput></programlisting>

        <para>But we can also create useful recursive definitions with
        <literal moreinfo="none">lazy</literal>. In particular, we can use
        laziness to make our definition of <literal moreinfo="none">memo_rec</literal> work without explicit
        mutation:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/letrec.topscript">OCaml utop</ulink>
        (part 5)</para>

        <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let lazy_memo_rec f_norec x =</userinput>
<userinput moreinfo="none">    let rec f = lazy (memoize (fun x -&gt; f_norec (Lazy.force f) x)) in</userinput>
<userinput moreinfo="none">    (Lazy.force f) x</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val lazy_memo_rec : (('a -&gt; 'b) -&gt; 'a -&gt; 'b) -&gt; 'a -&gt; 'b = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">time (fun () -&gt; lazy_memo_rec fib_norec 40);;</userinput>
<computeroutput moreinfo="none">Time: 0.0650883ms</computeroutput>
<computeroutput moreinfo="none">- : int = 102334155</computeroutput></programlisting>

        <para>Laziness is more constrained than explicit mutation, and so in
        some cases can lead to code whose behavior is easier to think
        about.<indexterm class="endofrange" startref="BEmem"/></para>
      </note>
    </sect2>
  </sect1>

  <sect1 id="input-and-output">
    <title>Input and Output</title>

    <para>Imperative programming is about more than modifying in-memory data
    structures. Any function that doesn't boil down to a deterministic
    transformation from its arguments to its return value is imperative in
    nature. That includes not only things that mutate your program's data, but
    also operations that interact with the world outside of your program. An
    important example of this kind of interaction is I/O, i.e., operations for
    reading or writing data to things like files, terminal input and output,
    and network sockets.<indexterm class="singular">
        <primary>I/O (input/output) operations</primary>

        <secondary>terminal I/O</secondary>
      </indexterm><indexterm class="startofrange" id="IPinpout">
        <primary>imperative programming</primary>

        <secondary>input and output</secondary>
      </indexterm></para>

    <para>There are multiple I/O libraries in OCaml. In this section we'll discuss OCaml's buffered
      I/O library that can be used through the <literal moreinfo="none">In_channel</literal> and
        <literal moreinfo="none">Out_channel</literal> modules in Core. Other I/O primitives are
      also available through the <literal moreinfo="none">Unix</literal> module in Core as well as
        <literal moreinfo="none">Async</literal>, the asynchronous I/O library that is covered in
        <xref linkend="concurrent-programming-with-async"/>. Most of the functionality in Core's
        <literal moreinfo="none">In_channel</literal> and <literal moreinfo="none">Out_channel</literal> (and in Core's <literal moreinfo="none">Unix</literal> module)
      derives from the standard library, but we'll use Core's interfaces here.</para>

    <sect2 id="terminal-io">
      <title>Terminal I/O</title>

      <para>OCaml's buffered I/O library is organized around two types:
      <literal moreinfo="none">in_channel</literal>, for channels you read
      from, and <literal moreinfo="none">out_channel</literal>, for channels
      you write to. The <literal moreinfo="none">In_channel</literal> and
      <literal moreinfo="none">Out_channel</literal> modules only have direct
      support for channels corresponding to files and terminals; other kinds
      of channels can be created through the <literal moreinfo="none">Unix</literal> module.<indexterm class="singular">
          <primary>Out_channel module</primary>

          <secondary>Out_channel.stderr</secondary>
        </indexterm><indexterm class="singular">
          <primary>Out_channel module</primary>

          <secondary>Out_channel.stdout</secondary>
        </indexterm><indexterm class="singular">
          <primary>In_channel module</primary>
        </indexterm></para>

      <para>We'll start our discussion of I/O by focusing on the terminal.
      Following the UNIX model, communication with the terminal is organized
      around three channels, which correspond to the three standard file
      descriptors in Unix:</para>

      <variablelist>
        <varlistentry>
          <term><literal moreinfo="none">In_channel.stdin</literal></term>

          <listitem>
            <para>The "standard input" channel. By default, input comes from
            the terminal, which handles keyboard input.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal moreinfo="none">Out_channel.stdout</literal></term>

          <listitem>
            <para>The "standard output" channel. By default, output written to
            <literal moreinfo="none">stdout</literal> appears on the user
            terminal.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal moreinfo="none">Out_channel.stderr</literal></term>

          <listitem>
            <para>The "standard error" channel. This is similar to <literal moreinfo="none">stdout</literal> but is intended for error
            messages.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>The values <literal moreinfo="none">stdin</literal>, <literal moreinfo="none">stdout</literal>, and <literal moreinfo="none">stderr</literal> are useful enough that they are also
      available in the global namespace directly, without having to go through
      the <literal moreinfo="none">In_channel</literal> and <literal moreinfo="none">Out_channel</literal> modules.</para>

      <para>Let's see this in action in a simple interactive application. The
      following program, <literal moreinfo="none">time_converter</literal>,
      prompts the user for a time zone, and then prints out the current time
      in that time zone. Here, we use Core's <literal moreinfo="none">Zone</literal> module for looking up a time zone, and
      the <literal moreinfo="none">Time</literal> module for computing the
      current time and printing it out in the time zone in question:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/time_converter.ml">OCaml</ulink></para>

      <programlisting format="linespecific" language="ocaml">open Core.Std

let () =
  Out_channel.output_string stdout "Pick a timezone: ";
  Out_channel.flush stdout;
  match In_channel.input_line stdin with
  | None -&gt; failwith "No timezone provided"
  | Some zone_string -&gt;
    let zone = Zone.find_exn zone_string in
    let time_string = Time.to_string_abs (Time.now ()) ~zone in
    Out_channel.output_string stdout
      (String.concat
         ["The time in ";Zone.to_string zone;" is ";time_string;".\n"]);
    Out_channel.flush stdout</programlisting>

      <para>We can build this program using <command moreinfo="none">corebuild</command> and run it. You'll see that it
      prompts you for input, as follows:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/time_converter.out">Terminal</ulink></para>

      <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">corebuild time_converter.byte</userinput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">./time_converter.byte</userinput>
<computeroutput moreinfo="none">Pick a timezone:</computeroutput></programlisting>

      <para>You can then type in the name of a time zone and hit Return, and
      it will print out the current time in the time zone in question:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/time_converter2.out">Terminal</ulink></para>

      <programlisting format="linespecific" language="console"><computeroutput moreinfo="none">Pick a timezone: Europe/London</computeroutput>
<computeroutput moreinfo="none">The time in Europe/London is 2013-08-15 00:03:10.666220+01:00.</computeroutput></programlisting>

      <para>We called <literal moreinfo="none">Out_channel.flush</literal> on
      <literal moreinfo="none">stdout</literal> because <literal moreinfo="none">out_channel</literal>s are buffered, which is to say
      that OCaml doesn't immediately do a write every time you call <literal moreinfo="none">output_string</literal>. Instead, writes are buffered
      until either enough has been written to trigger the flushing of the
      buffers, or until a flush is explicitly requested. This greatly
      increases the efficiency of the writing process by reducing the number
      of system calls.</para>

      <para>Note that <literal moreinfo="none">In_channel.input_line</literal>
      returns a <literal moreinfo="none">string option</literal>, with
      <literal moreinfo="none">None</literal> indicating that the input stream
      has ended (i.e., an end-of-file condition). <literal moreinfo="none">Out_channel.output_string</literal> is used to print the
      final output, and <literal moreinfo="none">Out_channel.flush</literal>
      is called to flush that output to the screen. The final flush is not
      technically required, since the program ends after that instruction, at
      which point all remaining output will be flushed anyway, but the
      explicit flush is nonetheless good practice.</para>
    </sect2>

    <sect2 id="formatted-output-with-printf">
      <title>Formatted Output with printf</title>

      <para>Generating output with functions like <literal moreinfo="none">Out_channel.output_string</literal> is simple and easy
      to understand, but can be a bit verbose. OCaml also supports formatted
      output using the <literal moreinfo="none">printf</literal> function,
      which is modeled after <literal moreinfo="none">printf</literal> in the
      C standard library. <literal moreinfo="none">printf</literal> takes a
      <emphasis>format string</emphasis> that describes what to print and how
      to format it, as well as arguments to be printed, as determined by the
      formatting directives embedded in the format string. So, for example, we
      can write:<indexterm class="singular">
          <primary>strings</primary>

          <secondary>format strings</secondary>
        </indexterm><indexterm class="singular">
          <primary>format strings</primary>
        </indexterm><indexterm class="singular">
          <primary>printf function</primary>
        </indexterm><indexterm class="singular">
          <primary>I/O (input/output) operations</primary>

          <secondary>formatted output</secondary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/printf.topscript">OCaml utop</ulink>
      (part 1)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">printf "%i is an integer, %F is a float, \"%s\" is a string\n"</userinput>
<userinput moreinfo="none">    3 4.5 "five";;</userinput>
<computeroutput moreinfo="none">3 is an integer, 4.5 is a float, "five" is a string</computeroutput>
<computeroutput moreinfo="none">- : unit = ()</computeroutput></programlisting>

      <para>Unlike C's <literal moreinfo="none">printf</literal>, the <literal moreinfo="none">printf</literal> in OCaml is type-safe. In particular,
      if we provide an argument whose type doesn't match what's presented in
      the format string, we'll get a type error:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/printf.topscript">OCaml utop</ulink>
      (part 2)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">printf "An integer: %i\n" 4.5;;</userinput>
<computeroutput moreinfo="none">Characters 26-29:</computeroutput>
<computeroutput moreinfo="none">Error: This expression has type float but an expression was expected of type</computeroutput>
<computeroutput moreinfo="none">         int</computeroutput></programlisting>

      <sidebar>
        <title>Understanding Format Strings</title>

        <para>The format strings used by <literal moreinfo="none">printf</literal> turn out to be quite different from
        ordinary strings. This difference ties to the fact that OCaml format
        strings, unlike their equivalent in C, are type-safe. In particular,
        the compiler checks that the types referred to by the format string
        match the types of the rest of the arguments passed to <literal moreinfo="none">printf</literal>.</para>

        <para>To check this, OCaml needs to analyze the contents of the format
        string at compile time, which means the format string needs to be
        available as a string literal at compile time. Indeed, if you try to
        pass an ordinary string to <literal moreinfo="none">printf</literal>,
        the compiler will complain:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/printf.topscript">OCaml utop</ulink>
        (part 3)</para>

        <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let fmt = "%i is an integer, %F is a float, \"%s\" is a string\n";;</userinput>
<computeroutput moreinfo="none">val fmt : string = "%i is an integer, %F is a float, \"%s\" is a string\n"</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">printf fmt 3 4.5 "five";;</userinput>
<computeroutput moreinfo="none">Characters 9-12:</computeroutput>
<computeroutput moreinfo="none">Error: This expression has type string but an expression was expected of type</computeroutput>
<computeroutput moreinfo="none">         ('a -&gt; 'b -&gt; 'c -&gt; 'd, out_channel, unit) format =</computeroutput>
<computeroutput moreinfo="none">           ('a -&gt; 'b -&gt; 'c -&gt; 'd, out_channel, unit, unit, unit, unit)</computeroutput>
<computeroutput moreinfo="none">           format6</computeroutput></programlisting>

        <para>If OCaml infers that a given string literal is a format string,
        then it parses it at compile time as such, choosing its type in
        accordance with the formatting directives it finds. Thus, if we add a
        type annotation indicating that the string we're defining is actually
        a format string, it will be interpreted as such:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/printf.topscript">OCaml utop</ulink>
        (part 4)</para>

        <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let fmt : ('a, 'b, 'c) format =</userinput>
<userinput moreinfo="none">    "%i is an integer, %F is a float, \"%s\" is a string\n";;</userinput>
<computeroutput moreinfo="none">val fmt : (int -&gt; float -&gt; string -&gt; 'c, 'b, 'c) format = &lt;abstr&gt;</computeroutput></programlisting>

        <para>And accordingly, we can pass it to <literal moreinfo="none">printf</literal>:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/printf.topscript">OCaml utop</ulink>
        (part 5)</para>

        <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">printf fmt 3 4.5 "five";;</userinput>
<computeroutput moreinfo="none">3 is an integer, 4.5 is a float, "five" is a string - : unit = ()</computeroutput>
        </programlisting>
<?hard-pagebreak?>
        <para>If this looks different from everything else you've seen so far,
        that's because it is. This is really a special case in the type
        system. Most of the time, you don't need to worry about this special
        handling of format strings—you can just use <literal moreinfo="none">printf</literal> and not worry about the details. But
        it's useful to keep the broad outlines of the story in the back of
        your head.</para>
      </sidebar>

      <para>Now let's see how we can rewrite our time conversion program to be
      a little more concise using <literal moreinfo="none">printf</literal>:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/time_converter2.ml">OCaml</ulink></para>

      <programlisting format="linespecific" language="ocaml">open Core.Std

let () =
  printf "Pick a timezone: %!";
  match In_channel.input_line stdin with
  | None -&gt; failwith "No timezone provided"
  | Some zone_string -&gt;
    let zone = Zone.find_exn zone_string in
    let time_string = Time.to_string_abs (Time.now ()) ~zone in
    printf "The time in %s is %s.\n%!" (Zone.to_string zone) time_string</programlisting>

      <para>In the preceding example, we've used only two formatting
      directives: <literal moreinfo="none">%s</literal>, for including a
      string, and <literal moreinfo="none">%!</literal> which causes <literal moreinfo="none">printf</literal> to flush the channel.</para>

      <para><literal moreinfo="none">printf</literal>'s formatting directives
      offer a significant amount of control, allowing you to specify things
      like:<indexterm class="singular">
          <primary>binary numbers, formatting with printf</primary>
        </indexterm><indexterm class="singular">
          <primary>hex numbers, formatting with printf</primary>
        </indexterm><indexterm class="singular">
          <primary>decimals, formatting with printf</primary>
        </indexterm><indexterm class="singular">
          <primary>alignment, formatting with printf</primary>
        </indexterm></para>

      <itemizedlist>
        <listitem>
          <para>Alignment and padding</para>
        </listitem>

        <listitem>
          <para>Escaping rules for strings</para>
        </listitem>

        <listitem>
          <para>Whether numbers should be formatted in decimal, hex, or
          binary</para>
        </listitem>

        <listitem>
          <para>Precision of float conversions</para>
        </listitem>
      </itemizedlist>

      <para>There are also <literal moreinfo="none">printf</literal>-style
      functions that target outputs other than <literal moreinfo="none">stdout</literal>, including:<indexterm class="singular">
          <primary>sprintf function</primary>
        </indexterm><indexterm class="singular">
          <primary>fprintf function</primary>
        </indexterm><indexterm class="singular">
          <primary>eprintf function</primary>
        </indexterm></para>

      <itemizedlist>
        <listitem>
          <para><literal moreinfo="none">eprintf</literal>, which prints to
          <literal moreinfo="none">stderr</literal></para>
        </listitem>

        <listitem>
          <para><literal moreinfo="none">fprintf</literal>, which prints to an
          arbitrary <literal moreinfo="none">out_channel</literal></para>
        </listitem>

        <listitem>
          <para><literal moreinfo="none">sprintf</literal>, which returns a
          formatted string</para>
        </listitem>
      </itemizedlist>

      <para>All of this, and a good deal more, is described in the API
      documentation for the <literal moreinfo="none">Printf</literal> module
      in the OCaml Manual.</para>
    </sect2>

    <sect2 id="file-io">
      <title>File I/O</title>

      <para>Another common use of <literal moreinfo="none">in_channel</literal>s and <literal moreinfo="none">out_channel</literal>s is for working with files. Here
      are a couple of functions—one that creates a file full of numbers, and
      the other that reads in such a file and returns the sum of those
      numbers:<indexterm class="singular">
          <primary>files</primary>

          <secondary>file I/O</secondary>
        </indexterm><indexterm class="singular">
          <primary>I/O (input/output) operations</primary>

          <secondary>file I/O</secondary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/file.topscript">OCaml utop</ulink>
      (part 1)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let create_number_file filename numbers =</userinput>
<userinput moreinfo="none">    let outc = Out_channel.create filename in</userinput>
<userinput moreinfo="none">    List.iter numbers ~f:(fun x -&gt; fprintf outc "%d\n" x);</userinput>
<userinput moreinfo="none">    Out_channel.close outc</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val create_number_file : string -&gt; int list -&gt; unit = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let sum_file filename =</userinput>
<userinput moreinfo="none">     let file = In_channel.create filename in</userinput>
<userinput moreinfo="none">     let numbers = List.map ~f:Int.of_string (In_channel.input_lines file) in</userinput>
<userinput moreinfo="none">     let sum = List.fold ~init:0 ~f:(+) numbers in</userinput>
<userinput moreinfo="none">     In_channel.close file;</userinput>
<userinput moreinfo="none">     sum</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val sum_file : string -&gt; int = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">create_number_file "numbers.txt" [1;2;3;4;5];;</userinput>
<computeroutput moreinfo="none">- : unit = ()</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">sum_file "numbers.txt";;</userinput>
<computeroutput moreinfo="none">- : int = 15</computeroutput></programlisting>

      <para>For both of these functions, we followed the same basic sequence:
      we first create the channel, then use the channel, and finally close the
      channel. The closing of the channel is important, since without it, we
      won't release resources associated with the file back to the operating
      system.</para>

      <para>One problem with the preceding code is that if it throws an
      exception in the middle of its work, it won't actually close the file.
      If we try to read a file that doesn't actually contain numbers, we'll
      see such an error:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/file.topscript">OCaml utop</ulink>
      (part 2)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">sum_file "/etc/hosts";;</userinput>
<computeroutput moreinfo="none">Exception: (Failure "Int.of_string: \"127.0.0.1    localhost\"").</computeroutput></programlisting>

      <para>And if we do this over and over in a loop, we'll eventually run
      out of file descriptors:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/file.topscript">OCaml utop</ulink>
      (part 3)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">for i = 1 to 10000 do try ignore (sum_file "/etc/hosts") with _ -&gt; () done;;</userinput>
<computeroutput moreinfo="none">- : unit = ()</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">sum_file "numbers.txt";;</userinput>
<computeroutput moreinfo="none">Exception: (Sys_error "numbers.txt: Too many open files").</computeroutput></programlisting>

      <para>And now, you'll need to restart your toplevel if you want to open
      any more files!</para>

      <para>To avoid this, we need to make sure that our code cleans up after
      itself. We can do this using the <literal moreinfo="none">protect</literal> function described in <xref linkend="error-handling"/>, as follows:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/file2.topscript">OCaml utop</ulink>
      (part 1)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let sum_file filename =</userinput>
<userinput moreinfo="none">    let file = In_channel.create filename in</userinput>
<userinput moreinfo="none">    protect ~f:(fun () -&gt;</userinput>
<userinput moreinfo="none">        let numbers = List.map ~f:Int.of_string (In_channel.input_lines file) in</userinput>
<userinput moreinfo="none">        List.fold ~init:0 ~f:(+) numbers)</userinput>
<userinput moreinfo="none">      ~finally:(fun () -&gt; In_channel.close file)</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val sum_file : string -&gt; int = &lt;fun&gt;</computeroutput></programlisting>

      <para>And now, the file descriptor leak is gone:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/file2.topscript">OCaml utop</ulink>
      (part 2)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">for i = 1 to 10000 do try ignore (sum_file "/etc/hosts") with _ -&gt; () done;;</userinput>
<computeroutput moreinfo="none">- : unit = ()</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">sum_file "numbers.txt";;</userinput>
<computeroutput moreinfo="none">- : int = 15</computeroutput></programlisting>

      <para>This is really an example of a more general issue with imperative
      programming. When programming imperatively, you need to be quite careful
      to make sure that exceptions don't leave you in an awkward state.</para>

      <para><literal moreinfo="none">In_channel</literal> has functions that
      automate the handling of some of these details. For example, <literal moreinfo="none">In_channel.with_file</literal> takes a filename and a
      function for processing data from an <literal moreinfo="none">in_channel</literal> and takes care of the bookkeeping
      associated with opening and closing the file. We can rewrite <literal moreinfo="none">sum_file</literal> using this function, as shown
      here:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/file2.topscript">OCaml utop</ulink>
      (part 3)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let sum_file filename =</userinput>
<userinput moreinfo="none">    In_channel.with_file filename ~f:(fun file -&gt;</userinput>
<userinput moreinfo="none">      let numbers = List.map ~f:Int.of_string (In_channel.input_lines file) in</userinput>
<userinput moreinfo="none">      List.fold ~init:0 ~f:(+) numbers)</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val sum_file : string -&gt; int = &lt;fun&gt;</computeroutput></programlisting>

      <para>Another misfeature of our implementation of <literal moreinfo="none">sum_file</literal> is that we read the entire file into
      memory before processing it. For a large file, it's more efficient to
      process a line at a time. You can use the <literal moreinfo="none">In_channel.fold_lines</literal> function to do just
      that:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/file2.topscript">OCaml utop</ulink>
      (part 4)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let sum_file filename =</userinput>
<userinput moreinfo="none">    In_channel.with_file filename ~f:(fun file -&gt;</userinput>
<userinput moreinfo="none">      In_channel.fold_lines file ~init:0 ~f:(fun sum line -&gt;</userinput>
<userinput moreinfo="none">        sum + Int.of_string line))</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val sum_file : string -&gt; int = &lt;fun&gt;</computeroutput></programlisting>

      <para>This is just a taste of the functionality of <literal moreinfo="none">In_channel</literal> and <literal moreinfo="none">Out_channel</literal>. To get a fuller understanding,
      you should review the API documentation for those modules.<indexterm class="endofrange" startref="IPinpout"/></para>
    </sect2>
  </sect1>

  <sect1 id="order-of-evaluation">
    <title>Order of Evaluation</title>

    <para>The order in which expressions are evaluated is an important part of the definition of a
      programming language, and it is particularly important when programming imperatively. Most
      programming languages you're likely to have encountered are <emphasis>strict</emphasis>, and
      OCaml is, too. In a strict language, when you bind an identifier to the result of some
      expression, the expression is evaluated before the variable is bound. Similarly, if you call a
      function on a set of arguments, those arguments are evaluated before they are passed to the
        function.<indexterm class="singular">
        <primary>strict evaluation</primary>
      </indexterm><indexterm class="singular">
        <primary>expressions, order of evaluation</primary>
      </indexterm><indexterm class="singular">
        <primary>evaluation, order of</primary>
      </indexterm><indexterm class="singular">
        <primary>order of evaluation</primary>
      </indexterm><indexterm class="singular">
        <primary>imperative programming</primary>
        <secondary>order of evaluation</secondary>
      </indexterm></para>

    <para>Consider the following simple example. Here, we have a collection of
    angles, and we want to determine if any of them have a negative <literal moreinfo="none">sin</literal>. The following snippet of code would answer
    that question:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/order.topscript">OCaml utop</ulink>
    (part 1)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let x = sin 120. in</userinput>
<userinput moreinfo="none">  let y = sin 75.  in</userinput>
<userinput moreinfo="none">  let z = sin 128. in</userinput>
<userinput moreinfo="none">  List.exists ~f:(fun x -&gt; x &lt; 0.) [x;y;z]</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">- : bool = true</computeroutput></programlisting>

    <para>In some sense, we don't really need to compute the <literal moreinfo="none">sin 128.</literal> because <literal moreinfo="none">sin
    75.</literal> is negative, so we could know the answer before even
    computing <literal moreinfo="none">sin 128.</literal>.</para>

    <para>It doesn't have to be this way. Using the <literal moreinfo="none">lazy</literal> keyword, we can write the original
    computation so that <literal moreinfo="none">sin 128.</literal> won't ever
    be computed:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/order.topscript">OCaml utop</ulink>
    (part 2)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let x = lazy (sin 120.) in</userinput>
<userinput moreinfo="none">  let y = lazy (sin 75.)  in</userinput>
<userinput moreinfo="none">  let z = lazy (sin 128.) in</userinput>
<userinput moreinfo="none">  List.exists ~f:(fun x -&gt; Lazy.force x &lt; 0.) [x;y;z]</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">- : bool = true</computeroutput></programlisting>

    <para>We can confirm that fact by a few well-placed <literal moreinfo="none">printf</literal>s:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/order.topscript">OCaml utop</ulink>
    (part 3)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let x = lazy (printf "1\n"; sin 120.) in</userinput>
<userinput moreinfo="none">  let y = lazy (printf "2\n"; sin 75.)  in</userinput>
<userinput moreinfo="none">  let z = lazy (printf "3\n"; sin 128.) in</userinput>
<userinput moreinfo="none">  List.exists ~f:(fun x -&gt; Lazy.force x &lt; 0.) [x;y;z]</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">1</computeroutput>
<computeroutput moreinfo="none">2</computeroutput>
<computeroutput moreinfo="none">- : bool = true</computeroutput></programlisting>

    <para>OCaml is strict by default for a good reason: lazy evaluation and
    imperative programming generally don't mix well because laziness makes it
    harder to reason about when a given side effect is going to occur.
    Understanding the order of side effects is essential to reasoning about
    the behavior of an imperative program.</para>

    <para>In a strict language, we know that expressions that are bound by a
    sequence of <literal>let</literal> bindings will be evaluated in the order
    that they're defined. But what about the evaluation order within a single
    expression? Officially, the answer is that evaluation order within an
    expression is undefined. In practice, OCaml has only one compiler, and
    that behavior is a kind of de facto standard. Unfortunately, the
    evaluation order in this case is often the opposite of what one might
    expect.</para>

    <para>Consider the following example:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/order.topscript">OCaml utop</ulink>
    (part 4)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">List.exists ~f:(fun x -&gt; x &lt; 0.)</userinput>
<userinput moreinfo="none">  [ (printf "1\n"; sin 120.);</userinput>
<userinput moreinfo="none">    (printf "2\n"; sin 75.);</userinput>
<userinput moreinfo="none">    (printf "3\n"; sin 128.); ]</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">3</computeroutput>
<computeroutput moreinfo="none">2</computeroutput>
<computeroutput moreinfo="none">1</computeroutput>
<computeroutput moreinfo="none">- : bool = true</computeroutput></programlisting>

    <para>Here, you can see that the subexpression that came last was actually
    evaluated first! This is generally the case for many different kinds of
    expressions. If you want to make sure of the evaluation order of different
    subexpressions, you should express them as a series of <literal moreinfo="none">let</literal> bindings.</para>
  </sect1>

  <sect1 id="side-effects-and-weak-polymorphism">
    <title>Side Effects and Weak Polymorphism</title>

    <para>Consider the following simple, imperative function:<indexterm class="singular">
        <primary>polymorphism</primary>

        <secondary>weak polymorphism</secondary>
      </indexterm><indexterm class="singular">
        <primary>weak polymorphism</primary>
      </indexterm><indexterm class="singular">
        <primary>side effects</primary>
      </indexterm><indexterm class="startofrange" id="IPsideweak">
        <primary>imperative programming</primary>

        <secondary>side effects/weak polymorphism</secondary>
      </indexterm></para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/weak.topscript">OCaml utop</ulink>
    (part 1)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let remember =</userinput>
<userinput moreinfo="none">    let cache = ref None in</userinput>
<userinput moreinfo="none">    (fun x -&gt;</userinput>
<userinput moreinfo="none">       match !cache with</userinput>
<userinput moreinfo="none">       | Some y -&gt; y</userinput>
<userinput moreinfo="none">       | None -&gt; cache := Some x; x)</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val remember : '_a -&gt; '_a = &lt;fun&gt;</computeroutput></programlisting>

    <para><literal moreinfo="none">remember</literal> simply caches the first
    value that's passed to it, returning that value on every call. That's
    because <literal moreinfo="none">cache</literal> is created and
    initialized once and is shared across invocations of <literal moreinfo="none">remember</literal>.</para>

    <para><literal moreinfo="none">remember</literal> is not a terribly useful
    function, but it raises an interesting question: what is its type?</para>

    <para>On its first call, <literal moreinfo="none">remember</literal>
    returns the same value it's passed, which means its input type and return
    type should match. Accordingly, <literal moreinfo="none">remember</literal> should have type <literal moreinfo="none">t -&gt; t</literal> for some type <literal moreinfo="none">t</literal>. There's nothing about <literal moreinfo="none">remember</literal> that ties the choice of <literal moreinfo="none">t</literal> to any particular type, so you might expect
    OCaml to generalize, replacing <literal moreinfo="none">t</literal> with a
    polymorphic type variable. It's this kind of generalization that gives us
    polymorphic types in the first place. The identity function, as an
    example, gets a polymorphic type in this way:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/weak.topscript">OCaml utop</ulink>
    (part 2)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let identity x = x;;</userinput>
<computeroutput moreinfo="none">val identity : 'a -&gt; 'a = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">identity 3;;</userinput>
<computeroutput moreinfo="none">- : int = 3</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">identity "five";;</userinput>
<computeroutput moreinfo="none">- : string = "five"</computeroutput></programlisting>

    <para>As you can see, the polymorphic type of <literal moreinfo="none">identity</literal> lets it operate on values with
    different types.</para>

    <para>This is not what happens with <literal moreinfo="none">remember</literal>, though. As you
      can see from the above examples, the type that OCaml infers for <literal moreinfo="none">remember</literal> looks almost, but not quite, like the type of the identity function.
      Here it is again:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/remember_type.ml">OCaml</ulink></para>

    <programlisting format="linespecific" language="ocaml">val remember : '_a -&gt; '_a = &lt;fun&gt;</programlisting>

    <para>The underscore in the type variable <literal moreinfo="none">'_a</literal> tells us that the variable is only
    <emphasis>weakly polymorphic</emphasis>, which is to say that it can be
    used with any <emphasis>single</emphasis> type. That makes sense because,
    unlike <literal moreinfo="none">identity</literal>, <literal moreinfo="none">remember</literal> always returns the value it was passed
    on its first invocation, which means its return value must always have the
    same type.<indexterm class="singular">
      <primary>type variables</primary>
    </indexterm></para>

    <para>OCaml will convert a weakly polymorphic variable to a concrete type
    as soon as it gets a clue as to what concrete type it is to be used
    as:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/weak.topscript">OCaml utop</ulink>
    (part 3)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let remember_three () = remember 3;;</userinput>
<computeroutput moreinfo="none">val remember_three : unit -&gt; int = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">remember;;</userinput>
<computeroutput moreinfo="none">- : int -&gt; int = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">remember "avocado";;</userinput>
<computeroutput moreinfo="none">Characters 9-18:</computeroutput>
<computeroutput moreinfo="none">Error: This expression has type string but an expression was expected of type</computeroutput>
<computeroutput moreinfo="none">         int</computeroutput></programlisting>

    <para>Note that the type of <literal moreinfo="none">remember</literal>
    was settled by the definition of <literal moreinfo="none">remember_three</literal>, even though <literal moreinfo="none">remember_three</literal> was never called!</para>

    <sect2 id="the-value-restriction">
      <title>The Value Restriction</title>

      <para>So, when does the compiler infer weakly polymorphic types? As
      we've seen, we need weakly polymorphic types when a value of unknown
      type is stored in a persistent mutable cell. Because the type system
      isn't precise enough to determine all cases where this might happen,
      OCaml uses a rough rule to flag cases that don't introduce any
      persistent mutable cells, and to only infer polymorphic types in those
      cases. This rule is called <emphasis>the value
      restriction</emphasis>.<indexterm class="singular">
          <primary>value restriction</primary>
        </indexterm></para>

      <para>The core of the value restriction is the observation that some
      kinds of expressions, which we'll refer to as <emphasis>simple
      values</emphasis>, by their nature can't introduce persistent mutable
      cells, including:</para>

      <itemizedlist>
        <listitem>
          <para>Constants (i.e., things like integer and floating-point
          literals)</para>
        </listitem>

        <listitem>
          <para>Constructors that only contain other simple values</para>
        </listitem>

        <listitem>
          <para>Function declarations, i.e., expressions that begin with
          <literal moreinfo="none">fun</literal> or <literal moreinfo="none">function</literal>, or the equivalent let binding,
          <literal moreinfo="none">let f x = ...</literal></para>
        </listitem>

        <listitem>
          <para><literal moreinfo="none">let</literal> bindings of the form
          <literal moreinfo="none">let</literal> <emphasis><literal moreinfo="none">var</literal></emphasis> <literal moreinfo="none">=</literal> <emphasis><literal moreinfo="none">expr1</literal></emphasis> <literal moreinfo="none">in</literal> <emphasis><literal moreinfo="none">expr2</literal></emphasis>, where both
          <emphasis><literal moreinfo="none">expr1</literal></emphasis> and
          <emphasis><literal moreinfo="none">expr2</literal></emphasis> are
          simple values</para>
        </listitem>
      </itemizedlist>

      <para>Thus, the following expression is a simple value, and as a result,
      the types of values contained within it are allowed to be
      polymorphic:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/value_restriction.topscript">OCaml utop</ulink>
      (part 1)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">(fun x -&gt; [x;x]);;</userinput>
<computeroutput moreinfo="none">- : 'a -&gt; 'a list = &lt;fun&gt;</computeroutput></programlisting>

      <para>But, if we write down an expression that isn't a simple value by
      the preceding definition, we'll get different results. For example,
      consider what happens if we try to memoize the function defined
      previously.</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/value_restriction.topscript">OCaml utop</ulink>
      (part 2)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">memoize (fun x -&gt; [x;x]);;</userinput>
<computeroutput moreinfo="none">- : '_a -&gt; '_a list = &lt;fun&gt;</computeroutput></programlisting>

      <para>The memoized version of the function does in fact need to be
      restricted to a single type because it uses mutable state behind the
      scenes to cache values returned by previous invocations of the function.
      But OCaml would make the same determination even if the function in
      question did no such thing. Consider this example:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/value_restriction.topscript">OCaml utop</ulink>
      (part 3)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">identity (fun x -&gt; [x;x]);;</userinput>
<computeroutput moreinfo="none">- : '_a -&gt; '_a list = &lt;fun&gt;</computeroutput></programlisting>

      <para>It would be safe to infer a fully polymorphic variable here, but
      because OCaml's type system doesn't distinguish between pure and impure
      functions, it can't separate those two cases.</para>

      <para>The value restriction doesn't require that there is no mutable
      state, only that there is no <emphasis>persistent</emphasis> mutable
      state that could share values between uses of the same function. Thus, a
      function that produces a fresh reference every time it's called can have
      a fully polymorphic type:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/value_restriction.topscript">OCaml utop</ulink>
      (part 4)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let f () = ref None;;</userinput>
<computeroutput moreinfo="none">val f : unit -&gt; 'a option ref = &lt;fun&gt;</computeroutput></programlisting>

      <para>But a function that has a mutable cache that persists across
      calls, like <literal>memoize</literal>, can only be weakly
      polymorphic.</para>
    </sect2>

    <sect2 id="partial-application-and-the-value-restriction">
      <title>Partial Application and the Value Restriction</title>

      <para>Most of the time, when the value restriction kicks in, it's for a
      good reason, i.e., it's because the value in question can actually only
      safely be used with a single type. But sometimes, the value restriction
      kicks in when you don't want it. The most common such case is partially
      applied functions. A partially applied function, like any function
      application, is not a simple value, and as such, functions created by
      partial application are sometimes less general than you might
      expect.<indexterm class="singular">
          <primary>partial application</primary>
        </indexterm></para>

      <para>Consider the <literal moreinfo="none">List.init</literal>
      function, which is used for creating lists where each element is created
      by calling a function on the index of that element:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/value_restriction.topscript">OCaml utop</ulink>
      (part 5)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">List.init;;</userinput>
<computeroutput moreinfo="none">- : int -&gt; f:(int -&gt; 'a) -&gt; 'a list = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">List.init 10 ~f:Int.to_string;;</userinput>
<computeroutput moreinfo="none">- : string list = ["0"; "1"; "2"; "3"; "4"; "5"; "6"; "7"; "8"; "9"]</computeroutput></programlisting>

      <para>Imagine we wanted to create a specialized version of <literal moreinfo="none">List.init</literal> that always created lists of length
      10. We could do that using partial application, as follows:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/value_restriction.topscript">OCaml utop</ulink>
      (part 6)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let list_init_10 = List.init 10;;</userinput>
<computeroutput moreinfo="none">val list_init_10 : f:(int -&gt; '_a) -&gt; '_a list = &lt;fun&gt;</computeroutput></programlisting>

      <para>As you can see, we now infer a weakly polymorphic type for the
      resulting function. That's because there's nothing that guarantees that
      <literal moreinfo="none">List.init</literal> isn't creating a persistent
      <literal moreinfo="none">ref</literal> somewhere inside of it that would
      be shared across multiple calls to <literal moreinfo="none">list_init_10</literal>. We can eliminate this
      possibility, and at the same time get the compiler to infer a
      polymorphic type, by avoiding partial application:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/value_restriction.topscript">OCaml utop</ulink>
      (part 7)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let list_init_10 ~f = List.init 10 ~f;;</userinput>
<computeroutput moreinfo="none">val list_init_10 : f:(int -&gt; 'a) -&gt; 'a list = &lt;fun&gt;</computeroutput></programlisting>

      <para>This transformation is referred to as <emphasis>eta
      expansion</emphasis> and is often useful to resolve problems that arise
      from the value restriction.</para>
    </sect2>

    <sect2 id="relaxing-the-value-restriction">
      <title>Relaxing the Value Restriction</title>

      <para>OCaml is actually a little better at inferring polymorphic types
      than was suggested previously. The value restriction as we described it
      is basically a syntactic check: you can do a few operations that count
      as simple values, and anything that's a simple value can be
      generalized.</para>

      <para>But OCaml actually has a relaxed version of the value restriction that can make use of
        type information to allow polymorphic types for things that are not simple values.</para>

      <para>For example, we saw that a function application, even a simple
      application of the identity function, is not a simple value and thus can
      turn a polymorphic value into a weakly polymorphic one:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/value_restriction.topscript">OCaml utop</ulink>
      (part 8)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">identity (fun x -&gt; [x;x]);;</userinput>
<computeroutput moreinfo="none">- : '_a -&gt; '_a list = &lt;fun&gt;</computeroutput></programlisting>

      <para>But that's not always the case. When the type of the returned
      value is immutable, then OCaml can typically infer a fully polymorphic
      type:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/value_restriction.topscript">OCaml utop</ulink>
      (part 9)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">identity [];;</userinput>
<computeroutput moreinfo="none">- : 'a list = []</computeroutput></programlisting>

      <para>On the other hand, if the returned type is potentially mutable,
      then the result will be weakly polymorphic:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/value_restriction.topscript">OCaml utop</ulink>
      (part 10)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">[||];;</userinput>
<computeroutput moreinfo="none">- : 'a array = [||]</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">identity [||];;</userinput>
<computeroutput moreinfo="none">- : '_a array = [||]</computeroutput></programlisting>

      <para>A more important example of this comes up when defining abstract
      data types. Consider the following simple data structure for an
      immutable list type that supports constant-time concatenation:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/value_restriction.topscript">OCaml utop</ulink>
      (part 11)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">module Concat_list : sig</userinput>
<userinput moreinfo="none">    type 'a t</userinput>
<userinput moreinfo="none">    val empty : 'a t</userinput>
<userinput moreinfo="none">    val singleton : 'a -&gt; 'a t</userinput>
<userinput moreinfo="none">    val concat  : 'a t -&gt; 'a t -&gt; 'a t  (* constant time *)</userinput>
<userinput moreinfo="none">    val to_list : 'a t -&gt; 'a list       (* linear time   *)</userinput>
<userinput moreinfo="none">  end = struct</userinput>
<userinput moreinfo="none"/>
<userinput moreinfo="none">    type 'a t = Empty | Singleton of 'a | Concat of 'a t * 'a t</userinput>
<userinput moreinfo="none"/>
<userinput moreinfo="none">    let empty = Empty</userinput>
<userinput moreinfo="none">    let singleton x = Singleton x</userinput>
<userinput moreinfo="none">    let concat x y = Concat (x,y)</userinput>
<userinput moreinfo="none"/>
<userinput moreinfo="none">    let rec to_list_with_tail t tail =</userinput>
<userinput moreinfo="none">      match t with</userinput>
<userinput moreinfo="none">      | Empty -&gt; tail</userinput>
<userinput moreinfo="none">      | Singleton x -&gt; x :: tail</userinput>
<userinput moreinfo="none">      | Concat (x,y) -&gt; to_list_with_tail x (to_list_with_tail y tail)</userinput>
<userinput moreinfo="none"/>
<userinput moreinfo="none">    let to_list t =</userinput>
<userinput moreinfo="none">      to_list_with_tail t []</userinput>
<userinput moreinfo="none"/>
<userinput moreinfo="none">  end;;</userinput>
<computeroutput moreinfo="none">module Concat_list :</computeroutput>
<computeroutput moreinfo="none">  sig</computeroutput>
<computeroutput moreinfo="none">    type 'a t</computeroutput>
<computeroutput moreinfo="none">    val empty : 'a t</computeroutput>
<computeroutput moreinfo="none">    val singleton : 'a -&gt; 'a t</computeroutput>
<computeroutput moreinfo="none">    val concat : 'a t -&gt; 'a t -&gt; 'a t</computeroutput>
<computeroutput moreinfo="none">    val to_list : 'a t -&gt; 'a list</computeroutput>
<computeroutput moreinfo="none">  end</computeroutput></programlisting>

      <para>The details of the implementation don't matter so much, but it's
      important to note that a <literal moreinfo="none">Concat_list.t</literal> is unquestionably an immutable
      value. However, when it comes to the value restriction, OCaml treats it
      as if it were mutable:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/value_restriction.topscript">OCaml utop</ulink>
      (part 12)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">Concat_list.empty;;</userinput>
<computeroutput moreinfo="none">- : 'a Concat_list.t = &lt;abstr&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">identity Concat_list.empty;;</userinput>
<computeroutput moreinfo="none">- : '_a Concat_list.t = &lt;abstr&gt;</computeroutput></programlisting>

      <para>The issue here is that the signature, by virtue of being abstract,
      has obscured the fact that <literal moreinfo="none">Concat_list.t</literal> is in fact an immutable data
      type. We can resolve this in one of two ways: either by making the type
      concrete (i.e., exposing the implementation in the <literal moreinfo="none">mli</literal>), which is often not desirable; or by
      marking the type variable in question as <emphasis>covariant</emphasis>.
      We'll learn more about covariance and contravariance in <xref linkend="objects"/>, but for now, you can think of it as an annotation
      that can be put in the interface of a pure data structure.<indexterm class="singular">
          <primary>datatypes</primary>

          <secondary>covariant</secondary>
        </indexterm></para>

      <para>In particular, if we replace <literal moreinfo="none">type 'a
      t</literal> in the interface with <literal moreinfo="none">type +'a
      t</literal>, that will make it explicit in the interface that the data
      structure doesn't contain any persistent references to values of type
      <literal moreinfo="none">'a</literal>, at which point, OCaml can infer
      polymorphic types for expressions of this type that are not simple
      values:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/value_restriction-13.rawscript">OCaml utop</ulink></para>

      <programlisting format="linespecific" language="ocaml"><userinput moreinfo="none"># module Concat_list : sig
    type +'a t
    val empty : 'a t
    val singleton : 'a -&gt; 'a t
    val concat  : 'a t -&gt; 'a t -&gt; 'a t  (* constant time *)
    val to_list : 'a t -&gt; 'a list       (* linear time   *)
  end = struct

    type 'a t = Empty | Singleton of 'a | Concat of 'a t * 'a t

    ...

  end;;</userinput>
<computeroutput moreinfo="none"> module Concat_list :
  sig
    type '+a t
    val empty : 'a t
    val singleton : 'a -&gt; 'a t
    val concat : 'a t -&gt; 'a t -&gt; 'a t
    val to_list : 'a t -&gt; 'a list
  end</computeroutput></programlisting>

      <para>Now, we can apply the identity function to <literal moreinfo="none">Concat_list.empty</literal> without without losing any
      polymorphism:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/value_restriction.topscript">OCaml utop</ulink>
      (part 14)<indexterm class="endofrange" startref="IPsideweak"/></para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">identity Concat_list.empty;;</userinput>
<computeroutput moreinfo="none">- : 'a Concat_list.t = &lt;abstr&gt;</computeroutput></programlisting>
    </sect2>
  </sect1>

  <sect1 id="summary">
    <title>Summary</title>

    <para>This chapter has covered quite a lot of ground, including:<indexterm class="singular">
        <primary>imperative programming</primary>

        <secondary>overview of</secondary>
      </indexterm></para>

    <itemizedlist>
      <listitem>
        <para>Discussing the building blocks of mutable data structures as
        well as the basic imperative constructs like <literal moreinfo="none">for</literal> loops, <literal moreinfo="none">while</literal> loops, and the sequencing operator
        <literal moreinfo="none">;</literal></para>
      </listitem>

      <listitem>
        <para>Walking through the implementation of a couple of classic
        imperative data structures</para>
      </listitem>

      <listitem>
        <para>Discussing so-called benign effects like memoization and
        laziness</para>
      </listitem>

      <listitem>
        <para>Covering OCaml's API for blocking I/O</para>
      </listitem>

      <listitem>
        <para>Discussing how language-level issues like order of evaluation
        and weak polymorphism interact with OCaml's imperative features</para>
      </listitem>
    </itemizedlist>

    <para>The scope and sophistication of the material here is an indication
    of the importance of OCaml's imperative features. The fact that OCaml
    defaults to immutability shouldn't obscure the fact that imperative
    programming is a fundamental part of building any serious application, and
    that if you want to be an effective OCaml programmer, you need to
    understand OCaml's approach to imperative programming.<indexterm class="endofrange" startref="PROGimper"/></para>
  </sect1>
</chapter>

  <chapter id="functors">
  <title>Functors</title>

  <para>Up until now, we've seen OCaml's modules play an important but limited
  role. In particular, we've seen them as a mechanism for organizing code into
  units with specified interfaces. But OCaml's module system can do much more
  than that, serving as a powerful tool for building generic code and
  structuring large-scale systems. Much of that power comes from
  functors.<indexterm class="singular">
      <primary>functors</primary>

      <secondary>benefits of</secondary>
    </indexterm></para>

  <para>Functors are, roughly speaking, functions from modules to modules, and
  they can be used to solve a variety of code-structuring problems,
  including:</para>

  <para><variablelist>
      <varlistentry>
        <term>Dependency injection</term>

        <listitem>
          <para>Makes the implementations of some components of a system
          swappable. This is particularly useful when you want to mock up
          parts of your system for testing and simulation purposes.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>Autoextension of modules</term>

        <listitem>
          <para>Functors give you a way of extending existing modules with new
          functionality in a standardized way. For example, you might want to
          add a slew of comparison operators derived from a base comparison
          function. To do this by hand would require a lot of repetitive code
          for each type, but functors let you write this logic just once and
          apply it to many different types.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>Instantiating modules with state</term>

        <listitem>
          <para>Modules can contain mutable states, and that means that you'll
          occasionally want to have multiple instantiations of a particular
          module, each with its own separate and independent mutable state.
          Functors let you automate the construction of such modules.</para>
        </listitem>
      </varlistentry>
    </variablelist></para>

  <para>These are really just some of the uses that you can put functors to.
  We'll make no attempt to provide examples of all of the uses of functors
  here. Instead, this chapter will try to provide examples that illuminate the
  language features and design patterns that you need to master in order to
  use functors effectively.</para>

  <sect1 id="a-trivial-example">
    <title>A Trivial Example</title>

    <para>Let's create a functor that takes a module containing a single
    integer variable <literal moreinfo="none">x</literal> and returns a new
    module with <literal moreinfo="none">x</literal> incremented by one. This
    is intended to serve as a way to walk through the basic mechanics of
    functors, even though it's not something you'd want to do in
    practice.<indexterm class="singular">
        <primary>functors</primary>

        <secondary>basic mechanics of</secondary>
      </indexterm></para>

    <para>First, let's define a signature for a module that contains a single
    value of type <literal moreinfo="none">int</literal>:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/functors/main.topscript">OCaml utop</ulink></para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">module type X_int = sig val x : int end;;</userinput>
<computeroutput moreinfo="none">module type X_int = sig val x : int end</computeroutput></programlisting>

    <para>Now we can define our functor. We'll use <literal moreinfo="none">X_int</literal> both to constrain the argument to the
    functor and to constrain the module returned by the functor:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/functors/main.topscript">OCaml utop</ulink>
    (part 1)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">module Increment (M : X_int) : X_int = struct</userinput>
<userinput moreinfo="none">    let x = M.x + 1</userinput>
<userinput moreinfo="none">  end;;</userinput>
<computeroutput moreinfo="none">module Increment : functor (M : X_int) -&gt; X_int</computeroutput></programlisting>

    <para>One thing that immediately jumps out is that functors are more
    syntactically heavyweight than ordinary functions. For one thing, functors
    require explicit (module) type annotations, which ordinary functions do
    not. Technically, only the type on the input is mandatory, although in
    practice, you should usually constrain the module returned by the functor,
    just as you should use an <literal moreinfo="none">mli</literal>, even
    though it's not mandatory.</para>

    <para>The following shows what happens when we omit the module type for
    the output of the functor:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/functors/main.topscript">OCaml utop</ulink>
    (part 2)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">module Increment (M : X_int) = struct</userinput>
<userinput moreinfo="none">    let x = M.x + 1</userinput>
<userinput moreinfo="none">  end;;</userinput>
<computeroutput moreinfo="none">module Increment : functor (M : X_int) -&gt; sig val x : int end</computeroutput></programlisting>

    <para>We can see that the inferred module type of the output is now
    written out explicitly, rather than being a reference to the named
    signature <literal moreinfo="none">X_int</literal>.</para>

    <para>We can use <literal moreinfo="none">Increment</literal> to define
    new modules:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/functors/main.topscript">OCaml utop</ulink>
    (part 3)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">module Three = struct let x = 3 end;;</userinput>
<computeroutput moreinfo="none">module Three : sig val x : int end</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">module Four = Increment(Three);;</userinput>
<computeroutput moreinfo="none">module Four : sig val x : int end</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Four.x - Three.x;;</userinput>
<computeroutput moreinfo="none">- : int = 1</computeroutput></programlisting>

    <para>In this case, we applied <literal moreinfo="none">Increment</literal> to a module whose signature is exactly
    equal to <literal moreinfo="none">X_int</literal>. But we can apply
    <literal moreinfo="none">Increment</literal> to any module that
    <emphasis>satisfies</emphasis> the interface <literal moreinfo="none">X_int</literal>, in the same way that the contents of an
    <literal moreinfo="none">ml</literal> file must satisfy the <literal moreinfo="none">mli</literal>. That means that the module type can omit
    some information available in the module, either by dropping fields or by
    leaving some fields abstract. Here's an example:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/functors/main.topscript">OCaml utop</ulink>
    (part 4)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">module Three_and_more = struct</userinput>
<userinput moreinfo="none">    let x = 3</userinput>
<userinput moreinfo="none">    let y = "three"</userinput>
<userinput moreinfo="none">  end;;</userinput>
<computeroutput moreinfo="none">module Three_and_more : sig val x : int val y : string end</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">module Four = Increment(Three_and_more);;</userinput>
<computeroutput moreinfo="none">module Four : sig val x : int end</computeroutput></programlisting>

    <para>The rules for determining whether a module matches a given signature
    are similar in spirit to the rules in an object-oriented language that
    determine whether an object satisfies a given interface. As in an
    object-oriented context, the extra information that doesn't match the
    signature you're looking for (in this case, the variable <literal moreinfo="none">y</literal>) is simply ignored.</para>
  </sect1>

  <sect1 id="a-bigger-example-computing-with-intervals">
    <title>A Bigger Example: Computing with Intervals</title>

    <para>Let's consider a more realistic example of how to use functors: a
    library for computing with intervals. Intervals are a common computational
    object, and they come up in different contexts and for different types.
    You might need to work with intervals of floating-point values or strings
    or times, and in each of these cases, you want similar operations: testing
    for emptiness, checking for containment, intersecting intervals, and so
    on.</para>

    <para>Let's see how to use functors to build a generic interval library
    that can be used with any type that supports a total ordering on the
    underlying set over which you want to build intervals.<indexterm class="singular">
        <primary>interval computation</primary>

        <secondary>generic library for</secondary>
      </indexterm><indexterm class="startofrange" id="FUNCTinterv">
        <primary>functors</primary>

        <secondary>interval computation with</secondary>
      </indexterm></para>

    <para>First we'll define a module type that captures the information we'll
    need about the endpoints of the intervals. This interface, which we'll
    call <literal moreinfo="none">Comparable</literal>, contains just two
    things: a comparison function and the type of the values to be
    compared:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/functors/main.topscript">OCaml utop</ulink>
    (part 5)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">module type Comparable = sig</userinput>
<userinput moreinfo="none">    type t</userinput>
<userinput moreinfo="none">    val compare : t -&gt; t -&gt; int</userinput>
<userinput moreinfo="none">  end ;;</userinput>
<computeroutput moreinfo="none">module type Comparable = sig type t val compare : t -&gt; t -&gt; int end</computeroutput></programlisting>

    <para>The comparison function follows the standard OCaml idiom for such
    functions, returning <literal moreinfo="none">0</literal> if the two
    elements are equal, a positive number if the first element is larger than
    the second, and a negative number if the first element is smaller than the
    second. Thus, we could rewrite the standard comparison functions on top of
    <literal moreinfo="none">compare</literal>.</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/functors/compare_example.ml">OCaml</ulink></para>

    <programlisting format="linespecific" language="ocaml">compare x y &lt; 0     (* x &lt; y *)
compare x y = 0     (* x = y *)
compare x y &gt; 0     (* x &gt; y *)</programlisting>

    <para>(This idiom is a bit of a historical error. It would be better if
        <literal>compare</literal> returned a variant with three cases for less than, greater than,
      and equal. But it's a well-established idiom at this point, and unlikely to change.)</para>

    <para>The functor for creating the interval module follows. We represent an interval with a
      variant type, which is either <literal moreinfo="none">Empty</literal> or <literal moreinfo="none">Interval (x,y)</literal>, where <literal moreinfo="none">x</literal> and
        <literal moreinfo="none">y</literal> are the bounds of the interval. In addition to the
      type, the body of the functor contains implementations of a number of useful primitives for
      interacting with intervals:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/functors/main.topscript">OCaml utop</ulink>
    (part 6)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">module Make_interval(Endpoint : Comparable) = struct</userinput>
<userinput moreinfo="none"/>
<userinput moreinfo="none">    type t = | Interval of Endpoint.t * Endpoint.t</userinput>
<userinput moreinfo="none">             | Empty</userinput>
<userinput moreinfo="none"/>
<userinput moreinfo="none">    (** [create low high] creates a new interval from [low] to</userinput>
<userinput moreinfo="none">        [high].  If [low &gt; high], then the interval is empty *)</userinput>
<userinput moreinfo="none">    let create low high =</userinput>
<userinput moreinfo="none">      if Endpoint.compare low high &gt; 0 then Empty</userinput>
<userinput moreinfo="none">      else Interval (low,high)</userinput>
<userinput moreinfo="none"/>
<userinput moreinfo="none">    (** Returns true iff the interval is empty *)</userinput>
<userinput moreinfo="none">    let is_empty = function</userinput>
<userinput moreinfo="none">      | Empty -&gt; true</userinput>
<userinput moreinfo="none">      | Interval _ -&gt; false</userinput>
<userinput moreinfo="none"/>
<userinput moreinfo="none">    (** [contains t x] returns true iff [x] is contained in the</userinput>
<userinput moreinfo="none">        interval [t] *)</userinput>
<userinput moreinfo="none">    let contains t x =</userinput>
<userinput moreinfo="none">      match t with</userinput>
<userinput moreinfo="none">      | Empty -&gt; false</userinput>
<userinput moreinfo="none">      | Interval (l,h) -&gt;</userinput>
<userinput moreinfo="none">        Endpoint.compare x l &gt;= 0 &amp;&amp; Endpoint.compare x h &lt;= 0</userinput>
<userinput moreinfo="none"/>
<userinput moreinfo="none">    (** [intersect t1 t2] returns the intersection of the two input</userinput>
<userinput moreinfo="none">        intervals *)</userinput>
<userinput moreinfo="none">    let intersect t1 t2 =</userinput>
<userinput moreinfo="none">      let min x y = if Endpoint.compare x y &lt;= 0 then x else y in</userinput>
<userinput moreinfo="none">      let max x y = if Endpoint.compare x y &gt;= 0 then x else y in</userinput>
<userinput moreinfo="none">      match t1,t2 with</userinput>
<userinput moreinfo="none">      | Empty, _ | _, Empty -&gt; Empty</userinput>
<userinput moreinfo="none">      | Interval (l1,h1), Interval (l2,h2) -&gt;</userinput>
<userinput moreinfo="none">        create (max l1 l2) (min h1 h2)</userinput>
<userinput moreinfo="none"/>
<userinput moreinfo="none">  end ;;</userinput>
<computeroutput moreinfo="none">module Make_interval :</computeroutput>
<computeroutput moreinfo="none">  functor (Endpoint : Comparable) -&gt;</computeroutput>
<computeroutput moreinfo="none">    sig</computeroutput>
<computeroutput moreinfo="none">      type t = Interval of Endpoint.t * Endpoint.t | Empty</computeroutput>
<computeroutput moreinfo="none">      val create : Endpoint.t -&gt; Endpoint.t -&gt; t</computeroutput>
<computeroutput moreinfo="none">      val is_empty : t -&gt; bool</computeroutput>
<computeroutput moreinfo="none">      val contains : t -&gt; Endpoint.t -&gt; bool</computeroutput>
<computeroutput moreinfo="none">      val intersect : t -&gt; t -&gt; t</computeroutput>
<computeroutput moreinfo="none">    end</computeroutput></programlisting>

    <para>We can instantiate the functor by applying it to a module with the
    right signature. In the following code, rather than name the module first
    and then call the functor, we provide the functor input as an anonymous
    module:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/functors/main.topscript">OCaml utop</ulink>
    (part 7)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">module Int_interval =</userinput>
<userinput moreinfo="none">    Make_interval(struct</userinput>
<userinput moreinfo="none">      type t = int</userinput>
<userinput moreinfo="none">      let compare = Int.compare</userinput>
<userinput moreinfo="none">    end);;</userinput>
<computeroutput moreinfo="none">module Int_interval :</computeroutput>
<computeroutput moreinfo="none">  sig</computeroutput>
<computeroutput moreinfo="none">    type t = Interval of int * int | Empty</computeroutput>
<computeroutput moreinfo="none">    val create : int -&gt; int -&gt; t</computeroutput>
<computeroutput moreinfo="none">    val is_empty : t -&gt; bool</computeroutput>
<computeroutput moreinfo="none">    val contains : t -&gt; int -&gt; bool</computeroutput>
<computeroutput moreinfo="none">    val intersect : t -&gt; t -&gt; t</computeroutput>
<computeroutput moreinfo="none">  end</computeroutput></programlisting>

    <para>If the input interface for your functor is aligned with the
    standards of the libraries you use, then you don't need to construct a
    custom module to feed to the functor. In this case, we can directly use
    the <literal moreinfo="none">Int</literal> or <literal moreinfo="none">String</literal> modules provided by Core:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/functors/main.topscript">OCaml utop</ulink>
    (part 8)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">module Int_interval = Make_interval(Int) ;;</userinput>
<computeroutput moreinfo="none">module Int_interval :</computeroutput>
<computeroutput moreinfo="none">  sig</computeroutput>
<computeroutput moreinfo="none">    type t = Make_interval(Core.Std.Int).t = Interval of int * int | Empty</computeroutput>
<computeroutput moreinfo="none">    val create : int -&gt; int -&gt; t</computeroutput>
<computeroutput moreinfo="none">    val is_empty : t -&gt; bool</computeroutput>
<computeroutput moreinfo="none">    val contains : t -&gt; int -&gt; bool</computeroutput>
<computeroutput moreinfo="none">    val intersect : t -&gt; t -&gt; t</computeroutput>
<computeroutput moreinfo="none">  end</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">module String_interval = Make_interval(String) ;;</userinput>
<computeroutput moreinfo="none">module String_interval :</computeroutput>
<computeroutput moreinfo="none">  sig</computeroutput>
<computeroutput moreinfo="none">    type t =</computeroutput>
<computeroutput moreinfo="none">      Make_interval(Core.Std.String).t =</computeroutput>
<computeroutput moreinfo="none">        Interval of string * string</computeroutput>
<computeroutput moreinfo="none">      | Empty</computeroutput>
<computeroutput moreinfo="none">    val create : string -&gt; string -&gt; t</computeroutput>
<computeroutput moreinfo="none">    val is_empty : t -&gt; bool</computeroutput>
<computeroutput moreinfo="none">    val contains : t -&gt; string -&gt; bool</computeroutput>
<computeroutput moreinfo="none">    val intersect : t -&gt; t -&gt; t</computeroutput>
<computeroutput moreinfo="none">  end</computeroutput></programlisting>

    <para>This works because many modules in Core, including <literal moreinfo="none">Int</literal>
      and <literal moreinfo="none">String</literal>, satisfy an extended version of the <literal moreinfo="none">Comparable</literal> signature described previously. Such standardized
      signatures are good practice, both because they make functors easier to use, and because they
      encourage standardization that makes your codebase easier to navigate.</para>

    <para>We can use the newly defined <literal moreinfo="none">Int_interval</literal> module like
      any ordinary module:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/functors/main.topscript">OCaml utop</ulink>
    (part 9)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let i1 = Int_interval.create 3 8;;</userinput>
<computeroutput moreinfo="none">val i1 : Int_interval.t = Int_interval.Interval (3, 8)</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let i2 = Int_interval.create 4 10;;</userinput>
<computeroutput moreinfo="none">val i2 : Int_interval.t = Int_interval.Interval (4, 10)</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Int_interval.intersect i1 i2;;</userinput>
<computeroutput moreinfo="none">- : Int_interval.t = Int_interval.Interval (4, 8)</computeroutput></programlisting>

    <para>This design gives us the freedom to use any comparison function we
    want for comparing the endpoints. We could, for example, create a type of
    integer interval with the order of the comparison reversed, as
    follows:<indexterm class="singular">
        <primary>interval computation</primary>

        <secondary>comparison function for</secondary>
      </indexterm></para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/functors/main.topscript">OCaml utop</ulink>
    (part 10)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">module Rev_int_interval =</userinput>
<userinput moreinfo="none">    Make_interval(struct</userinput>
<userinput moreinfo="none">      type t = int</userinput>
<userinput moreinfo="none">      let compare x y = Int.compare y x</userinput>
<userinput moreinfo="none">    end);;</userinput>
<computeroutput moreinfo="none">module Rev_int_interval :</computeroutput>
<computeroutput moreinfo="none">  sig</computeroutput>
<computeroutput moreinfo="none">    type t = Interval of int * int | Empty</computeroutput>
<computeroutput moreinfo="none">    val create : int -&gt; int -&gt; t</computeroutput>
<computeroutput moreinfo="none">    val is_empty : t -&gt; bool</computeroutput>
<computeroutput moreinfo="none">    val contains : t -&gt; int -&gt; bool</computeroutput>
<computeroutput moreinfo="none">    val intersect : t -&gt; t -&gt; t</computeroutput>
<computeroutput moreinfo="none">  end</computeroutput></programlisting>

    <para>The behavior of <literal moreinfo="none">Rev_int_interval</literal>
    is of course different from <literal moreinfo="none">Int_interval</literal>:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/functors/main.topscript">OCaml utop</ulink>
    (part 11)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let interval = Int_interval.create 4 3;;</userinput>
<computeroutput moreinfo="none">val interval : Int_interval.t = Int_interval.Empty</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let rev_interval = Rev_int_interval.create 4 3;;</userinput>
<computeroutput moreinfo="none">val rev_interval : Rev_int_interval.t = Rev_int_interval.Interval (4, 3)</computeroutput></programlisting>

    <para>Importantly, <literal moreinfo="none">Rev_int_interval.t</literal>
    is a different type than <literal moreinfo="none">Int_interval.t</literal>, even though its physical
    representation is the same. Indeed, the type system will prevent us from
    confusing them.</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/functors/main.topscript">OCaml utop</ulink>
    (part 12)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">Int_interval.contains rev_interval 3;;</userinput>
<computeroutput moreinfo="none">Characters 22-34:</computeroutput>
<computeroutput moreinfo="none">Error: This expression has type Rev_int_interval.t</computeroutput>
<computeroutput moreinfo="none">       but an expression was expected of type Int_interval.t</computeroutput></programlisting>

    <para>This is important, because confusing the two kinds of intervals
    would be a semantic error, and it's an easy one to make. The ability of
    functors to mint new types is a useful trick that comes up a lot.</para>

    <sect2 id="making-the-functor-abstract">
      <title>Making the Functor Abstract</title>

      <para>There's a problem with <literal moreinfo="none">Make_interval</literal>. The code we wrote depends on
      the invariant that the upper bound of an interval is greater than its
      lower bound, but that invariant can be violated. The invariant is
      enforced by the <literal>create</literal> function, but because <literal moreinfo="none">Interval.t</literal> is not abstract, we can bypass the
      <literal moreinfo="none">create</literal> function:<indexterm class="singular">
          <primary>interval computation</primary>

          <secondary>abstract functor for</secondary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/functors/main.topscript">OCaml utop</ulink>
      (part 13)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">Int_interval.is_empty (* going through create *)</userinput>
<userinput moreinfo="none">    (Int_interval.create 4 3) ;;</userinput>
<computeroutput moreinfo="none">- : bool = true</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Int_interval.is_empty (* bypassing create *)</userinput>
<userinput moreinfo="none">    (Int_interval.Interval (4,3)) ;;</userinput>
<computeroutput moreinfo="none">- : bool = false</computeroutput></programlisting>

      <para>To make <literal moreinfo="none">Int_interval.t</literal>
      abstract, we need to restrict the output of <literal moreinfo="none">Make_interval</literal> with an interface. Here's an
      explicit interface that we can use for that purpose:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/functors/main.topscript">OCaml utop</ulink>
      (part 14)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">module type Interval_intf = sig</userinput>
<userinput moreinfo="none">   type t</userinput>
<userinput moreinfo="none">   type endpoint</userinput>
<userinput moreinfo="none">   val create : endpoint -&gt; endpoint -&gt; t</userinput>
<userinput moreinfo="none">   val is_empty : t -&gt; bool</userinput>
<userinput moreinfo="none">   val contains : t -&gt; endpoint -&gt; bool</userinput>
<userinput moreinfo="none">   val intersect : t -&gt; t -&gt; t</userinput>
<userinput moreinfo="none">  end;;</userinput>
<computeroutput moreinfo="none">module type Interval_intf =</computeroutput>
<computeroutput moreinfo="none">  sig</computeroutput>
<computeroutput moreinfo="none">    type t</computeroutput>
<computeroutput moreinfo="none">    type endpoint</computeroutput>
<computeroutput moreinfo="none">    val create : endpoint -&gt; endpoint -&gt; t</computeroutput>
<computeroutput moreinfo="none">    val is_empty : t -&gt; bool</computeroutput>
<computeroutput moreinfo="none">    val contains : t -&gt; endpoint -&gt; bool</computeroutput>
<computeroutput moreinfo="none">    val intersect : t -&gt; t -&gt; t</computeroutput>
<computeroutput moreinfo="none">  end</computeroutput></programlisting>

      <para>This interface includes the type <literal moreinfo="none">endpoint</literal> to give us a way of referring to the
      endpoint type. Given this interface, we can redo our definition of
      <literal moreinfo="none">Make_interval</literal>. Notice that we added
      the type <literal moreinfo="none">endpoint</literal> to the
      implementation of the module to match <literal moreinfo="none">Interval_intf</literal>:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/functors/main-15.rawscript">OCaml utop</ulink></para>

      <programlisting format="linespecific" language="ocaml"><userinput moreinfo="none"># module Make_interval(Endpoint : Comparable) : Interval_intf = struct
    type endpoint = Endpoint.t
    type t = | Interval of Endpoint.t * Endpoint.t
             | Empty

    ...

  end ;;</userinput>
<computeroutput moreinfo="none">  module Make_interval : functor (Endpoint : Comparable) -&gt; Interval_intf</computeroutput></programlisting>
    </sect2>

    <sect2 id="sharing-constraints">
      <title>Sharing Constraints</title>

      <para>The resulting module is abstract, but it's unfortunately too
      abstract. In particular, we haven't exposed the type <literal moreinfo="none">endpoint</literal>, which means that we can't even
      construct an interval anymore:<indexterm class="singular">
          <primary>sharing constraint</primary>
        </indexterm><indexterm class="singular">
          <primary>interval computation</primary>

          <secondary>sharing constraints</secondary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/functors/main.topscript">OCaml utop</ulink>
      (part 16)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">module Int_interval = Make_interval(Int);;</userinput>
<computeroutput moreinfo="none">module Int_interval :</computeroutput>
<computeroutput moreinfo="none">  sig</computeroutput>
<computeroutput moreinfo="none">    type t = Make_interval(Core.Std.Int).t</computeroutput>
<computeroutput moreinfo="none">    type endpoint = Make_interval(Core.Std.Int).endpoint</computeroutput>
<computeroutput moreinfo="none">    val create : endpoint -&gt; endpoint -&gt; t</computeroutput>
<computeroutput moreinfo="none">    val is_empty : t -&gt; bool</computeroutput>
<computeroutput moreinfo="none">    val contains : t -&gt; endpoint -&gt; bool</computeroutput>
<computeroutput moreinfo="none">    val intersect : t -&gt; t -&gt; t</computeroutput>
<computeroutput moreinfo="none">  end</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Int_interval.create 3 4;;</userinput>
<computeroutput moreinfo="none">Characters 20-21:</computeroutput>
<computeroutput moreinfo="none">Error: This expression has type int but an expression was expected of type</computeroutput>
<computeroutput moreinfo="none">         Int_interval.endpoint</computeroutput></programlisting>

      <para>To fix this, we need to expose the fact that <literal moreinfo="none">endpoint</literal> is equal to <literal moreinfo="none">Int.t</literal> (or more generally, <literal moreinfo="none">Endpoint.t</literal>, where <literal moreinfo="none">Endpoint</literal> is the argument to the functor). One
      way of doing this is through a <emphasis>sharing constraint</emphasis>,
      which allows you to tell the compiler to expose the fact that a given
      type is equal to some other type. The syntax for a simple sharing
      constraint is as follows:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/functors/sharing_constraint.syntax">Syntax</ulink></para>

      <programlisting format="linespecific" language="ocaml"><emphasis>&lt;Module_type&gt;</emphasis> with type <emphasis>&lt;type&gt;</emphasis> = <emphasis>&lt;type'&gt;</emphasis></programlisting>

      <para>The result of this expression is a new signature that's been modified so that it exposes
        the fact that <emphasis><literal moreinfo="none">type</literal></emphasis> defined inside of
        the module type is equal to <emphasis><literal moreinfo="none">type'</literal></emphasis>
        whose definition is outside of it. One can also apply multiple sharing constraints to the
        same signature:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/functors/multi_sharing_constraint.syntax">Syntax</ulink></para>

      <programlisting format="linespecific" language="ocaml"><emphasis>&lt;Module_type&gt;</emphasis> with type <emphasis>&lt;type1&gt;</emphasis> = <emphasis>&lt;type1'&gt;</emphasis> and <emphasis>&lt;type2&gt;</emphasis> = <emphasis>&lt;type2'&gt;</emphasis></programlisting>

      <para>We can use a sharing constraint to create a specialized version of
      <literal moreinfo="none">Interval_intf</literal> for integer
      intervals:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/functors/main.topscript">OCaml utop</ulink>
      (part 17)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">module type Int_interval_intf =</userinput>
<userinput moreinfo="none">    Interval_intf with type endpoint = int;;</userinput>
<computeroutput moreinfo="none">module type Int_interval_intf =</computeroutput>
<computeroutput moreinfo="none">  sig</computeroutput>
<computeroutput moreinfo="none">    type t</computeroutput>
<computeroutput moreinfo="none">    type endpoint = int</computeroutput>
<computeroutput moreinfo="none">    val create : endpoint -&gt; endpoint -&gt; t</computeroutput>
<computeroutput moreinfo="none">    val is_empty : t -&gt; bool</computeroutput>
<computeroutput moreinfo="none">    val contains : t -&gt; endpoint -&gt; bool</computeroutput>
<computeroutput moreinfo="none">    val intersect : t -&gt; t -&gt; t</computeroutput>
<computeroutput moreinfo="none">  end</computeroutput></programlisting>

      <para>We can also use sharing constraints in the context of a functor.
      The most common use case is where you want to expose that some of the
      types of the module being generated by the functor are related to the
      types in the module fed to the functor.</para>

      <para>In this case, we'd like to expose an equality between the type
      <literal moreinfo="none">endpoint</literal> in the new module and the
      type <literal moreinfo="none">Endpoint.t</literal>, from the module
      <literal moreinfo="none">Endpoint</literal> that is the functor
      argument. We can do this as follows:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/functors/main-18.rawscript">OCaml utop</ulink></para>

      <programlisting format="linespecific" language="ocaml"><userinput moreinfo="none"># module Make_interval(Endpoint : Comparable)
      : (Interval_intf with type endpoint = Endpoint.t)
  = struct

    type endpoint = Endpoint.t
    type t = | Interval of Endpoint.t * Endpoint.t
             | Empty

    ...

  end ;;</userinput>
<computeroutput moreinfo="none">module Make_interval :
  functor (Endpoint : Comparable) -&gt;
    sig
      type t
      type endpoint = Endpoint.t
      val create : endpoint -&gt; endpoint -&gt; t
      val is_empty : t -&gt; bool
      val contains : t -&gt; endpoint -&gt; bool
      val intersect : t -&gt; t -&gt; t
    end</computeroutput></programlisting>

      <para>So now, the interface is as it was, except that <literal moreinfo="none">endpoint</literal> is known to be equal to <literal moreinfo="none">Endpoint.t</literal>.
        As a result of that type equality, we can again do things that require that <literal moreinfo="none">endpoint</literal> be exposed, like constructing intervals:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/functors/main.topscript">OCaml utop</ulink>
      (part 19)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">module Int_interval = Make_interval(Int);;</userinput>
<computeroutput moreinfo="none">module Int_interval :</computeroutput>
<computeroutput moreinfo="none">  sig</computeroutput>
<computeroutput moreinfo="none">    type t = Make_interval(Core.Std.Int).t</computeroutput>
<computeroutput moreinfo="none">    type endpoint = int</computeroutput>
<computeroutput moreinfo="none">    val create : endpoint -&gt; endpoint -&gt; t</computeroutput>
<computeroutput moreinfo="none">    val is_empty : t -&gt; bool</computeroutput>
<computeroutput moreinfo="none">    val contains : t -&gt; endpoint -&gt; bool</computeroutput>
<computeroutput moreinfo="none">    val intersect : t -&gt; t -&gt; t</computeroutput>
<computeroutput moreinfo="none">  end</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let i = Int_interval.create 3 4;;</userinput>
<computeroutput moreinfo="none">val i : Int_interval.t = &lt;abstr&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Int_interval.contains i 5;;</userinput>
<computeroutput moreinfo="none">- : bool = false</computeroutput></programlisting>
    </sect2>

    <sect2 id="destructive-substitution">
      <title>Destructive Substitution</title>

      <para>Sharing constraints basically do the job, but they have some
      downsides. In particular, we've now been stuck with the useless type
      declaration of <literal moreinfo="none">endpoint</literal> that clutters
      up both the interface and the implementation. A better solution would be
      to modify the <literal moreinfo="none">Interval_intf</literal> signature
      by replacing <literal moreinfo="none">endpoint</literal> with <literal moreinfo="none">Endpoint.t</literal> everywhere it shows up, and
      deleting the definition of <literal moreinfo="none">endpoint</literal>
      from the signature. We can do just this using what's called
      <emphasis>destructive substitution</emphasis>. Here's the basic
      syntax:<indexterm class="singular">
          <primary>destructive substitution</primary>
        </indexterm><indexterm class="singular">
          <primary>interval computation</primary>

          <secondary>destructive substitution</secondary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/functors/destructive_sub.syntax">Syntax</ulink></para>

      <programlisting format="linespecific" language="ocaml"><emphasis>&lt;Module_type&gt;</emphasis> with type <emphasis>&lt;type&gt;</emphasis> := <emphasis>&lt;type'&gt;</emphasis></programlisting>

      <para>The following shows how we could use this with <literal moreinfo="none">Make_interval</literal>:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/functors/main.topscript">OCaml utop</ulink>
      (part 20)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">module type Int_interval_intf =</userinput>
<userinput moreinfo="none">    Interval_intf with type endpoint := int;;</userinput>
<computeroutput moreinfo="none">module type Int_interval_intf =</computeroutput>
<computeroutput moreinfo="none">  sig</computeroutput>
<computeroutput moreinfo="none">    type t</computeroutput>
<computeroutput moreinfo="none">    val create : int -&gt; int -&gt; t</computeroutput>
<computeroutput moreinfo="none">    val is_empty : t -&gt; bool</computeroutput>
<computeroutput moreinfo="none">    val contains : t -&gt; int -&gt; bool</computeroutput>
<computeroutput moreinfo="none">    val intersect : t -&gt; t -&gt; t</computeroutput>
<computeroutput moreinfo="none">  end</computeroutput></programlisting>

      <para>There's now no <literal moreinfo="none">endpoint</literal> type:
      all of its occurrences of have been replaced by <literal moreinfo="none">int</literal>. As with sharing constraints, we can also
      use this in the context of a functor:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/functors/main-21.rawscript">OCaml utop</ulink></para>

      <programlisting format="linespecific" language="ocaml"><userinput moreinfo="none"># module Make_interval(Endpoint : Comparable)
    : Interval_intf with type endpoint := Endpoint.t =
  struct

    type t = | Interval of Endpoint.t * Endpoint.t
             | Empty

    ...

  end ;;</userinput>
<computeroutput moreinfo="none">  module Make_interval :
    functor (Endpoint : Comparable) -&gt;
    sig
      type t
      val create : Endpoint.t -&gt; Endpoint.t -&gt; t
      val is_empty : t -&gt; bool
      val contains : t -&gt; Endpoint.t -&gt; bool
      val intersect : t -&gt; t -&gt; t
    end</computeroutput></programlisting>

      <para>The interface is precisely what we want: the type <literal moreinfo="none">t</literal> is abstract, and the type of the endpoint is
      exposed; so we can create values of type <literal moreinfo="none">Int_interval.t</literal> using the creation function,
      but not directly using the constructors and thereby violating the
      invariants of the module:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/functors/main.topscript">OCaml utop</ulink>
      (part 22)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">module Int_interval = Make_interval(Int);;</userinput>
<computeroutput moreinfo="none">module Int_interval :</computeroutput>
<computeroutput moreinfo="none">  sig</computeroutput>
<computeroutput moreinfo="none">    type t = Make_interval(Core.Std.Int).t</computeroutput>
<computeroutput moreinfo="none">    val create : int -&gt; int -&gt; t</computeroutput>
<computeroutput moreinfo="none">    val is_empty : t -&gt; bool</computeroutput>
<computeroutput moreinfo="none">    val contains : t -&gt; int -&gt; bool</computeroutput>
<computeroutput moreinfo="none">    val intersect : t -&gt; t -&gt; t</computeroutput>
<computeroutput moreinfo="none">  end</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Int_interval.is_empty</userinput>
<userinput moreinfo="none">    (Int_interval.create 3 4);;</userinput>
<computeroutput moreinfo="none">- : bool = false</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Int_interval.is_empty</userinput>
<userinput moreinfo="none">    (Int_interval.Interval (4,3));;</userinput>
<computeroutput moreinfo="none">Characters 40-48:</computeroutput>
<computeroutput moreinfo="none">Error: Unbound constructor Int_interval.Interval</computeroutput></programlisting>

      <para>In addition, the <literal moreinfo="none">endpoint</literal> type
      is gone from the interface, meaning we no longer need to define the
      <literal moreinfo="none">endpoint</literal> type alias in the body of
      the module.</para>

      <para>It's worth noting that the name is somewhat misleading, in that
      there's nothing destructive about destructive substitution; it's really
      just a way of creating a new signature by transforming an existing
      one.</para>
    </sect2>

    <sect2 id="using-multiple-interfaces">
      <title>Using Multiple Interfaces</title>

      <para>Another feature that we might want for our interval module is the
      ability to <emphasis>serialize</emphasis>, i.e., to be able to read and
      write intervals as a stream of bytes. In this case, we'll do this by
      converting to and from s-expressions, which were mentioned already in
      <xref linkend="error-handling"/>. To recall, an s-expression is
      essentially a parenthesized expression whose atoms are strings, and it
      is a serialization format that is used commonly in Core. Here's an
      example:<indexterm class="singular">
          <primary>s-expressions</primary>

          <secondary>example of</secondary>
        </indexterm><indexterm class="singular">
          <primary>interval computation</primary>

          <secondary>multiple interfaces and</secondary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/functors/main.topscript">OCaml utop</ulink>
      (part 23)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">Sexp.of_string "(This is (an s-expression))";;</userinput>
<computeroutput moreinfo="none">- : Sexp.t = (This is (an s-expression))</computeroutput></programlisting>

      <para>Core comes with a syntax extension called Sexplib which can
      autogenerate s-expression conversion functions from a type declaration.
      Attaching <literal moreinfo="none">with sexp</literal> to a type
      definition signals to the extension to generate the converters. Thus, we
      can write:<indexterm class="singular">
          <primary>sexp declaration</primary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/functors/main.topscript">OCaml utop</ulink>
      (part 24)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">type some_type = int * string list with sexp;;</userinput>
<computeroutput moreinfo="none">type some_type = int * string list</computeroutput>
<computeroutput moreinfo="none">val some_type_of_sexp : Sexp.t -&gt; int * string list = &lt;fun&gt;</computeroutput>
<computeroutput moreinfo="none">val sexp_of_some_type : int * string list -&gt; Sexp.t = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">sexp_of_some_type (33, ["one"; "two"]);;</userinput>
<computeroutput moreinfo="none">- : Sexp.t = (33 (one two))</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Sexp.of_string "(44 (five six))" |&gt; some_type_of_sexp;;</userinput>
<computeroutput moreinfo="none">- : int * string list = (44, ["five"; "six"])</computeroutput></programlisting>

      <para>We'll discuss s-expressions and Sexplib in more detail in <xref linkend="data-serialization-with-s-expressions"/>, but for now, let's
      see what happens if we attach the <literal moreinfo="none">with
      sexp</literal> declaration to the definition of <literal moreinfo="none">t</literal> within the functor:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/functors/main-25.rawscript">OCaml utop</ulink></para>

      <programlisting format="linespecific" language="ocaml"><userinput moreinfo="none"># module Make_interval(Endpoint : Comparable)
    : (Interval_intf with type endpoint := Endpoint.t) = struct

    type t = | Interval of Endpoint.t * Endpoint.t
             | Empty
    with sexp

    ...

  end ;;</userinput>
<computeroutput moreinfo="none">  Characters 136-146:
    Error: Unbound value Endpoint.t_of_sexp</computeroutput></programlisting>

      <para>The problem is that <literal moreinfo="none">with sexp</literal>
      adds code for defining the s-expression converters, and that code
      assumes that <literal moreinfo="none">Endpoint</literal> has the
      appropriate sexp-conversion functions for <literal moreinfo="none">Endpoint.t</literal>. But all we know about <literal moreinfo="none">Endpoint</literal> is that it satisfies the <literal moreinfo="none">Comparable</literal> interface, which doesn't say
      anything about s-expressions.</para>

      <para>Happily, Core comes with a built-in interface for just this
      purpose called <literal moreinfo="none">Sexpable</literal>, which is
      defined as follows:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/functors/sexpable.ml">OCaml</ulink></para>

      <programlisting format="linespecific" language="ocaml">module type Sexpable = sig
  type t
  val sexp_of_t : t -&gt; Sexp.t
  val t_of_sexp : Sexp.t -&gt; t
end</programlisting>

      <para>We can modify <literal moreinfo="none">Make_interval</literal> to
      use the <literal moreinfo="none">Sexpable</literal> interface, for both
      its input and its output. First, let's create an extended version of the
      <literal moreinfo="none">Interval_intf</literal> interface that includes
      the functions from the <literal>Sexpable</literal> interface. We can do
      this using destructive substitution on the <literal moreinfo="none">Sexpable</literal> interface, to avoid having multiple
      distinct type <literal moreinfo="none">t</literal>'s clashing with each
      other:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/functors/main.topscript">OCaml utop</ulink>
      (part 26)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">module type Interval_intf_with_sexp = sig</userinput>
<userinput moreinfo="none">   include Interval_intf</userinput>
<userinput moreinfo="none">   include Sexpable with type t := t</userinput>
<userinput moreinfo="none">  end;;</userinput>
<computeroutput moreinfo="none">module type Interval_intf_with_sexp =</computeroutput>
<computeroutput moreinfo="none">  sig</computeroutput>
<computeroutput moreinfo="none">    type t</computeroutput>
<computeroutput moreinfo="none">    type endpoint</computeroutput>
<computeroutput moreinfo="none">    val create : endpoint -&gt; endpoint -&gt; t</computeroutput>
<computeroutput moreinfo="none">    val is_empty : t -&gt; bool</computeroutput>
<computeroutput moreinfo="none">    val contains : t -&gt; endpoint -&gt; bool</computeroutput>
<computeroutput moreinfo="none">    val intersect : t -&gt; t -&gt; t</computeroutput>
<computeroutput moreinfo="none">    val t_of_sexp : Sexp.t -&gt; t</computeroutput>
<computeroutput moreinfo="none">    val sexp_of_t : t -&gt; Sexp.t</computeroutput>
<computeroutput moreinfo="none">  end</computeroutput></programlisting>

      <para>Equivalently, we can define a type <literal moreinfo="none">t</literal> within our new module, and apply destructive
      substitutions to all of the included interfaces, <literal moreinfo="none">Interval_intf</literal> included, as shown in the
      following example. This is somewhat cleaner when combining multiple
      interfaces, since it correctly reflects that all of the signatures are
      being handled equivalently:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/functors/main.topscript">OCaml utop</ulink>
      (part 27)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">module type Interval_intf_with_sexp = sig</userinput>
<userinput moreinfo="none">   type t</userinput>
<userinput moreinfo="none">   include Interval_intf with type t := t</userinput>
<userinput moreinfo="none">   include Sexpable      with type t := t</userinput>
<userinput moreinfo="none">  end;;</userinput>
<computeroutput moreinfo="none">module type Interval_intf_with_sexp =</computeroutput>
<computeroutput moreinfo="none">  sig</computeroutput>
<computeroutput moreinfo="none">    type t</computeroutput>
<computeroutput moreinfo="none">    type endpoint</computeroutput>
<computeroutput moreinfo="none">    val create : endpoint -&gt; endpoint -&gt; t</computeroutput>
<computeroutput moreinfo="none">    val is_empty : t -&gt; bool</computeroutput>
<computeroutput moreinfo="none">    val contains : t -&gt; endpoint -&gt; bool</computeroutput>
<computeroutput moreinfo="none">    val intersect : t -&gt; t -&gt; t</computeroutput>
<computeroutput moreinfo="none">    val t_of_sexp : Sexp.t -&gt; t</computeroutput>
<computeroutput moreinfo="none">    val sexp_of_t : t -&gt; Sexp.t</computeroutput>
<computeroutput moreinfo="none">  end</computeroutput></programlisting>

      <para>Now we can write the functor itself. We have been careful to
      override the sexp converter here to ensure that the data structure's
      invariants are still maintained when reading in from an
      s-expression:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/functors/main.topscript">OCaml utop</ulink>
      (part 28)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">module Make_interval(Endpoint : sig</userinput>
<userinput moreinfo="none">                         type t</userinput>
<userinput moreinfo="none">                         include Comparable with type t := t</userinput>
<userinput moreinfo="none">                         include Sexpable   with type t := t</userinput>
<userinput moreinfo="none">                       end)</userinput>
<userinput moreinfo="none">    : (Interval_intf_with_sexp with type endpoint := Endpoint.t)</userinput>
<userinput moreinfo="none">  = struct</userinput>
<userinput moreinfo="none"/>
<userinput moreinfo="none">    type t = | Interval of Endpoint.t * Endpoint.t</userinput>
<userinput moreinfo="none">             | Empty</userinput>
<userinput moreinfo="none">    with sexp</userinput>
<userinput moreinfo="none"/>
<userinput moreinfo="none">    (** [create low high] creates a new interval from [low] to</userinput>
<userinput moreinfo="none">        [high].  If [low &gt; high], then the interval is empty *)</userinput>
<userinput moreinfo="none">    let create low high =</userinput>
<userinput moreinfo="none">      if Endpoint.compare low high &gt; 0 then Empty</userinput>
<userinput moreinfo="none">      else Interval (low,high)</userinput>
<userinput moreinfo="none"/>
<userinput moreinfo="none">    (* put a wrapper around the autogenerated [t_of_sexp] to enforce</userinput>
<userinput moreinfo="none">       the invariants of the data structure *)</userinput>
<userinput moreinfo="none">    let t_of_sexp sexp =</userinput>
<userinput moreinfo="none">      match t_of_sexp sexp with</userinput>
<userinput moreinfo="none">      | Empty -&gt; Empty</userinput>
<userinput moreinfo="none">      | Interval (x,y) -&gt; create x y</userinput>
<userinput moreinfo="none"/>
<userinput moreinfo="none">    (** Returns true iff the interval is empty *)</userinput>
<userinput moreinfo="none">    let is_empty = function</userinput>
<userinput moreinfo="none">      | Empty -&gt; true</userinput>
<userinput moreinfo="none">      | Interval _ -&gt; false</userinput>
<userinput moreinfo="none"/>
<userinput moreinfo="none">    (** [contains t x] returns true iff [x] is contained in the</userinput>
<userinput moreinfo="none">        interval [t] *)</userinput>
<userinput moreinfo="none">    let contains t x =</userinput>
<userinput moreinfo="none">      match t with</userinput>
<userinput moreinfo="none">      | Empty -&gt; false</userinput>
<userinput moreinfo="none">      | Interval (l,h) -&gt;</userinput>
<userinput moreinfo="none">        Endpoint.compare x l &gt;= 0 &amp;&amp; Endpoint.compare x h &lt;= 0</userinput>
<userinput moreinfo="none"/>
<userinput moreinfo="none">    (** [intersect t1 t2] returns the intersection of the two input</userinput>
<userinput moreinfo="none">        intervals *)</userinput>
<userinput moreinfo="none">    let intersect t1 t2 =</userinput>
<userinput moreinfo="none">      let min x y = if Endpoint.compare x y &lt;= 0 then x else y in</userinput>
<userinput moreinfo="none">      let max x y = if Endpoint.compare x y &gt;= 0 then x else y in</userinput>
<userinput moreinfo="none">      match t1,t2 with</userinput>
<userinput moreinfo="none">      | Empty, _ | _, Empty -&gt; Empty</userinput>
<userinput moreinfo="none">      | Interval (l1,h1), Interval (l2,h2) -&gt;</userinput>
<userinput moreinfo="none">        create (max l1 l2) (min h1 h2)</userinput>
<userinput moreinfo="none">  end;;</userinput>
<computeroutput moreinfo="none">module Make_interval :</computeroutput>
<computeroutput moreinfo="none">  functor</computeroutput>
<computeroutput moreinfo="none">    (Endpoint : sig</computeroutput>
<computeroutput moreinfo="none">                  type t</computeroutput>
<computeroutput moreinfo="none">                  val compare : t -&gt; t -&gt; int</computeroutput>
<computeroutput moreinfo="none">                  val t_of_sexp : Sexp.t -&gt; t</computeroutput>
<computeroutput moreinfo="none">                  val sexp_of_t : t -&gt; Sexp.t</computeroutput>
<computeroutput moreinfo="none">                end) -&gt;</computeroutput>
<computeroutput moreinfo="none">    sig</computeroutput>
<computeroutput moreinfo="none">      type t</computeroutput>
<computeroutput moreinfo="none">      val create : Endpoint.t -&gt; Endpoint.t -&gt; t</computeroutput>
<computeroutput moreinfo="none">      val is_empty : t -&gt; bool</computeroutput>
<computeroutput moreinfo="none">      val contains : t -&gt; Endpoint.t -&gt; bool</computeroutput>
<computeroutput moreinfo="none">      val intersect : t -&gt; t -&gt; t</computeroutput>
<computeroutput moreinfo="none">      val t_of_sexp : Sexp.t -&gt; t</computeroutput>
<computeroutput moreinfo="none">      val sexp_of_t : t -&gt; Sexp.t</computeroutput>
<computeroutput moreinfo="none">    end</computeroutput></programlisting>

      <para>And now, we can use that sexp converter in the ordinary
      way:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/functors/main.topscript">OCaml utop</ulink>
      (part 29)<indexterm class="endofrange" startref="FUNCTinterv"/></para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">module Int_interval = Make_interval(Int) ;;</userinput>
<computeroutput moreinfo="none">module Int_interval :</computeroutput>
<computeroutput moreinfo="none">  sig</computeroutput>
<computeroutput moreinfo="none">    type t = Make_interval(Core.Std.Int).t</computeroutput>
<computeroutput moreinfo="none">    val create : int -&gt; int -&gt; t</computeroutput>
<computeroutput moreinfo="none">    val is_empty : t -&gt; bool</computeroutput>
<computeroutput moreinfo="none">    val contains : t -&gt; int -&gt; bool</computeroutput>
<computeroutput moreinfo="none">    val intersect : t -&gt; t -&gt; t</computeroutput>
<computeroutput moreinfo="none">    val t_of_sexp : Sexp.t -&gt; t</computeroutput>
<computeroutput moreinfo="none">    val sexp_of_t : t -&gt; Sexp.t</computeroutput>
<computeroutput moreinfo="none">  end</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Int_interval.sexp_of_t (Int_interval.create 3 4);;</userinput>
<computeroutput moreinfo="none">- : Sexp.t = (Interval 3 4)</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Int_interval.sexp_of_t (Int_interval.create 4 3);;</userinput>
<computeroutput moreinfo="none">- : Sexp.t = Empty</computeroutput></programlisting>
    </sect2>
  </sect1>

  <sect1 id="extending-modules">
    <title>Extending Modules</title>

    <para>Another common use of functors is to generate type-specific
    functionality for a given module in a standardized way. Let's see how this
    works in the context of a functional queue, which is just a functional
    version of a FIFO (first-in, first-out) queue. Being functional,
    operations on the queue return new queues, rather than modifying the
    queues that were passed in.<indexterm class="singular">
        <primary>modules</primary>

        <secondary>type-specific functionality in</secondary>
      </indexterm><indexterm class="singular">
        <primary>FIFO (first-in, first-out) queue</primary>
      </indexterm><indexterm class="singular">
        <primary>functors</primary>

        <secondary>module extension with</secondary>
      </indexterm></para>

    <para>Here's a reasonable <literal moreinfo="none">mli</literal> for such
    a module:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/functors/fqueue.mli">OCaml</ulink></para>

    <programlisting format="linespecific" language="ocaml">type 'a t

val empty : 'a t

(** [enqueue q el] adds [el] to the back of [q] *)
val enqueue : 'a t -&gt; 'a -&gt; 'a t

(** [dequeue q] returns None if the [q] is empty, otherwise returns
    the first element of the queue and the remainder of the queue *)
val dequeue : 'a t -&gt; ('a * 'a t) option

(** Folds over the queue, from front to back *)
val fold : 'a t -&gt; init:'acc -&gt; f:('acc -&gt; 'a -&gt; 'acc) -&gt; 'acc</programlisting>

    <para>The preceding <literal moreinfo="none">Fqueue.fold</literal>
    function requires some explanation. It follows the same pattern as the
    <literal moreinfo="none">List.fold</literal> function we described in
    <xref linkend="using-the-list-module-effectively"/>. Essentially,
    <literal moreinfo="none">Fqueue.fold q ~init ~f</literal> walks over the
    elements of <literal moreinfo="none">q</literal> from front to back,
    starting with an accumulator of <literal moreinfo="none">init</literal>
    and using <literal moreinfo="none">f</literal> to update the accumulator
    value as it walks over the queue, returning the final value of the
    accumulator at the end of the computation. <literal>fold</literal> is a
    quite powerful operation, as we'll see.</para>

    <para>We'll implement <literal moreinfo="none">Fqueue</literal> the well known trick of
      maintaining an input and an output list so that one can efficiently enqueue on the input list
      and efficiently dequeue from the output list. If you attempt to dequeue when the output list
      is empty, the input list is reversed and becomes the new output list. Here's the
      implementation:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/functors/fqueue.ml">OCaml</ulink></para>

    <programlisting format="linespecific" language="ocaml">open Core.Std

type 'a t = 'a list * 'a list

let empty = ([],[])

let enqueue (in_list, out_list) x =
  (x :: in_list,out_list)

let dequeue (in_list, out_list) =
  match out_list with
  | hd :: tl -&gt; Some (hd, (in_list, tl))
  | [] -&gt;
    match List.rev in_list with
    | [] -&gt; None
    | hd :: tl -&gt; Some (hd, ([], tl))

let fold (in_list, out_list) ~init ~f =
  let after_out = List.fold ~init ~f out_list in
  List.fold_right ~init:after_out ~f:(fun x acc -&gt; f acc x) in_list</programlisting>

    <para>One problem with <literal moreinfo="none">Fqueue</literal> is that
    the interface is quite skeletal. There are lots of useful helper functions
    that one might want that aren't there. The <literal moreinfo="none">List</literal> module, by way of contrast, has functions
    like <literal moreinfo="none">List.iter</literal>, which runs a function
    on each element; and <literal moreinfo="none">List.for_all</literal>,
    which returns true if and only if the given predicate evaluates to
    <literal moreinfo="none">true</literal> on every element of the list. Such
    helper functions come up for pretty much every container type, and
    implementing them over and over is a dull and repetitive affair.</para>

    <para>As it happens, many of these helper functions can be derived mechanically from the
        <literal>fold</literal> function we already implemented. Rather than write all of these
      helper functions by hand for every new container type, we can instead use a functor to add
      this functionality to any container that has a <literal moreinfo="none">fold</literal>
      function.</para>

    <para>We'll create a new module, <literal moreinfo="none">Foldable</literal>, that automates the process of adding
    helper functions to a <literal>fold</literal>-supporting container. As you
    can see, <literal moreinfo="none">Foldable</literal> contains a module
    signature <literal moreinfo="none">S</literal> which defines the signature
    that is required to support folding; and a functor <literal moreinfo="none">Extend</literal> that allows one to extend any module that
    matches <literal moreinfo="none">Foldable.S</literal>:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/functors/foldable.ml">OCaml</ulink></para>

    <programlisting format="linespecific" language="ocaml">open Core.Std

module type S = sig
  type 'a t
  val fold : 'a t -&gt; init:'acc -&gt; f:('acc -&gt; 'a -&gt; 'acc) -&gt; 'acc
end

module type Extension = sig
  type 'a t
  val iter    : 'a t -&gt; f:('a -&gt; unit) -&gt; unit
  val length  : 'a t -&gt; int
  val count   : 'a t -&gt; f:('a -&gt; bool) -&gt; int
  val for_all : 'a t -&gt; f:('a -&gt; bool) -&gt; bool
  val exists  : 'a t -&gt; f:('a -&gt; bool) -&gt; bool
end

(* For extending a Foldable module *)
module Extend(Arg : S)
  : (Extension with type 'a t := 'a Arg.t) =
struct
  open Arg

  let iter t ~f =
    fold t ~init:() ~f:(fun () a -&gt; f a)

  let length t =
    fold t ~init:0  ~f:(fun acc _ -&gt; acc + 1)

  let count t ~f =
    fold t ~init:0  ~f:(fun count x -&gt; count + if f x then 1 else 0)

  exception Short_circuit

  let for_all c ~f =
    try iter c ~f:(fun x -&gt; if not (f x) then raise Short_circuit); true
    with Short_circuit -&gt; false

  let exists c ~f =
    try iter c ~f:(fun x -&gt; if f x then raise Short_circuit); false
    with Short_circuit -&gt; true
end</programlisting>

    <para>Now we can apply this to <literal moreinfo="none">Fqueue</literal>. We can create an
      interface for an extended version of <literal moreinfo="none">Fqueue</literal> as follows: </para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/functors/extended_fqueue.mli">OCaml</ulink></para>

    <programlisting format="linespecific" language="ocaml">type 'a t
include (module type of Fqueue) with type 'a t := 'a t
include Foldable.Extension with type 'a t := 'a t</programlisting>

    <para>In order to apply the functor, we'll put the definition of <literal moreinfo="none">Fqueue</literal> in a submodule called <literal moreinfo="none">T</literal>, and then call <literal moreinfo="none">Foldable.Extend</literal> on <literal moreinfo="none">T</literal>:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/functors/extended_fqueue.ml">OCaml</ulink></para>

    <programlisting format="linespecific" language="ocaml">include Fqueue
include Foldable.Extend(Fqueue)</programlisting>

    <para>Core comes with a number of functors for extending modules that
    follow this same basic pattern, including:<indexterm class="singular">
        <primary>Monad.Make</primary>
      </indexterm><indexterm class="singular">
        <primary>Hashable.Make</primary>
      </indexterm><indexterm class="singular">
        <primary>Comparable module</primary>

        <secondary>Comparable.Make</secondary>
      </indexterm><indexterm class="singular">
        <primary>Container.Make</primary>
      </indexterm></para>

    <variablelist>
      <varlistentry>
        <term><literal moreinfo="none">Container.Make</literal></term>

        <listitem>
          <para>Very similar to <literal moreinfo="none">Foldable.Extend</literal>.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal moreinfo="none">Comparable.Make</literal></term>

        <listitem>
          <para>Adds support for functionality that depends on the presence of
          a comparison function, including support for containers like maps
          and sets.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal moreinfo="none">Hashable.Make</literal></term>

        <listitem>
          <para>Adds support for hashing-based data structures including hash
          tables, hash sets, and hash heaps.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal moreinfo="none">Monad.Make</literal></term>

        <listitem>
          <para>For so-called monadic libraries, like those discussed in Chapters <xref xrefstyle="select: labelnumber" linkend="error-handling"/> and <xref xrefstyle="select: labelnumber" linkend="concurrent-programming-with-async"/>. Here, the functor is
          used to provide a collection of standard helper functions based on
          the <literal moreinfo="none">bind</literal> and <literal moreinfo="none">return</literal> operators.</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <para>These functors come in handy when you want to add the same kind of
    functionality that is commonly available in Core to your own types.</para>
    <para>We've really only covered some of the possible uses of functors. Functors are really a
      quite powerful tool for modularizing your code. The cost is that functors are syntactically
      heavyweight compared to the rest of the language, and that there are some tricky issues you
      need to understand to use them effectively, with sharing constraints and destructive
      substitution being high on that list. </para>
    <para>All of this means that for small and simple programs, heavy use of functors is probably a
      mistake. But as your programs get more complicated and you need more effective modular
      architectures, functors become a highly valuable tool.</para>
  </sect1>
</chapter>

  <chapter id="first-class-modules">
  <title>First-Class Modules</title>

  <para>You can think of OCaml as being broken up into two parts: a core
  language that is concerned with values and types, and a module language that
  is concerned with modules and module signatures. These sublanguages are
  stratified, in that modules can contain types and values, but ordinary
  values can't contain modules or module types. That means you can't do things
  like define a variable whose value is a module, or a function that takes a
  module as an argument.<indexterm class="startofrange" id="MODfirst">
      <primary>modules</primary>

      <secondary>first-class modules</secondary>
    </indexterm></para>

  <para>OCaml provides a way around this stratification in the form of
  <emphasis>first-class modules</emphasis>. First-class modules are ordinary
  values that can be created from and converted back to regular
  modules.<indexterm class="startofrange" id="FCMwork">
      <primary>first-class modules</primary>

      <secondary>working with</secondary>
    </indexterm></para>

  <para>First-class modules are a sophisticated technique, and you'll need to get comfortable with
        some advanced aspects of the language to use them effectively. But it's worth learning,
        because letting modules into the core language is quite powerful, increasing the range of
        what you can express and making it easier to build flexible and modular <phrase role="keep-together">systems</phrase>.</para>

  <sect1 id="working-with-first-class-modules">
    <title>Working with First-Class Modules</title>

    <para>We'll start out by covering the basic mechanics of first-class
    modules by working through some toy examples. We'll get to more realistic
    examples in the next section.</para>

    <para>In that light, consider the following signature of a module with a
    single integer variable:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/fcm/main.topscript">OCaml utop</ulink></para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">module type X_int = sig val x : int end;;</userinput>
<computeroutput moreinfo="none">module type X_int = sig val x : int end</computeroutput></programlisting>

    <para>We can also create a module that matches this signature:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/fcm/main.topscript">OCaml utop</ulink>
    (part 1)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">module Three : X_int = struct let x = 3 end;;</userinput>
<computeroutput moreinfo="none">module Three : X_int</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Three.x;;</userinput>
<computeroutput moreinfo="none">- : int = 3</computeroutput></programlisting>

    <para>A first-class module is created by packaging up a module with a
    signature that it satisfies. This is done using the <literal moreinfo="none">module</literal> keyword, using the following
    syntax:<indexterm class="singular">
        <primary>module keyword</primary>
      </indexterm></para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/fcm/pack.syntax">Syntax</ulink></para>

    <programlisting format="linespecific">(module &lt;Module&gt; : &lt;Module_type&gt;)</programlisting>

    <para>So, we can convert <literal moreinfo="none">Three</literal> into a
    first-class module as follows:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/fcm/main.topscript">OCaml utop</ulink>
    (part 2)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let three = (module Three : X_int);;</userinput>
<computeroutput moreinfo="none">val three : (module X_int) = &lt;module&gt;</computeroutput></programlisting>

    <para>The module type doesn't need to be part of the construction of a
    first-class module if it can be inferred. Thus, we can write:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/fcm/main.topscript">OCaml utop</ulink>
    (part 3)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">module Four = struct let x = 4 end;;</userinput>
<computeroutput moreinfo="none">module Four : sig val x : int end</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let numbers = [ three; (module Four) ];;</userinput>
<computeroutput moreinfo="none">val numbers : (module X_int) list = [&lt;module&gt;; &lt;module&gt;]</computeroutput></programlisting>

    <para>We can also create a first-class module from an anonymous
    module:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/fcm/main.topscript">OCaml utop</ulink>
    (part 4)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let numbers = [three; (module struct let x = 4 end)];;</userinput>
<computeroutput moreinfo="none">val numbers : (module X_int) list = [&lt;module&gt;; &lt;module&gt;]</computeroutput></programlisting>

    <para>In order to access the contents of a first-class module, you need to
    unpack it into an ordinary module. This can be done using the <literal moreinfo="none">val</literal> keyword, using this syntax:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/fcm/unpack.syntax">Syntax</ulink></para>

    <programlisting format="linespecific" language="ocaml">(val <emphasis>&lt;first_class_module&gt;</emphasis> : <emphasis>&lt;Module_type&gt;</emphasis>)</programlisting>

    <para>And here's an example:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/fcm/main.topscript">OCaml utop</ulink>
    (part 5)<indexterm class="singular">
        <primary>first-class modules</primary>

        <secondary>type equality in</secondary>
      </indexterm></para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">module New_three = (val three : X_int) ;;</userinput>
<computeroutput moreinfo="none">module New_three : X_int</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">New_three.x;;</userinput>
<computeroutput moreinfo="none">- : int = 3</computeroutput></programlisting>
<?hard-pagebreak?>
    <sidebar>
      <title>Equality of First-Class Module Types</title>

      <para>The type of the first-class module, e.g., <literal moreinfo="none">(module X_int)</literal>, is based on the fully
      qualified name of the signature that was used to construct it. A
      first-class module based on a signature with a different name, even if
      it is substantively the same signature, will result in a distinct
      type:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/fcm/main.topscript">OCaml utop</ulink>
      (part 6)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">module type Y_int = X_int;;</userinput>
<computeroutput moreinfo="none">module type Y_int = X_int</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let five = (module struct let x = 5 end : Y_int);;</userinput>
<computeroutput moreinfo="none">val five : (module Y_int) = &lt;module&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">[three; five];;</userinput>
<computeroutput moreinfo="none">Characters 8-12:</computeroutput>
<computeroutput moreinfo="none">Error: This expression has type (module Y_int)</computeroutput>
<computeroutput moreinfo="none">       but an expression was expected of type (module X_int)</computeroutput></programlisting>

      <para>Even though their types as first-class modules are distinct, the
      underlying module types are compatible (indeed, identical), so we can
      unify the types by unpacking and repacking the module:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/fcm/main.topscript">OCaml utop</ulink>
      (part 7)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">[three; (module (val five))];;</userinput>
<computeroutput moreinfo="none">- : (module X_int) list = [&lt;module&gt;; &lt;module&gt;]</computeroutput></programlisting>

      <para>The way in which type equality for first-class modules is determined can be confusing.
                One common and problematic case is that of creating an alias of a module type
                defined elsewhere. This is often done to improve readability and can happen both
                through an explicit declaration of a module type or implicitly through an <literal moreinfo="none">include</literal> declaration. In both cases, this has the
                unintended side effect of making first-class modules built off the alias
                incompatible with those built off the original module type. To deal with this, we
                should be disciplined in how we refer to signatures when constructing first-class
                    <phrase role="keep-together">modules</phrase>.</para>
    </sidebar>

    <para>We can also write ordinary functions which consume and create
    first-class modules. The following shows the definition of two functions:
    <literal moreinfo="none">to_int</literal>, which converts a <literal moreinfo="none">(module X_int)</literal> into an <literal moreinfo="none">int</literal>; and <literal moreinfo="none">plus</literal>, which returns the sum of two <literal moreinfo="none">(module X_int)</literal>:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/fcm/main.topscript">OCaml utop</ulink>
    (part 8)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let to_int m =</userinput>
<userinput moreinfo="none">    let module M = (val m : X_int) in</userinput>
<userinput moreinfo="none">    M.x</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val to_int : (module X_int) -&gt; int = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let plus m1 m2 =</userinput>
<userinput moreinfo="none">    (module struct</userinput>
<userinput moreinfo="none">       let x = to_int m1 + to_int m2</userinput>
<userinput moreinfo="none">     end : X_int)</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val plus : (module X_int) -&gt; (module X_int) -&gt; (module X_int) = &lt;fun&gt;</computeroutput></programlisting>

    <para>With these functions in hand, we can now work with values of type <literal moreinfo="none">(module X_int)</literal> in a more natural style, taking advantage of the concision
            and simplicity of the core <phrase role="keep-together">language</phrase>:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/fcm/main.topscript">OCaml utop</ulink>
    (part 9)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let six = plus three three;;</userinput>
<computeroutput moreinfo="none">val six : (module X_int) = &lt;module&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">to_int (List.fold ~init:six ~f:plus [three;three]);;</userinput>
<computeroutput moreinfo="none">- : int = 12</computeroutput></programlisting>

    <para>There are some useful syntactic shortcuts when dealing with
    first-class modules. One notable one is that you can do the conversion to
    an ordinary module within a pattern match. Thus, we can rewrite the
    <literal moreinfo="none">to_int</literal> function as follows:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/fcm/main.topscript">OCaml utop</ulink>
    (part 10)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let to_int (module M : X_int) = M.x ;;</userinput>
<computeroutput moreinfo="none">val to_int : (module X_int) -&gt; int = &lt;fun&gt;</computeroutput></programlisting>

    <para>First-class modules can contain types and functions in addition to
    simple values like <literal moreinfo="none">int</literal>. Here's an
    interface that contains a type and a corresponding <literal moreinfo="none">bump</literal> operation that takes a value of the type
    and produces a new one:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/fcm/main.topscript">OCaml utop</ulink>
    (part 11)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">module type Bumpable = sig</userinput>
<userinput moreinfo="none">    type t</userinput>
<userinput moreinfo="none">    val bump : t -&gt; t</userinput>
<userinput moreinfo="none">  end;;</userinput>
<computeroutput moreinfo="none">module type Bumpable = sig type t val bump : t -&gt; t end</computeroutput></programlisting>

    <para>We can create multiple instances of this module with different
    underlying types:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/fcm/main.topscript">OCaml utop</ulink>
    (part 12)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">module Int_bumper = struct</userinput>
<userinput moreinfo="none">    type t = int</userinput>
<userinput moreinfo="none">    let bump n = n + 1</userinput>
<userinput moreinfo="none">  end;;</userinput>
<computeroutput moreinfo="none">module Int_bumper : sig type t = int val bump : t -&gt; t end</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">module Float_bumper = struct</userinput>
<userinput moreinfo="none">     type t = float</userinput>
<userinput moreinfo="none">     let bump n = n +. 1.</userinput>
<userinput moreinfo="none">  end;;</userinput>
<computeroutput moreinfo="none">module Float_bumper : sig type t = float val bump : t -&gt; t end</computeroutput></programlisting>

    <para>And we can convert these to first-class modules:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/fcm/main.topscript">OCaml utop</ulink>
    (part 13)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let int_bumper = (module Int_bumper : Bumpable);;</userinput>
<computeroutput moreinfo="none">val int_bumper : (module Bumpable) = &lt;module&gt;</computeroutput></programlisting>

    <para>But you can't do much with <literal moreinfo="none">int_bumper</literal>, since <literal moreinfo="none">int_bumper</literal> is fully abstract, so that we can no longer
            recover the fact that the type in question is <literal moreinfo="none">int</literal>. </para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/fcm/main.topscript">OCaml utop</ulink>
    (part 14)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let (module Bumpable) = int_bumper in Bumpable.bump 3;;</userinput>
<computeroutput moreinfo="none">Characters 52-53:</computeroutput>
<computeroutput moreinfo="none">Error: This expression has type int but an expression was expected of type</computeroutput>
<computeroutput moreinfo="none">         Bumpable.t</computeroutput></programlisting>

    <para>To make <literal moreinfo="none">int_bumper</literal> usable, we
    need to expose the type, which we can do as follows:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/fcm/main.topscript">OCaml utop</ulink>
    (part 15)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let int_bumper = (module Int_bumper : Bumpable with type t = int);;</userinput>
<computeroutput moreinfo="none">val int_bumper : (module Bumpable with type t = int) = &lt;module&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let float_bumper = (module Float_bumper : Bumpable with type t = float);;</userinput>
<computeroutput moreinfo="none">val float_bumper : (module Bumpable with type t = float) = &lt;module&gt;</computeroutput></programlisting>

    <para>The sharing constraints we've added above make the resulting
    first-class modules <phrase role="keep-together">polymorphic</phrase> in
    the type <literal moreinfo="none">t</literal>. As a result, we can now use
    these values on values of the matching type:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/fcm/main.topscript">OCaml utop</ulink>
    (part 16)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let (module Bumpable) = int_bumper in Bumpable.bump 3;;</userinput>
<computeroutput moreinfo="none">- : int = 4</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let (module Bumpable) = float_bumper in Bumpable.bump 3.5;;</userinput>
<computeroutput moreinfo="none">- : float = 4.5</computeroutput></programlisting>

    <para>We can also write functions that use such first-class modules
    polymorphically. The following function takes two arguments: a <literal moreinfo="none">Bumpable</literal> module and a list of elements of the
    same type as the type <literal moreinfo="none">t</literal> of the
    module:<indexterm class="singular">
        <primary>polymorphism</primary>

        <secondary>in first-class modules</secondary>
      </indexterm><indexterm class="singular">
        <primary>first-class modules</primary>

        <secondary>polymorphism in</secondary>
      </indexterm></para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/fcm/main.topscript">OCaml utop</ulink>
    (part 17)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let bump_list</userinput>
<userinput moreinfo="none">       (type a)</userinput>
<userinput moreinfo="none">       (module B : Bumpable with type t = a)</userinput>
<userinput moreinfo="none">       (l: a list)</userinput>
<userinput moreinfo="none">    =</userinput>
<userinput moreinfo="none">    List.map ~f:B.bump l</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val bump_list : (module Bumpable with type t = 'a) -&gt; 'a list -&gt; 'a list =</computeroutput>
<computeroutput moreinfo="none">  &lt;fun&gt;</computeroutput></programlisting>

    <para>Here, we used a feature of OCaml that hasn't come up before: a <emphasis>locally abstract
                type</emphasis>. For any function, you can declare a pseudoparameter of the form
                <literal moreinfo="none">(type a)</literal> for any type name <literal moreinfo="none">a</literal> which introduces a fresh type. This type acts like an
            abstract type within the context of the function. In the example above, the locally
            abstract type was used as part of a sharing constraint that ties the type <literal moreinfo="none">B.t</literal> with the type of the elements of the list passed
                in.<indexterm class="singular">
                <primary>datatypes</primary>
                <secondary>locally abstract types</secondary>
            </indexterm><indexterm class="singular">
                <primary>abstract types</primary>
            </indexterm><indexterm class="singular">
                <primary>locally abstract types</primary>
            </indexterm></para>

    <para>The resulting function is polymorphic in both the type of the list
    element and the type <literal moreinfo="none">Bumpable.t</literal>. We can
    see this function in action:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/fcm/main.topscript">OCaml utop</ulink>
    (part 18)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">bump_list int_bumper [1;2;3];;</userinput>
<computeroutput moreinfo="none">- : int list = [2; 3; 4]</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">bump_list float_bumper [1.5;2.5;3.5];;</userinput>
<computeroutput moreinfo="none">- : float list = [2.5; 3.5; 4.5]</computeroutput></programlisting>

    <para>Polymorphic first-class modules are important because they allow you
    to connect the types associated with a first-class module to the types of
    other values you're working with.</para>

    <note>
      <title>More on Locally Abstract Types</title>

      <para>One of the key properties of locally abstract types is that
      they're dealt with as abstract types in the function they're defined
      within, but are polymorphic from the outside. Consider the following
      example:<indexterm class="singular">
          <primary>polymorphism</primary>

          <secondary sortas="locally">in locally abstract types</secondary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/fcm/main.topscript">OCaml utop</ulink>
      (part 19)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let wrap_in_list (type a) (x:a) = [x];;</userinput>
<computeroutput moreinfo="none">val wrap_in_list : 'a -&gt; 'a list = &lt;fun&gt;</computeroutput></programlisting>

      <para>This compiles successfully because the type <literal moreinfo="none">a</literal> is used in a way that is compatible with it
      being abstract, but the type of the function that is inferred is
      polymorphic.</para>

      <para>If, on the other hand, we try to use the type <literal moreinfo="none">a</literal> as equivalent to some concrete type, say,
      <literal moreinfo="none">int</literal>, then the compiler will
      complain:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/fcm/main.topscript">OCaml utop</ulink>
      (part 20)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let double_int (type a) (x:a) = x + x;;</userinput>
<computeroutput moreinfo="none">Characters 38-39:</computeroutput>
<computeroutput moreinfo="none">Error: This expression has type a but an expression was expected of type int</computeroutput></programlisting>

      <para>One common use of locally abstract types is to create a new type
      that can be used in constructing a module. Here's an example of doing
      this to create a new first-class module:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/fcm/main.topscript">OCaml utop</ulink>
      (part 21)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">module type Comparable = sig</userinput>
<userinput moreinfo="none">    type t</userinput>
<userinput moreinfo="none">    val compare : t -&gt; t -&gt; int</userinput>
<userinput moreinfo="none">  end ;;</userinput>
<computeroutput moreinfo="none">module type Comparable = sig type t val compare : t -&gt; t -&gt; int end</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let create_comparable (type a) compare =</userinput>
<userinput moreinfo="none">    (module struct</userinput>
<userinput moreinfo="none">       type t = a</userinput>
<userinput moreinfo="none">       let compare = compare</userinput>
<userinput moreinfo="none">     end : Comparable with type t = a)</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val create_comparable :</computeroutput>
<computeroutput moreinfo="none">  ('a -&gt; 'a -&gt; int) -&gt; (module Comparable with type t = 'a) = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">create_comparable Int.compare;;</userinput>
<computeroutput moreinfo="none">- : (module Comparable with type t = int) = &lt;module&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">create_comparable Float.compare;;</userinput>
<computeroutput moreinfo="none">- : (module Comparable with type t = float) = &lt;module&gt;</computeroutput></programlisting>

      <para>Here, what we effectively do is capture a polymorphic type and
      export it as a concrete type within a module.</para>

      <para>This technique is useful beyond first-class modules. For example,
      we can use the same approach to construct a local module to be fed to a
      functor.<indexterm class="endofrange" startref="FCMwork"/></para>
    </note>
  </sect1>

  <sect1 id="example-a-query-handling-framework">
    <title>Example: A Query-Handling Framework</title>

    <para>Now let's look at first-class modules in the context of a more complete and realistic
            example. In particular, consider the following signature for a module that implements a
            system for responding to user-generated queries.<indexterm class="singular">
                <primary>query-handlers</primary>
                <secondary sortas="first-class">and first-class modules</secondary>
            </indexterm><indexterm class="startofrange" id="FCMquery">
                <primary>first-class modules</primary>
                <secondary>query-handling framework</secondary>
            </indexterm></para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/fcm/query_handler.topscript">OCaml utop</ulink></para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">module type Query_handler = sig</userinput>
<userinput moreinfo="none"/>
<userinput moreinfo="none">    (** Configuration for a query handler.  Note that this can be
         converted to and from an s-expression *)</userinput>
<userinput moreinfo="none">    type config with sexp</userinput>
<userinput moreinfo="none"/>
<userinput moreinfo="none">    (** The name of the query-handling service *)</userinput>
<userinput moreinfo="none">    val name : string</userinput>
<userinput moreinfo="none"/>
<userinput moreinfo="none">    (** The state of the query handler *)</userinput>
<userinput moreinfo="none">    type t</userinput>
<userinput moreinfo="none"/>
<userinput moreinfo="none">    (** Creates a new query handler from a config *)</userinput>
<userinput moreinfo="none">    val create : config -&gt; t</userinput>
<userinput moreinfo="none"/>
<userinput moreinfo="none">    (** Evaluate a given query, where both input and output are
         s-expressions *)</userinput>
<userinput moreinfo="none">    val eval : t -&gt; Sexp.t -&gt; Sexp.t Or_error.t</userinput>
<userinput moreinfo="none">  end;;</userinput>
<computeroutput moreinfo="none">module type Query_handler =</computeroutput>
<computeroutput moreinfo="none">  sig</computeroutput>
<computeroutput moreinfo="none">    type config</computeroutput>
<computeroutput moreinfo="none">    val name : string</computeroutput>
<computeroutput moreinfo="none">    type t</computeroutput>
<computeroutput moreinfo="none">    val create : config -&gt; t</computeroutput>
<computeroutput moreinfo="none">    val eval : t -&gt; Sexp.t -&gt; Sexp.t Or_error.t</computeroutput>
<computeroutput moreinfo="none">    val config_of_sexp : Sexp.t -&gt; config</computeroutput>
<computeroutput moreinfo="none">    val sexp_of_config : config -&gt; Sexp.t</computeroutput>
<computeroutput moreinfo="none">  end</computeroutput></programlisting>

    <para>Here, we used s-expressions as the format for queries and responses, as well as the
            configuration for the query handler. S-expressions are a simple, flexible, and
            human-readable serialization format commonly used in Core. For now, it's enough to think
            of them as balanced parenthetical expressions whose atomic values are strings, e.g.,
                <literal moreinfo="none">(this (is an) (s expression))</literal>.<indexterm class="singular">
                <primary>s-expressions</primary>
                <secondary sortas="queries">in queries and responses</secondary>
            </indexterm></para>

    <para>In addition, we use the Sexplib syntax extension which extends OCaml
    by adding the <literal moreinfo="none">with sexp</literal> declaration.
    When attached to a type in a signature, <literal moreinfo="none">with
    sexp</literal> adds declarations of s-expression converters, for
    example:<indexterm class="singular">
        <primary>sexp declaration</primary>
      </indexterm></para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/fcm/query_handler.topscript">OCaml utop</ulink>
    (part 1)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">module type M = sig type t with sexp end;;</userinput>
<computeroutput moreinfo="none">module type M =</computeroutput>
<computeroutput moreinfo="none">  sig type t val t_of_sexp : Sexp.t -&gt; t val sexp_of_t : t -&gt; Sexp.t end</computeroutput></programlisting>

    <para>In a module, <literal moreinfo="none">with sexp</literal> adds the
    implementation of those functions. Thus, we can write:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/fcm/query_handler.topscript">OCaml utop</ulink>
    (part 2)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">type u = { a: int; b: float } with sexp;;</userinput>
<computeroutput moreinfo="none">type u = { a : int; b : float; }</computeroutput>
<computeroutput moreinfo="none">val u_of_sexp : Sexp.t -&gt; u = &lt;fun&gt;</computeroutput>
<computeroutput moreinfo="none">val sexp_of_u : u -&gt; Sexp.t = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">sexp_of_u {a=3;b=7.};;</userinput>
<computeroutput moreinfo="none">- : Sexp.t = ((a 3) (b 7))</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">u_of_sexp (Sexp.of_string "((a 43) (b 3.4))");;</userinput>
<computeroutput moreinfo="none">- : u = {a = 43; b = 3.4}</computeroutput></programlisting>

    <para>This is all described in more detail in <xref linkend="data-serialization-with-s-expressions"/>.</para>

    <sect2 id="implementing-a-query-handler">
      <title>Implementing a Query Handler</title>

      <para>Let's look at some examples of query handlers that satisfy the
      <literal moreinfo="none">Query_handler</literal> interface. The first
      example is a handler that produces unique integer IDs. It works by
      keeping an internal counter which it bumps every time it produces a new
      value. The input to the query in this case is just the trivial
      s-expression <literal moreinfo="none">()</literal>, otherwise known as
      <literal moreinfo="none">Sexp.unit</literal>:<indexterm class="singular">
          <primary>query-handlers</primary>

          <secondary>implementation of</secondary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/fcm/query_handler.topscript">OCaml utop</ulink>
      (part 3)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">module Unique = struct</userinput>
<userinput moreinfo="none">    type config = int with sexp</userinput>
<userinput moreinfo="none">    type t = { mutable next_id: int }</userinput>
<userinput moreinfo="none"/>
<userinput moreinfo="none">    let name = "unique"</userinput>
<userinput moreinfo="none">    let create start_at = { next_id = start_at }</userinput>
<userinput moreinfo="none"/>
<userinput moreinfo="none">    let eval t sexp =</userinput>
<userinput moreinfo="none">      match Or_error.try_with (fun () -&gt; unit_of_sexp sexp) with</userinput>
<userinput moreinfo="none">      | Error _ as err -&gt; err</userinput>
<userinput moreinfo="none">      | Ok () -&gt;</userinput>
<userinput moreinfo="none">        let response = Ok (Int.sexp_of_t t.next_id) in</userinput>
<userinput moreinfo="none">        t.next_id &lt;- t.next_id + 1;</userinput>
<userinput moreinfo="none">        response</userinput>
<userinput moreinfo="none">  end;;</userinput>
<computeroutput moreinfo="none">module Unique :</computeroutput>
<computeroutput moreinfo="none">  sig</computeroutput>
<computeroutput moreinfo="none">    type config = int</computeroutput>
<computeroutput moreinfo="none">    val config_of_sexp : Sexp.t -&gt; config</computeroutput>
<computeroutput moreinfo="none">    val sexp_of_config : config -&gt; Sexp.t</computeroutput>
<computeroutput moreinfo="none">    type t = { mutable next_id : config; }</computeroutput>
<computeroutput moreinfo="none">    val name : string</computeroutput>
<computeroutput moreinfo="none">    val create : config -&gt; t</computeroutput>
<computeroutput moreinfo="none">    val eval : t -&gt; Sexp.t -&gt; (Sexp.t, Error.t) Result.t</computeroutput>
<computeroutput moreinfo="none">  end</computeroutput></programlisting>

      <para>We can use this module to create an instance of the <literal moreinfo="none">Unique</literal> query handler and interact with it
      directly:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/fcm/query_handler.topscript">OCaml utop</ulink>
      (part 4)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let unique = Unique.create 0;;</userinput>
<computeroutput moreinfo="none">val unique : Unique.t = {Unique.next_id = 0}</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Unique.eval unique Sexp.unit;;</userinput>
<computeroutput moreinfo="none">- : (Sexp.t, Error.t) Result.t = Ok 0</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Unique.eval unique Sexp.unit;;</userinput>
<computeroutput moreinfo="none">- : (Sexp.t, Error.t) Result.t = Ok 1</computeroutput></programlisting>

      <para>Here's another example: a query handler that does directory
      listings. Here, the config is the default directory that relative paths
      are interpreted within:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/fcm/query_handler.topscript">OCaml utop</ulink>
      (part 5)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">module List_dir = struct</userinput>
<userinput moreinfo="none">    type config = string with sexp</userinput>
<userinput moreinfo="none">    type t = { cwd: string }</userinput>
<userinput moreinfo="none"/>
<userinput moreinfo="none">    (** [is_abs p] Returns true if [p] is an absolute path  *)</userinput>
<userinput moreinfo="none">    let is_abs p =</userinput>
<userinput moreinfo="none">      String.length p &gt; 0 &amp;&amp; p.[0] = '/'</userinput>
<userinput moreinfo="none"/>
<userinput moreinfo="none">    let name = "ls"</userinput>
<userinput moreinfo="none">    let create cwd = { cwd }</userinput>
<userinput moreinfo="none"/>
<userinput moreinfo="none">    let eval t sexp =</userinput>
<userinput moreinfo="none">      match Or_error.try_with (fun () -&gt; string_of_sexp sexp) with</userinput>
<userinput moreinfo="none">      | Error _ as err -&gt; err</userinput>
<userinput moreinfo="none">      | Ok dir -&gt;</userinput>
<userinput moreinfo="none">        let dir =</userinput>
<userinput moreinfo="none">          if is_abs dir then dir</userinput>
<userinput moreinfo="none">          else Filename.concat t.cwd dir</userinput>
<userinput moreinfo="none">        in</userinput>
<userinput moreinfo="none">        Ok (Array.sexp_of_t String.sexp_of_t (Sys.readdir dir))</userinput>
<userinput moreinfo="none">  end;;</userinput>
<computeroutput moreinfo="none">module List_dir :</computeroutput>
<computeroutput moreinfo="none">  sig</computeroutput>
<computeroutput moreinfo="none">    type config = string</computeroutput>
<computeroutput moreinfo="none">    val config_of_sexp : Sexp.t -&gt; config</computeroutput>
<computeroutput moreinfo="none">    val sexp_of_config : config -&gt; Sexp.t</computeroutput>
<computeroutput moreinfo="none">    type t = { cwd : config; }</computeroutput>
<computeroutput moreinfo="none">    val is_abs : config -&gt; bool</computeroutput>
<computeroutput moreinfo="none">    val name : config</computeroutput>
<computeroutput moreinfo="none">    val create : config -&gt; t</computeroutput>
<computeroutput moreinfo="none">    val eval : t -&gt; Sexp.t -&gt; (Sexp.t, Error.t) Result.t</computeroutput>
<computeroutput moreinfo="none">  end</computeroutput></programlisting>

      <para>Again, we can create an instance of this query handler and
      interact with it directly:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/fcm/query_handler.topscript">OCaml utop</ulink>
      (part 6)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let list_dir = List_dir.create "/var";;</userinput>
<computeroutput moreinfo="none">val list_dir : List_dir.t = {List_dir.cwd = "/var"}</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">List_dir.eval list_dir (sexp_of_string ".");;</userinput>
<computeroutput moreinfo="none">- : (Sexp.t, Error.t) Result.t =</computeroutput>
<computeroutput moreinfo="none">Ok (lib mail cache www spool run log lock opt local backups tmp)</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">List_dir.eval list_dir (sexp_of_string "yp");;</userinput>
<computeroutput moreinfo="none">Exception: (Sys_error "/var/yp: No such file or directory").</computeroutput></programlisting>
    </sect2>

    <sect2 id="dispatching-to-multiple-query-handlers">
      <title>Dispatching to Multiple Query Handlers</title>

      <para>Now, what if we want to dispatch queries to any of an arbitrary
      collection of handlers? Ideally, we'd just like to pass in the handlers
      as a simple data structure like a list. This is awkward to do with
      modules and functors alone, but it's quite natural with first-class
      modules. The first thing we'll need to do is create a signature that
      combines a <literal moreinfo="none">Query_handler</literal> module with
      an instantiated query handler:<indexterm class="singular">
          <primary>query-handlers</primary>

          <secondary>dispatching to multiple</secondary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/fcm/query_handler.topscript">OCaml utop</ulink>
      (part 7)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">module type Query_handler_instance = sig</userinput>
<userinput moreinfo="none">    module Query_handler : Query_handler</userinput>
<userinput moreinfo="none">    val this : Query_handler.t</userinput>
<userinput moreinfo="none">  end;;</userinput>
<computeroutput moreinfo="none">module type Query_handler_instance =</computeroutput>
<computeroutput moreinfo="none">  sig module Query_handler : Query_handler val this : Query_handler.t end</computeroutput></programlisting>

      <para>With this signature, we can create a first-class module that
      encompasses both an instance of the query and the matching operations
      for working with that query.</para>

      <para>We can create an instance as follows:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/fcm/query_handler.topscript">OCaml utop</ulink>
      (part 8)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let unique_instance =</userinput>
<userinput moreinfo="none">    (module struct</userinput>
<userinput moreinfo="none">       module Query_handler = Unique</userinput>
<userinput moreinfo="none">       let this = Unique.create 0</userinput>
<userinput moreinfo="none">     end : Query_handler_instance);;</userinput>
<computeroutput moreinfo="none">val unique_instance : (module Query_handler_instance) = &lt;module&gt;</computeroutput></programlisting>

      <para>Constructing instances in this way is a little verbose, but we can
      write a function that eliminates most of this boilerplate. Note that we
      are again making use of a locally abstract type:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/fcm/query_handler.topscript">OCaml utop</ulink>
      (part 9)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let build_instance</userinput>
<userinput moreinfo="none">        (type a)</userinput>
<userinput moreinfo="none">        (module Q : Query_handler with type config = a)</userinput>
<userinput moreinfo="none">        config</userinput>
<userinput moreinfo="none">    =</userinput>
<userinput moreinfo="none">    (module struct</userinput>
<userinput moreinfo="none">       module Query_handler = Q</userinput>
<userinput moreinfo="none">       let this = Q.create config</userinput>
<userinput moreinfo="none">     end : Query_handler_instance)</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val build_instance :</computeroutput>
<computeroutput moreinfo="none">  (module Query_handler with type config = 'a) -&gt;</computeroutput>
<computeroutput moreinfo="none">  'a -&gt; (module Query_handler_instance) = &lt;fun&gt;</computeroutput></programlisting>

      <para>Using <literal moreinfo="none">build_instance</literal>,
      constructing a new instance becomes a one-liner:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/fcm/query_handler.topscript">OCaml utop</ulink>
      (part 10)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let unique_instance = build_instance (module Unique) 0;;</userinput>
<computeroutput moreinfo="none">val unique_instance : (module Query_handler_instance) = &lt;module&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let list_dir_instance = build_instance (module List_dir)  "/var";;</userinput>
<computeroutput moreinfo="none">val list_dir_instance : (module Query_handler_instance) = &lt;module&gt;</computeroutput></programlisting>

      <para>We can now write code that lets you dispatch queries to one of a
      list of query handler instances. We assume that the shape of the query
      is as follows:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/fcm/query-syntax.scm">Scheme</ulink></para>

      <programlisting format="linespecific" language="scheme">(<emphasis>query-name query</emphasis>)</programlisting>

      <para>where <emphasis><literal moreinfo="none">query-name</literal></emphasis> is the name used to
      determine which query handler to dispatch the query to, and
      <emphasis><literal moreinfo="none">query</literal></emphasis> is the
      body of the query.</para>

      <para>The first thing we'll need is a function that takes a list of
      query handler instances and constructs a dispatch table from it:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/fcm/query_handler.topscript">OCaml utop</ulink>
      (part 11)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let build_dispatch_table handlers =</userinput>
<userinput moreinfo="none">    let table = String.Table.create () in</userinput>
<userinput moreinfo="none">    List.iter handlers</userinput>
<userinput moreinfo="none">      ~f:(fun ((module I : Query_handler_instance) as instance) -&gt;</userinput>
<userinput moreinfo="none">        Hashtbl.replace table ~key:I.Query_handler.name ~data:instance);</userinput>
<userinput moreinfo="none">    table</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val build_dispatch_table :</computeroutput>
<computeroutput moreinfo="none">  (module Query_handler_instance) list -&gt;</computeroutput>
<computeroutput moreinfo="none">  (module Query_handler_instance) String.Table.t = &lt;fun&gt;</computeroutput></programlisting>

      <para>Now, we need a function that dispatches to a handler using a
      dispatch table:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/fcm/query_handler.topscript">OCaml utop</ulink>
      (part 12)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let dispatch dispatch_table name_and_query =</userinput>
<userinput moreinfo="none">    match name_and_query with</userinput>
<userinput moreinfo="none">    | Sexp.List [Sexp.Atom name; query] -&gt;</userinput>
<userinput moreinfo="none">      begin match Hashtbl.find dispatch_table name with</userinput>
<userinput moreinfo="none">      | None -&gt;</userinput>
<userinput moreinfo="none">        Or_error.error "Could not find matching handler"</userinput>
<userinput moreinfo="none">          name String.sexp_of_t</userinput>
<userinput moreinfo="none">      | Some (module I : Query_handler_instance) -&gt;</userinput>
<userinput moreinfo="none">        I.Query_handler.eval I.this query</userinput>
<userinput moreinfo="none">      end</userinput>
<userinput moreinfo="none">    | _ -&gt;</userinput>
<userinput moreinfo="none">      Or_error.error_string "malformed query"</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val dispatch :</computeroutput>
<computeroutput moreinfo="none">  (string, (module Query_handler_instance)) Hashtbl.t -&gt;</computeroutput>
<computeroutput moreinfo="none">  Sexp.t -&gt; Sexp.t Or_error.t = &lt;fun&gt;</computeroutput></programlisting>

      <para>This function interacts with an instance by unpacking it into a
      module <literal moreinfo="none">I</literal> and then using the query
      handler instance (<literal moreinfo="none">I.this</literal>) in concert
      with the associated module (<literal moreinfo="none">I.Query_handler</literal>).<indexterm class="singular">
          <primary>I.Query_handler module</primary>
        </indexterm></para>

      <para>The bundling together of the module and the value is in many ways
      reminiscent of object-oriented languages. One key difference, is that
      first-class modules allow you to package up more than just functions or
      methods. As we've seen, you can also include types and even modules.
      We've only used it in a small way here, but this extra power allows you
      to build more sophisticated components that involve multiple
      interdependent types and values.</para>

      <para>Now let's turn this into a complete, running example by adding a
      command-line interface:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/fcm/query_handler.topscript">OCaml utop</ulink>
      (part 13)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let rec cli dispatch_table =</userinput>
<userinput moreinfo="none">    printf "&gt;&gt;&gt; %!";</userinput>
<userinput moreinfo="none">    let result =</userinput>
<userinput moreinfo="none">      match In_channel.input_line stdin with</userinput>
<userinput moreinfo="none">      | None -&gt; `Stop</userinput>
<userinput moreinfo="none">      | Some line -&gt;</userinput>
<userinput moreinfo="none">        match Or_error.try_with (fun () -&gt; Sexp.of_string line) with</userinput>
<userinput moreinfo="none">        | Error e -&gt; `Continue (Error.to_string_hum e)</userinput>
<userinput moreinfo="none">        | Ok (Sexp.Atom "quit") -&gt; `Stop</userinput>
<userinput moreinfo="none">        | Ok query -&gt;</userinput>
<userinput moreinfo="none">          begin match dispatch dispatch_table query with</userinput>
<userinput moreinfo="none">          | Error e -&gt; `Continue (Error.to_string_hum e)</userinput>
<userinput moreinfo="none">          | Ok s    -&gt; `Continue (Sexp.to_string_hum s)</userinput>
<userinput moreinfo="none">          end;</userinput>
<userinput moreinfo="none">    in</userinput>
<userinput moreinfo="none">    match result with</userinput>
<userinput moreinfo="none">    | `Stop -&gt; ()</userinput>
<userinput moreinfo="none">    | `Continue msg -&gt;</userinput>
<userinput moreinfo="none">      printf "%s\n%!" msg;</userinput>
<userinput moreinfo="none">      cli dispatch_table</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val cli : (string, (module Query_handler_instance)) Hashtbl.t -&gt; unit = &lt;fun&gt;</computeroutput></programlisting>

      <para>We can most effectively run this command-line interface from a
      standalone program, which we can do by putting the above code in a file
      along with following command to launch the interface:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/fcm/query_handler.ml">OCaml</ulink>
      (part 1)</para>

      <programlisting format="linespecific" language="ocaml">let () =
  cli (build_dispatch_table [unique_instance; list_dir_instance])</programlisting>

      <para>Here's an example of a session with this program:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/fcm/query_example.rawscript">OCaml utop</ulink></para>

      <programlisting format="linespecific" language="ocaml"><computeroutput moreinfo="none">$ ./query_handler.byte 
&gt;&gt;&gt; (unique ())
0
&gt;&gt;&gt; (unique ())
1
&gt;&gt;&gt; (ls .)
(agentx at audit backups db empty folders jabberd lib log mail msgs named
 netboot pgsql_socket_alt root rpc run rwho spool tmp vm yp)
&gt;&gt;&gt; (ls vm)
(sleepimage swapfile0 swapfile1 swapfile2 swapfile3 swapfile4 swapfile5
 swapfile6)</computeroutput>
</programlisting>
    </sect2>

    <sect2 id="loading-and-unloading-query-handlers">
      <title>Loading and Unloading Query Handlers</title>

      <para>One of the advantages of first-class modules is that they afford a
      great deal of dynamism and flexibility. For example, it's a fairly
      simple matter to change our design to allow query handlers to be loaded
      and unloaded at runtime.<indexterm class="singular">
          <primary>query-handlers</primary>

          <secondary>loading/unloading of</secondary>
        </indexterm></para>

      <para>We'll do this by creating a query handler whose job is to control
      the set of active query handlers. The module in question will be called
      <literal moreinfo="none">Loader</literal>, and its configuration is a
      list of known <literal moreinfo="none">Query_handler</literal> modules.
      Here are the basic types:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/fcm/query_handler_core.ml">OCaml</ulink>
      (part 1)</para>

      <programlisting format="linespecific" language="ocaml">module Loader = struct
  type config = (module Query_handler) list sexp_opaque
  with sexp

  type t = { known  : (module Query_handler)          String.Table.t
           ; active : (module Query_handler_instance) String.Table.t
           }

  let name = "loader"</programlisting>

      <para>Note that a <literal moreinfo="none">Loader.t</literal> has two
      tables: one containing the known query handler modules, and one
      containing the active query handler instances. The <literal moreinfo="none">Loader.t</literal> will be responsible for creating new
      instances and adding them to the table, as well as for removing
      instances, all in response to user queries.</para>

      <para>Next, we'll need a function for creating a <literal moreinfo="none">Loader.t</literal>. This function requires the list of
      known query handler modules. Note that the table of active modules
      starts out as empty:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/fcm/query_handler_core.ml">OCaml</ulink>
      (part 2)</para>

      <programlisting format="linespecific" language="ocaml">let create known_list =
    let active = String.Table.create () in
    let known  = String.Table.create () in
    List.iter known_list
      ~f:(fun ((module Q : Query_handler) as q) -&gt;
        Hashtbl.replace known ~key:Q.name ~data:q);
    { known; active }</programlisting>

      <para>Now we'll start writing out the functions for manipulating the
      table of active query handlers. We'll start with the function for
      loading an instance. Note that it takes as an argument both the name of
      the query handler and the configuration for instantiating that handler
      in the form of an s-expression. These are used for creating a
      first-class module of type <literal moreinfo="none">(module
      Query_handler_instance)</literal>, which is then added to the active
      table:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/fcm/query_handler_core.ml">OCaml</ulink>
      (part 3)</para>

      <programlisting format="linespecific" language="ocaml">let load t handler_name config =
    if Hashtbl.mem t.active handler_name then
      Or_error.error "Can't re-register an active handler"
        handler_name String.sexp_of_t
    else
      match Hashtbl.find t.known handler_name with
      | None -&gt;
        Or_error.error "Unknown handler" handler_name String.sexp_of_t
      | Some (module Q : Query_handler) -&gt;
        let instance =
          (module struct
             module Query_handler = Q
             let this = Q.create (Q.config_of_sexp config)
           end : Query_handler_instance)
        in
        Hashtbl.replace t.active ~key:handler_name ~data:instance;
        Ok Sexp.unit</programlisting>

      <para>Since the <literal moreinfo="none">load</literal> function will
      refuse to <literal moreinfo="none">load</literal> an already active
      handler, we also need the ability to unload a handler. Note that the
      handler explicitly refuses to unload itself:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/fcm/query_handler_core.ml">OCaml</ulink>
      (part 4)</para>

      <programlisting format="linespecific" language="ocaml">let unload t handler_name =
    if not (Hashtbl.mem t.active handler_name) then
      Or_error.error "Handler not active" handler_name String.sexp_of_t
    else if handler_name = name then
      Or_error.error_string "It's unwise to unload yourself"
    else (
      Hashtbl.remove t.active handler_name;
      Ok Sexp.unit
    )</programlisting>

      <para>Finally, we need to implement the <literal moreinfo="none">eval</literal> function,
                which will determine the query <phrase role="keep-together">interface</phrase>
                presented to the user. We'll do this by creating a variant type, and using the
                s-expression converter generated for that type to parse the query from the
                user:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/fcm/query_handler_core.ml">OCaml</ulink>
      (part 5)</para>

      <programlisting format="linespecific" language="ocaml">type request =
    | Load of string * Sexp.t
    | Unload of string
    | Known_services
    | Active_services
  with sexp</programlisting>

      <para>The <literal>eval</literal> function itself is fairly straightforward, dispatching to
                the appropriate functions to respond to each type of query. Note that we write
                    <literal moreinfo="none">&lt;:sexp_of&lt;string list&gt;&gt;</literal> to
                autogenerate a function for converting a list of strings to an s-expression, as
                described in <xref linkend="data-serialization-with-s-expressions"/>.</para>

      <para>This function ends the definition of the <literal moreinfo="none">Loader</literal> module:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/fcm/query_handler_core.ml">OCaml</ulink>
      (part 6)</para>

      <programlisting format="linespecific" language="ocaml">let eval t sexp =
    match Or_error.try_with (fun () -&gt; request_of_sexp sexp) with
    | Error _ as err -&gt; err
    | Ok resp -&gt;
      match resp with
      | Load (name,config) -&gt; load   t name config
      | Unload name        -&gt; unload t name
      | Known_services -&gt;
        Ok (&lt;:sexp_of&lt;string list&gt;&gt; (Hashtbl.keys t.known))
      | Active_services -&gt;
        Ok (&lt;:sexp_of&lt;string list&gt;&gt; (Hashtbl.keys t.active))
end</programlisting>

      <para>Finally, we can put this all together with the command-line
      interface. We first create an instance of the loader query handler and
      then add that instance to the loader's active table. We can then just
      launch the command-line interface, passing it the active table:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/fcm/query_handler_loader.ml">OCaml</ulink>
      (part 1)</para>

      <programlisting format="linespecific" language="ocaml">let () =
  let loader = Loader.create [(module Unique); (module List_dir)] in
  let loader_instance =
    (module struct
       module Query_handler = Loader
       let this = loader
     end : Query_handler_instance)
  in
  Hashtbl.replace loader.Loader.active
    ~key:Loader.name ~data:loader_instance;
  cli loader.Loader.active</programlisting>

      <para>Now build this into a command-line interface to experiment with it:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/fcm/build_query_handler_loader.out">Terminal</ulink></para>

      <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">corebuild query_handler_loader.byte</userinput>
</programlisting>

      <para>The resulting command-line interface behaves much as you'd expect,
      starting out with no query handlers available but giving you the ability
      to load and unload them. Here's an example of it in action. As you can
      see, we start out with <literal moreinfo="none">loader</literal> itself
      as the only active handler:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/fcm/loader_cli1.out">Terminal</ulink></para>

      <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">./query_handler_loader.byte</userinput>
<computeroutput moreinfo="none">&gt;&gt;&gt; (loader known_services)</computeroutput>
<computeroutput moreinfo="none">(ls unique)</computeroutput>
<computeroutput moreinfo="none">&gt;&gt;&gt; (loader active_services)</computeroutput>
<computeroutput moreinfo="none">(loader)</computeroutput></programlisting>

      <para>Any attempt to use an inactive query handler will fail:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/fcm/loader_cli2.out">Terminal</ulink></para>

      <programlisting format="linespecific" language="console"><computeroutput moreinfo="none">&gt;&gt;&gt; (ls .)</computeroutput>
<computeroutput moreinfo="none">Could not find matching handler: ls</computeroutput></programlisting>

      <para>But, we can load the <literal moreinfo="none">ls</literal> handler
      with a config of our choice, at which point it will be available for
      use. And once we unload it, it will be unavailable yet again and could
      be reloaded with a different config:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/fcm/loader_cli3.out">Terminal</ulink></para>

      <programlisting format="linespecific" language="console"><computeroutput moreinfo="none">&gt;&gt;&gt; (loader (load ls /var))</computeroutput>
<computeroutput moreinfo="none">()</computeroutput>
<computeroutput moreinfo="none">&gt;&gt;&gt; (ls /var)</computeroutput>
<computeroutput moreinfo="none">(agentx at audit backups db empty folders jabberd lib log mail msgs named</computeroutput>
<computeroutput moreinfo="none"> netboot pgsql_socket_alt root rpc run rwho spool tmp vm yp)</computeroutput>
<computeroutput moreinfo="none">&gt;&gt;&gt; (loader (unload ls))</computeroutput>
<computeroutput moreinfo="none">()</computeroutput>
<computeroutput moreinfo="none">&gt;&gt;&gt; (ls /var)</computeroutput>
<computeroutput moreinfo="none">Could not find matching handler: ls</computeroutput></programlisting>

      <para>Notably, the loader can't be loaded (since it's not on the list of
      known handlers) and can't be unloaded either:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/fcm/loader_cli4.out">Terminal</ulink></para>

      <programlisting format="linespecific" language="console"><computeroutput moreinfo="none">&gt;&gt;&gt; (loader (unload loader))</computeroutput>
<computeroutput moreinfo="none">It's unwise to unload yourself</computeroutput></programlisting>
            <para>Although we won't describe the details here, we can push this dynamism yet further
                using OCaml's dynamic linking facilities, which allow you to compile and link in new
                code to a running program. This can be automated using libraries like
                    <literal>ocaml_plugin</literal>, which can be installed via OPAM, and which
                automates much of the workflow around setting up dynamic linking. <indexterm class="endofrange" startref="FCMquery"/> </para>
    </sect2>
  </sect1>

  <sect1 id="living-without-first-class-modules">
    <title>Living Without First-Class Modules</title>

    <para>It's worth noting that most designs that can be done with
    first-class modules can be simulated without them, with some level of
    awkwardness. For example, we could rewrite our query handler example
    without first-class modules using the following types:<indexterm class="singular">
        <primary>first-class modules</primary>

        <secondary>alternatives to</secondary>
      </indexterm></para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/fcm/query_handler.topscript">OCaml utop</ulink>
    (part 14)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">type query_handler_instance = { name : string</userinput>
<userinput moreinfo="none">                                ; eval : Sexp.t -&gt; Sexp.t Or_error.t</userinput>
<userinput moreinfo="none">                                }</userinput>
<userinput moreinfo="none">  type query_handler = Sexp.t -&gt; query_handler_instance</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">type query_handler_instance = {</computeroutput>
<computeroutput moreinfo="none">  name : string;</computeroutput>
<computeroutput moreinfo="none">  eval : Sexp.t -&gt; Sexp.t Or_error.t;</computeroutput>
<computeroutput moreinfo="none">}</computeroutput>
<computeroutput moreinfo="none">type query_handler = Sexp.t -&gt; query_handler_instance</computeroutput></programlisting>

    <para>The idea here is that we hide the true types of the objects in
    question behind the functions stored in the closure. Thus, we could put
    the <literal moreinfo="none">Unique</literal> query handler into this
    framework as follows:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/fcm/query_handler.topscript">OCaml utop</ulink>
    (part 15)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let unique_handler config_sexp =</userinput>
<userinput moreinfo="none">    let config = Unique.config_of_sexp config_sexp in</userinput>
<userinput moreinfo="none">    let unique = Unique.create config in</userinput>
<userinput moreinfo="none">    { name = Unique.name</userinput>
<userinput moreinfo="none">    ; eval = (fun config -&gt; Unique.eval unique config)</userinput>
<userinput moreinfo="none">    }</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val unique_handler : Sexp.t -&gt; query_handler_instance = &lt;fun&gt;</computeroutput></programlisting>

    <para>For an example on this scale, the preceding approach is completely
    reasonable, and first-class modules are not really necessary. But the more
    functionality you need to hide away behind a set of closures, and the more
    complicated the relationships between the different types in question, the
    more awkward this approach becomes, and the better it is to use
    first-class modules.<indexterm class="endofrange" startref="MODfirst"/></para>
  </sect1>
</chapter>

  <chapter id="objects">
  <title>Objects</title>

  <para>We've already seen several tools that OCaml provides for organizing
  programs, particularly modules. In addition, OCaml also supports
  object-oriented programming. There are objects, classes, and their
  associated types. In this chapter, we'll introduce you to OCaml objects and
  subtyping. In the next chapter, <xref linkend="classes"/>, we'll introduce
  you to classes and inheritance.<indexterm class="singular">
      <primary>objects</primary>

      <secondary sortas="object-oriented">in object-oriented
      programming</secondary>
    </indexterm><indexterm class="singular">
      <primary>object-oriented programming (OOP)</primary>
    </indexterm><indexterm class="singular">
      <primary>programming</primary>

      <secondary>object-oriented programming (OOP)</secondary>
    </indexterm></para>

  <sidebar>
    <title>What Is Object-Oriented Programming?</title>

    <para>Object-oriented programming (often shorted to OOP) is a programming
    style that encapsulates computation and data within logical
    <emphasis>objects</emphasis>. Each object contains some data stored in
    <emphasis>fields</emphasis> and has <emphasis>method</emphasis> functions
    that can be invoked against the data within the object (also called
    "sending a message" to the object). The code definition behind an object
    is called a <emphasis>class</emphasis>, and objects are constructed from a
    class definition by calling a constructor with the data that the object
    will use to build itself.</para>

    <para>There are five fundamental properties that differentiate OOP from
    other styles:</para>

    <variablelist>
      <varlistentry>
        <term>Abstraction</term>

        <listitem>
          <para>The details of the implementation are hidden in the object,
          and the external interface is just the set of publicly accessible
          methods.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>Dynamic lookup</term>

        <listitem>
          <para>When a message is sent to an object, the method to be executed
          is determined by the implementation of the object, not by some
          static property of the program. In other words, different objects
          may react to the same message in different ways.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>Subtyping</term>

        <listitem>
          <para>If an object <literal moreinfo="none">a</literal> has all the
          functionality of an object <literal moreinfo="none">b</literal>,
          then we may use <literal moreinfo="none">a</literal> in any context
          where <literal moreinfo="none">b</literal> is expected.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>Inheritance</term>

        <listitem>
          <para>The definition of one kind of object can be reused to produce
          a new kind of object. This new definition can override some
          behavior, but also share code with its parent.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>Open recursion</term>

        <listitem>
          <para>An object's methods can invoke another method in the same
          object using a special variable (often called <literal moreinfo="none">self</literal> or <literal moreinfo="none">this</literal>). When objects are created from
          classes, these calls use dynamic lookup, allowing a method defined
          in one class to invoke methods defined in another class that
          inherits from the first.</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <para>Almost every notable modern programming language has been influenced
    by OOP, and you'll have run across these terms if you've ever used C++,
    Java, C#, Ruby, Python, or JavaScript.</para>
  </sidebar>

  <sect1 id="ocaml-objects">
    <title>OCaml Objects</title>

    <para>If you already know about object-oriented programming in a language
    like Java or <phrase role="keep-together">C++,</phrase> the OCaml object
    system may come as a surprise. Foremost is the complete separation of
    objects and their types from the class system. In a language like Java, a
    class name is also used as the type of objects created by instantiating
    it, and the relationships between these object types correspond to
    inheritance. For example, if we implement a class <literal moreinfo="none">Deque</literal> in Java by inheriting from a class
    <literal moreinfo="none">Stack</literal>, we would be allowed to pass a
    deque anywhere a stack is expected.<indexterm class="singular">
        <primary>objects</primary>

        <secondary sortas="OCaml">in OCaml</secondary>
      </indexterm></para>

    <para>OCaml is entirely different. Classes are used to construct objects
    and support inheritance, but classes are not types. Instead, objects have
    <emphasis>object types</emphasis>, and if you want to use objects, you
    aren't required to use classes at all. Here's an example of a simple
    object:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/objects/stack.topscript">OCaml utop</ulink>
    (part 1)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let s = object</userinput>
<userinput moreinfo="none">    val mutable v = [0; 2]</userinput>
<userinput moreinfo="none"/>
<userinput moreinfo="none">    method pop =</userinput>
<userinput moreinfo="none">      match v with</userinput>
<userinput moreinfo="none">      | hd :: tl -&gt; </userinput>
<userinput moreinfo="none">        v &lt;- tl;</userinput>
<userinput moreinfo="none">        Some hd</userinput>
<userinput moreinfo="none">      | [] -&gt; None</userinput>
<userinput moreinfo="none"/>
<userinput moreinfo="none">    method push hd = </userinput>
<userinput moreinfo="none">      v &lt;- hd :: v</userinput>
<userinput moreinfo="none">  end ;;</userinput>
<computeroutput moreinfo="none">val s : &lt; pop : int option; push : int -&gt; unit &gt; = &lt;obj&gt;</computeroutput></programlisting>

    <para>The object has an integer list value <literal moreinfo="none">v</literal>, a method <literal moreinfo="none">pop</literal> that returns the head of <literal moreinfo="none">v</literal>, and a method <literal moreinfo="none">push</literal> that adds an integer to the head of
    <literal moreinfo="none">v</literal>.</para>

    <para>The object type is enclosed in angle brackets <literal moreinfo="none">&lt; ... &gt;</literal>, containing just the types of the
    methods. Fields, like <literal moreinfo="none">v</literal>, are not part
    of the public interface of an object. All interaction with an object is
    through its methods. The syntax for a method invocation uses the <literal moreinfo="none">#</literal> character:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/objects/stack.topscript">OCaml utop</ulink>
    (part 2)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">s#pop ;;</userinput>
<computeroutput moreinfo="none">- : int option = Some 0</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">s#push 4 ;;</userinput>
<computeroutput moreinfo="none">- : unit = ()</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">s#pop ;;</userinput>
<computeroutput moreinfo="none">- : int option = Some 4</computeroutput></programlisting>

    <para>Note that unlike functions, methods can have zero parameters, since the method call is
      routed to a concrete object instance. That's why the <literal>pop</literal> method doesn't
      have a <literal>unit</literal> argument, as the equivalent functional version would. </para>

    <para>Objects can also be constructed by functions. If we want to specify
    the initial value of the object, we can define a function that takes the
    value and returns an object:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/objects/stack.topscript">OCaml utop</ulink>
    (part 3)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let stack init = object</userinput>
<userinput moreinfo="none">    val mutable v = init</userinput>
<userinput moreinfo="none"/>
<userinput moreinfo="none">    method pop =</userinput>
<userinput moreinfo="none">      match v with</userinput>
<userinput moreinfo="none">      | hd :: tl -&gt; </userinput>
<userinput moreinfo="none">        v &lt;- tl;</userinput>
<userinput moreinfo="none">        Some hd</userinput>
<userinput moreinfo="none">      | [] -&gt; None</userinput>
<userinput moreinfo="none"/>
<userinput moreinfo="none">    method push hd = </userinput>
<userinput moreinfo="none">      v &lt;- hd :: v</userinput>
<userinput moreinfo="none">  end ;;</userinput>
<computeroutput moreinfo="none">val stack : 'a list -&gt; &lt; pop : 'a option; push : 'a -&gt; unit &gt; = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let s = stack [3; 2; 1] ;;</userinput>
<computeroutput moreinfo="none">val s : &lt; pop : int option; push : int -&gt; unit &gt; = &lt;obj&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">s#pop ;;</userinput>
<computeroutput moreinfo="none">- : int option = Some 3</computeroutput></programlisting>

    <para>Note that the types of the function <literal moreinfo="none">stack</literal> and the returned object now use the
    polymorphic type <literal moreinfo="none">'a</literal>. When <literal moreinfo="none">stack</literal> is invoked on a concrete value <literal moreinfo="none">[3; 2; 1]</literal>, we get the same object type as
    before, with type <literal moreinfo="none">int</literal> for the values on
    the stack.</para>
  </sect1>

  <sect1 id="object-polymorphism">
    <title>Object Polymorphism</title>

    <para>Like polymorphic variants, methods can be used without an explicit
    type declaration:<indexterm class="singular">
        <primary>polymorphism</primary>

        <secondary>in objects</secondary>
      </indexterm><indexterm class="singular">
        <primary>objects</primary>

        <secondary>polymorphism of</secondary>
      </indexterm></para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/objects/polymorphism.topscript">OCaml utop</ulink>
    (part 1)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let area sq = sq#width * sq#width ;;</userinput>
<computeroutput moreinfo="none">val area : &lt; width : int; .. &gt; -&gt; int = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let minimize sq : unit = sq#resize 1 ;;</userinput>
<computeroutput moreinfo="none">val minimize : &lt; resize : int -&gt; unit; .. &gt; -&gt; unit = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let limit sq = </userinput>
<userinput moreinfo="none">    if (area sq) &gt; 100 then minimize sq ;;</userinput>
<computeroutput moreinfo="none">val limit : &lt; resize : int -&gt; unit; width : int; .. &gt; -&gt; unit = &lt;fun&gt;</computeroutput></programlisting>

    <para>As you can see, object types are inferred automatically from the
    methods that are invoked on them.</para>

    <para>The type system will complain if it sees incompatible uses of the
    same method:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/objects/polymorphism.topscript">OCaml utop</ulink>
    (part 2)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let toggle sq b : unit = </userinput>
<userinput moreinfo="none">    if b then sq#resize `Fullscreen</userinput>
<userinput moreinfo="none">    else minimize sq ;;</userinput>
<computeroutput moreinfo="none">Characters 80-82:</computeroutput>
<computeroutput moreinfo="none">Error: This expression has type &lt; resize : [&gt; `Fullscreen ] -&gt; unit; .. &gt;</computeroutput>
<computeroutput moreinfo="none">       but an expression was expected of type &lt; resize : int -&gt; unit; .. &gt;</computeroutput>
<computeroutput moreinfo="none">       Types for method resize are incompatible</computeroutput></programlisting>

    <para>The <literal moreinfo="none">..</literal> in the inferred object
    types are ellipses, standing for other unspecified methods that the object
    may have. The type <literal moreinfo="none">&lt; width : float; ..
    &gt;</literal> specifies an object that must have at least a <literal moreinfo="none">width</literal> method, and possibly some others as well.
    Such object types are said to be <emphasis>open</emphasis>.<indexterm class="singular">
        <primary>open object types</primary>
      </indexterm></para>

    <para>We can manually <emphasis>close</emphasis> an object type using a
    type annotation:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/objects/polymorphism.topscript">OCaml utop</ulink>
    (part 3)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let area_closed (sq: &lt; width : int &gt;) = sq#width * sq#width ;;</userinput>
<computeroutput moreinfo="none">val area_closed : &lt; width : int &gt; -&gt; int = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let sq = object</userinput>
<userinput moreinfo="none">    method width = 30 </userinput>
<userinput moreinfo="none">    method name = "sq" </userinput>
<userinput moreinfo="none">  end ;;</userinput>
<computeroutput moreinfo="none">val sq : &lt; name : string; width : int &gt; = &lt;obj&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">area_closed sq ;;</userinput>
<computeroutput moreinfo="none">Characters 12-14:</computeroutput>
<computeroutput moreinfo="none">Error: This expression has type &lt; name : string; width : int &gt;</computeroutput>
<computeroutput moreinfo="none">       but an expression was expected of type &lt; width : int &gt;</computeroutput>
<computeroutput moreinfo="none">       The second object type has no method name</computeroutput></programlisting>

    <note>
      <title>Elisions Are Polymorphic</title>

      <para>The <literal moreinfo="none">..</literal> in an open object type
      is an elision, standing for "possibly more methods." It may not be
      apparent from the syntax, but an elided object type is actually
      polymorphic. For example, if we try to write a type definition, we get
      an "unbound type variable" error:<indexterm class="singular">
          <primary>polymorphism</primary>

          <secondary>row polymorphism</secondary>
        </indexterm><indexterm class="singular">
          <primary>row polymorphism</primary>
        </indexterm><indexterm class="singular">
          <primary>ellipses (..)</primary>
        </indexterm><indexterm class="singular">
          <primary>type variables</primary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/objects/polymorphism.topscript">OCaml utop</ulink>
      (part 4)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">type square = &lt; width : int; ..&gt; ;;</userinput>
<computeroutput moreinfo="none">Characters 5-32:</computeroutput>
<computeroutput moreinfo="none">Error: A type variable is unbound in this type declaration.</computeroutput>
<computeroutput moreinfo="none">In type &lt; width : int; .. &gt; as 'a the variable 'a is unbound</computeroutput></programlisting>

      <para>This is because <literal moreinfo="none">..</literal> is really a
      special kind of type variable called a <emphasis>row
      variable</emphasis>.</para>

      <para>This kind of typing scheme using row variables is called
      <emphasis>row polymorphism</emphasis>. Row polymorphism is also used in
      polymorphic variant types, and there is a close relationship between
      objects and polymorphic variants: objects are to records what
      polymorphic variants are to ordinary variants.</para>
    </note>

    <para>An object of type <literal moreinfo="none">&lt; pop : int option; ..
    &gt;</literal> can be any object with a method <literal moreinfo="none">pop : int option</literal>; it doesn't matter how it is
    implemented. When the method <literal moreinfo="none">#pop</literal> is
    invoked, the actual method that is run is determined by the object:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/objects/stack.topscript">OCaml utop</ulink>
    (part 4)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let print_pop st = Option.iter ~f:(printf "Popped: %d\n") st#pop ;;</userinput>
<computeroutput moreinfo="none">val print_pop : &lt; pop : int option; .. &gt; -&gt; unit = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">print_pop (stack [5;4;3;2;1]) ;;</userinput>
<computeroutput moreinfo="none">Popped: 5</computeroutput>
<computeroutput moreinfo="none">- : unit = ()</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let t = object</userinput>
<userinput moreinfo="none">    method pop = Some (Float.to_int (Time.to_float (Time.now ())))</userinput>
<userinput moreinfo="none">  end ;;</userinput>
<computeroutput moreinfo="none">val t : &lt; pop : int option &gt; = &lt;obj&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">print_pop t ;;</userinput>
<computeroutput moreinfo="none">Popped: 1376833904</computeroutput>
<computeroutput moreinfo="none">- : unit = ()</computeroutput></programlisting>
  </sect1>

  <sect1 id="immutable-objects">
    <title>Immutable Objects</title>

    <para>Many people consider object-oriented programming to be intrinsically
    imperative, where an object is like a state machine. Sending a message to
    an object causes it to change state, possibly sending messages to other
    objects.<indexterm class="singular">
        <primary>objects</primary>

        <secondary>immutabile</secondary>
      </indexterm></para>

    <para>Indeed, in many programs this makes sense, but it is by no means
    required. Let's define a function that creates immutable stack
    objects:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/objects/immutable.topscript">OCaml utop</ulink>
    (part 1)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let imm_stack init = object</userinput>
<userinput moreinfo="none">    val v = init</userinput>
<userinput moreinfo="none"/>
<userinput moreinfo="none">    method pop =</userinput>
<userinput moreinfo="none">      match v with</userinput>
<userinput moreinfo="none">      | hd :: tl -&gt; Some (hd, {&lt; v = tl &gt;})</userinput>
<userinput moreinfo="none">      | [] -&gt; None </userinput>
<userinput moreinfo="none"/>
<userinput moreinfo="none">    method push hd = </userinput>
<userinput moreinfo="none">      {&lt; v = hd :: v &gt;}</userinput>
<userinput moreinfo="none">  end ;;</userinput>
<computeroutput moreinfo="none">val imm_stack :</computeroutput>
<computeroutput moreinfo="none">  'a list -&gt; (&lt; pop : ('a * 'b) option; push : 'a -&gt; 'b &gt; as 'b) = &lt;fun&gt;</computeroutput></programlisting>

    <para>The key parts of this implementation are in the <literal moreinfo="none">pop</literal> and <literal moreinfo="none">push</literal>
    methods. The expression <literal moreinfo="none">{&lt; ... &gt;}</literal>
    produces a copy of the current object, with the same type, and the
    specified fields updated. In other words, the <literal moreinfo="none">push hd</literal> method produces a copy of the object,
    with <literal moreinfo="none">v</literal> replaced by <literal moreinfo="none">hd :: v</literal>. The original object is not
    modified:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/objects/immutable.topscript">OCaml utop</ulink>
    (part 2)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let s = imm_stack [3; 2; 1] ;;</userinput>
<computeroutput moreinfo="none">val s : &lt; pop : (int * 'a) option; push : int -&gt; 'a &gt; as 'a = &lt;obj&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let t = s#push 4 ;;</userinput>
<computeroutput moreinfo="none">val t : &lt; pop : (int * 'a) option; push : int -&gt; 'a &gt; as 'a = &lt;obj&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">s#pop ;;</userinput>
<computeroutput moreinfo="none">- : (int * (&lt; pop : 'a; push : int -&gt; 'b &gt; as 'b)) option as 'a =</computeroutput>
<computeroutput moreinfo="none">Some (3, &lt;obj&gt;)</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">t#pop ;;</userinput>
<computeroutput moreinfo="none">- : (int * (&lt; pop : 'a; push : int -&gt; 'b &gt; as 'b)) option as 'a =</computeroutput>
<computeroutput moreinfo="none">Some (4, &lt;obj&gt;)</computeroutput></programlisting>

    <para>There are some restrictions on the use of the expression <literal moreinfo="none">{&lt;
        ... &gt;}</literal>. It can be used only within a method body, and only the values of fields
      may be updated. Method implementations are fixed at the time the object is created; they
      cannot be changed <phrase role="keep-together">dynamically</phrase>.</para>
  </sect1>

  <sect1 id="when-to-use-objects">
    <title>When to Use Objects</title>

    <para>You might wonder when to use objects in OCaml, which has a multitude
    of alternative mechanisms to express the similar concepts. First-class
    modules are more expressive (a module can include types, while classes and
    objects cannot). Modules, functors, and data types also offer a wide range
    of ways to express program structure. In fact, many seasoned OCaml
    programmers rarely use classes and objects, if at all.<indexterm class="singular">
        <primary>first-class modules</primary>

        <secondary sortas="objects">vs. objects</secondary>
      </indexterm><indexterm class="singular">
        <primary>objects</primary>

        <secondary>benefits and drawbacks of</secondary>
      </indexterm></para>

    <para>Objects have some advantages over records: they don't require type
    definitions, and their support for row polymorphism makes them more
    flexible. However, the heavy syntax and additional runtime cost means that
    objects are rarely used in place of records.</para>

    <para>The real benefits of objects come from the class system. Classes
    support inheritance and open recursion. Open recursion allows
    interdependent parts of an object to be defined separately. This works
    because calls between the methods of an object are determined when the
    object is instantiated, a form of <emphasis>late</emphasis> binding. This
    makes it possible (and necessary) for one method to refer to other methods
    in the object without knowing statically how they will be
    implemented.<indexterm class="singular">
        <primary>late binding</primary>
      </indexterm><indexterm class="singular">
        <primary>recursion</primary>

        <secondary>open recursion</secondary>
      </indexterm><indexterm class="singular">
        <primary>open recursion</primary>
      </indexterm><indexterm class="singular">
        <primary>classes</primary>

        <secondary>benefits of</secondary>
      </indexterm></para>

    <para>In contrast, modules use early binding. If you want to parameterize
    your module code so that some part of it can be implemented later, you
    would write a function or functor. This is more explicit, but often more
    verbose than overriding a method in a class.</para>

    <para>In general, a rule of thumb is: use classes and objects in
    situations where open recursion is a big win. Two good examples are Xavier
    Leroy's <ulink url="http://gallium.inria.fr/~xleroy/software.html#cryptokit">Cryptokit</ulink>,
    which provides a variety of cryptographic primitives that can be combined
    in building-block style; and the <ulink url="http://cristal.inria.fr/camlimages/">Camlimages</ulink> library,
    which manipulates various graphical file formats. Camlimages also provides
    a module-based version of the same library, letting you choose between
    functional and object-oriented styles depending on your problem
    domain.<indexterm class="singular">
        <primary>Camlimages library</primary>
      </indexterm><indexterm class="singular">
        <primary>Cryptokit library</primary>
      </indexterm><indexterm class="singular">
        <primary>libraries</primary>

        <secondary>Cryptokit</secondary>
      </indexterm><indexterm class="singular">
        <primary>libraries</primary>

        <secondary>Camlimages</secondary>
      </indexterm><indexterm class="singular">
        <primary>external libraries</primary>

        <secondary>Camlimages</secondary>
      </indexterm><indexterm class="singular">
        <primary>external libraries</primary>

        <secondary>Cryptokit</secondary>
      </indexterm></para>

    <para>We'll introduce you to classes, and examples using open recursion,
    in <xref linkend="classes"/>.</para>
  </sect1>

  <sect1 id="subtyping">
    <title>Subtyping</title>

    <para>Subtyping is a central concept in object-oriented programming. It
    governs when an object with one type <emphasis>A</emphasis> can be used in
    an expression that expects an object of another type
    <emphasis>B</emphasis>. When this is true, we say that
    <emphasis>A</emphasis> is a <emphasis>subtype</emphasis> of
    <emphasis>B</emphasis>. More concretely, subtyping restricts when the
    coercion operator <literal moreinfo="none">e :&gt; t</literal> can be
    applied. This coercion works only if the type of <literal moreinfo="none">e</literal> is a subtype of <literal moreinfo="none">t</literal>.<indexterm class="singular">
        <primary>subtyping</primary>

        <secondary>basics of</secondary>
      </indexterm><indexterm class="startofrange" id="OBsub">
        <primary>objects</primary>

        <secondary>subtyping and</secondary>
      </indexterm></para>

    <sect2 id="width-subtyping">
      <title>Width Subtyping</title>

      <para>To explore this, let's define some simple object types for
      geometric shapes. The generic type <literal moreinfo="none">shape</literal> has a method to compute the area, and
      <literal moreinfo="none">square</literal> and <literal moreinfo="none">circle</literal> are specific kinds of shapes:<indexterm class="singular">
          <primary>geometric shapes</primary>
        </indexterm><indexterm class="singular">
          <primary>width subtyping</primary>
        </indexterm><indexterm class="singular">
          <primary>subtyping</primary>

          <secondary>width subtyping</secondary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/objects/subtyping.ml">OCaml</ulink>
      (part 1)</para>

      <programlisting format="linespecific" language="ocaml">type shape = &lt; area : float &gt;

type square = &lt; area : float; width : int &gt;

let square w = object
  method area = Float.of_int (w * w)
  method width = w
end

type circle = &lt; area : float; radius : int &gt;

let circle r = object
  method area = 3.14 *. (Float.of_int r) ** 2.0
  method radius = r
end</programlisting>

      <para>A <literal moreinfo="none">square</literal> has a method <literal moreinfo="none">area</literal> just like a <literal moreinfo="none">shape</literal>, and an additional method <literal moreinfo="none">width</literal>. Still, we expect a <literal moreinfo="none">square</literal> to be a <literal moreinfo="none">shape</literal>, and it is. The coercion <literal moreinfo="none">:&gt;</literal> must be explicit:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/objects/subtyping.topscript">OCaml utop</ulink>
      (part 1)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let shape w : shape = square w ;;</userinput>
<computeroutput moreinfo="none">Characters 22-30:</computeroutput>
<computeroutput moreinfo="none">Error: This expression has type &lt; area : float; width : int &gt;</computeroutput>
<computeroutput moreinfo="none">       but an expression was expected of type shape</computeroutput>
<computeroutput moreinfo="none">       The second object type has no method width</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let shape w : shape = (square w :&gt; shape) ;;</userinput>
<computeroutput moreinfo="none">val shape : int -&gt; shape = &lt;fun&gt;</computeroutput></programlisting>

      <para>This form of object subtyping is called <emphasis>width</emphasis>
      subtyping. Width subtyping means that an object type
      <emphasis>A</emphasis> is a subtype of <emphasis>B</emphasis>, if
      <emphasis>A</emphasis> has all of the methods of <emphasis>B</emphasis>,
      and possibly more. A <literal moreinfo="none">square</literal> is a
      subtype of <literal moreinfo="none">shape</literal> because it
      implements all of the methods of <literal moreinfo="none">shape</literal> (the <literal moreinfo="none">area</literal> method).</para>
    </sect2>

    <sect2 id="depth-subtyping">
      <title>Depth Subtyping</title>

      <para>We can also use <emphasis>depth</emphasis> subtyping with objects.
      Depth subtyping allows us coerce an object if its individual methods
      could safely be coerced. So an object type <literal moreinfo="none">&lt;
      m: t1 &gt;</literal> is a subtype of <literal moreinfo="none">&lt; m: t2
      &gt;</literal> if <literal moreinfo="none">t1</literal> is a subtype of
      <literal moreinfo="none">t2</literal>.<indexterm class="singular">
          <primary>depth subtyping</primary>
        </indexterm><indexterm class="singular">
          <primary>subtyping</primary>

          <secondary>depth subtyping</secondary>
        </indexterm></para>

      <para>For example, we can create two objects with a <literal moreinfo="none">shape</literal> method:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/objects/subtyping.topscript">OCaml utop</ulink>
      (part 2)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let coin = object</userinput>
<userinput moreinfo="none">    method shape = circle 5</userinput>
<userinput moreinfo="none">    method color = "silver"</userinput>
<userinput moreinfo="none">  end ;;</userinput>
<computeroutput moreinfo="none">val coin : &lt; color : string; shape : &lt; area : float; radius : int &gt; &gt; = &lt;obj&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let map = object</userinput>
<userinput moreinfo="none">    method shape = square 10</userinput>
<userinput moreinfo="none">  end ;;</userinput>
<computeroutput moreinfo="none">val map : &lt; shape : &lt; area : float; width : int &gt; &gt; = &lt;obj&gt;</computeroutput></programlisting>

      <para>Both these objects have a <literal moreinfo="none">shape</literal>
      method whose type is a subtype of the <literal moreinfo="none">shape</literal> type, so they can both be coerced into
      the object type <literal moreinfo="none">&lt; shape : shape
      &gt;</literal>:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/objects/subtyping.topscript">OCaml utop</ulink>
      (part 3)<indexterm class="singular">
          <primary>polymorphic variant subtyping</primary>
        </indexterm></para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">type item = &lt; shape : shape &gt; ;;</userinput>
<computeroutput moreinfo="none">type item = &lt; shape : shape &gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let items = [ (coin :&gt; item) ; (map :&gt; item) ] ;;</userinput>
<computeroutput moreinfo="none">val items : item list = [&lt;obj&gt;; &lt;obj&gt;]</computeroutput></programlisting>

      <note>
        <title>Polymorphic Variant Subtyping</title>

        <para>Subtyping can also be used to coerce a polymorphic variant into
        a larger polymorphic variant type. A polymorphic variant type
        <emphasis>A</emphasis> is a subtype of <emphasis>B</emphasis>, if the
        tags of <emphasis>A</emphasis> are a subset of the tags of
        <emphasis>B</emphasis>:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/objects/subtyping.topscript">OCaml utop</ulink>
        (part 4)</para>

        <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">type num = [ `Int of int | `Float of float ] ;;</userinput>
<computeroutput moreinfo="none">type num = [ `Float of float | `Int of int ]</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">type const = [ num | `String of string ] ;;</userinput>
<computeroutput moreinfo="none">type const = [ `Float of float | `Int of int | `String of string ]</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let n : num = `Int 3 ;;</userinput>
<computeroutput moreinfo="none">val n : num = `Int 3</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let c : const = (n :&gt; const) ;;</userinput>
<computeroutput moreinfo="none">val c : const = `Int 3</computeroutput></programlisting>
      </note>
    </sect2>

    <sect2 id="variance">
      <title>Variance</title>

      <para>What about types built from object types? If a <literal moreinfo="none">square</literal> is a <literal moreinfo="none">shape</literal>, we expect a <literal moreinfo="none">square list</literal> to be a <literal moreinfo="none">shape list</literal>. OCaml does indeed allow such
      coercions:<indexterm class="startofrange" id="var">
          <primary>variance</primary>
        </indexterm><indexterm class="startofrange" id="SUBvar">
          <primary>subtyping</primary>

          <secondary>variance and</secondary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/objects/subtyping.topscript">OCaml utop</ulink>
      (part 5)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let squares: square list = [ square 10; square 20 ] ;;</userinput>
<computeroutput moreinfo="none">val squares : square list = [&lt;obj&gt;; &lt;obj&gt;]</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let shapes: shape list = (squares :&gt; shape list) ;;</userinput>
<computeroutput moreinfo="none">val shapes : shape list = [&lt;obj&gt;; &lt;obj&gt;]</computeroutput></programlisting>

      <para>Note that this relies on lists being immutable. It would not be
      safe to treat a <literal moreinfo="none">square array</literal> as a
      <literal moreinfo="none">shape array</literal> because it would allow
      you to store nonsquare shapes into what should be an array of squares.
      OCaml recognizes this and does not allow the coercion:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/objects/subtyping.topscript">OCaml utop</ulink>
      (part 6)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let square_array: square array = [| square 10; square 20 |] ;;</userinput>
<computeroutput moreinfo="none">val square_array : square array = [|&lt;obj&gt;; &lt;obj&gt;|]</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let shape_array: shape array = (square_array :&gt; shape array) ;;</userinput>
<computeroutput moreinfo="none">Characters 31-60:</computeroutput>
<computeroutput moreinfo="none">Error: Type square array is not a subtype of shape array </computeroutput>
<computeroutput moreinfo="none">       Type square = &lt; area : float; width : int &gt;</computeroutput>
<computeroutput moreinfo="none">       is not compatible with type shape = &lt; area : float &gt; </computeroutput>
<computeroutput moreinfo="none">       The second object type has no method width</computeroutput></programlisting>

      <para>We say that <literal moreinfo="none">'a list</literal> is
      <emphasis>covariant</emphasis> (in <literal moreinfo="none">'a</literal>), while <literal moreinfo="none">'a
      array</literal> is <emphasis>invariant</emphasis>.<indexterm class="singular">
          <primary>invariance</primary>
        </indexterm><indexterm class="singular">
          <primary>covariance</primary>
        </indexterm></para>

      <para>Subtyping function types requires a third class of variance. A
      function with type <literal moreinfo="none">square -&gt;
      string</literal> cannot be used with type <literal moreinfo="none">shape
      -&gt; string</literal> because it expects its argument to be a <literal moreinfo="none">square</literal> and would not know what to do with a
      <literal moreinfo="none">circle</literal>. However, a function with type
      <literal moreinfo="none">shape -&gt; string</literal>
      <emphasis>can</emphasis> safely be used with type <literal moreinfo="none">square -&gt; string</literal>:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/objects/subtyping.topscript">OCaml utop</ulink>
      (part 7)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let shape_to_string: shape -&gt; string = </userinput>
<userinput moreinfo="none">    fun s -&gt; sprintf "Shape(%F)" s#area ;;</userinput>
<computeroutput moreinfo="none">val shape_to_string : shape -&gt; string = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let square_to_string: square -&gt; string = </userinput>
<userinput moreinfo="none">    (shape_to_string :&gt; square -&gt; string) ;;</userinput>
<computeroutput moreinfo="none">val square_to_string : square -&gt; string = &lt;fun&gt;</computeroutput></programlisting>

      <para>We say that <literal moreinfo="none">'a -&gt; string</literal> is
      <emphasis>contravariant</emphasis> in <literal moreinfo="none">'a</literal>. In general, function types are
      contravariant in their arguments and covariant in their
      results.<indexterm class="singular">
          <primary>contravariance</primary>
        </indexterm></para>

      <sidebar>
        <title>Variance Annotations</title>

        <para>OCaml works out the variance of a type using that type's
        definition:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/objects/subtyping.topscript">OCaml utop</ulink>
        (part 8)</para>

        <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">module Either = struct</userinput>
<userinput moreinfo="none">    type ('a, 'b) t = </userinput>
<userinput moreinfo="none">      | Left of 'a</userinput>
<userinput moreinfo="none">      | Right of 'b</userinput>
<userinput moreinfo="none">    let left x = Left x</userinput>
<userinput moreinfo="none">    let right x = Right x</userinput>
<userinput moreinfo="none">  end ;;</userinput>
<computeroutput moreinfo="none">module Either :</computeroutput>
<computeroutput moreinfo="none">  sig</computeroutput>
<computeroutput moreinfo="none">    type ('a, 'b) t = Left of 'a | Right of 'b</computeroutput>
<computeroutput moreinfo="none">    val left : 'a -&gt; ('a, 'b) t</computeroutput>
<computeroutput moreinfo="none">    val right : 'a -&gt; ('b, 'a) t</computeroutput>
<computeroutput moreinfo="none">  end</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">(Either.left (square 40) :&gt; (shape, shape) Either.t) ;;</userinput>
<computeroutput moreinfo="none">- : (shape, shape) Either.t = Either.Left &lt;obj&gt;</computeroutput></programlisting>

        <para>However, if the definition is hidden by a signature, then OCaml
        is forced to assume that the type is invariant:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/objects/subtyping.topscript">OCaml utop</ulink>
        (part 9)</para>

        <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">module AbstractEither : sig </userinput>
<userinput moreinfo="none">    type ('a, 'b) t</userinput>
<userinput moreinfo="none">    val left: 'a -&gt; ('a, 'b) t</userinput>
<userinput moreinfo="none">    val right: 'b -&gt; ('a, 'b) t</userinput>
<userinput moreinfo="none">  end = Either ;;</userinput>
<computeroutput moreinfo="none">module AbstractEither :</computeroutput>
<computeroutput moreinfo="none">  sig</computeroutput>
<computeroutput moreinfo="none">    type ('a, 'b) t</computeroutput>
<computeroutput moreinfo="none">    val left : 'a -&gt; ('a, 'b) t</computeroutput>
<computeroutput moreinfo="none">    val right : 'b -&gt; ('a, 'b) t</computeroutput>
<computeroutput moreinfo="none">  end</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">(AbstractEither.left (square 40) :&gt; (shape, shape) AbstractEither.t) ;;</userinput>
<computeroutput moreinfo="none">Characters 1-32:</computeroutput>
<computeroutput moreinfo="none">Error: This expression cannot be coerced to type</computeroutput>
<computeroutput moreinfo="none">         (shape, shape) AbstractEither.t;</computeroutput>
<computeroutput moreinfo="none">       it has type (&lt; area : float; width : int &gt;, 'a) AbstractEither.t</computeroutput>
<computeroutput moreinfo="none">       but is here used with type (shape, shape) AbstractEither.t</computeroutput>
<computeroutput moreinfo="none">       Type &lt; area : float; width : int &gt; is not compatible with type</computeroutput>
<computeroutput moreinfo="none">         shape = &lt; area : float &gt; </computeroutput>
<computeroutput moreinfo="none">       The second object type has no method width</computeroutput></programlisting>

        <para>We can fix this by adding <emphasis>variance
        annotations</emphasis> to the type's parameters in the signature:
        <literal moreinfo="none">+</literal> for covariance or <literal moreinfo="none">-</literal> for contravariance:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/objects/subtyping.topscript">OCaml utop</ulink>
        (part 10)</para>

        <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">module VarEither : sig </userinput>
<userinput moreinfo="none">    type (+'a, +'b) t</userinput>
<userinput moreinfo="none">    val left: 'a -&gt; ('a, 'b) t</userinput>
<userinput moreinfo="none">    val right: 'b -&gt; ('a, 'b) t</userinput>
<userinput moreinfo="none">  end = Either ;;</userinput>
<computeroutput moreinfo="none">module VarEither :</computeroutput>
<computeroutput moreinfo="none">  sig</computeroutput>
<computeroutput moreinfo="none">    type (+'a, +'b) t</computeroutput>
<computeroutput moreinfo="none">    val left : 'a -&gt; ('a, 'b) t</computeroutput>
<computeroutput moreinfo="none">    val right : 'b -&gt; ('a, 'b) t</computeroutput>
<computeroutput moreinfo="none">  end</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">(VarEither.left (square 40) :&gt; (shape, shape) VarEither.t) ;;</userinput>
<computeroutput moreinfo="none">- : (shape, shape) VarEither.t = &lt;abstr&gt;</computeroutput></programlisting>
      </sidebar>

      <para>For a more concrete example of variance, let's create some stacks
      containing shapes by applying our <literal moreinfo="none">stack</literal> function to some squares and some
      circles:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/objects/subtyping.ml">OCaml</ulink>
      (part 2)</para>

      <programlisting format="linespecific" language="ocaml">type 'a stack = &lt; pop: 'a option; push: 'a -&gt; unit &gt;

let square_stack: square stack = stack [square 30; square 10]

let circle_stack: circle stack = stack [circle 20; circle 40]</programlisting>

      <para>If we wanted to write a function that took a list of such stacks
      and found the total area of their shapes, we might try:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/objects/subtyping.topscript">OCaml utop</ulink>
      (part 11)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let total_area (shape_stacks: shape stack list) =</userinput>
<userinput moreinfo="none">    let stack_area acc st = </userinput>
<userinput moreinfo="none">      let rec loop acc =</userinput>
<userinput moreinfo="none">        match st#pop with</userinput>
<userinput moreinfo="none">        | Some s -&gt; loop (acc +. s#area)</userinput>
<userinput moreinfo="none">        | None -&gt; acc</userinput>
<userinput moreinfo="none">      in</userinput>
<userinput moreinfo="none">      loop acc</userinput>
<userinput moreinfo="none">    in</userinput>
<userinput moreinfo="none">      List.fold ~init:0.0 ~f:stack_area shape_stacks ;;</userinput>
<computeroutput moreinfo="none">val total_area : shape stack list -&gt; float = &lt;fun&gt;</computeroutput></programlisting>

      <para>However, when we try to apply this function to our objects, we get
      an error:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/objects/subtyping.topscript">OCaml utop</ulink>
      (part 12)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">total_area [(square_stack :&gt; shape stack); (circle_stack :&gt; shape stack)] ;;</userinput>
<computeroutput moreinfo="none">Characters 12-41:</computeroutput>
<computeroutput moreinfo="none">Error: Type square stack = &lt; pop : square option; push : square -&gt; unit &gt;</computeroutput>
<computeroutput moreinfo="none">       is not a subtype of</computeroutput>
<computeroutput moreinfo="none">         shape stack = &lt; pop : shape option; push : shape -&gt; unit &gt; </computeroutput>
<computeroutput moreinfo="none">       Type shape = &lt; area : float &gt; is not a subtype of</computeroutput>
<computeroutput moreinfo="none">         square = &lt; area : float; width : int &gt; </computeroutput></programlisting>

      <para>As you can see, <literal moreinfo="none">square stack</literal>
      and <literal moreinfo="none">circle stack</literal> are not subtypes of
      <literal moreinfo="none">shape stack</literal>. The problem is with the
      <literal moreinfo="none">push</literal> method. For <literal moreinfo="none">shape stack</literal>, the <literal moreinfo="none">push</literal> method takes an arbitrary <literal moreinfo="none">shape</literal>. So if we could coerce a <literal moreinfo="none">square stack</literal> to a <literal moreinfo="none">shape stack</literal>, then it would be possible to push
      an arbitrary shape onto <literal moreinfo="none">square stack</literal>,
      which would be an error.</para>

      <para>Another way of looking at this is that <literal moreinfo="none">&lt; push: 'a -&gt;
          unit; .. &gt;</literal> is contravariant in <literal moreinfo="none">'a</literal>, so
          <literal moreinfo="none">&lt; push: square -&gt; unit; pop: square option &gt;</literal>
        cannot be a subtype of <phrase><literal moreinfo="none" role="keep-together">&lt; push:
            shape -&gt; unit; pop: shape option &gt;</literal></phrase>.</para>

      <para>Still, the <literal moreinfo="none">total_area</literal> function
      should be fine, in principle. It doesn't call <literal moreinfo="none">push</literal>, so it isn't making that error. To make
      it work, we need to use a more precise type that indicates we are not
      going to be using the <literal>set</literal> method. We define a type
      <literal moreinfo="none">readonly_stack</literal> and confirm that we
      can coerce the list of <literal>stack</literal>s to it:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/objects/subtyping.topscript">OCaml utop</ulink>
      (part 13)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">type 'a readonly_stack = &lt; pop : 'a option &gt; ;;</userinput>
<computeroutput moreinfo="none">type 'a readonly_stack = &lt; pop : 'a option &gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let total_area (shape_stacks: shape readonly_stack list) =</userinput>
<userinput moreinfo="none">    let stack_area acc st = </userinput>
<userinput moreinfo="none">      let rec loop acc =</userinput>
<userinput moreinfo="none">        match st#pop with</userinput>
<userinput moreinfo="none">        | Some s -&gt; loop (acc +. s#area)</userinput>
<userinput moreinfo="none">        | None -&gt; acc</userinput>
<userinput moreinfo="none">      in</userinput>
<userinput moreinfo="none">        loop acc</userinput>
<userinput moreinfo="none">    in</userinput>
<userinput moreinfo="none">      List.fold ~init:0.0 ~f:stack_area shape_stacks ;;</userinput>
<computeroutput moreinfo="none">val total_area : shape readonly_stack list -&gt; float = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">total_area [(square_stack :&gt; shape readonly_stack); (circle_stack :&gt; 
    shape readonly_stack)] ;;</userinput>
<computeroutput moreinfo="none">- : float = 7280.</computeroutput></programlisting>

      <para>Aspects of this section may seem fairly complicated, but it should
      be pointed out that this typing <emphasis>works</emphasis>, and in the
      end, the type annotations are fairly minor. In most typed
      object-oriented languages, these coercions would simply not be possible.
      For example, in C++, a STL type <literal moreinfo="none">list&lt;T&gt;</literal> is invariant in <literal moreinfo="none">T</literal>, so it is simply not possible to use
      <literal moreinfo="none">list&lt;square&gt;</literal> where <literal moreinfo="none">list&lt;shape&gt;</literal> is expected (at least
      safely). The situation is similar in Java, although Java has an escape
      hatch that allows the program to fall back to dynamic typing. The
      situation in OCaml is much better: it works, it is statically checked,
      and the annotations are pretty simple.<indexterm class="endofrange" startref="var"/><indexterm class="endofrange" startref="SUBvar"/></para>
    </sect2>

    <sect2 id="narrowing">
      <title>Narrowing</title>

      <para>Narrowing, also called <emphasis>down casting</emphasis>, is the
      ability to coerce an object to one of its subtypes. For example, if we
      have a list of shapes <literal moreinfo="none">shape list</literal>, we
      might know (for some reason) what the actual type of each shape is.
      Perhaps we know that all objects in the list have type <literal moreinfo="none">square</literal>. In this case,
      <emphasis>narrowing</emphasis> would allow the recasting of the object
      from type <literal moreinfo="none">shape</literal> to type <literal moreinfo="none">square</literal>. Many languages support narrowing
      through dynamic type checking. For example, in Java, a coercion <literal moreinfo="none">(Square) x</literal> is allowed if the value <literal moreinfo="none">x</literal> has type <literal moreinfo="none">Square</literal> or one of its subtypes; otherwise the
      coercion throws an exception.<indexterm class="singular">
          <primary>dynamic type checking</primary>
        </indexterm><indexterm class="singular">
          <primary>down casting</primary>
        </indexterm><indexterm class="singular">
          <primary>narrowing</primary>
        </indexterm><indexterm class="singular">
          <primary>objects</primary>

          <secondary>narrowing and</secondary>
        </indexterm></para>

      <para>Narrowing is <emphasis>not permitted</emphasis> in OCaml.
      Period.</para>

      <para>Why? There are two reasonable explanations, one based on a design
      principle, and another technical (the technical reason is simple: it is
      hard to implement).</para>

      <para>The design argument is this: narrowing violates abstraction. In
      fact, with a structural typing system like in OCaml, narrowing would
      essentially provide the ability to enumerate the methods in an object.
      To check whether an object <literal moreinfo="none">obj</literal> has
      some method <literal moreinfo="none">foo : int</literal>, one would
      attempt a coercion <literal moreinfo="none">(obj :&gt; &lt; foo : int
      &gt;)</literal>.</para>

      <para>More pragmatically, narrowing leads to poor object-oriented style.
      Consider the following Java code, which returns the name of a shape
      object:</para>

      <para role="sourcecode">Java: <ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/objects/Shape.java">objects/Shape.java</ulink></para>

      <programlisting format="linespecific" language="java">String GetShapeName(Shape s) {
  if (s instanceof Square) {
    return "Square";
  } else if (s instanceof Circle) {
    return "Circle";
  } else {
    return "Other";
  }
}</programlisting>

      <para>Most programmers would consider this code to be "wrong." Instead
      of performing a case analysis on the type of object, it would be better
      to define a method to return the name of the shape. Instead of calling
      <literal moreinfo="none">GetShapeName(s)</literal>, we should call
      <literal moreinfo="none">s.Name()</literal> instead.</para>

      <para>However, the situation is not always so obvious. The following
      code checks whether an array of shapes looks like a "barbell," composed
      of two <literal moreinfo="none">Circle</literal> objects separated by a
      <literal moreinfo="none">Line</literal>, where the circles have the same
      radius:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/objects/IsBarbell.java">Java</ulink></para>

      <programlisting format="linespecific" language="java">boolean IsBarbell(Shape[] s) {
  return s.length == 3 &amp;&amp; (s[0] instanceof Circle) &amp;&amp;
    (s[1] instanceof Line) &amp;&amp; (s[2] instanceof Circle) &amp;&amp;
        ((Circle) s[0]).radius() == ((Circle) s[2]).radius();
}</programlisting>

      <para>In this case, it is much less clear how to augment the <literal moreinfo="none">Shape</literal> class to support this kind of pattern
      analysis. It is also not obvious that object-oriented programming is
      well-suited for this situation. Pattern matching seems like a better
      fit:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/objects/is_barbell.ml">OCaml</ulink></para>

      <programlisting format="linespecific" language="ocaml">let is_barbell = function
| [Circle r1; Line _; Circle r2] when r1 = r2 -&gt; true
| _ -&gt; false</programlisting>

      <para>Regardless, there is a solution if you find yourself in this
      situation, which is to augment the classes with variants. You can define
      a method <literal moreinfo="none">variant</literal> that injects the
      actual object into a variant type:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/objects/narrowing.ml">OCaml</ulink>
      (part 1)</para>

      <programlisting format="linespecific" language="ocaml">type shape = &lt; variant : repr; area : float&gt;
and circle = &lt; variant : repr; area : float; radius : int &gt;
and line = &lt; variant : repr; area : float; length : int &gt;
and repr =
 | Circle of circle
 | Line of line;;

let is_barbell = function
| [s1; s2; s3] -&gt;
   (match s1#variant, s2#variant, s3#variant with
    | Circle c1, Line _, Circle c2 when c1#radius = c2#radius -&gt; true
    | _ -&gt; false)
| _ -&gt; false;;</programlisting>

      <para>This pattern works, but it has drawbacks. In particular, the
      recursive type definition should make it clear that this pattern is
      essentially equivalent to using variants, and that objects do not
      provide much value here.</para>
    </sect2>

    <sect2 id="subtyping-vs.-row-polymorphism">
      <title>Subtyping Versus Row Polymorphism</title>

      <para>There is considerable overlap between subtyping and row
      polymorphism. Both mechanisms allow you to write functions that can be
      applied to objects of different types. In these cases, row polymorphism
      is usually preferred over subtyping because it does not require explicit
      coercions, and it preserves more type information, allowing functions
      like the following:<indexterm class="singular">
          <primary>polymorphism</primary>

          <secondary>row polymorphism</secondary>
        </indexterm><indexterm class="singular">
          <primary>row polymorphism</primary>
        </indexterm><indexterm class="singular">
          <primary>subtyping</primary>

          <secondary sortas="row polymorphism">vs. row
          polymorphism</secondary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/objects/row_polymorphism.topscript">OCaml utop</ulink>
      (part 1)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let remove_large l =</userinput>
<userinput moreinfo="none">    List.filter ~f:(fun s -&gt; s#area &lt;= 100.) l ;;</userinput>
<computeroutput moreinfo="none">val remove_large : (&lt; area : float; .. &gt; as 'a) list -&gt; 'a list = &lt;fun&gt;</computeroutput></programlisting>

      <para>The return type of this function is built from the open object
      type of its argument, preserving any additional methods that it may
      have:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/objects/row_polymorphism.topscript">OCaml utop</ulink>
      (part 2)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let squares : &lt; area : float; width : int &gt; list = </userinput>
<userinput moreinfo="none">    [square 5; square 15; square 10] ;;</userinput>
<computeroutput moreinfo="none">val squares : &lt; area : float; width : int &gt; list = [&lt;obj&gt;; &lt;obj&gt;; &lt;obj&gt;]</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">remove_large squares ;;</userinput>
<computeroutput moreinfo="none">- : &lt; area : float; width : int &gt; list = [&lt;obj&gt;; &lt;obj&gt;]</computeroutput></programlisting>

      <para>Writing a similar function with a closed type and applying it
      using subtyping does not preserve the methods of the argument: the
      returned object is only known to have an <literal moreinfo="none">area</literal> method:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/objects/row_polymorphism.topscript">OCaml utop</ulink>
      (part 3)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let remove_large (l: &lt; area : float &gt; list) = </userinput>
<userinput moreinfo="none">    List.filter ~f:(fun s -&gt; s#area &lt;= 100.) l ;;</userinput>
<computeroutput moreinfo="none">val remove_large : &lt; area : float &gt; list -&gt; &lt; area : float &gt; list = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">remove_large (squares :&gt; &lt; area : float &gt; list ) ;;</userinput>
<computeroutput moreinfo="none">- : &lt; area : float &gt; list = [&lt;obj&gt;; &lt;obj&gt;]</computeroutput></programlisting>

      <para>However, there are some situations where we cannot use row
      polymorphism. In particular, row polymorphism cannot be used to place
      different types of object in the same container. For example, lists of
      heterogeneous elements cannot be created using row polymorphism:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/objects/row_polymorphism.topscript">OCaml utop</ulink>
      (part 4)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let hlist: &lt; area: float; ..&gt; list = [square 10; circle 30] ;;</userinput>
<computeroutput moreinfo="none">Characters 49-58:</computeroutput>
<computeroutput moreinfo="none">Error: This expression has type &lt; area : float; radius : int &gt;</computeroutput>
<computeroutput moreinfo="none">       but an expression was expected of type &lt; area : float; width : int &gt;</computeroutput>
<computeroutput moreinfo="none">       The second object type has no method radius</computeroutput></programlisting>

      <para>Similarly, we cannot use row polymorphism to store different types
      of object in the same reference:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/objects/row_polymorphism.topscript">OCaml utop</ulink>
      (part 5)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let shape_ref: &lt; area: float; ..&gt; ref = ref (square 40) ;;</userinput>
<computeroutput moreinfo="none">val shape_ref : &lt; area : float; width : int &gt; ref = {contents = &lt;obj&gt;}</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">shape_ref := circle 20 ;;</userinput>
<computeroutput moreinfo="none">Characters 13-22:</computeroutput>
<computeroutput moreinfo="none">Error: This expression has type &lt; area : float; radius : int &gt;</computeroutput>
<computeroutput moreinfo="none">       but an expression was expected of type &lt; area : float; width : int &gt;</computeroutput>
<computeroutput moreinfo="none">       The second object type has no method radius</computeroutput></programlisting>

      <para>In both these cases we must use subtyping:<indexterm class="endofrange" startref="OBsub"/></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/objects/row_polymorphism.topscript">OCaml utop</ulink>
      (part 6)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let hlist: shape list = [(square 10 :&gt; shape); (circle 30 :&gt; shape)] ;;</userinput>
<computeroutput moreinfo="none">val hlist : shape list = [&lt;obj&gt;; &lt;obj&gt;]</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let shape_ref: shape ref = ref (square 40 :&gt; shape) ;;</userinput>
<computeroutput moreinfo="none">val shape_ref : shape ref = {contents = &lt;obj&gt;}</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">shape_ref := (circle 20 :&gt; shape) ;;</userinput>
<computeroutput moreinfo="none">- : unit = ()</computeroutput></programlisting>

      <note>
        <title>Production Note</title>

        <para>This chapter contains significant contributions from Leo
        White.</para>
      </note>
    </sect2>
  </sect1>
</chapter>

  <chapter id="classes">
  <title>Classes</title>

  <para>Programming with objects directly is great for encapsulation, but one
  of the main goals of object-oriented programming is code reuse through
  inheritance. For inheritance, we need to introduce
  <emphasis>classes</emphasis>. In object-oriented programming, a class is a
  "recipe" for creating objects. The recipe can be changed by adding new
  methods and fields, or it can be changed by modifying existing
  methods.<indexterm class="singular">
      <primary>programming</primary>

      <secondary>object-oriented programming (OOP)</secondary>
    </indexterm></para>

  <sect1 id="ocaml-classes">
    <title>OCaml Classes</title>

    <para>In OCaml, class definitions must be defined as toplevel statements
    in a module. The syntax for a class definition uses the keyword <literal moreinfo="none">class</literal>:<indexterm class="singular">
        <primary>classes</primary>

        <secondary>basic syntax for</secondary>
      </indexterm></para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/classes/istack.topscript">OCaml utop</ulink></para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">class istack = object</userinput>
<userinput moreinfo="none">    val mutable v = [0; 2]</userinput>
<userinput moreinfo="none"/>
<userinput moreinfo="none">    method pop =</userinput>
<userinput moreinfo="none">      match v with</userinput>
<userinput moreinfo="none">      | hd :: tl -&gt;</userinput>
<userinput moreinfo="none">          v &lt;- tl;</userinput>
<userinput moreinfo="none">          Some hd</userinput>
<userinput moreinfo="none">      | [] -&gt; None</userinput>
<userinput moreinfo="none"/>
<userinput moreinfo="none">    method push hd =</userinput>
<userinput moreinfo="none">      v &lt;- hd :: v</userinput>
<userinput moreinfo="none">  end ;;</userinput>
<computeroutput moreinfo="none">class istack :</computeroutput>
<computeroutput moreinfo="none">  object</computeroutput>
<computeroutput moreinfo="none">    val mutable v : int list</computeroutput>
<computeroutput moreinfo="none">    method pop : int option</computeroutput>
<computeroutput moreinfo="none">    method push : int -&gt; unit</computeroutput>
<computeroutput moreinfo="none">  end</computeroutput></programlisting>

    <para>The <literal moreinfo="none">class istack : object ... end</literal> result shows that we
      have created a class <literal moreinfo="none" role="keep-together">istack</literal> with
        <emphasis>class type</emphasis>
      <literal moreinfo="none">object ... end</literal>. Like module types, class types are
      completely separate from regular OCaml types (e.g., <literal moreinfo="none">int</literal>,
        <literal moreinfo="none">string</literal>, and <literal moreinfo="none">list</literal>) and,
      in particular, should not be confused with object types (e.g., <literal moreinfo="none">&lt;
        get : int; .. &gt;</literal>). The class type describes the class itself rather than the
      objects that the class creates. This particular class type specifies that the <literal moreinfo="none">istack</literal> class defines a mutable field <literal moreinfo="none">v</literal>, a method <literal moreinfo="none">pop</literal> that returns an
          <phrase><literal moreinfo="none" role="keep-together">int option</literal></phrase>, and a
      method <literal moreinfo="none">push</literal> with type <literal moreinfo="none">int -&gt;
        unit</literal>.</para>

    <para>To produce an object, classes are instantiated with the keyword
    <literal moreinfo="none">new</literal>:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/classes/istack.topscript">OCaml utop</ulink>
    (part 1)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let s = new istack ;;</userinput>
<computeroutput moreinfo="none">val s : istack = &lt;obj&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">s#pop ;;</userinput>
<computeroutput moreinfo="none">- : int option = Some 0</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">s#push 5 ;;</userinput>
<computeroutput moreinfo="none">- : unit = ()</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">s#pop ;;</userinput>
<computeroutput moreinfo="none">- : int option = Some 5</computeroutput></programlisting>

    <para>You may have noticed that the object <literal moreinfo="none">s</literal> has been given the type <literal moreinfo="none">istack</literal>. But wait, we've stressed
    <emphasis>classes are not types</emphasis>, so what's up with that? In
    fact, what we've said is entirely true: classes and class names
    <emphasis>are not</emphasis> types. However, for convenience, the
    definition of the class <literal moreinfo="none">istack</literal> also
    defines an object type <literal moreinfo="none">istack</literal> with the
    same methods as the class. This type definition is equivalent to:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/classes/istack.topscript">OCaml utop</ulink>
    (part 2)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">type istack = &lt; pop: int option; push: int -&gt; unit &gt; ;;</userinput>
<computeroutput moreinfo="none">type istack = &lt; pop : int option; push : int -&gt; unit &gt;</computeroutput></programlisting>

    <para>Note that this type represents any object with these methods:
    objects created using the <literal moreinfo="none">istack</literal> class
    will have this type, but objects with this type may not have been created
    by the <literal moreinfo="none">istack</literal> class.</para>
  </sect1>

  <sect1 id="class-parameters-and-polymorphism">
    <title>Class Parameters and Polymorphism</title>

    <para>A class definition serves as the <emphasis>constructor</emphasis>
    for the class. In general, a class definition may have parameters that
    must be provided as arguments when the object is created with <literal moreinfo="none">new</literal>.<indexterm class="singular">
        <primary>polymorphism</primary>

        <secondary>class parameters and</secondary>
      </indexterm><indexterm class="singular">
        <primary>classes</primary>

        <secondary>class parameters and polymorphism</secondary>
      </indexterm></para>

    <para>Let's implement a variant of the <literal moreinfo="none">istack</literal> class that can hold any values, not just
    integers. When defining the class, the type parameters are placed in
    square brackets before the class name in the class definition. We also add
    a parameter <literal moreinfo="none">init</literal> for the initial
    contents of the stack:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/classes/stack.topscript">OCaml utop</ulink></para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">class ['a] stack init = object</userinput>
<userinput moreinfo="none">    val mutable v : 'a list = init</userinput>
<userinput moreinfo="none"/>
<userinput moreinfo="none">    method pop =</userinput>
<userinput moreinfo="none">      match v with</userinput>
<userinput moreinfo="none">      | hd :: tl -&gt;</userinput>
<userinput moreinfo="none">        v &lt;- tl;</userinput>
<userinput moreinfo="none">        Some hd</userinput>
<userinput moreinfo="none">      | [] -&gt; None</userinput>
<userinput moreinfo="none"/>
<userinput moreinfo="none">    method push hd =</userinput>
<userinput moreinfo="none">      v &lt;- hd :: v</userinput>
<userinput moreinfo="none">  end ;;</userinput>
<computeroutput moreinfo="none">class ['a] stack :</computeroutput>
<computeroutput moreinfo="none">  'a list -&gt;</computeroutput>
<computeroutput moreinfo="none">  object</computeroutput>
<computeroutput moreinfo="none">    val mutable v : 'a list</computeroutput>
<computeroutput moreinfo="none">    method pop : 'a option</computeroutput>
<computeroutput moreinfo="none">    method push : 'a -&gt; unit</computeroutput>
<computeroutput moreinfo="none">  end</computeroutput></programlisting>

    <para>Note that the type parameter <literal moreinfo="none">['a]</literal>
    in the definition uses square brackets, but for other uses of the type
    they are omitted (or replaced with parentheses if there is more than one
    type parameter).</para>

    <para>The type annotation on the declaration of <literal moreinfo="none">v</literal> is used to constrain type inference. If we
    omit this annotation, the type inferred for the class will be "too
    polymorphic": <literal moreinfo="none">init</literal> could have some type
    <literal moreinfo="none">'b list</literal>:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/classes/stack.topscript">OCaml utop</ulink>
    (part 1)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">class ['a] stack init = object</userinput>
<userinput moreinfo="none">      val mutable v = init</userinput>
<userinput moreinfo="none">    </userinput>
<userinput moreinfo="none">      method pop = </userinput>
<userinput moreinfo="none">        match v with</userinput>
<userinput moreinfo="none">        | hd :: tl -&gt; </userinput>
<userinput moreinfo="none">          v &lt;- tl;</userinput>
<userinput moreinfo="none">          Some hd</userinput>
<userinput moreinfo="none">        | [] -&gt; None</userinput>
<userinput moreinfo="none"/>
<userinput moreinfo="none">      method push hd = </userinput>
<userinput moreinfo="none">        v &lt;- hd :: v</userinput>
<userinput moreinfo="none">  end ;;</userinput>
<computeroutput moreinfo="none">Characters 6-16:</computeroutput>
<computeroutput moreinfo="none">Error: Some type variables are unbound in this type:</computeroutput>
<computeroutput moreinfo="none">         class ['a] stack :</computeroutput>
<computeroutput moreinfo="none">           'b list -&gt;</computeroutput>
<computeroutput moreinfo="none">           object</computeroutput>
<computeroutput moreinfo="none">             val mutable v : 'b list</computeroutput>
<computeroutput moreinfo="none">             method pop : 'b option</computeroutput>
<computeroutput moreinfo="none">             method push : 'b -&gt; unit</computeroutput>
<computeroutput moreinfo="none">           end</computeroutput>
<computeroutput moreinfo="none">       The method pop has type 'b option where 'b is unbound</computeroutput></programlisting>

    <para>In general, we need to provide enough constraints so that the
    compiler will infer the correct type. We can add type constraints to the
    parameters, to the fields, and to the methods. It is a matter of
    preference how many constraints to add. You can add type constraints in
    all three places, but the extra text may not help clarity. A convenient
    middle ground is to annotate the fields and/or class parameters, and add
    constraints to methods only if necessary.</para>
  </sect1>

  <sect1 id="object-types-as-interfaces">
    <title>Object Types as Interfaces</title>

    <para>We may wish to traverse the elements on our stack. One common style
    for doing this in object-oriented languages is to define a class for an
    <literal moreinfo="none">iterator</literal> object. An iterator provides a
    generic mechanism to inspect and traverse the elements of a
    collection.<indexterm class="singular">
        <primary>elements</primary>

        <secondary>traversing with iterator objects</secondary>
      </indexterm><indexterm class="singular">
        <primary>iterators</primary>
      </indexterm><indexterm class="singular">
        <primary>objects</primary>

        <secondary>object types as interfaces</secondary>
      </indexterm><indexterm class="singular">
        <primary>interfaces</primary>

        <secondary>object types as</secondary>
      </indexterm><indexterm class="singular">
        <primary>classes</primary>

        <secondary>object types as interfaces</secondary>
      </indexterm></para>

    <para>There are two common styles for defining abstract interfaces like
    this. In Java, an iterator would normally be specified with an interface,
    which specifies a set of method types:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/classes/Iterator.java">Java</ulink></para>

    <programlisting format="linespecific" language="java">// Java-style iterator, specified as an interface.
interface &lt;T&gt; iterator {
  T Get();
  boolean HasValue();
  void Next();
};</programlisting>

    <para>In languages without interfaces, like C++, the specification would
    normally use <emphasis>abstract</emphasis> classes to specify the methods
    without implementing them (C++ uses the "= 0" definition to mean "not
    implemented"):</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/classes/citerator.cpp">C</ulink></para>

    <programlisting format="linespecific" language="c">// Abstract class definition in C++.
template&lt;typename T&gt;
class Iterator {
 public:
  virtual ~Iterator() {}
  virtual T get() const = 0;
  virtual bool has_value() const = 0;
  virtual void next() = 0;
};</programlisting>

    <para>OCaml supports both styles. In fact, OCaml is more flexible than
    these approaches because an object type can be implemented by any object
    with the appropriate methods; it does not have to be specified by the
    object's class <emphasis>a priori</emphasis>. We'll leave abstract classes
    for later. Let's demonstrate the technique using object types.</para>

    <para>First, we'll define an object type <literal moreinfo="none">iterator</literal> that specifies the methods in an
    iterator:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/classes/iter.topscript">OCaml utop</ulink></para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">type 'a iterator = &lt; get : 'a; has_value : bool; next : unit &gt; ;;</userinput>
<computeroutput moreinfo="none">type 'a iterator = &lt; get : 'a; has_value : bool; next : unit &gt;</computeroutput></programlisting>

    <para>Next, we'll define an actual iterator for lists. We can use this to
    iterate over the contents of our stack:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/classes/iter.topscript">OCaml utop</ulink>
    (part 1)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">class ['a] list_iterator init = object</userinput>
<userinput moreinfo="none">    val mutable current : 'a list = init</userinput>
<userinput moreinfo="none"/>
<userinput moreinfo="none">    method has_value = current &lt;&gt; []</userinput>
<userinput moreinfo="none"/>
<userinput moreinfo="none">    method get =</userinput>
<userinput moreinfo="none">      match current with</userinput>
<userinput moreinfo="none">      | hd :: tl -&gt; hd</userinput>
<userinput moreinfo="none">      | [] -&gt; raise (Invalid_argument "no value")</userinput>
<userinput moreinfo="none"/>
<userinput moreinfo="none">    method next =</userinput>
<userinput moreinfo="none">      match current with</userinput>
<userinput moreinfo="none">      | hd :: tl -&gt; current &lt;- tl</userinput>
<userinput moreinfo="none">      | [] -&gt; raise (Invalid_argument "no value")</userinput>
<userinput moreinfo="none">   end  ;;</userinput>
<computeroutput moreinfo="none">class ['a] list_iterator :</computeroutput>
<computeroutput moreinfo="none">  'a list -&gt;</computeroutput>
<computeroutput moreinfo="none">  object</computeroutput>
<computeroutput moreinfo="none">    val mutable current : 'a list</computeroutput>
<computeroutput moreinfo="none">    method get : 'a</computeroutput>
<computeroutput moreinfo="none">    method has_value : bool</computeroutput>
<computeroutput moreinfo="none">    method next : unit</computeroutput>
<computeroutput moreinfo="none">  end</computeroutput></programlisting>

    <para>Finally, we add a method <literal moreinfo="none">iterator</literal>
    to the <literal moreinfo="none">stack</literal> class to produce an
    iterator. To do so, we construct a <literal moreinfo="none">list_iterator</literal> that refers to the current
    contents of the stack:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/classes/iter.topscript">OCaml utop</ulink>
    (part 2)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">class ['a] stack init = object</userinput>
<userinput moreinfo="none">    val mutable v : 'a list = init</userinput>
<userinput moreinfo="none"/>
<userinput moreinfo="none">    method pop =</userinput>
<userinput moreinfo="none">      match v with</userinput>
<userinput moreinfo="none">      | hd :: tl -&gt;</userinput>
<userinput moreinfo="none">        v &lt;- tl;</userinput>
<userinput moreinfo="none">        Some hd</userinput>
<userinput moreinfo="none">      | [] -&gt; None</userinput>
<userinput moreinfo="none"/>
<userinput moreinfo="none">    method push hd =</userinput>
<userinput moreinfo="none">      v &lt;- hd :: v</userinput>
<userinput moreinfo="none"/>
<userinput moreinfo="none">    method iterator : 'a iterator =</userinput>
<userinput moreinfo="none">      new list_iterator v</userinput>
<userinput moreinfo="none">  end ;;</userinput>
<computeroutput moreinfo="none">class ['a] stack :</computeroutput>
<computeroutput moreinfo="none">  'a list -&gt;</computeroutput>
<computeroutput moreinfo="none">  object</computeroutput>
<computeroutput moreinfo="none">    val mutable v : 'a list</computeroutput>
<computeroutput moreinfo="none">    method iterator : 'a iterator</computeroutput>
<computeroutput moreinfo="none">    method pop : 'a option</computeroutput>
<computeroutput moreinfo="none">    method push : 'a -&gt; unit</computeroutput>
<computeroutput moreinfo="none">  end</computeroutput></programlisting>

    <para>Now we can build a new stack, push some values to it, and iterate
    over them:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/classes/iter.topscript">OCaml utop</ulink>
    (part 3)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let s = new stack [] ;;</userinput>
<computeroutput moreinfo="none">val s : '_a stack = &lt;obj&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">s#push 5 ;;</userinput>
<computeroutput moreinfo="none">- : unit = ()</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">s#push 4 ;;</userinput>
<computeroutput moreinfo="none">- : unit = ()</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let it = s#iterator ;;</userinput>
<computeroutput moreinfo="none">val it : int iterator = &lt;obj&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">it#get ;;</userinput>
<computeroutput moreinfo="none">- : int = 4</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">it#next ;;</userinput>
<computeroutput moreinfo="none">- : unit = ()</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">it#get ;;</userinput>
<computeroutput moreinfo="none">- : int = 5</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">it#next ;;</userinput>
<computeroutput moreinfo="none">- : unit = ()</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">it#has_value ;;</userinput>
<computeroutput moreinfo="none">- : bool = false</computeroutput></programlisting>

    <sect2 id="functional-iterators">
      <title>Functional Iterators</title>

      <para>In practice, most OCaml programmers avoid iterator objects in
      favor of functional-style techniques. For example, the alternative
      <literal>stack</literal> class that follows takes a function <literal moreinfo="none">f</literal> and applies it to each of the elements on
      the stack:<indexterm class="singular">
          <primary>functional iterators</primary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/classes/iter.topscript">OCaml utop</ulink>
      (part 4)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">class ['a] stack init = object</userinput>
<userinput moreinfo="none">    val mutable v : 'a list = init</userinput>
<userinput moreinfo="none"/>
<userinput moreinfo="none">    method pop =</userinput>
<userinput moreinfo="none">      match v with</userinput>
<userinput moreinfo="none">      | hd :: tl -&gt;</userinput>
<userinput moreinfo="none">        v &lt;- tl;</userinput>
<userinput moreinfo="none">        Some hd</userinput>
<userinput moreinfo="none">      | [] -&gt; None</userinput>
<userinput moreinfo="none"/>
<userinput moreinfo="none">    method push hd =</userinput>
<userinput moreinfo="none">      v &lt;- hd :: v</userinput>
<userinput moreinfo="none"/>
<userinput moreinfo="none">   method iter f = </userinput>
<userinput moreinfo="none">     List.iter ~f v </userinput>
<userinput moreinfo="none">  end ;;</userinput>
<computeroutput moreinfo="none">class ['a] stack :</computeroutput>
<computeroutput moreinfo="none">  'a list -&gt;</computeroutput>
<computeroutput moreinfo="none">  object</computeroutput>
<computeroutput moreinfo="none">    val mutable v : 'a list</computeroutput>
<computeroutput moreinfo="none">    method iter : ('a -&gt; unit) -&gt; unit</computeroutput>
<computeroutput moreinfo="none">    method pop : 'a option</computeroutput>
<computeroutput moreinfo="none">    method push : 'a -&gt; unit</computeroutput>
<computeroutput moreinfo="none">  end</computeroutput></programlisting>

      <para>What about functional operations like <literal moreinfo="none">map</literal> and <literal moreinfo="none">fold</literal>? In general, these methods take a
      function that produces a value of some other type than the elements of
      the set.</para>

      <para>For example, a <literal moreinfo="none">fold</literal> method for
      our <literal moreinfo="none">['a] stack</literal> class should have type
      <literal moreinfo="none">('b -&gt; 'a -&gt; 'b) -&gt; 'b -&gt;
      'b</literal>, where the <literal moreinfo="none">'b</literal> is
      polymorphic. To express a polymorphic method type like this, we must use
      a type quantifier, as shown in the following example:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/classes/iter.topscript">OCaml utop</ulink>
      (part 5)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">class ['a] stack init = object</userinput>
<userinput moreinfo="none">    val mutable v : 'a list = init</userinput>
<userinput moreinfo="none"/>
<userinput moreinfo="none">    method pop =</userinput>
<userinput moreinfo="none">      match v with</userinput>
<userinput moreinfo="none">      | hd :: tl -&gt;</userinput>
<userinput moreinfo="none">        v &lt;- tl;</userinput>
<userinput moreinfo="none">        Some hd</userinput>
<userinput moreinfo="none">      | [] -&gt; None</userinput>
<userinput moreinfo="none"/>
<userinput moreinfo="none">    method push hd =</userinput>
<userinput moreinfo="none">      v &lt;- hd :: v</userinput>
<userinput moreinfo="none"/>
<userinput moreinfo="none">    method fold : 'b. ('b -&gt; 'a -&gt; 'b) -&gt; 'b -&gt; 'b =</userinput>
<userinput moreinfo="none">     (fun f init -&gt; List.fold ~f ~init v) </userinput>
<userinput moreinfo="none">  end ;;</userinput>
<computeroutput moreinfo="none">class ['a] stack :</computeroutput>
<computeroutput moreinfo="none">  'a list -&gt;</computeroutput>
<computeroutput moreinfo="none">  object</computeroutput>
<computeroutput moreinfo="none">    val mutable v : 'a list</computeroutput>
<computeroutput moreinfo="none">    method fold : ('b -&gt; 'a -&gt; 'b) -&gt; 'b -&gt; 'b</computeroutput>
<computeroutput moreinfo="none">    method pop : 'a option</computeroutput>
<computeroutput moreinfo="none">    method push : 'a -&gt; unit</computeroutput>
<computeroutput moreinfo="none">  end</computeroutput></programlisting>

      <para>The type quantifier <literal moreinfo="none">'b.</literal> can be
      read as "for all <literal moreinfo="none">'b</literal>.” Type
      quantifiers can only be used <emphasis>directly after</emphasis> the
      method name, which means that method parameters must be expressed using
      a <literal moreinfo="none">fun</literal> or <literal moreinfo="none">function</literal> expression.</para>
    </sect2>
  </sect1>

  <sect1 id="inheritance">
    <title>Inheritance</title>

    <para>Inheritance uses an existing class to define a new one. For example,
    the following class definition inherits from our <literal>stack</literal>
    class for strings and adds a new method <literal moreinfo="none">print</literal> that prints all the strings on the
    stack:<indexterm class="singular">
        <primary>inheritance</primary>
      </indexterm><indexterm class="singular">
        <primary>classes</primary>

        <secondary>inheritance in</secondary>
      </indexterm></para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/classes/stack.topscript">OCaml utop</ulink>
    (part 2)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">class sstack init = object</userinput>
<userinput moreinfo="none">    inherit [string] stack init</userinput>
<userinput moreinfo="none"/>
<userinput moreinfo="none">    method print =</userinput>
<userinput moreinfo="none">      List.iter ~f:print_string v</userinput>
<userinput moreinfo="none">  end ;;</userinput>
<computeroutput moreinfo="none">class sstack :</computeroutput>
<computeroutput moreinfo="none">  string list -&gt;</computeroutput>
<computeroutput moreinfo="none">  object</computeroutput>
<computeroutput moreinfo="none">    val mutable v : string list</computeroutput>
<computeroutput moreinfo="none">    method pop : string option</computeroutput>
<computeroutput moreinfo="none">    method print : unit</computeroutput>
<computeroutput moreinfo="none">    method push : string -&gt; unit</computeroutput>
<computeroutput moreinfo="none">  end</computeroutput></programlisting>

    <para>A class can override methods from classes it inherits. For example,
    this class creates stacks of integers that double the integers before they
    are pushed onto the stack:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/classes/stack.topscript">OCaml utop</ulink>
    (part 3)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">class double_stack init = object</userinput>
<userinput moreinfo="none">    inherit [int] stack init as super</userinput>
<userinput moreinfo="none"/>
<userinput moreinfo="none">    method push hd =</userinput>
<userinput moreinfo="none">      super#push (hd * 2)</userinput>
<userinput moreinfo="none">  end ;;</userinput>
<computeroutput moreinfo="none">class double_stack :</computeroutput>
<computeroutput moreinfo="none">  int list -&gt;</computeroutput>
<computeroutput moreinfo="none">  object</computeroutput>
<computeroutput moreinfo="none">    val mutable v : int list</computeroutput>
<computeroutput moreinfo="none">    method pop : int option</computeroutput>
<computeroutput moreinfo="none">    method push : int -&gt; unit</computeroutput>
<computeroutput moreinfo="none">  end</computeroutput></programlisting>

    <para>The preceding <literal moreinfo="none">as super</literal> statement
    creates a special object called <literal moreinfo="none">super</literal>
    which can be used to call superclass methods. Note that <literal moreinfo="none">super</literal> is not a real object and can only be used
    to call methods.</para>
  </sect1>

  <sect1 id="class-types">
    <title>Class Types</title>

    <para>To allow code in a different file or module to inherit from a class,
    we must expose it and give it a class type. What is the class
    type?<indexterm class="singular">
        <primary>classes</primary>

        <secondary>class types</secondary>
      </indexterm></para>

    <para>As an example, let's wrap up our <literal moreinfo="none">stack</literal> class in an explicit module (we'll use
    explicit modules for illustration, but the process is similar when we want
    to define a <literal moreinfo="none">.mli</literal> file). In keeping with
    the usual style for modules, we define a type <literal moreinfo="none">'a
    t</literal> to represent the type of our stacks:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/classes/class_types_stack.ml">OCaml</ulink></para>

    <programlisting format="linespecific" language="ocaml">module Stack = struct
  class ['a] stack init = object
    ...    
  end

  type 'a t = 'a stack

  let make init = new stack init
end</programlisting>

    <para>We have multiple choices in defining the module type, depending on
    how much of the implementation we want to expose. At one extreme, a
    maximally abstract signature would completely hide the class
    definitions:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/classes/class_types_stack.ml">OCaml</ulink>
    (part 1)</para>

    <programlisting format="linespecific" language="ocaml">module AbstractStack : sig
   type 'a t = &lt; pop: 'a option; push: 'a -&gt; unit &gt;

   val make : unit -&gt; 'a t
end = Stack</programlisting>

    <para>The abstract signature is simple because we ignore the classes. But
    what if we want to include them in the signature so that other modules can
    inherit from the class definitions? For this, we need to specify types for
    the classes, called <emphasis>class types</emphasis>.</para>

    <para>Class types do not appear in mainstream object-oriented programming
    languages, so you may not be familiar with them, but the concept is pretty
    simple. A class type specifies the type of each of the visible parts of
    the class, including both fields and methods. Just as with module types,
    you don't have to give a type for everything; anything you omit will be
    hidden:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/classes/class_types_stack.ml">OCaml</ulink>
    (part 2)</para>

    <programlisting format="linespecific" language="ocaml">module VisibleStack : sig
  
  type 'a t = &lt; pop: 'a option; push: 'a -&gt; unit &gt;

  class ['a] stack : object
    val mutable v : 'a list
    method pop : 'a option
    method push : 'a -&gt; unit
  end

  val make : unit -&gt; 'a t
end = Stack</programlisting>

    <para>In this signature, we've chosen to make everything visible. The
    class type for <literal moreinfo="none">stack</literal> specifies the
    types of the field <literal moreinfo="none">v</literal>, as well as the
    types of each of the methods.</para>
  </sect1>

  <sect1 id="open-recursion">
    <title>Open Recursion</title>

    <para>Open recursion allows an object's methods to invoke other methods on
    the same object. These calls are looked up dynamically, allowing a method
    in one class to call a method from another class, if both classes are
    inherited by the same object. This allows mutually recursive parts of an
    object to be defined separately.<indexterm class="singular">
        <primary>recursion</primary>

        <secondary>open recursion</secondary>
      </indexterm><indexterm class="singular">
        <primary>open recursion</primary>
      </indexterm><indexterm class="singular">
        <primary>classes</primary>

        <secondary>open recursion in</secondary>
      </indexterm></para>

    <para>This ability to define mutually recursive methods from separate
    components is a key feature of classes: achieving similar functionality
    with data types or modules is much more cumbersome and verbose.</para>

    <para>For example, consider writing recursive functions over a simple
    document format. This format is represented as a tree with three different
    types of node:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/classes/doc.ml">OCaml</ulink></para>

    <programlisting format="linespecific" language="ocaml">type doc =
  | Heading of string
  | Paragraph of text_item list
  | Definition of string list_item list

and text_item =
  | Raw of string
  | Bold of text_item list
  | Enumerate of int list_item list
  | Quote of doc

and 'a list_item = 
  { tag: 'a;
    text: text_item list }</programlisting>

    <para>It is quite easy to write a function that operates by recursively
    traversing this data. However, what if you need to write many similar
    recursive functions? How can you factor out the common parts of these
    functions to avoid repetitive boilerplate?</para>

    <para>The simplest way is to use classes and open recursion. For example,
    the following class defines objects that fold over the document
    data:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/classes/doc.ml">OCaml</ulink>
    (part 1)</para>

    <programlisting format="linespecific" language="ocaml">open Core.Std

class ['a] folder = object(self)
  method doc acc = function
  | Heading _ -&gt; acc
  | Paragraph text -&gt; List.fold ~f:self#text_item ~init:acc text
  | Definition list -&gt; List.fold ~f:self#list_item ~init:acc list

  method list_item: 'b. 'a -&gt; 'b list_item -&gt; 'a = 
    fun acc {tag; text} -&gt;
      List.fold ~f:self#text_item ~init:acc text

  method text_item acc = function
  | Raw _ -&gt; acc
  | Bold text -&gt; List.fold ~f:self#text_item ~init:acc text
  | Enumerate list -&gt; List.fold ~f:self#list_item ~init:acc list
  | Quote doc -&gt; self#doc acc doc
end</programlisting>

    <para>The <literal moreinfo="none">object (self)</literal> syntax binds
    <literal moreinfo="none">self</literal> to the current object, allowing
    the <literal moreinfo="none">doc</literal>, <literal moreinfo="none">list_item</literal>, and <literal moreinfo="none">text_item</literal> methods to call each other.</para>

    <para>By inheriting from this class, we can create functions that fold
    over the document data. For example, the <literal moreinfo="none">count_doc</literal> function counts the number of bold
    tags in the document that are not within a list:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/classes/doc.ml">OCaml</ulink>
    (part 2)</para>

    <programlisting format="linespecific" language="ocaml">class counter = object
  inherit [int] folder as super

  method list_item acc li = acc

  method text_item acc ti =
    let acc = super#text_item acc ti in
    match ti with
    | Bold _ -&gt; acc + 1
    | _ -&gt; acc
end

let count_doc = (new counter)#doc</programlisting>

    <para>Note how the <literal moreinfo="none">super</literal> special object
    is used in <literal moreinfo="none">text_item</literal> to call the
    <literal moreinfo="none">[int] folder</literal> class's <literal moreinfo="none">text_item</literal> method to fold over the children of
    the <literal moreinfo="none">text_item</literal> node.</para>
  </sect1>

  <sect1 id="private-methods">
    <title>Private Methods</title>

    <para>Methods can be declared <emphasis>private</emphasis>, which means
    that they may be called by subclasses, but they are not visible otherwise
    (similar to a <emphasis>protected</emphasis> method in C++).<indexterm class="singular">
        <primary>methods</primary>

        <secondary>private methods</secondary>
      </indexterm><indexterm class="singular">
        <primary>protected methods</primary>
      </indexterm><indexterm class="singular">
        <primary>private methods</primary>
      </indexterm><indexterm class="singular">
        <primary>classes</primary>

        <secondary>private methods for</secondary>
      </indexterm></para>

    <para>For example, we may want to include methods in our <literal moreinfo="none">folder</literal> class for handling each of the different
    cases in <literal moreinfo="none">doc</literal> and <literal moreinfo="none">text_item</literal>. However, we may not want to force
    subclasses of <literal moreinfo="none">folder</literal> to expose these
    methods, as they probably shouldn't be called directly:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/classes/doc.ml">OCaml</ulink>
    (part 3)</para>

    <programlisting format="linespecific" language="ocaml">class ['a] folder2 = object(self)
  method doc acc = function
  | Heading str -&gt; self#heading acc str
  | Paragraph text -&gt; self#paragraph acc text
  | Definition list -&gt; self#definition acc list

  method list_item: 'b. 'a -&gt; 'b list_item -&gt; 'a =
    fun acc {tag; text} -&gt;
      List.fold ~f:self#text_item ~init:acc text

  method text_item acc = function
  | Raw str -&gt; self#raw acc str
  | Bold text -&gt; self#bold acc text
  | Enumerate list -&gt; self#enumerate acc list
  | Quote doc -&gt; self#quote acc doc

  method private heading acc str = acc
  method private paragraph acc text =
    List.fold ~f:self#text_item ~init:acc text
  method private definition acc list =
    List.fold ~f:self#list_item ~init:acc list

  method private raw acc str = acc
  method private bold acc text = 
    List.fold ~f:self#text_item ~init:acc text
  method private enumerate acc list = 
    List.fold ~f:self#list_item ~init:acc list
  method private quote acc doc = self#doc acc doc
end

let f :
  &lt; doc : int -&gt; doc -&gt; int;
    list_item : 'a . int -&gt; 'a list_item -&gt; int;
    text_item : int -&gt; text_item -&gt; int &gt;  = new folder2</programlisting>

    <para>The final statement that builds the value <literal moreinfo="none">f</literal> shows how the instantiation of a <literal moreinfo="none">folder2</literal> object has a type that hides the private
    methods.</para>

    <para>To be precise, the private methods are part of the class type, but
    not part of the object type. This means, for example, that the object
    <literal moreinfo="none">f</literal> has no method <literal moreinfo="none">bold</literal>. However, the private methods are available
    to subclasses: we can use them to simplify our <literal moreinfo="none">counter</literal> class:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/classes/doc.ml">OCaml</ulink>
    (part 4)</para>

    <programlisting format="linespecific" language="ocaml">class counter_with_private_method = object
  inherit [int] folder2 as super

  method list_item acc li = acc

  method private bold acc txt = 
    let acc = super#bold acc txt in
    acc + 1
end</programlisting>

    <para>The key property of private methods is that they are visible to
    subclasses, but not anywhere else. If you want the stronger guarantee that
    a method is <emphasis>really</emphasis> private, not even accessible in
    subclasses, you can use an explicit class type that omits the method. In
    the following code, the private methods are explicitly omitted from the
    class type of <literal moreinfo="none">counter_with_sig</literal> and
    can't be invoked in subclasses of <literal moreinfo="none">counter_with_sig</literal>:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/classes/doc.ml">OCaml</ulink>
    (part 5)</para>

    <programlisting format="linespecific" language="ocaml">class counter_with_sig : object
  method doc : int -&gt; doc -&gt; int
  method list_item : int -&gt; 'b list_item -&gt; int
  method text_item : int -&gt; text_item -&gt; int
end = object
  inherit [int] folder2 as super

  method list_item acc li = acc

  method private bold acc txt = 
    let acc = super#bold acc txt in
    acc + 1
end</programlisting>
  </sect1>

  <sect1 id="binary-methods">
    <title>Binary Methods</title>

    <para>A <emphasis>binary method</emphasis> is a method that takes an
    object of <literal moreinfo="none">self</literal> type. One common example
    is defining a method for equality:<indexterm class="singular">
        <primary>methods</primary>

        <secondary>binary methods</secondary>
      </indexterm><indexterm class="singular">
        <primary>classes</primary>

        <secondary>binary methods for</secondary>
      </indexterm><indexterm class="singular">
        <primary>binary methods</primary>
      </indexterm></para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/classes/binary.topscript">OCaml utop</ulink></para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">class square w = object(self : 'self) </userinput>
<userinput moreinfo="none">    method width = w</userinput>
<userinput moreinfo="none">    method area = Float.of_int (self#width * self#width)</userinput>
<userinput moreinfo="none">    method equals (other : 'self) = other#width = self#width</userinput>
<userinput moreinfo="none">  end ;;</userinput>
<computeroutput moreinfo="none">class square :</computeroutput>
<computeroutput moreinfo="none">  int -&gt;</computeroutput>
<computeroutput moreinfo="none">  object ('a)</computeroutput>
<computeroutput moreinfo="none">    method area : float</computeroutput>
<computeroutput moreinfo="none">    method equals : 'a -&gt; bool</computeroutput>
<computeroutput moreinfo="none">    method width : int</computeroutput>
<computeroutput moreinfo="none">  end</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">class circle r = object(self : 'self)</userinput>
<userinput moreinfo="none">    method radius = r</userinput>
<userinput moreinfo="none">    method area = 3.14 *. (Float.of_int self#radius) ** 2.0</userinput>
<userinput moreinfo="none">    method equals (other : 'self) = other#radius = self#radius</userinput>
<userinput moreinfo="none">  end ;;</userinput>
<computeroutput moreinfo="none">class circle :</computeroutput>
<computeroutput moreinfo="none">  int -&gt;</computeroutput>
<computeroutput moreinfo="none">  object ('a)</computeroutput>
<computeroutput moreinfo="none">    method area : float</computeroutput>
<computeroutput moreinfo="none">    method equals : 'a -&gt; bool</computeroutput>
<computeroutput moreinfo="none">    method radius : int</computeroutput>
<computeroutput moreinfo="none">  end</computeroutput></programlisting>

    <para>Note how we can use the type annotation <literal moreinfo="none">(self: 'self)</literal> to obtain the type of the current
    object.</para>

    <para>We can now test different object instances for equality by using the
    <literal moreinfo="none">equals</literal> binary method:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/classes/binary.topscript">OCaml utop</ulink>
    (part 1)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">(new square 5)#equals (new square 5) ;;</userinput>
<computeroutput moreinfo="none">- : bool = true</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">(new circle 10)#equals (new circle 7) ;;</userinput>
<computeroutput moreinfo="none">- : bool = false</computeroutput></programlisting>

    <para>This works, but there is a problem lurking here. The method <literal moreinfo="none">equals</literal> takes an object of the exact type
    <literal moreinfo="none">square</literal> or <literal moreinfo="none">circle</literal>. Because of this, we can't define a
    common base class <literal moreinfo="none">shape</literal> that also
    includes an equality method:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/classes/binary.topscript">OCaml utop</ulink>
    (part 2)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">type shape = &lt; equals : shape -&gt; bool; area : float &gt; ;;</userinput>
<computeroutput moreinfo="none">type shape = &lt; area : float; equals : shape -&gt; bool &gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">(new square 5 :&gt; shape) ;;</userinput>
<computeroutput moreinfo="none">Characters -1-23:</computeroutput>
<computeroutput moreinfo="none">Error: Type square = &lt; area : float; equals : square -&gt; bool; width : int &gt;</computeroutput>
<computeroutput moreinfo="none">       is not a subtype of shape = &lt; area : float; equals : shape -&gt; bool &gt; </computeroutput>
<computeroutput moreinfo="none">       Type shape = &lt; area : float; equals : shape -&gt; bool &gt;</computeroutput>
<computeroutput moreinfo="none">       is not a subtype of</computeroutput>
<computeroutput moreinfo="none">         square = &lt; area : float; equals : square -&gt; bool; width : int &gt; </computeroutput></programlisting>

    <para>The problem is that a <literal moreinfo="none">square</literal>
    expects to be compared with a <literal moreinfo="none">square</literal>,
    not an arbitrary shape; likewise for <literal moreinfo="none">circle</literal>. This problem is fundamental. Many
    languages solve it either with narrowing (with dynamic type checking), or
    by method overloading. Since OCaml has neither of these, what can we
    do?<indexterm class="singular">
        <primary>methods</primary>

        <secondary>method overloading</secondary>
      </indexterm><indexterm class="singular">
        <primary>dynamic type checking</primary>
      </indexterm><indexterm class="singular">
        <primary>narrowing</primary>
      </indexterm><indexterm class="singular">
        <primary>polymorphism</primary>

        <secondary>polymorphic equality</secondary>
      </indexterm></para>

    <para>Since the problematic method is equality, one proposal we could
    consider is to just drop it from the base type <literal moreinfo="none">shape</literal> and use polymorphic equality instead.
    However, the built-in polymorphic equality has very poor behavior when
    applied to objects:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/classes/binary.topscript">OCaml utop</ulink>
    (part 3)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">(object method area = 5 end) = (object method area = 5 end) ;;</userinput>
<computeroutput moreinfo="none">- : bool = false</computeroutput></programlisting>

    <para>The problem here is that two objects are considered equal by the
    built-in polymorphic equality if and only if they are physically equal.
    There are other reasons not to use the built-in polymorphic equality, but
    these false negatives are a showstopper.</para>

    <para>If we want to define equality for shapes in general, the remaining
    solution is to use the same approach as we described for narrowing. That
    is, introduce a <emphasis>representation</emphasis> type implemented using
    variants, and implement the comparison based on the representation
    type:<indexterm class="singular">
        <primary>representation types</primary>
      </indexterm></para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/classes/binary.topscript">OCaml utop</ulink>
    (part 4)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">type shape_repr =</userinput>
<userinput moreinfo="none">  | Square of int</userinput>
<userinput moreinfo="none">  | Circle of int ;;</userinput>
<computeroutput moreinfo="none">type shape_repr = Square of int | Circle of int</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">type shape =</userinput>
<userinput moreinfo="none">  &lt; repr : shape_repr; equals : shape -&gt; bool; area : float &gt; ;;</userinput>
<computeroutput moreinfo="none">type shape = &lt; area : float; equals : shape -&gt; bool; repr : shape_repr &gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">class square w = object(self) </userinput>
<userinput moreinfo="none">    method width = w</userinput>
<userinput moreinfo="none">    method area = Float.of_int (self#width * self#width)</userinput>
<userinput moreinfo="none">    method repr = Square self#width</userinput>
<userinput moreinfo="none">    method equals (other : shape) = other#repr = self#repr</userinput>
<userinput moreinfo="none">  end ;;</userinput>
<computeroutput moreinfo="none">class square :</computeroutput>
<computeroutput moreinfo="none">  int -&gt;</computeroutput>
<computeroutput moreinfo="none">  object</computeroutput>
<computeroutput moreinfo="none">    method area : float</computeroutput>
<computeroutput moreinfo="none">    method equals : shape -&gt; bool</computeroutput>
<computeroutput moreinfo="none">    method repr : shape_repr</computeroutput>
<computeroutput moreinfo="none">    method width : int</computeroutput>
<computeroutput moreinfo="none">  end</computeroutput></programlisting>

    <para>The binary method <literal moreinfo="none">equals</literal> is now
    implemented in terms of the concrete type <literal moreinfo="none">shape_repr</literal>. When using this pattern, you will
    not be able to hide the <literal moreinfo="none">repr</literal> method,
    but you can hide the type definition using the module system:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/classes/binary_module.ml">OCaml</ulink></para>

    <programlisting format="linespecific" language="ocaml">module Shapes : sig
  type shape_repr
  type shape =
    &lt; repr : shape_repr; equals : shape -&gt; bool; area: float &gt;

  class square : int -&gt;
    object
      method width : int
      method area : float
      method repr : shape_repr
      method equals : shape -&gt; bool
    end
end = struct
  type shape_repr = 
  | Square of int 
  | Circle of int 
  ...
end</programlisting>

    <para>Note that this solution prevents us from adding new kinds of shapes
    without adding new constructors to the <literal moreinfo="none">shape_repr</literal> type, which is quite restrictive. The
    objects created by these classes are also in one-to-one correspondence
    with members of the representation type, making the objects seem somewhat
    redundant.</para>

    <para>However, equality is quite an extreme instance of a binary method:
    it needs access to all the information of the other object. Many other
    binary methods need only partial information about the object. For
    instance, a method that compares shapes by their sizes:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/classes/binary_larger.ml">OCaml</ulink></para>

    <programlisting format="linespecific" language="ocaml">class square w = object(self) 
  method width = w
  method area = Float.of_int (self#width * self#width)
  method larger other = self#area &gt; other#area
end</programlisting>

    <para>In this case, there is no one-to-one correspondence between the
    objects and their sizes, and we can still easily define new kinds of
    shape.</para>
  </sect1>

  <sect1 id="virtual-classes-and-methods">
    <title>Virtual Classes and Methods</title>

    <para>A <emphasis>virtual</emphasis> class is a class where some methods
    or fields are declared but not implemented. This should not be confused
    with the word <literal moreinfo="none">virtual</literal> as it is used in
    C++. A <literal moreinfo="none">virtual</literal> method in C++ uses
    dynamic dispatch, while regular, nonvirtual methods are statically
    dispatched. In OCaml, <emphasis>all</emphasis> methods use dynamic
    dispatch, but the keyword <literal moreinfo="none">virtual</literal> means
    that the method or field is not implemented. A class containing virtual
    methods must also be flagged <literal moreinfo="none">virtual</literal>
    and cannot be directly instantiated (i.e., no object of this class can be
    created).<indexterm class="singular">
        <primary>dispatching, dynamic vs. static</primary>
      </indexterm><indexterm class="singular">
        <primary>static dispatch</primary>
      </indexterm><indexterm class="singular">
        <primary>dynamic dispatch</primary>
      </indexterm><indexterm class="singular">
        <primary>virtual methods</primary>
      </indexterm><indexterm class="singular">
        <primary>methods</primary>

        <secondary sortas="virtural">and virtual classes</secondary>
      </indexterm><indexterm class="singular">
        <primary>virtual classes</primary>
      </indexterm><indexterm class="singular">
        <primary>classes</primary>

        <secondary>virtual classes</secondary>
      </indexterm></para>

    <para>To explore this, let's extend our shapes examples to simple,
    interactive graphics. We will use the Async concurrency library and the
    <ulink url="http://github.com/lpw25/async_graphics/">Async_graphics</ulink>
    library, which provides an asynchronous interface to OCaml's built-in
    Graphics library. Concurrent programming with Async will be explored later
    in <xref linkend="concurrent-programming-with-async"/>; for now you can
    safely ignore the details. You just need to run <literal moreinfo="none">opam install async_graphics</literal> to get the library
    installed on your system.</para>

    <para>We will give each shape a <literal moreinfo="none">draw</literal>
    method that describes how to draw the shape on the <literal moreinfo="none">Async_graphics</literal> display:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/classes-async/shapes.ml">OCaml</ulink></para>

    <programlisting format="linespecific" language="ocaml">open Core.Std
open Async.Std
open Async_graphics

type drawable = &lt; draw: unit &gt;</programlisting>

    <sect2 id="create-some-simple-shapes">
      <title>Create Some Simple Shapes</title>

      <para>Now let's add classes for making squares and circles. We include
      an <literal moreinfo="none">on_click</literal> method for adding event
      handlers to the shapes:<indexterm class="singular">
          <primary>geometric shapes</primary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/classes-async/verbose_shapes.ml">OCaml</ulink>
      (part 1)</para>

      <programlisting format="linespecific" language="ocaml">class square w x y = object(self)
  val mutable x: int = x
  method x = x

  val mutable y: int = y
  method y = y

  val mutable width = w
  method width = width

  method draw = fill_rect x y width width

  method private contains x' y' =
    x &lt;= x' &amp;&amp; x' &lt;= x + width &amp;&amp;
      y &lt;= y' &amp;&amp; y' &lt;= y + width

  method on_click ?start ?stop f =
    on_click ?start ?stop
      (fun ev -&gt;
         if self#contains ev.mouse_x ev.mouse_y then
           f ev.mouse_x ev.mouse_y)
end</programlisting>

      <para>The <literal moreinfo="none">square</literal> class is pretty
      straightforward, and the <literal moreinfo="none">circle</literal> class
      below also looks very similar:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/classes-async/verbose_shapes.ml">OCaml</ulink>
      (part 2)</para>

      <programlisting format="linespecific" language="ocaml">class circle r x y = object(self)
  val mutable x: int = x
  method x = x

  val mutable y: int = y
  method y = y

  val mutable radius = r
  method radius = radius

  method draw = fill_circle x y radius

  method private contains x' y' =
    let dx = abs (x' - x) in
    let dy = abs (y' - y) in
    let dist = sqrt (Float.of_int ((dx * dx) + (dy * dy))) in
      dist &lt;= (Float.of_int radius)

  method on_click ?start ?stop f =
    on_click ?start ?stop
      (fun ev -&gt;
         if self#contains ev.mouse_x ev.mouse_y then
           f ev.mouse_x ev.mouse_y)
end</programlisting>

      <para>These classes have a lot in common, and it would be useful to
      factor out this common functionality into a superclass. We can easily
      move the definitions of <literal moreinfo="none">x</literal> and
      <literal moreinfo="none">y</literal> into a superclass, but what about
      <literal moreinfo="none">on_click</literal>? Its definition depends on
      <literal moreinfo="none">contains</literal>, which has a different
      definition in each class. The solution is to create a
      <emphasis>virtual</emphasis> class. This class will declare a <literal moreinfo="none">contains</literal> method but leave its definition to
      the subclasses.</para>

      <para>Here is the more succinct definition, starting with a virtual
      <literal moreinfo="none">shape</literal> class that implements <literal moreinfo="none">on_click</literal> and <literal moreinfo="none">on_mousedown</literal>:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/classes-async/shapes.ml">OCaml</ulink>
      (part 1)</para>

      <programlisting format="linespecific" language="ocaml">class virtual shape x y = object(self)
  method virtual private contains: int -&gt; int -&gt; bool

  val mutable x: int = x
  method x = x

  val mutable y: int = y
  method y = y

  method on_click ?start ?stop f =
    on_click ?start ?stop
      (fun ev -&gt;  
         if self#contains ev.mouse_x ev.mouse_y then
           f ev.mouse_x ev.mouse_y)

  method on_mousedown ?start ?stop f =
    on_mousedown ?start ?stop
      (fun ev -&gt;
         if self#contains ev.mouse_x ev.mouse_y then
           f ev.mouse_x ev.mouse_y)
end</programlisting>

      <para>Now we can define <literal moreinfo="none">square</literal> and
      <literal moreinfo="none">circle</literal> by inheriting from <literal moreinfo="none">shape</literal>:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/classes-async/shapes.ml">OCaml</ulink>
      (part 2)</para>

      <programlisting format="linespecific" language="ocaml">class square w x y = object
  inherit shape x y

  val mutable width = w
  method width = width

  method draw = fill_rect x y width width

  method private contains x' y' = 
    x &lt;= x' &amp;&amp; x' &lt;= x + width &amp;&amp;
    y &lt;= y' &amp;&amp; y' &lt;= y + width 
end 

class circle r x y = object
  inherit shape x y

  val mutable radius = r
  method radius = radius

  method draw = fill_circle x y radius

  method private contains x' y' =
    let dx = abs (x' - x) in
    let dy = abs (y' - y) in
    let dist = sqrt (Float.of_int ((dx * dx) + (dy * dy))) in
    dist &lt;= (Float.of_int radius)
end</programlisting>

      <para>One way to view a <literal moreinfo="none">virtual</literal> class
      is that it is like a functor, where the "inputs" are the declared—but
      not defined—virtual methods and fields. The functor application is
      implemented through inheritance, when virtual methods are given concrete
      implementations.</para>
    </sect2>
  </sect1>

  <sect1 id="initializers">
    <title>Initializers</title>

    <para>You can execute expressions during the instantiation of a class by
    placing them before the object expression or in the initial value of a
    field:<indexterm class="singular">
        <primary>initializers</primary>
      </indexterm><indexterm class="singular">
        <primary>classes</primary>

        <secondary>initializers for</secondary>
      </indexterm></para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/classes/initializer.topscript">OCaml utop</ulink></para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">class obj x = </userinput>
<userinput moreinfo="none">    let () = printf "Creating obj %d\n" x in</userinput>
<userinput moreinfo="none">    object </userinput>
<userinput moreinfo="none">      val field = printf "Initializing field\n"; x</userinput>
<userinput moreinfo="none">    end ;;</userinput>
<computeroutput moreinfo="none">class obj : int -&gt; object val field : int end</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let o = new obj 3 ;;</userinput>
<computeroutput moreinfo="none">Creating obj 3</computeroutput>
<computeroutput moreinfo="none">Initializing field</computeroutput>
<computeroutput moreinfo="none">val o : obj = &lt;obj&gt;</computeroutput></programlisting>

    <para>However, these expressions are executed before the object has been
    created and cannot refer to the methods of the object. If you need to use
    an object's methods during instantiation, you can use an initializer. An
    initializer is an expression that will be executed during instantiation
    but after the object has been created.</para>

    <para>For example, suppose we wanted to extend our previous shapes module
    with a <literal moreinfo="none">growing_circle</literal> class for circles
    that expand when clicked. We could inherit from <literal moreinfo="none">circle</literal> and used the inherited <literal moreinfo="none">on_click</literal> to add a handler for click
    events:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/classes-async/shapes.ml">OCaml</ulink>
    (part 3)</para>

    <programlisting format="linespecific" language="ocaml">class growing_circle r x y = object(self)
  inherit circle r x y

  initializer
    self#on_click (fun _x _y -&gt; radius &lt;- radius * 2)
end</programlisting>
  </sect1>

  <sect1 id="multiple-inheritance">
    <title>Multiple Inheritance</title>

    <para>When a class inherits from more than one superclass, it is using
    <emphasis>multiple inheritance</emphasis>. Multiple inheritance extends
    the variety of ways that classes can be combined, and it can be quite
    useful, particularly with virtual classes. However, it can be tricky to
    use, particularly when the inheritance hierarchy is a graph rather than a
    tree, so it should be used with care.<indexterm class="singular">
        <primary>multiple inheritance</primary>

        <secondary>name resolution in</secondary>
      </indexterm><indexterm class="startofrange">
        <primary>inheritance</primary>
      </indexterm><indexterm class="singular">
        <primary>classes</primary>

        <secondary>multiple inheritance in</secondary>
      </indexterm></para>

    <sect2 id="how-names-are-resolved">
      <title>How Names Are Resolved</title>

      <para>The main trickiness of multiple inheritance is due to naming—what
      happens when a method or field with some name is defined in more than
      one class?</para>

      <para>If there is one thing to remember about inheritance in OCaml, it
      is this: inheritance is like textual inclusion. If there is more than
      one definition for a name, the last definition wins.</para>

      <para>For example, consider this class, which inherits from <literal moreinfo="none">square</literal> and defines a new <literal moreinfo="none">draw</literal> method that uses <literal moreinfo="none">draw_rect</literal> instead of <literal moreinfo="none">fill_rect</literal> to draw the square:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/classes-async/multiple_inheritance.ml">OCaml</ulink>
      (part 1)</para>

      <programlisting format="linespecific" language="ocaml">class square_outline w x y = object
  inherit square w x y
  method draw = draw_rect x y width width
end</programlisting>

      <para>Since the <literal moreinfo="none">inherit</literal> declaration
      comes before the method definition, the new <literal moreinfo="none">draw</literal> method overrides the old one, and the
      square is drawn using <literal moreinfo="none">draw_rect</literal>. But,
      what if we had defined <literal moreinfo="none">square_outline</literal>
      as follows?</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/classes-async/multiple_inheritance_wrong.ml">OCaml</ulink>
      (part 1)</para>

      <programlisting format="linespecific" language="ocaml">class square_outline w x y = object
  method draw = draw_rect x y w w
  inherit square w x y
end</programlisting>

      <para>Here the <literal moreinfo="none">inherit</literal> declaration
      comes after the method definition, so the <literal moreinfo="none">draw</literal> method from <literal moreinfo="none">square</literal> will override the other definition, and
      the square will be drawn using <literal moreinfo="none">fill_rect</literal>.</para>

      <para>To reiterate, to understand what inheritance means, replace each
      <literal moreinfo="none">inherit</literal> directive with its
      definition, and take the last definition of each method or field. Note
      that the methods and fields added by an inheritance are those listed in
      its class type, so private methods that are hidden by the type will not
      be included.</para>
    </sect2>

    <sect2 id="mixins">
      <title>Mixins</title>

      <para>When should you use multiple inheritance? If you ask multiple
      people, you're likely to get multiple (perhaps heated) answers. Some
      will argue that multiple inheritance is overly complicated; others will
      argue that inheritance is problematic in general, and one should use
      object composition instead. But regardless of who you talk to, you will
      rarely hear that multiple inheritance is great and that you should use
      it widely.<indexterm class="singular">
          <primary>mixin patterns</primary>
        </indexterm><indexterm class="singular">
          <primary>multiple inheritance</primary>

          <secondary>mixin pattern and</secondary>
        </indexterm></para>

      <para>In any case, if you're programming with objects, there's one
      general pattern for multiple inheritance that is both useful and
      reasonably simple: the <emphasis>mixin</emphasis> pattern. Generically,
      a <emphasis>mixin</emphasis> is just a virtual class that implements a
      feature based on another one. If you have a class that implements
      methods <emphasis>A</emphasis>, and you have a mixin
      <emphasis>M</emphasis> that provides methods <emphasis>B</emphasis> from
      <emphasis>A</emphasis>, then you can inherit from
      <emphasis>M</emphasis>—"mixing" it in—to get features
      <emphasis>B</emphasis>.</para>

      <para>That's too abstract, so let's give some examples based on our
      interactive shapes. We may wish to allow a shape to be dragged by the
      mouse. We can define this functionality for any object that has mutable
      <literal moreinfo="none">x</literal> and <literal moreinfo="none">y</literal> fields and an <literal moreinfo="none">on_mousedown</literal> method for adding event
      handlers:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/classes-async/shapes.ml">OCaml</ulink>
      (part 4)</para>

      <programlisting format="linespecific" language="ocaml">class virtual draggable = object(self)
  method virtual on_mousedown: 
    ?start:unit Deferred.t -&gt; 
    ?stop:unit Deferred.t -&gt; 
    (int -&gt; int -&gt; unit) -&gt; unit
  val virtual mutable x: int  
  val virtual mutable y: int  

  val mutable dragging = false
  method dragging = dragging

  initializer 
    self#on_mousedown 
      (fun mouse_x mouse_y -&gt;
         let offset_x = x - mouse_x in
         let offset_y = y - mouse_y in
         let mouse_up = Ivar.create () in
         let stop = Ivar.read mouse_up in
         dragging &lt;- true;
         on_mouseup ~stop
           (fun _ -&gt;
              Ivar.fill mouse_up ();
              dragging &lt;- false);
         on_mousemove ~stop
           (fun ev -&gt;
              x &lt;- ev.mouse_x + offset_x;
              y &lt;- ev.mouse_y + offset_y))
end</programlisting>

      <para>This allows us to create draggable shapes using multiple
      inheritance:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/classes-async/shapes.ml">OCaml</ulink>
      (part 5)</para>

      <programlisting format="linespecific" language="ocaml">class small_square = object
  inherit square 20 40 40
  inherit draggable 
end</programlisting>

      <para>We can also use mixins to create animated shapes. Each animated
      shape has a list of update functions to be called during animation. We
      create an <literal moreinfo="none">animated</literal> mixin to provide
      this update list and ensure that the functions in it are called regular
      intervals when the shape is animated:<indexterm class="singular">
          <primary>animation</primary>

          <secondary>creating with mixins</secondary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/classes-async/shapes.ml">OCaml</ulink>
      (part 6)</para>

      <programlisting format="linespecific" language="ocaml">class virtual animated span = object(self)
  method virtual on_click: 
    ?start:unit Deferred.t -&gt; 
    ?stop:unit Deferred.t -&gt; 
    (int -&gt; int -&gt; unit) -&gt; unit
  val mutable updates: (int -&gt; unit) list = []
  val mutable step = 0
  val mutable running = false

  method running = running

  method animate =
    step &lt;- 0;
    running &lt;- true;
    let stop =
      Clock.after span
      &gt;&gt;| fun () -&gt; running &lt;- false 
    in
    Clock.every ~stop (Time.Span.of_sec (1.0 /. 24.0))
      (fun () -&gt;
         step &lt;- step + 1;
         List.iter ~f:(fun f -&gt; f step) updates
      )

  initializer
    self#on_click (fun _x _y -&gt; if not self#running then self#animate)
end</programlisting>

      <para>We use initializers to add functions to this update list. For
      example, this class will produce circles that move to the right for a
      second when clicked:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/classes-async/shapes.ml">OCaml</ulink>
      (part 7)</para>

      <programlisting format="linespecific" language="ocaml">class my_circle = object
  inherit circle 20 50 50
  inherit animated Time.Span.second
  initializer updates &lt;- [fun _ -&gt; x &lt;- x + 5]
end</programlisting>

      <para>These initializers can also be added using mixins:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/classes-async/shapes.ml">OCaml</ulink>
      (part 8)</para>

      <programlisting format="linespecific" language="ocaml">class virtual linear x' y' = object
  val virtual mutable updates: (int -&gt; unit) list
  val virtual mutable x: int
  val virtual mutable y: int

  initializer
    let update _ =
      x &lt;- x + x';
      y &lt;- y + y'
    in
    updates &lt;- update :: updates
end

let pi = (atan 1.0) *. 4.0

class virtual harmonic offset x' y' = object
  val virtual mutable updates: (int -&gt; unit) list
  val virtual mutable x: int
  val virtual mutable y: int

  initializer
    let update step =
      let m = sin (offset +. ((Float.of_int step) *. (pi /. 64.))) in
      let x' = Float.to_int (m *. Float.of_int x') in
      let y' = Float.to_int (m *. Float.of_int y') in
      x &lt;- x + x';
      y &lt;- y + y'
    in
    updates &lt;- update :: updates
end</programlisting>

      <para>Since the <literal moreinfo="none">linear</literal> and <literal moreinfo="none">harmonic</literal> mixins are only used for their side
      effects, they can be inherited multiple times within the same object to
      produce a variety of different animations:<indexterm class="singular">
          <primary>linear mixins</primary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/classes-async/shapes.ml">OCaml</ulink>
      (part 9)</para>

      <programlisting format="linespecific" language="ocaml">class my_square x y = object
  inherit square 40 x y
  inherit draggable
  inherit animated (Time.Span.of_int_sec 5)
  inherit linear 5 0
  inherit harmonic 0.0 7 ~-10
end

let my_circle = object
  inherit circle 30 250 250
  inherit animated (Time.Span.minute)
  inherit harmonic 0.0 10 0
  inherit harmonic (pi /. 2.0) 0 10
end</programlisting>
    </sect2>

    <sect2 id="displaying-the-animated-shapes">
      <title>Displaying the Animated Shapes</title>

      <para>We finish our shapes module by creating a <literal moreinfo="none">main</literal> function to draw some shapes on the
      graphical display and running that function using the Async
      scheduler:<indexterm class="singular">
          <primary>animation</primary>

          <secondary>displaying animated shapes</secondary>
        </indexterm><indexterm class="singular">
          <primary>multiple inheritance</primary>

          <secondary>displaying animated shapes with</secondary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/classes-async/shapes.ml">OCaml</ulink>
      (part 10)</para>

      <programlisting format="linespecific" language="ocaml">let main () =
  let shapes = [ 
     (my_circle :&gt; drawable); 
     (new my_square 50 350 :&gt; drawable); 
     (new my_square 50 200 :&gt; drawable);
     (new growing_circle 20 70 70 :&gt; drawable);
  ] in
  let repaint () =
    clear_graph ();
    List.iter ~f:(fun s -&gt; s#draw) shapes;
    synchronize ()
  in 
    open_graph "";
    auto_synchronize false;
    Clock.every (Time.Span.of_sec (1.0 /. 24.0)) repaint

let () = never_returns (Scheduler.go_main ~main ())</programlisting>

      <para>Our <literal moreinfo="none">main</literal> function creates a
      list of shapes to be displayed and defines a <literal moreinfo="none">repaint</literal> function that actually draws them on
      the display. We then open a graphical display and ask Async to run
      <literal moreinfo="none">repaint</literal> at regular intervals.</para>

      <para>Finally, build the binary by linking against the <literal moreinfo="none">async_graphics</literal> package, which will pull in all
      the other dependencies:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/classes-async/build_shapes.out">Terminal</ulink></para>

      <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">corebuild -pkg async_graphics shapes.native</userinput>
</programlisting>

      <para>When you run the binary, a new graphical window should appear (on
      Mac OS X, you will need to install the X11 package first, which you will
      be prompted for). Try clicking on the various widgets, and gasp in awe
      at the sophisticated animations that unfold as a result.</para>

      <para>The graphics library described here is the one built into OCaml
      and is more useful as a learning tool than anything else. There are
      several third-party libraries that provide more sophisticated bindings
      to various graphics subsystems:<indexterm class="singular">
          <primary>js_of_ocaml library</primary>
        </indexterm><indexterm class="singular">
          <primary>LabIGL library</primary>
        </indexterm><indexterm class="singular">
          <primary>Lablgtk library</primary>
        </indexterm><indexterm class="singular">
          <primary>graphics libraries</primary>
        </indexterm><indexterm class="singular">
          <primary>libraries</primary>

          <secondary>for graphics</secondary>
        </indexterm><indexterm class="singular">
          <primary>external libraries</primary>

          <secondary sortas="graphics">for graphics</secondary>
        </indexterm></para>

      <variablelist>
        <varlistentry>
          <term><ulink url="http://lablgtk.forge.ocamlcore.org">Lablgtk</ulink></term>

          <listitem>
            <para>A strongly typed interface to the GTK widget library.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><ulink url="https://forge.ocamlcore.org/projects/lablgl/">LablGL</ulink></term>

          <listitem>
            <para>An interface between OCaml and OpenGL, a widely supported
            standard for 3D rendering.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><ulink url="http://ocsigen.org/js_of_ocaml/api/Js">js_of_ocaml</ulink></term>

          <listitem>
            <para>Compiles OCaml code to JavaScript and has bindings to WebGL.
            This is the emerging standard for 3D rendering in web
            browsers.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      
    </sect2>
  </sect1>
</chapter>
</part>

  <part>
    <title>Tools and Techniques</title>

    <partintro>
      <para>Part II builds on the basics by demonstrating more advanced tools and techniques that
      are useful for building real world programs. Here you'll learn about useful libraries for
      building practical applications, as well as design patterns that help combine different
      features of the language to good effect.</para>

      <para>This part begins by introducing two of the most common datastructures used in OCaml:
      maps and hashtables. We then change gears and explain how to build expressive command-line
      interfaces, which is a good example of a sophisticated use of the type system to create a user
      friendly library.</para>
    <para>Some of the examples in this part use the JSON interchange format, and so we first show
      how to use third-party tools to parse and generate JSON, as well as how to build a parser from
      scratch. Another interchange format used throughout OCaml are s-expressions, and this chapter
      shows how to turn any OCaml value into an s-expression by using the powerful camlp4 syntax
      preprocessor.</para>
    <para>We close with a tour of the Async communications library, which lets you build scalable,
      high-performance networked applications in OCaml. By the end of the chapter, you will be able
      to run web queries against the DuckDuckGo engine by using Async, JSON and a HTTP library all
      written in OCaml.</para>
    </partintro>

    <chapter id="maps-and-hash-tables">
  <title>Maps and Hash Tables</title>

  <para>Lots of programming problems require dealing with data organized as
  key/value pairs. Maybe the simplest way of representing such data in OCaml
  is an <emphasis>association list</emphasis>, which is simply a list of pairs
  of keys and values. For example, you could represent a mapping between the
  10 digits and their English names as follows:<indexterm class="singular">
      <primary>key/value pairs</primary>
    </indexterm><indexterm class="singular">
      <primary>data structures</primary>

      <secondary>key/value pairs</secondary>
    </indexterm><indexterm class="singular">
      <primary>lists</primary>

      <secondary>association lists</secondary>
    </indexterm><indexterm class="singular">
      <primary>association lists</primary>
    </indexterm></para>

  <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/maps-and-hash-tables/main.topscript">OCaml utop</ulink>
  (part 1)</para>

  <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let digit_alist =</userinput>
<userinput moreinfo="none">    [ 0, "zero"; 1, "one"; 2, "two"  ; 3, "three"; 4, "four"</userinput>
<userinput moreinfo="none">    ; 5, "five"; 6, "six"; 7, "seven"; 8, "eight"; 9, "nine" ]</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val digit_alist : (int * string) list =</computeroutput>
<computeroutput moreinfo="none">  [(0, "zero"); (1, "one"); (2, "two"); (3, "three"); (4, "four");</computeroutput>
<computeroutput moreinfo="none">   (5, "five"); (6, "six"); (7, "seven"); (8, "eight"); (9, "nine")]</computeroutput></programlisting>

  <para>We can use functions from the <literal moreinfo="none">List.Assoc</literal> module to
    manipulate this data:</para>

  <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/maps-and-hash-tables/main.topscript">OCaml utop</ulink>
  (part 2)</para>

  <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">List.Assoc.find digit_alist 6;;</userinput>
<computeroutput moreinfo="none">- : string option = Some "six"</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">List.Assoc.find digit_alist 22;;</userinput>
<computeroutput moreinfo="none">- : string option = None</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">List.Assoc.add digit_alist 0 "zilch";;</userinput>
<computeroutput moreinfo="none">- : (int, string) List.Assoc.t =</computeroutput>
<computeroutput moreinfo="none">[(0, "zilch"); (1, "one"); (2, "two"); (3, "three"); (4, "four");</computeroutput>
<computeroutput moreinfo="none"> (5, "five"); (6, "six"); (7, "seven"); (8, "eight"); (9, "nine")]</computeroutput></programlisting>

  <para>Association lists are simple and easy to use, but their performance is
  not ideal, since almost every nontrivial operation on an association list
  requires a linear-time scan of the list.</para>

  <para>In this chapter, we'll talk about two more efficient alternatives to
  association lists: <emphasis>maps</emphasis> and <emphasis>hash
  tables</emphasis>. A map is an immutable tree-based data structure where
  most operations take time logarithmic in the size of the map, whereas a hash
  table is a mutable data structure where most operations have constant time
  complexity. We'll describe both of these data structures in detail and
  provide some advice as to how to choose between them.<indexterm class="singular">
      <primary>hash tables</primary>

      <secondary>basics of</secondary>
    </indexterm><indexterm class="singular">
      <primary>maps</primary>

      <secondary>basics of</secondary>
    </indexterm></para>

  <sect1 id="maps">
    <title>Maps</title>

    <para>Let's consider an example of how one might use a map in practice. In
    <xref linkend="files-modules-and-programs"/>, we showed a module <literal moreinfo="none">Counter</literal> for keeping frequency counts on a set of
    strings. Here's the interface:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/files-modules-and-programs-freq-fast/counter.mli">OCaml</ulink></para>

    <programlisting format="linespecific" language="ocaml">open Core.Std

(** A collection of string frequency counts *)
type t

(** The empty set of frequency counts  *)
val empty : t

(** Bump the frequency count for the given string. *)
val touch : t -&gt; string -&gt; t

(* Converts the set of frequency counts to an association list.  Every string
   in the list will show up at most once, and the integers will be at least
   1. *)
val to_list : t -&gt; (string * int) list</programlisting>

    <para>The intended behavior here is straightforward. <literal moreinfo="none">Counter.empty</literal> represents an empty collection of
    frequency counts; <literal moreinfo="none">touch</literal> increments the
    frequency count of the specified string by 1; and <literal moreinfo="none">to_list</literal> returns the list of nonzero
    frequencies.</para>

    <para>Here's the implementation:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/files-modules-and-programs-freq-fast/counter.ml">OCaml</ulink></para>

    <programlisting format="linespecific" language="ocaml">open Core.Std

type t = int String.Map.t

let empty = String.Map.empty

let to_list t = Map.to_alist t

let touch t s =
  let count =
    match Map.find t s with
    | None -&gt; 0
    | Some x -&gt; x
  in
  Map.add t ~key:s ~data:(count + 1)</programlisting>

    <para>Note that in some places the preceding code refers to <literal moreinfo="none">String.Map.t</literal>, and in others <literal moreinfo="none">Map.t</literal>. This has to do with the fact that maps
    are implemented as ordered binary trees, and as such, need a way of
    comparing keys.</para>

    <para>To deal with this, a map, once created, stores the necessary
    comparison function within the data structure. Thus, operations like
    <literal moreinfo="none">Map.find</literal> or <literal moreinfo="none">Map.add</literal> that access the contents of a map or
    create a new map from an existing one, do so by using the comparison
    function embedded within the map.</para>

    <para>But in order to get a map in the first place, you need to get your
    hands on the comparison function somehow. For this reason, modules like
    <literal moreinfo="none">String</literal> contain a <literal moreinfo="none">Map</literal> submodule that has values like <literal moreinfo="none">String.Map.empty</literal> and <literal moreinfo="none">String.Map.of_alist</literal> that are specialized to
    strings, and thus have access to a string comparison function. Such a
    <literal moreinfo="none">Map</literal> submodule is included in every
    module that satisfies the <literal moreinfo="none">Comparable.S</literal>
    interface from Core.</para>

    <sect2 id="creating-maps-with-comparators">
      <title>Creating Maps with Comparators</title>

      <para>The specialized <literal moreinfo="none">Map</literal> submodule
      is convenient, but it's not the only way of creating a <literal moreinfo="none">Map.t</literal>. The information required to compare
      values of a given type is wrapped up in a value called a
      <emphasis>comparator</emphasis> that can be used to create maps using
      the <literal moreinfo="none">Map</literal> module directly:<indexterm class="singular">
          <primary>comparators, creating maps with</primary>
        </indexterm><indexterm class="singular">
          <primary>Map module</primary>

          <secondary>Map.of_alist_exn</secondary>
        </indexterm><indexterm class="singular">
          <primary>maps</primary>

          <secondary>creating with comparators</secondary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/maps-and-hash-tables/main.topscript">OCaml utop</ulink>
      (part 3)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let digit_map = Map.of_alist_exn digit_alist</userinput>
<userinput moreinfo="none">                     ~comparator:Int.comparator;;</userinput>
<computeroutput moreinfo="none">val digit_map : (int, string, Int.comparator) Map.t = &lt;abstr&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Map.find digit_map 3;;</userinput>
<computeroutput moreinfo="none">- : string option = Some "three"</computeroutput></programlisting>

      <para>The preceding code uses <literal moreinfo="none">Map.of_alist_exn</literal>, which creates a map from an
      association list, throwing an exception if there are duplicate keys in
      the list.</para>

      <para>The comparator is only required for operations that create maps
      from scratch. Operations that update an existing map simply inherit the
      comparator of the map they start with:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/maps-and-hash-tables/main.topscript">OCaml utop</ulink>
      (part 4)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let zilch_map = Map.add digit_map ~key:0 ~data:"zilch";;</userinput>
<computeroutput moreinfo="none">val zilch_map : (int, string, Int.comparator) Map.t = &lt;abstr&gt;</computeroutput></programlisting>

      <para>The type <literal moreinfo="none">Map.t</literal> has three type
      parameters: one for the key, one for the value, and one to identify the
      comparator. Indeed, the type <literal moreinfo="none">'a
      Int.Map.t</literal> is just a type alias for <literal moreinfo="none">(int,'a,Int.comparator) Map.t</literal>.</para>

      <para>Including the comparator in the type is important because
      operations that work on multiple maps at the same time often require
      that the maps share their comparison function. Consider, for example,
      <literal moreinfo="none">Map.symmetric_diff</literal>, which computes a
      summary of the differences between two maps:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/maps-and-hash-tables/main.topscript">OCaml utop</ulink>
      (part 5)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let left = String.Map.of_alist_exn ["foo",1; "bar",3; "snoo",0]</userinput>
<userinput moreinfo="none">  let right = String.Map.of_alist_exn ["foo",0; "snoo",0]</userinput>
<userinput moreinfo="none">  let diff = Map.symmetric_diff ~data_equal:Int.equal left right</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val left : int String.Map.t = &lt;abstr&gt;</computeroutput>
<computeroutput moreinfo="none">val right : int String.Map.t = &lt;abstr&gt;</computeroutput>
<computeroutput moreinfo="none">val diff :</computeroutput>
<computeroutput moreinfo="none">  (string * [ `Left of int | `Right of int | `Unequal of int * int ]) list =</computeroutput>
<computeroutput moreinfo="none">  [("foo", `Unequal (1, 0)); ("bar", `Left 3)]</computeroutput></programlisting>

      <para>The type of <literal moreinfo="none">Map.symmetric_diff</literal>,
      which follows, requires that the two maps it compares have the same
      comparator type. Each comparator has a fresh abstract type, so the type
      of a comparator identifies the comparator uniquely:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/maps-and-hash-tables/main.topscript">OCaml utop</ulink>
      (part 6)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">Map.symmetric_diff;;</userinput>
<computeroutput moreinfo="none">- : ('k, 'v, 'cmp) Map.t -&gt;</computeroutput>
<computeroutput moreinfo="none">    ('k, 'v, 'cmp) Map.t -&gt;</computeroutput>
<computeroutput moreinfo="none">    data_equal:('v -&gt; 'v -&gt; bool) -&gt;</computeroutput>
<computeroutput moreinfo="none">    ('k * [ `Left of 'v | `Right of 'v | `Unequal of 'v * 'v ]) list</computeroutput>
<computeroutput moreinfo="none">= &lt;fun&gt;</computeroutput></programlisting>

      <para>This constraint is important because the algorithm that <literal moreinfo="none">Map.symmetric_diff</literal> uses depends for its
      correctness on the fact that both maps have the same comparator.</para>

      <para>We can create a new comparator using the <literal moreinfo="none">Comparator.Make</literal> functor, which takes as its
      input a module containing the type of the object to be compared, sexp
      converter functions, and a comparison function. The sexp converters are
      included in the comparator to make it possible for users of the
      comparator to generate better error messages. Here's an
      example:<indexterm class="singular">
          <primary>Sexplib package</primary>

          <secondary>sexp converter</secondary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/maps-and-hash-tables/main.topscript">OCaml utop</ulink>
      (part 7)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">module Reverse = Comparator.Make(struct</userinput>
<userinput moreinfo="none">    type t = string</userinput>
<userinput moreinfo="none">    let sexp_of_t = String.sexp_of_t</userinput>
<userinput moreinfo="none">    let t_of_sexp = String.t_of_sexp</userinput>
<userinput moreinfo="none">    let compare x y = String.compare y x</userinput>
<userinput moreinfo="none">  end);;</userinput>
<computeroutput moreinfo="none">module Reverse :</computeroutput>
<computeroutput moreinfo="none">  sig</computeroutput>
<computeroutput moreinfo="none">    type t = string</computeroutput>
<computeroutput moreinfo="none">    val compare : t -&gt; t -&gt; int</computeroutput>
<computeroutput moreinfo="none">    val t_of_sexp : Sexp.t -&gt; t</computeroutput>
<computeroutput moreinfo="none">    val sexp_of_t : t -&gt; Sexp.t</computeroutput>
<computeroutput moreinfo="none">    type comparator</computeroutput>
<computeroutput moreinfo="none">    val comparator : (t, comparator) Comparator.t_</computeroutput>
<computeroutput moreinfo="none">  end</computeroutput></programlisting>

      <para>As you can see in the following code, both <literal moreinfo="none">Reverse.comparator</literal> and <literal moreinfo="none">String.comparator</literal> can be used to create maps
      with a key type of <literal moreinfo="none">string</literal>:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/maps-and-hash-tables/main.topscript">OCaml utop</ulink>
      (part 8)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let alist = ["foo", 0; "snoo", 3];;</userinput>
<computeroutput moreinfo="none">val alist : (string * int) list = [("foo", 0); ("snoo", 3)]</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let ord_map = Map.of_alist_exn ~comparator:String.comparator alist;;</userinput>
<computeroutput moreinfo="none">val ord_map : (string, int, String.comparator) Map.t = &lt;abstr&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let rev_map = Map.of_alist_exn ~comparator:Reverse.comparator alist;;</userinput>
<computeroutput moreinfo="none">val rev_map : (string, int, Reverse.comparator) Map.t = &lt;abstr&gt;</computeroutput></programlisting>

      <para><literal moreinfo="none">Map.min_elt</literal> returns the key and
      value for the smallest key in the map, which lets us see that these two
      maps do indeed use different comparison functions:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/maps-and-hash-tables/main.topscript">OCaml utop</ulink>
      (part 9)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">Map.min_elt ord_map;;</userinput>
<computeroutput moreinfo="none">- : (string * int) option = Some ("foo", 0)</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Map.min_elt rev_map;;</userinput>
<computeroutput moreinfo="none">- : (string * int) option = Some ("snoo", 3)</computeroutput></programlisting>

      <para>Accordingly, if we try to use <literal moreinfo="none">Map.symmetric_diff</literal> on these two maps, we'll
      get a compile-time error:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/maps-and-hash-tables/main.topscript">OCaml utop</ulink>
      (part 10)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">Map.symmetric_diff ord_map rev_map;;</userinput>
<computeroutput moreinfo="none">Characters 27-34:</computeroutput>
<computeroutput moreinfo="none">Error: This expression has type (string, int, Reverse.comparator) Map.t</computeroutput>
<computeroutput moreinfo="none">       but an expression was expected of type</computeroutput>
<computeroutput moreinfo="none">         (string, int, String.comparator) Map.t</computeroutput>
<computeroutput moreinfo="none">       Type Reverse.comparator is not compatible with type String.comparator </computeroutput></programlisting>
    </sect2>

    <sect2 id="trees">
      <title>Trees</title>

      <para>As we've discussed, maps carry within them the comparator that
      they were created with. Sometimes, often for space efficiency reasons,
      you want a version of the map data structure that doesn't include the
      comparator. You can get such a representation with <literal moreinfo="none">Map.to_tree</literal>, which returns just the tree
      underlying the map, without the comparator:<indexterm class="singular">
          <primary>Map module</primary>

          <secondary>Map.to_tree</secondary>
        </indexterm><indexterm class="singular">
          <primary>maps</primary>

          <secondary>tree structure</secondary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/maps-and-hash-tables/main.topscript">OCaml utop</ulink>
      (part 11)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let ord_tree = Map.to_tree ord_map;;</userinput>
<computeroutput moreinfo="none">val ord_tree : (string, int, String.comparator) Map.Tree.t = &lt;abstr&gt;</computeroutput></programlisting>

      <para>Even though a <literal moreinfo="none">Map.Tree.t</literal>
      doesn't physically include a comparator, it does include the comparator
      in its type. This is what is known as a <emphasis>phantom
      type</emphasis>, because it reflects something about the logic of the
      value in question, even though it doesn't correspond to any values
      directly represented in the underlying physical structure of the
      value.</para>

      <para>Since the comparator isn't included in the tree, we need to
      provide the comparator explicitly when we, say, search for a key, as
      shown below:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/maps-and-hash-tables/main.topscript">OCaml utop</ulink>
      (part 12)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">Map.Tree.find ~comparator:String.comparator ord_tree "snoo";;</userinput>
<computeroutput moreinfo="none">- : int option = Some 3</computeroutput></programlisting>

      <para>The algorithm of <literal moreinfo="none">Map.Tree.find</literal>
      depends on the fact that it's using the same comparator when looking up
      a value as you were when you stored it. That's the invariant that the
      phantom type is there to enforce. As you can see in the following
      example, using the wrong comparator will lead to a type error:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/maps-and-hash-tables/main.topscript">OCaml utop</ulink>
      (part 13)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">Map.Tree.find ~comparator:Reverse.comparator ord_tree "snoo";;</userinput>
<computeroutput moreinfo="none">Characters 45-53:</computeroutput>
<computeroutput moreinfo="none">Error: This expression has type (string, int, String.comparator) Map.Tree.t</computeroutput>
<computeroutput moreinfo="none">       but an expression was expected of type</computeroutput>
<computeroutput moreinfo="none">         (string, int, Reverse.comparator) Map.Tree.t</computeroutput>
<computeroutput moreinfo="none">       Type String.comparator is not compatible with type Reverse.comparator </computeroutput></programlisting>
    </sect2>

    <sect2 id="the-polymorphic-comparator">
      <title>The Polymorphic Comparator</title>

      <para>We don't need to generate specialized comparators for every type
      we want to build a map on. We can instead use a comparator based on
      OCaml's built-in polymorphic comparison function, which was discussed in
      <xref linkend="lists-and-patterns"/>. This comparator is found in the
      <literal moreinfo="none">Comparator.Poly</literal> module, allowing us
      to write:<indexterm class="singular">
          <primary>maps</primary>

          <secondary>polymorphic comparison in</secondary>
        </indexterm><indexterm class="singular">
          <primary>Comparator.Poly module</primary>
        </indexterm><indexterm class="singular">
          <primary>polymorphic comparisons</primary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/maps-and-hash-tables/main.topscript">OCaml utop</ulink>
      (part 14)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">Map.of_alist_exn ~comparator:Comparator.Poly.comparator digit_alist;;</userinput>
<computeroutput moreinfo="none">- : (int, string, Comparator.Poly.comparator) Map.t = &lt;abstr&gt;</computeroutput></programlisting>

      <para>Or, equivalently:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/maps-and-hash-tables/main.topscript">OCaml utop</ulink>
      (part 15)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">Map.Poly.of_alist_exn digit_alist;;</userinput>
<computeroutput moreinfo="none">- : (int, string) Map.Poly.t = &lt;abstr&gt;</computeroutput></programlisting>

      <para>Note that maps based on the polymorphic comparator are not
      equivalent to those based on the type-specific comparators from the
      point of view of the type system. Thus, the compiler rejects the
      following:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/maps-and-hash-tables/main.topscript">OCaml utop</ulink>
      (part 16)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">Map.symmetric_diff (Map.Poly.singleton 3 "three")</userinput>
<userinput moreinfo="none">                     (Int.Map.singleton  3 "four" ) ;;</userinput>
<computeroutput moreinfo="none">Characters 72-99:</computeroutput>
<computeroutput moreinfo="none">Error: This expression has type</computeroutput>
<computeroutput moreinfo="none">         string Int.Map.t = (int, string, Int.comparator) Map.t</computeroutput>
<computeroutput moreinfo="none">       but an expression was expected of type</computeroutput>
<computeroutput moreinfo="none">         (int, string, Comparator.Poly.comparator) Map.t</computeroutput>
<computeroutput moreinfo="none">       Type Int.comparator is not compatible with type</computeroutput>
<computeroutput moreinfo="none">         Comparator.Poly.comparator </computeroutput></programlisting>

      <para>This is rejected for good reason: there's no guarantee that the
      comparator associated with a given type will order things in the same
      way that polymorphic compare does.</para>

      <sidebar>
        <title>The Perils of Polymorphic Compare</title>

        <para>Polymorphic compare is highly convenient, but it has serious
        downsides as well and should be used with care. In particular,
        polymorphic compare has a fixed algorithm for comparing values of any
        type, and that algorithm can sometimes yield surprising
        results.</para>

        <para>To understand what's wrong with polymorphic compare, you need to
        understand a bit about how it works. Polymorphic compare is
        <emphasis>structural</emphasis>, in that it operates directly on the
        runtime representation of OCaml values, walking the structure of the
        values in question without regard for their type.</para>

        <para>This is convenient because it provides a comparison function that works for most OCaml
          values and largely behaves as you would expect. For example, on <literal moreinfo="none">int</literal>s and <literal moreinfo="none">float</literal>s, it acts as you would
          expect a numeric comparison function to act. For simple containers like strings and lists
          and arrays, it operates as a lexicographic comparison. And except for functions and values
          from outside of the OCaml heap, it works on almost every OCaml type.</para>

        <para>But sometimes, a structural comparison is not what you want.
        Sets are a great example of this. Consider the following two
        sets:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/maps-and-hash-tables/main.topscript">OCaml utop</ulink>
        (part 18)</para>

        <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let (s1,s2) = (Int.Set.of_list [1;2],</userinput>
<userinput moreinfo="none">                 Int.Set.of_list [2;1]);;</userinput>
<computeroutput moreinfo="none">val s1 : Int.Set.t = &lt;abstr&gt;</computeroutput>
<computeroutput moreinfo="none">val s2 : Int.Set.t = &lt;abstr&gt;</computeroutput></programlisting>

        <para>Logically, these two sets should be equal, and that's the result
        that you get if you call <literal moreinfo="none">Set.equal</literal>
        on them:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/maps-and-hash-tables/main.topscript">OCaml utop</ulink>
        (part 19)</para>

        <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">Set.equal s1 s2;;</userinput>
<computeroutput moreinfo="none">- : bool = true</computeroutput></programlisting>

        <para>But because the elements were added in different orders, the
        layout of the trees underlying the sets will be different. As such, a
        structural comparison function will conclude that they're
        different.</para>

        <para>Let's see what happens if we use polymorphic compare to test for
        equality by way of the <literal moreinfo="none">=</literal> operator.
        Comparing the maps directly will fail at runtime because the
        comparators stored within the sets contain function values:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/maps-and-hash-tables/main.topscript">OCaml utop</ulink>
        (part 20)</para>

        <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">s1 = s2;;</userinput>
<computeroutput moreinfo="none">Exception: (Invalid_argument "equal: functional value").</computeroutput></programlisting>

        <para>We can, however, use the function <literal moreinfo="none">Set.to_tree</literal> to expose the underlying tree
        without the attached comparator:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/maps-and-hash-tables/main.topscript">OCaml utop</ulink>
        (part 21)</para>

        <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">Set.to_tree s1 = Set.to_tree s2;;</userinput>
<computeroutput moreinfo="none">- : bool = false</computeroutput></programlisting>

        <para>This can cause real and quite subtle bugs. If, for example, you
        use a map whose keys contain sets, then the map built with the
        polymorphic comparator will behave incorrectly, separating out keys
        that should be aggregated together. Even worse, it will work sometimes
        and fail others; since if the sets are built in a consistent order,
        then they will work as expected, but once the order changes, the
        behavior will change.</para>
      </sidebar>
    </sect2>

    <sect2 id="sets">
      <title>Sets</title>

      <para>Sometimes, instead of keeping track of a set of key/value pairs,
      you just want a data type for keeping track of a set of keys. You could
      build this on top of a map by representing a set of values by a map
      whose data type is <literal moreinfo="none">unit</literal>. But a more
      idiomatic (and efficient) solution is to use Core's set type, which is
      similar in design and spirit to the map type, while having an API better
      tuned to working with sets and a lower memory footprint. Here's a simple
      example:<indexterm class="singular">
          <primary>set types</primary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/maps-and-hash-tables/main.topscript">OCaml utop</ulink>
      (part 17)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let dedup ~comparator l =</userinput>
<userinput moreinfo="none">    List.fold l ~init:(Set.empty ~comparator) ~f:Set.add</userinput>
<userinput moreinfo="none">    |&gt; Set.to_list</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val dedup :</computeroutput>
<computeroutput moreinfo="none">  comparator:('a, 'b) Core_kernel.Comparator.t_ -&gt; 'a list -&gt; 'a list = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">dedup ~comparator:Int.comparator [8;3;2;3;7;8;10];;</userinput>
<computeroutput moreinfo="none">- : int list = [2; 3; 7; 8; 10]</computeroutput></programlisting>

      <para>In addition to the operators you would expect to have for maps,
      sets support the traditional set operations, including union,
      intersection, and set difference. And, as with maps, we can create sets
      based on type-specific comparators or on the polymorphic
      comparator.</para>
    </sect2>

    <sect2 id="satisfying-the-comparable.s-interface">
      <title>Satisfying the Comparable.S Interface</title>

      <para>Core's <literal moreinfo="none">Comparable.S</literal> interface
      includes a lot of useful functionality, including support for working
      with maps and sets. In particular, <literal moreinfo="none">Comparable.S</literal> requires the presence of the
      <literal moreinfo="none">Map</literal> and <literal moreinfo="none">Set</literal> submodules, as well as a
      comparator.<indexterm class="singular">
          <primary>interfaces</primary>

          <secondary>Comparable.S</secondary>
        </indexterm><indexterm class="singular">
          <primary>Comparable module</primary>

          <secondary>Comparable.Make</secondary>
        </indexterm><indexterm class="singular">
          <primary>Comparable module</primary>

          <secondary>Comparable.S</secondary>
        </indexterm><indexterm class="singular">
          <primary>maps</primary>

          <secondary>comparable.S interface</secondary>
        </indexterm></para>

      <para><literal moreinfo="none">Comparable.S</literal> is satisfied by
      most of the types in Core, but the question arises of how to satisfy the
      comparable interface for a new type that you design. Certainly
      implementing all of the required functionality from scratch would be an
      absurd amount of work.</para>

      <para>The module <literal moreinfo="none">Comparable</literal> contains
      a number of functors to help you automate this task. The simplest one of
      these is <literal moreinfo="none">Comparable.Make</literal>, which takes
      as an input any module that satisfies the following interface:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/maps-and-hash-tables/comparable.ml">OCaml</ulink></para>

      <programlisting format="linespecific" language="ocaml">module type Comparable = sig
  type t
  val sexp_of_t : t -&gt; Sexp.t
  val t_of_sexp : Sexp.t -&gt; t
  val compare : t -&gt; t -&gt; int
end</programlisting>

      <para>In other words, it expects a type with a comparison function, as
      well as functions for converting to and from
      <emphasis>s-expressions</emphasis>. S-expressions are a serialization
      format used commonly in Core and are required here to enable better
      error messages. We'll discuss s-expressions more in <xref linkend="data-serialization-with-s-expressions"/>, but in the meantime,
      we'll use the <literal moreinfo="none">with sexp</literal> declaration
      that comes from the Sexplib syntax extension. This declaration kicks off
      the automatic generation of s-expression conversion functions for the
      marked type.</para>

      <para>The following example shows how this all fits together, following
      the same basic pattern for using functors described in <xref linkend="extending-modules"/>:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/maps-and-hash-tables/main-22.rawscript">OCaml utop</ulink></para>

      <programlisting format="linespecific" language="ocaml"><userinput moreinfo="none"># module Foo_and_bar : sig
    type t = { foo: Int.Set.t; bar: string }
    include Comparable.S with type t := t
  end = struct
    module T = struct
      type t = { foo: Int.Set.t; bar: string } with sexp
      let compare t1 t2 =
        let c = Int.Set.compare t1.foo t2.foo in
        if c &lt;&gt; 0 then c else String.compare t1.bar t2.bar
    end
    include T
    include Comparable.Make(T)
  end;;</userinput>
<computeroutput moreinfo="none">module Foo_and_bar :
sig
  type t = { foo : Int.Set.t; bar : string; }
  val ( &gt;= ) : t -&gt; t -&gt; bool
  val ( &lt;= ) : t -&gt; t -&gt; bool
  val ( = ) : t -&gt; t -&gt; bool

    ...

end</computeroutput></programlisting>

      <para>We don't include the full response from the toplevel because it is
      quite lengthy, but <literal moreinfo="none">Foo_and_bar</literal> does
      satisfy <literal moreinfo="none">Comparable.S</literal>.</para>

      <para>In the preceding code we wrote the comparison function by hand,
      but this isn't strictly necessary. Core ships with a syntax extension
      called <literal moreinfo="none">comparelib</literal>, which will create
      a comparison function from a type definition. Using it, we can rewrite
      the previous example as follows:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/maps-and-hash-tables/main-23.rawscript">OCaml utop</ulink></para>

      <programlisting format="linespecific" language="ocaml"><userinput moreinfo="none"># module Foo_and_bar : sig
    type t = { foo: Int.Set.t; bar: string }
    include Comparable.S with type t := t
  end = struct
    module T = struct
      type t = { foo: Int.Set.t; bar: string } with sexp, compare
    end
    include T
    include Comparable.Make(T)
  end;;</userinput>
<computeroutput moreinfo="none">module Foo_and_bar :
sig
  type t = { foo : Int.Set.t; bar : string; }
  val ( &gt;= ) : t -&gt; t -&gt; bool
  val ( &lt;= ) : t -&gt; t -&gt; bool
  val ( = ) : t -&gt; t -&gt; bool

  ...

end</computeroutput></programlisting>

      <para>The comparison function created by <literal moreinfo="none">comparelib</literal> for a given type will call out to
      the comparison functions for its component types. As a result, the
      <literal moreinfo="none">foo</literal> field will be compared using
      <literal moreinfo="none">Int.Set.compare</literal>. This is different,
      and saner than the structural comparison done by polymorphic
      compare.</para>

      <para>If you want your comparison function to behave in a specific way,
      you should still write your own comparison function by hand; but if all
      you want is a total order suitable for creating maps and sets with, then
      <literal moreinfo="none">comparelib</literal> is a good way to
      go.</para>

      <para>You can also satisfy the <literal moreinfo="none">Comparable.S</literal> interface using polymorphic
      compare:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/maps-and-hash-tables/main-24.rawscript">OCaml utop</ulink></para>

      <programlisting format="linespecific" language="ocaml"><userinput moreinfo="none"># module Foo_and_bar : sig
    type t = { foo: int; bar: string }
    include Comparable.S with type t := t
  end = struct
    module T = struct
      type t = { foo: int; bar: string } with sexp
    end
    include T
    include Comparable.Poly(T)
  end;;</userinput>
<computeroutput moreinfo="none">module Foo_and_bar :
sig
  type t = { foo : int; bar : string; }
  val ( &gt;= ) : t -&gt; t -&gt; bool
  val ( &lt;= ) : t -&gt; t -&gt; bool
  val ( = ) : t -&gt; t -&gt; bool

  ...

end
</computeroutput></programlisting>

      <para>That said, for reasons we discussed earlier, polymorphic compare
      should be used sparingly.</para>
      <sidebar>
        <title>=, ==, and phys_equal</title>
        
        <para>If you come from a C/C++ background, you'll probably reflexively
          use <literal moreinfo="none">==</literal> to test two values for
          equality. In OCaml, the <literal moreinfo="none">==</literal> operator
          tests for <emphasis>physical</emphasis> equality, while the <literal moreinfo="none">=</literal> operator tests for
          <emphasis>structural</emphasis> equality.</para>
        
        <para>The physical equality test will match if two data structures have
          precisely the same pointer in memory. Two data structures that have
          identical contents but are constructed separately will not match using
          <literal moreinfo="none">==</literal>.</para>
        
        <para>The <literal moreinfo="none">=</literal> structural equality
          operator recursively inspects each field in the two values and tests
          them individually for equality. Crucially, if your data structure is
          cyclical (that is, a value recursively points back to another field
          within the same structure), the <literal moreinfo="none">=</literal>
          operator will never terminate, and your program will hang! You therefore
          must use the physical equality operator or write a custom comparison
          function when comparing cyclic values.</para>
        
        <para>It's quite easy to mix up the use of <literal moreinfo="none">=</literal> and <literal moreinfo="none">==</literal>,
          so Core disables the <literal moreinfo="none">==</literal> operator and
          provides the more explicit <literal moreinfo="none">phys_equal</literal>
          function instead. You'll see a type error if you use <literal moreinfo="none">==</literal> anywhere in code that opens <literal moreinfo="none">Core.Std</literal>:</para>
        
        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/maps-and-hash-tables/core_phys_equal.topscript">OCaml utop</ulink></para>
        
        <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">open Core.Std ;;</userinput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">1 == 2 ;;</userinput>
<computeroutput moreinfo="none">Characters -1-1:</computeroutput>
<computeroutput moreinfo="none">Error: This expression has type int but an expression was expected of type</computeroutput>
<computeroutput moreinfo="none">         [ `Consider_using_phys_equal ]</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">phys_equal 1 2 ;;</userinput>
<computeroutput moreinfo="none">- : bool = false</computeroutput></programlisting>
        
        <para>If you feel like hanging your OCaml interpreter, you can verify
          what happens with recursive values and structural equality for
          yourself:</para>
        
        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/maps-and-hash-tables/phys_equal.rawscript">OCaml utop</ulink></para>
        
        <programlisting format="linespecific" language="ocaml"><userinput moreinfo="none"># type t1 = { foo1:int; bar1:t2 } and t2 = { foo2:int; bar2:t1 } ;;</userinput>
<computeroutput moreinfo="none">type t1 = { foo1 : int; bar1 : t2; }
and t2 = { foo2 : int; bar2 : t1; }</computeroutput>
<userinput moreinfo="none"># let rec v1 = { foo1=1; bar1=v2 } and v2 = { foo2=2; bar2=v1 } ;;</userinput>
<computeroutput moreinfo="none">&lt;lots of text&gt;</computeroutput>
<userinput moreinfo="none"># v1 == v1;;</userinput>
<computeroutput moreinfo="none">- : bool = true</computeroutput>
<userinput moreinfo="none"># phys_equal v1 v1;;</userinput>
<computeroutput moreinfo="none">- : bool = true</computeroutput>
<userinput moreinfo="none"># v1 = v1 ;;</userinput>
<computeroutput moreinfo="none">&lt;press ^Z and kill the process now&gt;</computeroutput></programlisting>
      </sidebar>
    </sect2>
    
  </sect1>

  <sect1 id="hash-tables">
    <title>Hash Tables</title>

    <para>Hash tables are the imperative cousin of maps. We walked over a
    basic hash table implementation in <xref linkend="imperative-programming-1"/>, so in this section we'll mostly
    discuss the pragmatics of Core's <literal moreinfo="none">Hashtbl</literal> module. We'll cover this material more
    briefly than we did with maps because many of the concepts are
    shared.<indexterm class="singular">
        <primary>hash tables</primary>

        <secondary>basics of</secondary>
      </indexterm></para>

    <para>Hash tables differ from maps in a few key ways. First, hash tables
    are mutable, meaning that adding a key/value pair to a hash table modifies
    the table, rather than creating a new table with the binding added.
    Second, hash tables generally have better time-complexity than maps,
    providing constant-time lookup and modifications, as opposed to
    logarithmic for maps. And finally, just as maps depend on having a
    comparison function for creating the ordered binary tree that underlies a
    map, hash tables depend on having a <emphasis>hash function</emphasis>,
    i.e., a function for converting a key to an integer.<indexterm class="singular">
        <primary>functions</primary>

        <secondary>hash functions</secondary>
      </indexterm><indexterm class="singular">
        <primary>Hashtbl module</primary>
      </indexterm><indexterm class="singular">
        <primary>hash tables</primary>

        <secondary>time complexity of</secondary>
      </indexterm></para>

    <warning role="allow_break">
      <title>Time Complexity of Hash Tables</title>

      <para>The statement that hash tables provide constant-time access hides some complexities.
        First of all, any hash table implementation, OCaml's included, needs to resize the table
        when it gets too full. A resize requires allocating a new backing array for the hash table
        and copying over all entries, and so it is quite an expensive operation. That means adding a
        new element to the table is only <emphasis>amortized</emphasis> constant, which is to say,
        it's constant on average over a long sequence of operations, but some of the individual
        operations can be quite expensive.</para>

      <para>Another hidden cost of hash tables has to do with the hash function you use. If you end
        up with a pathologically bad hash function that hashes all of your data to the same number,
        then all of your insertions will hash to the same underlying bucket, meaning you no longer
        get constant-time access at all. Core's hash table implementation uses binary trees for the
        hash-buckets, so this case only leads to logarithmic time, rather than linear for a
        traditional hash table.</para>

      <para>The logarithmic behavior of Core's hash tables in the presence of hash collisions also
        helps protect against some denial-of-service attacks. One well-known type of attack is to
        send queries to a service with carefully chosen keys to cause many collisions. This, in
        combination with the linear behavior of most hashtables, can cause the service to become
        unresponsive due to high CPU load. Core's hash tables would be much less susceptible to such
        an attack because the amount of degradation would be far less.<indexterm class="singular">
          <primary>security issues</primary>
          <secondary>denial-of-service attacks</secondary>
        </indexterm><indexterm class="singular">
          <primary>denial-of-service attacks, avoiding</primary>
        </indexterm></para>
    </warning>

    <para>When creating a hash table, we need to provide a value of type
    <emphasis>hashable</emphasis>, which includes among other things the
    function for hashing the key type. This is analogous to the comparator
    used for creating maps:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/maps-and-hash-tables/main.topscript">OCaml utop</ulink>
    (part 25)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let table = Hashtbl.create ~hashable:String.hashable ();;</userinput>
<computeroutput moreinfo="none">val table : (string, '_a) Hashtbl.t = &lt;abstr&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Hashtbl.replace table ~key:"three" ~data:3;;</userinput>
<computeroutput moreinfo="none">- : unit = ()</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Hashtbl.find table "three";;</userinput>
<computeroutput moreinfo="none">- : int option = Some 3</computeroutput></programlisting>

    <para>The <literal moreinfo="none">hashable</literal> value is included as
    part of the <literal moreinfo="none">Hashable.S</literal> interface, which
    is satisfied by most types in Core. The <literal moreinfo="none">Hashable.S</literal> interface also includes a <literal moreinfo="none">Table</literal> submodule which provides more convenient
    creation functions:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/maps-and-hash-tables/main.topscript">OCaml utop</ulink>
    (part 26)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let table = String.Table.create ();;</userinput>
<computeroutput moreinfo="none">val table : '_a String.Table.t = &lt;abstr&gt;</computeroutput></programlisting>

    <para>There is also a polymorphic <literal moreinfo="none">hashable</literal> value, corresponding to the polymorphic
    hash function provided by the OCaml runtime, for cases where you don't
    have a hash function for your specific type:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/maps-and-hash-tables/main.topscript">OCaml utop</ulink>
    (part 27)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let table = Hashtbl.create ~hashable:Hashtbl.Poly.hashable ();;</userinput>
<computeroutput moreinfo="none">val table : ('_a, '_b) Hashtbl.t = &lt;abstr&gt;</computeroutput></programlisting>

    <para>Or, equivalently:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/maps-and-hash-tables/main.topscript">OCaml utop</ulink>
    (part 28)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let table = Hashtbl.Poly.create ();;</userinput>
<computeroutput moreinfo="none">val table : ('_a, '_b) Hashtbl.t = &lt;abstr&gt;</computeroutput></programlisting>

    <para>Note that, unlike the comparators used with maps and sets, hashables
    don't show up in the type of a <literal moreinfo="none">Hashtbl.t</literal>. That's because hash tables don't have
    operations that operate on multiple hash tables that depend on those
    tables having the same hash function, in the way that <literal moreinfo="none">Map.symmetric_diff</literal> and <literal moreinfo="none">Set.union</literal> depend on their arguments using the
    same comparison function.<indexterm class="singular">
        <primary>polymorphism</primary>

        <secondary sortas="hash functions">in hash functions</secondary>
      </indexterm></para>

    <warning>
      <title>Collisions with the Polymorphic Hash Function</title>

      <para>OCaml's polymorphic hash function works by walking over the data
      structure it’s given using a breadth-first traversal that is bounded in
      the number of nodes it’s willing to traverse. By default, that bound is
      set at 10 "meaningful" nodes.<indexterm class="singular">
          <primary>hash tables</primary>

          <secondary>polymorphic hash function</secondary>
        </indexterm></para>

      <para>The bound on the traversal means that the hash function may ignore part of the data
        structure, and this can lead to pathological <phrase role="keep-together">cases</phrase>
        where every value you store has the same hash value. We'll demonstrate this below, using the
        function <literal moreinfo="none">List.range</literal> to allocate lists of integers of
        different length:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/maps-and-hash-tables/main.topscript">OCaml utop</ulink>
      (part 29)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">Caml.Hashtbl.hash (List.range 0 9);;</userinput>
<computeroutput moreinfo="none">- : int = 209331808</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Caml.Hashtbl.hash (List.range 0 10);;</userinput>
<computeroutput moreinfo="none">- : int = 182325193</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Caml.Hashtbl.hash (List.range 0 11);;</userinput>
<computeroutput moreinfo="none">- : int = 182325193</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Caml.Hashtbl.hash (List.range 0 100);;</userinput>
<computeroutput moreinfo="none">- : int = 182325193</computeroutput></programlisting>

      <para>As you can see, the hash function stops after the first 10
      elements. The same can happen with any large data structure, including
      records and arrays. When building hash functions over large custom data
      structures, it is generally a good idea to write one's own hash
      function.</para>
    </warning>

    <sect2 id="satisfying-the-hashable.s-interface">
      <title>Satisfying the Hashable.S Interface</title>

      <para>Most types in Core satisfy the <literal moreinfo="none">Hashable.S</literal> interface, but as with the <literal moreinfo="none">Comparable.S</literal> interface, the question remains
      of how one should satisfy this interface when writing a new module.
      Again, the answer is to use a functor to build the necessary
      functionality; in this case, <literal moreinfo="none">Hashable.Make</literal>. Note that we use OCaml's
      <literal moreinfo="none">lxor</literal> operator for doing the "logical"
      (i.e., bitwise) exclusive Or of the hashes from the component
      values:<indexterm class="singular">
          <primary>Hashable.Make</primary>
        </indexterm><indexterm class="singular">
          <primary>interfaces</primary>

          <secondary>Hashable.S</secondary>
        </indexterm><indexterm class="singular">
          <primary>Hashable.S interface</primary>
        </indexterm><indexterm class="singular">
          <primary>hash tables</primary>

          <secondary>satisfying Hashable.S interface</secondary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/maps-and-hash-tables/main-30.rawscript">OCaml utop</ulink></para>

      <programlisting format="linespecific" language="ocaml"><userinput moreinfo="none"># module Foo_and_bar : sig
    type t = { foo: int; bar: string }
    include Hashable.S with type t := t
  end = struct
    module T = struct
      type t = { foo: int; bar: string } with sexp, compare
      let hash t =
        (Int.hash t.foo) lxor (String.hash t.bar)
    end
    include T
    include Hashable.Make(T)
  end;;</userinput>
<computeroutput moreinfo="none">module Foo_and_bar :
sig
  type t = { foo : int; bar : string; }
  module Hashable : sig type t = t end
  val hash : t -&gt; int
  val compare : t -&gt; t -&gt; int
  val hashable : t Pooled_hashtbl.Hashable.t

  ...

end</computeroutput></programlisting>

      <para>Note that in order to satisfy hashable, one also needs to provide
      a comparison function. That's because Core's hash tables use an ordered
      binary tree data structure for the hash-buckets, so that performance of
      the table degrades gracefully in the case of pathologically bad choice
      of hash function.</para>

      <para>There is currently no analogue of <literal moreinfo="none">comparelib</literal> for autogeneration of hash
      functions, so you do need to either write the hash function by hand, or
      use the built-in polymorphic hash function, <literal moreinfo="none">Hashtbl.hash</literal>.</para>
    </sect2>
  </sect1>

  <sect1 id="choosing-between-maps-and-hash-tables">
    <title>Choosing Between Maps and Hash Tables</title>

    <para>Maps and hash tables overlap enough in functionality that it's not
    always clear when to choose one or the other. Maps, by virtue of being
    immutable, are generally the default choice in OCaml. OCaml also has good
    support for imperative programming, though, and when programming in an
    imperative idiom, hash tables are often the more natural choice.<indexterm class="singular">
        <primary>maps</primary>

        <secondary sortas="hashtables">vs. hashtables</secondary>
      </indexterm><indexterm class="singular">
        <primary>hash tables</primary>

        <secondary sortas="maps">vs. maps</secondary>
      </indexterm></para>

    <para>Programming idioms aside, there are significant performance differences between maps and
      hash tables. For code that is dominated by updates and lookups, hash tables are a clear
      performance win, and the win is clearer the larger the amount of data.</para>

    <para>The best way of answering a performance question is by running a
    benchmark, so let's do just that. The following benchmark uses the
    <literal moreinfo="none">core_bench</literal> library, and it compares
    maps and hash tables under a very simple workload. Here, we're keeping
    track of a set of 1,000 different integer keys and cycling over the keys
    and updating the values they contain. Note that we use the <literal moreinfo="none">Map.change</literal> and <literal moreinfo="none">Hashtbl.change</literal> functions to update the
    respective data structures:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/maps-and-hash-tables/map_vs_hash.ml">OCaml</ulink></para>

    <programlisting format="linespecific" language="ocaml">open Core.Std
open Core_bench.Std

let map_iter ~num_keys ~iterations =
  let rec loop i map =
    if i &lt;= 0 then ()
    else loop (i - 1)
           (Map.change map (i mod num_keys) (fun current -&gt;
              Some (1 + Option.value ~default:0 current)))
  in
  loop iterations Int.Map.empty

let table_iter ~num_keys ~iterations =
  let table = Int.Table.create ~size:num_keys () in
  let rec loop i =
    if i &lt;= 0 then ()
    else (
      Hashtbl.change table (i mod num_keys) (fun current -&gt;
        Some (1 + Option.value ~default:0 current));
      loop (i - 1)
    )
  in
  loop iterations

let tests ~num_keys ~iterations =
  let test name f = Bench.Test.create f ~name in
  [ test "map"   (fun () -&gt; map_iter   ~num_keys ~iterations)
  ; test "table" (fun () -&gt; table_iter ~num_keys ~iterations)
  ]

let () =
  tests ~num_keys:1000 ~iterations:100_000
  |&gt; Bench.make_command
  |&gt; Command.run</programlisting>

    <para>The results show the hash table version to be around four times
    faster than the map version:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/maps-and-hash-tables/run_map_vs_hash.out">Terminal</ulink></para>

    <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">corebuild -pkg core_bench map_vs_hash.native</userinput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">./map_vs_hash.native -ascii -clear-columns name time speedup</userinput>
<computeroutput moreinfo="none">Estimated testing time 20s (change using -quota SECS).</computeroutput>
<computeroutput moreinfo="none">                                </computeroutput>
<computeroutput moreinfo="none">  Name     Time (ns)   Speedup  </computeroutput>
<computeroutput moreinfo="none"> ------- ------------ --------- </computeroutput>
<computeroutput moreinfo="none">  map     31_698_313      1.00  </computeroutput>
<computeroutput moreinfo="none">  table    7_202_631      4.40  </computeroutput>
<computeroutput moreinfo="none">                                </computeroutput></programlisting>

    <para>We can make the speedup smaller or larger depending on the details
    of the test; for example, it will vary with the number of distinct keys.
    But overall, for code that is heavy on sequences of querying and updating
    a set of key/value pairs, hash tables will significantly outperform
    maps.</para>

    <para>Hash tables are not always the faster choice, though. In particular,
    maps are often more performant in situations where you need to keep
    multiple related versions of the data structure in memory at once. That's
    because maps are immutable, and so operations like <literal moreinfo="none">Map.add</literal> that modify a map do so by creating a
    new map, leaving the original undisturbed. Moreover, the new and old maps
    share most of their physical structure, so multiple versions can be kept
    around efficiently.</para>

    <para>Here's a benchmark that demonstrates this. In it, we create a list
    of maps (or hash tables) that are built up by iteratively applying small
    updates, keeping these copies around. In the map case, this is done by
    using <literal moreinfo="none">Map.change</literal> to update the map. In
    the hash table implementation, the updates are done using <literal moreinfo="none">Hashtbl.change</literal>, but we also need to call
    <literal moreinfo="none">Hashtbl.copy</literal> to take snapshots of the
    table:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/maps-and-hash-tables/map_vs_hash2.ml">OCaml</ulink></para>

    <programlisting format="linespecific" language="ocaml">open Core.Std
open Core_bench.Std

let create_maps ~num_keys ~iterations =
  let rec loop i map =
    if i &lt;= 0 then []
    else
      let new_map =
        Map.change map (i mod num_keys) (fun current -&gt;
          Some (1 + Option.value ~default:0 current))
      in
      new_map :: loop (i - 1) new_map
  in
  loop iterations Int.Map.empty

let create_tables ~num_keys ~iterations =
  let table = Int.Table.create ~size:num_keys () in
  let rec loop i =
    if i &lt;= 0 then []
    else (
      Hashtbl.change table (i mod num_keys) (fun current -&gt;
        Some (1 + Option.value ~default:0 current));
      let new_table = Hashtbl.copy table in
      new_table :: loop (i - 1)
    )
  in
  loop iterations

let tests ~num_keys ~iterations =
  let test name f = Bench.Test.create f ~name in
  [ test "map"   (fun () -&gt; ignore (create_maps   ~num_keys ~iterations))
  ; test "table" (fun () -&gt; ignore (create_tables ~num_keys ~iterations))
  ]

let () =
  tests ~num_keys:50 ~iterations:1000
  |&gt; Bench.make_command
  |&gt; Command.run</programlisting>

    <para>Unsurprisingly, maps perform far better than hash tables on this
    benchmark, in this case by more than a factor of 10:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/maps-and-hash-tables/run_map_vs_hash2.out">Terminal</ulink></para>

    <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">corebuild -pkg core_bench map_vs_hash2.native</userinput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">./map_vs_hash2.native -ascii -clear-columns name time speedup</userinput>
<computeroutput moreinfo="none">Estimated testing time 20s (change using -quota SECS).</computeroutput>
<computeroutput moreinfo="none">                               </computeroutput>
<computeroutput moreinfo="none">  Name    Time (ns)   Speedup  </computeroutput>
<computeroutput moreinfo="none"> ------- ----------- --------- </computeroutput>
<computeroutput moreinfo="none">  map       218_581     12.03  </computeroutput>
<computeroutput moreinfo="none">  table   2_628_423      1.00  </computeroutput>
<computeroutput moreinfo="none">                               </computeroutput></programlisting>

    <para>These numbers can be made more extreme by increasing the size of the
    tables or the length of the list.</para>

    <para>As you can see, the relative performance of trees and maps depends a
    great deal on the details of how they're used, and so whether to choose
    one data structure or the other will depend on the details of the
    application.<indexterm class="singular">
        <primary>phys_equal function</primary>
      </indexterm><indexterm class="singular">
        <primary>equal equal (= =) operator</primary>
      </indexterm><indexterm class="singular">
        <primary>equal (=) operator</primary>
      </indexterm><indexterm class="singular">
        <primary>structural equality</primary>
      </indexterm><indexterm class="singular">
        <primary>physical equality</primary>
      </indexterm><indexterm class="singular">
        <primary>equality, tests of</primary>
      </indexterm></para>
  </sect1>
</chapter>

    <chapter id="command-line-parsing">
  <title>Command-Line Parsing</title>

  <para>Many of the OCaml programs that you'll write will end up as binaries
  that need to be run from a command prompt. Any nontrivial command line
  should support a collection of basic features:</para>

  <itemizedlist>
    <listitem>
      <para>Parsing of command-line arguments</para>
    </listitem>

    <listitem>
      <para>Generation of error messages in response to incorrect
      inputs</para>
    </listitem>

    <listitem>
      <para>Help for all the available options</para>
    </listitem>

    <listitem>
      <para>Interactive autocompletion</para>
    </listitem>
  </itemizedlist>

  <para>It's tedious and error-prone to code all of this manually for every
  program you write. Core provides the Command library, which simplifies all
  of this by letting you declare all your command-line options in one place
  and by deriving all of the above functionality from these
  declarations.<indexterm class="singular">
      <primary>command-line parsing</primary>

      <secondary>Command library for</secondary>
    </indexterm></para>

  <para>Command is simple to use for simple applications but also scales well
  as your needs grow more complex. In particular, Command provides a
  sophisticated subcommand mode that groups related commands together as the
  complexity of your user interface grows. You may already be familiar with
  this command-line style from the Git or Mercurial version control
  systems.</para>

  <para>In this chapter, we'll:</para>

  <itemizedlist>
    <listitem>
      <para>Learn how to use Command to construct basic and grouped
      command-line interfaces</para>
    </listitem>

    <listitem>
      <para>We will build simple equivalents to the cryptographic <literal moreinfo="none">md5</literal> and <literal moreinfo="none">shasum</literal> utilities</para>
    </listitem>

    <listitem>
      <para>Demonstrate how <emphasis>functional combinators</emphasis> can be
      used to declare complex command-line interfaces in a type-safe and
      elegant way<indexterm class="singular">
        <primary>combinators</primary>
        
        <secondary>functional combinators</secondary>
      </indexterm></para>
    </listitem>
  </itemizedlist>

  <sect1 id="basic-command-line-parsing">
    <title>Basic Command-Line Parsing</title>

    <para>Let's start by working through a clone of the <emphasis>md5sum</emphasis> command that is
      present on most Linux installations (the equivalent command on Mac OS X is simply <literal moreinfo="none">md5</literal>). The following function defined below reads in the contents
      of a file, applies the MD5 one-way cryptographic hash function to the data, and outputs an
      ASCII hex representation of the result:<indexterm class="singular">
        <primary>MD5 one-way cryptographic hash function</primary>
      </indexterm><indexterm class="singular">
        <primary>command-line parsing</primary>
        <secondary>basic approach to</secondary>
      </indexterm></para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/command-line-parsing/basic_md5.ml">OCaml</ulink></para>

    <programlisting format="linespecific" language="ocaml">open Core.Std

let do_hash file =
  In_channel.with_file file ~f:(fun ic -&gt;
    let open Cryptokit in
    hash_channel (Hash.md5 ()) ic
    |&gt; transform_string (Hexa.encode ())
    |&gt; print_endline
  )</programlisting>

    <para>The <literal moreinfo="none">do_hash</literal> function accepts a
    <literal moreinfo="none">filename</literal> parameter and prints the
    human-readable MD5 string to the console standard output. The first step
    toward turning this function into a command-line program is to declare all
    the possible command-line arguments in a
    <emphasis>specification</emphasis>. <literal moreinfo="none">Command.Spec</literal> defines combinators that can be
    chained together to define optional flags and positional arguments, what
    types they should map to, and whether to take special actions (such as
    pausing for interactive input) if certain inputs are encountered.</para>

    <sect2 id="anonymous-arguments">
      <title>Anonymous Arguments</title>

      <para>Let's build the specification for a single argument that is passed
      directly on the command line. This is known as an
      <emphasis>anonymous</emphasis> argument:<indexterm class="singular">
          <primary>arguments</primary>

          <secondary>anonymous arguments</secondary>
        </indexterm><indexterm class="singular">
          <primary>anonymous arguments</primary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/command-line-parsing/basic_md5.ml">OCaml</ulink>
      (part 1)</para>

      <programlisting format="linespecific" language="ocaml">let spec =
  let open Command.Spec in
  empty
  +&gt; anon ("filename" %: string)</programlisting>

      <para>The <literal moreinfo="none">Command.Spec</literal> module defines
      the tools you'll need to build up a command-line specification. We start
      with the <literal moreinfo="none">empty</literal> value and add
      parameters to that using the <literal moreinfo="none">+&gt;</literal>
      combinator. (Both of these values come from <literal moreinfo="none">Command.Spec</literal>.)</para>

      <para>In this case, we defined a single anonymous argument called
      <literal moreinfo="none">filename</literal>, which takes a value of type
      <literal moreinfo="none">string</literal>. Anonymous parameters are
      created using the <literal moreinfo="none">%:</literal> operator, which
      binds a textual name (used in the help text to identify the parameter)
      to an OCaml conversion function that parses the command-line string
      fragments into a higher-level OCaml data type. In the preceding example,
      this is just <literal moreinfo="none">Command.Spec.string</literal>, but
      we'll see more complex conversion options later in the chapter.</para>
    </sect2>

    <sect2 id="defining-basic-commands">
      <title>Defining Basic Commands</title>

      <para>Once we've defined a specification, we need to put it to work on
      real input. The simplest way is to directly create a command-line
      interface via the <literal moreinfo="none">Command.basic</literal>
      module:<indexterm class="singular">
          <primary>Command.basic module</primary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/command-line-parsing/basic_md5.ml">OCaml</ulink>
      (part 2)</para>

      <programlisting format="linespecific" language="ocaml">let command =
  Command.basic
    ~summary:"Generate an MD5 hash of the input data"
    ~readme:(fun () -&gt; "More detailed information")
    spec
    (fun filename () -&gt; do_hash filename)</programlisting>

      <para><literal moreinfo="none">Command.basic</literal> defines a
      complete command-line interface that takes the following extra
      arguments, in addition to the ones defined in the specification:</para>

      <variablelist>
        <varlistentry>
          <term><literal moreinfo="none">summary</literal></term>

          <listitem>
            <para>A required one-line description to go at the top of the
            command help screen.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal moreinfo="none">readme</literal></term>

          <listitem>
            <para>For longer help text when the command is called with
            <literal moreinfo="none">-help</literal>. The <literal moreinfo="none">readme</literal> argument is a function that is
            only evaluated when the help text is actually needed.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>The specification and the callback function follow as nonlabeled
      arguments.</para>

      <para>The callback function is where all the work happens after the
      command-line parsing is complete. This function is applied with the
      arguments containing the parsed command-line values, and it takes over
      as the main thread of the application. The callback's arguments are
      passed in the same order as they were bound in the specification (using
      the <literal moreinfo="none">+&gt;</literal> operator).<indexterm class="singular">
          <primary>arguments</primary>

          <secondary>unit argument to callbacks</secondary>
        </indexterm><indexterm class="singular">
          <primary>unit argument</primary>
        </indexterm><indexterm class="singular">
          <primary>callback function</primary>
        </indexterm></para>

      <note>
        <title>The Extra unit Argument to Callbacks</title>

        <para>The preceding callback needs an extra <literal moreinfo="none">unit</literal> argument after <literal moreinfo="none">filename</literal>. This is to ensure that
        specifications can work even when they are empty (i.e. the <literal moreinfo="none">Command.Spec.empty</literal> value).</para>

        <para>Every OCaml function needs at least one argument, so the final
        <literal moreinfo="none">unit</literal> guarantees that it will not be
        evaluated immediately as a value if there are no other
        arguments.</para>
      </note>
    </sect2>

    <sect2 id="running-basic-commands">
      <title>Running Basic Commands</title>

      <para>Once we've defined the basic command, running it is just one
      function call away:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/command-line-parsing/basic_md5.ml">OCaml</ulink>
      (part 3)</para>

      <programlisting format="linespecific" language="ocaml">let () =
  Command.run ~version:"1.0" ~build_info:"RWO" command</programlisting>

      <para><literal moreinfo="none">Command.run</literal> takes a couple of
      optional arguments that are useful to identify which version of the
      binary you are running in production. You'll need to install Cryptokit
      via <literal moreinfo="none">opam install cryptokit</literal> before
      building this example. Once that's completed, run the following to
      compile the binary:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/command-line-parsing/build_basic_md5.out">Terminal</ulink></para>

      <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">corebuild -pkg cryptokit basic_md5.native</userinput>
</programlisting>

      <para>You can now query the version information for the binary you just
      compiled:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/command-line-parsing/get_basic_md5_version.out">Terminal</ulink></para>

      <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">./basic_md5.native -version</userinput>
<computeroutput moreinfo="none">1.0</computeroutput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">./basic_md5.native -build-info</userinput>
<computeroutput moreinfo="none">RWO</computeroutput></programlisting>

      <para>The versions that you see in the output were defined via the
      optional arguments to <literal moreinfo="none">Command.run</literal>.
      You can leave these blank in your own programs or get your build system
      to generate them directly from your version control system (e.g., by
      running <literal moreinfo="none">hg id</literal> to generate a build
      revision number, in the case of Mercurial):</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/command-line-parsing/get_basic_md5_help.out">Terminal</ulink></para>

      <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">./basic_md5.native</userinput>
<computeroutput moreinfo="none">Generate an MD5 hash of the input data</computeroutput>
<computeroutput moreinfo="none"> </computeroutput>
<computeroutput moreinfo="none">  basic_md5.native FILENAME</computeroutput>
<computeroutput moreinfo="none"> </computeroutput>
<computeroutput moreinfo="none">More detailed information</computeroutput>
<computeroutput moreinfo="none"> </computeroutput>
<computeroutput moreinfo="none">=== flags ===</computeroutput>
<computeroutput moreinfo="none"> </computeroutput>
<computeroutput moreinfo="none">  [-build-info]  print info about this build and exit</computeroutput>
<computeroutput moreinfo="none">  [-version]     print the version of this build and exit</computeroutput>
<computeroutput moreinfo="none">  [-help]        print this help text and exit</computeroutput>
<computeroutput moreinfo="none">                 (alias: -?)</computeroutput>
<computeroutput moreinfo="none"> </computeroutput>
<computeroutput moreinfo="none">missing anonymous argument: FILENAME</computeroutput></programlisting>

      <para>When we invoke this binary without any arguments, it helpfully
      displays all of the command-line options available, along with a message
      to the standard error that informs you that a required argument <literal moreinfo="none">filename</literal> is missing.</para>

      <para>If you do supply the <literal moreinfo="none">filename</literal>
      argument, then <literal moreinfo="none">do_hash</literal> is called with
      the argument and the MD5 output is displayed to the standard
      output:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/command-line-parsing/run_basic_md5.out">Terminal</ulink></para>

      <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">./basic_md5.native ./basic_md5.native</userinput>
<computeroutput moreinfo="none">b5ee7de449a2e0c6c01d4f2d898926de</computeroutput></programlisting>

      <para>And that's all it took to build our little MD5 utility! Here's a
      complete version of the example we just walked through, made slightly
      more succinct by removing intermediate variables:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/command-line-parsing/basic_md5_succinct.ml">OCaml</ulink></para>

      <programlisting format="linespecific" language="ocaml">open Core.Std

let do_hash file () =
  In_channel.with_file file ~f:(fun ic -&gt;
    let open Cryptokit in
    hash_channel (Hash.md5 ()) ic
    |&gt; transform_string (Hexa.encode ())
    |&gt; print_endline
  )

let command =
  Command.basic
    ~summary:"Generate an MD5 hash of the input data"
    ~readme:(fun () -&gt; "More detailed information")
    Command.Spec.(empty +&gt; anon ("filename" %: string))
    do_hash

let () =
  Command.run ~version:"1.0" ~build_info:"RWO" command</programlisting>

      <para>Now that we have the basics in place, the rest of the chapter will
      examine some of the more advanced features of Command.</para>
    </sect2>
  </sect1>

  <sect1 id="argument-types">
    <title>Argument Types</title>

    <para>You aren't just limited to parsing command lines as strings, of
    course. <literal moreinfo="none">Command.Spec</literal> defines several
    other conversion functions (shown in <xref linkend="table14_1"/>) that
    validate and parse input into various types.<indexterm class="singular">
        <primary>arguments</primary>

        <secondary>argument types</secondary>
      </indexterm><indexterm class="singular">
        <primary>command-line parsing</primary>

        <secondary>argument types</secondary>
      </indexterm></para>

    <table id="table14_1">
      <title>Conversion functions defined by
      <literal>Command.spec</literal></title>

      <tgroup cols="3">
        <colspec align="left"/>

        <colspec align="left"/>

        <colspec align="left"/>

        <thead>
          <row>
            <entry>Argument type</entry>

            <entry>OCaml type</entry>

            <entry>Example</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry><literal moreinfo="none">string</literal></entry>

            <entry><literal moreinfo="none">string</literal></entry>

            <entry><literal moreinfo="none">foo</literal></entry>
          </row>

          <row>
            <entry><literal moreinfo="none">int</literal></entry>

            <entry><literal moreinfo="none">int</literal></entry>

            <entry><literal moreinfo="none">123</literal></entry>
          </row>

          <row>
            <entry><literal moreinfo="none">float</literal></entry>

            <entry><literal moreinfo="none">float</literal></entry>

            <entry><literal moreinfo="none">123.01</literal></entry>
          </row>

          <row>
            <entry><literal moreinfo="none">bool</literal></entry>

            <entry><literal moreinfo="none">bool</literal></entry>

            <entry><literal moreinfo="none">true</literal></entry>
          </row>

          <row>
            <entry><literal moreinfo="none">date</literal></entry>

            <entry><literal moreinfo="none">Date.t</literal></entry>

            <entry><literal moreinfo="none">2013-12-25</literal></entry>
          </row>

          <row>
            <entry><literal moreinfo="none">time_span</literal></entry>

            <entry><literal moreinfo="none">Span.t</literal></entry>

            <entry><literal moreinfo="none">5s</literal></entry>
          </row>

          <row>
            <entry><literal moreinfo="none">file</literal></entry>

            <entry><literal moreinfo="none">string</literal></entry>

            <entry><literal moreinfo="none">/etc/passwd</literal></entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <para>We can tighten up the specification of the command to <literal moreinfo="none">file</literal> to reflect that the argument must be a
    valid filename, and not just any string:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/command-line-parsing/basic_md5_as_filename.ml">OCaml</ulink>
    (part 1)</para>

    <programlisting format="linespecific" language="ocaml">let command =
  Command.basic
    ~summary:"Generate an MD5 hash of the input data"
    ~readme:(fun () -&gt; "More detailed information")
    Command.Spec.(empty +&gt; anon ("filename" %: file))
    do_hash

let () =
  Command.run ~version:"1.0" ~build_info:"RWO" command</programlisting>

    <para>Running this with a nonexistent filename will now output an error if
    the file doesn't exist. As a bonus, it also enables interactive
    command-line completion to work on the filename argument (explained later
    in the chapter):</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/command-line-parsing/run_basic_md5_as_filename.out">Terminal</ulink></para>

    <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">./basic_md5_as_filename.native nonexistent</userinput>
<computeroutput moreinfo="none">Uncaught exception:</computeroutput>
<computeroutput moreinfo="none">  </computeroutput>
<computeroutput moreinfo="none">  (Sys_error "nonexistent: No such file or directory")</computeroutput>
<computeroutput moreinfo="none"> </computeroutput>
<computeroutput moreinfo="none">Raised by primitive operation at file "pervasives.ml", line 292, characters 20-46</computeroutput>
<computeroutput moreinfo="none">Called from file "lib/in_channel.ml", line 19, characters 46-65</computeroutput>
<computeroutput moreinfo="none">Called from file "lib/exn.ml", line 87, characters 6-10</computeroutput></programlisting>

    <sect2 id="defining-custom-argument-types">
      <title>Defining Custom Argument Types</title>

      <para>We can also define our own argument types if the predefined ones
      aren't sufficient. For instance, let's make a <literal moreinfo="none">regular_file</literal> argument type that ensures that
      the input file isn't a character device or some other odd UNIX file type
      that can't be fully read:<indexterm class="singular">
          <primary>arguments</primary>

          <secondary>defining custom types</secondary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/command-line-parsing/basic_md5_with_custom_arg.ml">OCaml</ulink></para>

      <programlisting format="linespecific" language="ocaml">open Core.Std

let do_hash file () =
  In_channel.with_file file ~f:(fun ic -&gt;
    let open Cryptokit in
    hash_channel (Hash.md5 ()) ic
    |&gt; transform_string (Hexa.encode ())
    |&gt; print_endline
  )

let regular_file =
  Command.Spec.Arg_type.create
    (fun filename -&gt;
       match Sys.is_file filename with
       | `Yes -&gt; filename
       | `No | `Unknown -&gt;
         eprintf "'%s' is not a regular file.\n%!" filename;
         exit 1
    )

let command =
  Command.basic
    ~summary:"Generate an MD5 hash of the input data"
    ~readme:(fun () -&gt; "More detailed information")
    Command.Spec.(empty +&gt; anon ("filename" %: regular_file))
    do_hash

let () =
  Command.run ~version:"1.0" ~build_info:"RWO" command</programlisting>

      <para>The <literal moreinfo="none">regular_file</literal> function
      transforms a <literal moreinfo="none">filename</literal> string
      parameter into the same string but first checks that the file exists and
      is a regular file type. When you build and run this code, you will see
      the new error messages if you try to open a special device such as
      <literal moreinfo="none">/dev/null</literal>:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/command-line-parsing/run_basic_md5_with_custom_arg.out">Terminal</ulink></para>

      <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">./basic_md5_with_custom_arg.native /etc/passwd</userinput>
<computeroutput moreinfo="none">8cfb68a5622dd12932df658a54698aad</computeroutput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">./basic_md5_with_custom_arg.native /dev/null</userinput>
<computeroutput moreinfo="none">'/dev/null' is not a regular file.</computeroutput></programlisting>
    </sect2>

    <sect2 id="optional-and-default-arguments">
      <title>Optional and Default Arguments</title>

      <para>A more realistic MD5 binary could also read from the standard
      input if a <literal moreinfo="none">filename</literal> isn't
      specified:<indexterm class="singular">
          <primary>arguments</primary>

          <secondary>default arguments</secondary>
        </indexterm><indexterm class="singular">
          <primary>default arguments</primary>
        </indexterm><indexterm class="singular">
          <primary>optional arguments</primary>

          <secondary sortas="default">and default arguments</secondary>
        </indexterm><indexterm class="singular">
          <primary>arguments</primary>

          <secondary>optional arguments</secondary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/command-line-parsing/basic_md5_with_optional_file_broken.ml">OCaml</ulink>
      (part 1)</para>

      <programlisting format="linespecific" language="ocaml">let command =
  Command.basic
    ~summary:"Generate an MD5 hash of the input data"
    ~readme:(fun () -&gt; "More detailed information")
    Command.Spec.(empty +&gt; anon (maybe ("filename" %: string)))
    do_hash

let () =
  Command.run ~version:"1.0" ~build_info:"RWO" command</programlisting>

      <para>This just wraps the <literal moreinfo="none">filename</literal>
      argument declaration in the <literal moreinfo="none">maybe</literal>
      function to mark it as an optional argument. However, building this
      results in a compile-time error:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/command-line-parsing/build_basic_md5_with_optional_file_broken.out">Terminal</ulink></para>

      <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">corebuild -pkg cryptokit basic_md5_with_optional_file_broken.native</userinput>
<computeroutput moreinfo="none">File "basic_md5_with_optional_file_broken.ml", line 18, characters 4-11:</computeroutput>
<computeroutput moreinfo="none">Error: This expression has type string -&gt; unit -&gt; unit</computeroutput>
<computeroutput moreinfo="none">       but an expression was expected of type string option -&gt; unit -&gt; unit</computeroutput>
<computeroutput moreinfo="none">       Type string is not compatible with type string option </computeroutput>
<computeroutput moreinfo="none">Command exited with code 2.</computeroutput></programlisting>

      <para>This is because changing the argument type has also changed the
      type of the callback function. It now wants a <literal moreinfo="none">string option</literal> instead of a <literal moreinfo="none">string</literal>, since the value has become optional.
      We can adapt our example to use the new information and read from
      standard input if no file is specified:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/command-line-parsing/basic_md5_with_optional_file.ml">OCaml</ulink></para>

      <programlisting format="linespecific" language="ocaml">open Core.Std

let get_inchan = function
  | None | Some "-" -&gt;
    In_channel.stdin
  | Some filename -&gt;
    In_channel.create ~binary:true filename

let do_hash filename () =
  let open Cryptokit in
  get_inchan filename
  |&gt; hash_channel (Hash.md5 ())
  |&gt; transform_string (Hexa.encode ())
  |&gt; print_endline

let command =
  Command.basic
    ~summary:"Generate an MD5 hash of the input data"
    ~readme:(fun () -&gt; "More detailed information")
    Command.Spec.(empty +&gt; anon (maybe ("filename" %: file)))
    do_hash

let () =
  Command.run ~version:"1.0" ~build_info:"RWO" command</programlisting>

      <para>The <literal moreinfo="none">filename</literal> parameter to
      <literal moreinfo="none">do_hash</literal> is now a <literal moreinfo="none">string option</literal> type. This is resolved into an
      input channel via <literal moreinfo="none">get_inchan</literal> to
      determine whether to open the standard input or a file, and then the
      rest of the command is similar to our previous examples.</para>

      <para>Another possible way to handle this would be to supply a dash as
      the default filename if one isn't specified. The <literal moreinfo="none">maybe_with_default</literal> function can do just this,
      with the benefit of not having to change the callback parameter type
      (which may be a problem in more complex applications).</para>

      <para>The following example behaves exactly the same as the previous
      example, but replaces <literal moreinfo="none">maybe</literal> with
      <literal moreinfo="none">maybe_with_default</literal>:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/command-line-parsing/basic_md5_with_default_file.ml">OCaml</ulink></para>

      <programlisting format="linespecific" language="ocaml">open Core.Std

let get_inchan = function
  | "-"      -&gt; In_channel.stdin
  | filename -&gt; In_channel.create ~binary:true filename

let do_hash filename () =
  let open Cryptokit in
  get_inchan filename
  |&gt; hash_channel (Hash.md5 ())
  |&gt; transform_string (Hexa.encode ())
  |&gt; print_endline

let command =
  Command.basic
    ~summary:"Generate an MD5 hash of the input data"
    ~readme:(fun () -&gt; "More detailed information")
    Command.Spec.(
      empty
      +&gt; anon (maybe_with_default "-" ("filename" %: file))
    )
    do_hash

let () =
  Command.run ~version:"1.0" ~build_info:"RWO" command</programlisting>

      <para>Building and running both against a system file confirms that they
      have the same behavior:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/command-line-parsing/run_basic_and_default_md5.out">Terminal</ulink></para>

      <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">cat /etc/passwd | ./basic_md5_with_optional_file.native</userinput>
<computeroutput moreinfo="none">8cfb68a5622dd12932df658a54698aad</computeroutput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">cat /etc/passwd | ./basic_md5_with_default_file.native</userinput>
<computeroutput moreinfo="none">8cfb68a5622dd12932df658a54698aad</computeroutput></programlisting>
    </sect2>

    <sect2 id="sequences-of-arguments">
      <title>Sequences of Arguments</title>

      <para>One last transformation that's useful is to obtain lists of
      anonymous arguments rather than a single one. As an example, let's
      modify our MD5 code to take a collection of files to process on the
      command line:<indexterm class="singular">
          <primary>arguments</primary>

          <secondary>sequences of</secondary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/command-line-parsing/basic_md5_sequence.ml">OCaml</ulink></para>

      <programlisting format="linespecific" language="ocaml">open Core.Std

let do_hash filename ic =
  let open Cryptokit in
  hash_channel (Hash.md5 ()) ic
  |&gt; transform_string (Hexa.encode ())
  |&gt; fun md5 -&gt; printf "MD5 (%s) = %s\n" filename md5

let command =
  Command.basic
    ~summary:"Generate an MD5 hash of the input data"
    ~readme:(fun () -&gt; "More detailed information")
    Command.Spec.(empty +&gt; anon (sequence ("filename" %: file)))
    (fun files () -&gt;
       match files with
       | [] -&gt; do_hash "-" In_channel.stdin
       | _  -&gt;
         List.iter files ~f:(fun file -&gt;
           In_channel.with_file ~f:(do_hash file) file
         )
    )

let () =
  Command.run ~version:"1.0" ~build_info:"RWO" command</programlisting>

      <para>The callback function is a little more complex now, to handle the
      extra options. The <literal moreinfo="none">files</literal> are now a
      <literal moreinfo="none">string list</literal>, and an empty list
      reverts to using standard input, just as our previous <literal moreinfo="none">maybe</literal> and <literal moreinfo="none">maybe_with_default</literal> examples did. If the list
      of files isn't empty, then it opens up each file and runs them through
      <literal moreinfo="none">do_hash</literal> sequentially.</para>
    </sect2>
  </sect1>

  <sect1 id="adding-labeled-flags-to-the-command-line">
    <title>Adding Labeled Flags to the Command Line</title>

    <para>You aren't just limited to anonymous arguments on the command line.
    A <emphasis>flag</emphasis> is a named field that can be followed by an
    optional argument. These flags can appear in any order on the command
    line, or multiple times, depending on how they're declared in the
    specification.<indexterm class="singular">
        <primary>flags</primary>
      </indexterm><indexterm class="singular">
        <primary>command-line parsing</primary>

        <secondary>labeled flags and</secondary>
      </indexterm></para>

    <para>Let's add two arguments to our <literal moreinfo="none">md5</literal> command that mimics the Mac OS X version. A
    <literal moreinfo="none" role="keep-together">-s</literal> flag specifies
    the string to be hashed directly on the command line and <literal moreinfo="none">-t</literal> runs a self-test. The complete example
    follows:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/command-line-parsing/basic_md5_with_flags.ml">OCaml</ulink></para>

    <programlisting format="linespecific" language="ocaml">open Core.Std
open Cryptokit

let checksum_from_string buf =
  hash_string (Hash.md5 ()) buf
  |&gt; transform_string (Hexa.encode ())
  |&gt; print_endline

let checksum_from_file filename =
  let ic = match filename with
    | "-" -&gt; In_channel.stdin
    | _   -&gt; In_channel.create ~binary:true filename
  in
  hash_channel (Hash.md5 ()) ic
  |&gt; transform_string (Hexa.encode ())
  |&gt; print_endline

let command =
  Command.basic
    ~summary:"Generate an MD5 hash of the input data"
    Command.Spec.(
      empty
      +&gt; flag "-s" (optional string) ~doc:"string Checksum the given string"
      +&gt; flag "-t" no_arg ~doc:" run a built-in time trial"
      +&gt; anon (maybe_with_default "-" ("filename" %: file))
    )
    (fun use_string trial filename () -&gt;
       match trial with
       | true -&gt; printf "Running time trial\n"
       | false -&gt; begin
           match use_string with
           | Some buf -&gt; checksum_from_string buf
           | None -&gt; checksum_from_file filename
         end
    )

let () = Command.run command</programlisting>

    <para>The specification now uses the <literal moreinfo="none">flag</literal> function to define the two new labeled,
    command-line arguments. The <literal moreinfo="none">doc</literal> string
    is formatted so that the first word is the short name that appears in the
    usage text, with the remainder being the full help text. Notice that the
    <literal moreinfo="none" role="keep-together">-t</literal> flag has no
    argument, and so we prepend its <literal moreinfo="none">doc</literal>
    text with a blank space. The help text for the preceding code looks like
    this:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/command-line-parsing/run_basic_md5_flags_help.out">Terminal</ulink></para>

    <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">./basic_md5_with_flags.native -help</userinput>
<computeroutput moreinfo="none">Generate an MD5 hash of the input data</computeroutput>
<computeroutput moreinfo="none"> </computeroutput>
<computeroutput moreinfo="none">  basic_md5_with_flags.native [FILENAME]</computeroutput>
<computeroutput moreinfo="none"> </computeroutput>
<computeroutput moreinfo="none">=== flags ===</computeroutput>
<computeroutput moreinfo="none"> </computeroutput>
<computeroutput moreinfo="none">  [-s string]    Checksum the given string</computeroutput>
<computeroutput moreinfo="none">  [-t]           run a built-in time trial</computeroutput>
<computeroutput moreinfo="none">  [-build-info]  print info about this build and exit</computeroutput>
<computeroutput moreinfo="none">  [-version]     print the version of this build and exit</computeroutput>
<computeroutput moreinfo="none">  [-help]        print this help text and exit</computeroutput>
<computeroutput moreinfo="none">                 (alias: -?)</computeroutput>
<computeroutput moreinfo="none"> </computeroutput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">./basic_md5_with_flags.native -s "ocaml rocks"</userinput>
<computeroutput moreinfo="none">5a118fe92ac3b6c7854c595ecf6419cb</computeroutput></programlisting>

    <para>The <literal moreinfo="none">-s</literal> flag in our specification
    requires a <literal moreinfo="none">string</literal> argument and isn't
    optional. The Command parser outputs an error message if the flag isn't
    supplied, as with the anonymous arguments in earlier examples. <xref linkend="table14-2"/> contains a list of some of the functions that you
    can wrap flags in to control how they are parsed.<indexterm class="singular">
        <primary>flag functions</primary>
      </indexterm></para>

    <table id="table14-2">
      <title>Flag functions</title>

      <tgroup cols="2">
        <colspec align="left"/>

        <colspec align="left"/>

        <thead>
          <row>
            <entry>Flag function</entry>

            <entry>OCaml type</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry><literal moreinfo="none">required</literal>
            <emphasis>arg</emphasis></entry>

            <entry><emphasis>arg</emphasis> and error if not present</entry>
          </row>

          <row>
            <entry><literal moreinfo="none">optional</literal>
            <emphasis>arg</emphasis></entry>

            <entry><emphasis>arg</emphasis> <literal moreinfo="none">option</literal></entry>
          </row>

          <row>
            <entry><literal moreinfo="none">optional_with_default</literal>
            <emphasis>val</emphasis> <emphasis>arg</emphasis></entry>

            <entry><emphasis>arg</emphasis> with default
            <emphasis>val</emphasis> if not present</entry>
          </row>

          <row>
            <entry><literal moreinfo="none">listed</literal>
            <emphasis>arg</emphasis></entry>

            <entry><emphasis>arg</emphasis> <literal moreinfo="none">list</literal>, flag may appear multiple
            times</entry>
          </row>

          <row>
            <entry><literal moreinfo="none">no_arg</literal></entry>

            <entry><literal moreinfo="none">bool</literal> that is true if
            flag is present</entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <para>The flags affect the type of the callback function in exactly the
    same way as anonymous arguments do. This lets you change the specification
    and ensure that all the callback functions are updated appropriately,
    without runtime errors.</para>
  </sect1>

  <sect1 id="grouping-sub-commands-together">
    <title>Grouping Subcommands Together</title>

    <para>You can get pretty far by using flags and anonymous arguments to
    assemble complex, command-line interfaces. After a while, though, too many
    options can make the program very confusing for newcomers to your
    application. One way to solve this is by grouping common operations
    together and adding some hierarchy to the command-line
    interface.<indexterm class="singular">
        <primary>subcommands, grouping of</primary>
      </indexterm><indexterm class="singular">
        <primary>OPAM package manager</primary>
      </indexterm><indexterm class="singular">
        <primary>command-line parsing</primary>

        <secondary>subcommand grouping</secondary>
      </indexterm></para>

    <para>You'll have run across this style already when using the OPAM
    package manager (or, in the non-OCaml world, the Git or Mercurial
    commands). OPAM exposes commands in this form:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/command-line-parsing/opam.out">Terminal</ulink></para>

    <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">opam config env</userinput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">opam remote list -k git</userinput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">opam install --help</userinput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">opam install cryptokit --verbose</userinput></programlisting>

    <para>The <literal moreinfo="none">config</literal>, <literal moreinfo="none">remote</literal>, and <literal moreinfo="none">install</literal> keywords form a logical grouping of
    commands that factor out a set of flags and arguments. This lets you
    prevent flags that are specific to a particular subcommand from leaking
    into the general configuration space.<indexterm class="singular">
        <primary>install keyword</primary>
      </indexterm><indexterm class="singular">
        <primary>remote keyword</primary>
      </indexterm></para>

    <para>This usually only becomes a concern when your application
    organically grows features. Luckily, it's simple to extend your
    application to do this in Command: just swap the <literal moreinfo="none">Command.basic</literal> for <literal moreinfo="none">Command.group</literal>, which takes an association list
    of specifications and handles the subcommand parsing and help output for
    you:<indexterm class="singular">
        <primary>Command.group</primary>
      </indexterm></para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/command-line-parsing/group.topscript">OCaml utop</ulink></para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">Command.basic ;;</userinput>
<computeroutput moreinfo="none">- : summary:string -&gt;</computeroutput>
<computeroutput moreinfo="none">    ?readme:(unit -&gt; string) -&gt;</computeroutput>
<computeroutput moreinfo="none">    ('main, unit -&gt; unit) Command.Spec.t -&gt; 'main -&gt; Command.t</computeroutput>
<computeroutput moreinfo="none">= &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Command.group ;;</userinput>
<computeroutput moreinfo="none">- : summary:string -&gt;</computeroutput>
<computeroutput moreinfo="none">    ?readme:(unit -&gt; string) -&gt; (string * Command.t) list -&gt; Command.t</computeroutput>
<computeroutput moreinfo="none">= &lt;fun&gt;</computeroutput></programlisting>

    <para>The <literal moreinfo="none">group</literal> signature accepts a
    list of basic <literal moreinfo="none">Command.t</literal> values and
    their corresponding names. When executed, it looks for the appropriate
    subcommand from the name list, and dispatches it to the right command
    handler.</para>

    <para>Let's build the outline of a calendar tool that does a few
    operations over dates from the command line. We first need to define a
    command that adds days to an input date and prints the resulting
    date:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/command-line-parsing/cal_add_days.ml">OCaml</ulink></para>

    <programlisting format="linespecific" language="ocaml">open Core.Std

let add =
  Command.basic
    ~summary:"Add [days] to the [base] date and print day"
    Command.Spec.(
      empty
      +&gt; anon ("base" %: date)
      +&gt; anon ("days" %: int)
    )
    (fun base span () -&gt;
       Date.add_days base span
       |&gt; Date.to_string
       |&gt; print_endline
    )

let () = Command.run add</programlisting>

    <para>Everything in this command should be familiar to you by now. Once
    you've tested it and made sure it works, we can define another new command
    that takes the difference of two dates. However, instead of creating a new
    binary, we group both operations as subcommands using <literal moreinfo="none">Command.group</literal>:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/command-line-parsing/cal_add_sub_days.ml">OCaml</ulink></para>

    <programlisting format="linespecific" language="ocaml">open Core.Std

let add =
  Command.basic ~summary:"Add [days] to the [base] date"
    Command.Spec.(
      empty
      +&gt; anon ("base" %: date)
      +&gt; anon ("days" %: int)
    )
    (fun base span () -&gt;
       Date.add_days base span
       |&gt; Date.to_string
       |&gt; print_endline
    )

let diff =
  Command.basic ~summary:"Show days between [date1] and [date2]"
    Command.Spec.(
      empty
      +&gt; anon ("date1" %: date)
      +&gt; anon ("date2" %: date)
    )
    (fun date1 date2 () -&gt;
       Date.diff date1 date2
       |&gt; printf "%d days\n"
    )

let command =
  Command.group ~summary:"Manipulate dates"
    [ "add", add; "diff", diff ]

let () = Command.run command</programlisting>

    <para>And that's all you really need to add subcommand support! Let's
    build the example first in the usual way and inspect the help output,
    which now reflects the subcommands we just added.</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/command-line-parsing/build_cal_add_sub_days.out">Terminal</ulink></para>

    <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">corebuild cal_add_sub_days.native</userinput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">./cal_add_sub_days.native -help</userinput>
<computeroutput moreinfo="none">Manipulate dates</computeroutput>
<computeroutput moreinfo="none"> </computeroutput>
<computeroutput moreinfo="none">  cal_add_sub_days.native SUBCOMMAND</computeroutput>
<computeroutput moreinfo="none"> </computeroutput>
<computeroutput moreinfo="none">=== subcommands ===</computeroutput>
<computeroutput moreinfo="none"> </computeroutput>
<computeroutput moreinfo="none">  add      Add [days] to the [base] date</computeroutput>
<computeroutput moreinfo="none">  diff     Show days between [date1] and [date2]</computeroutput>
<computeroutput moreinfo="none">  version  print version information</computeroutput>
<computeroutput moreinfo="none">  help     explain a given subcommand (perhaps recursively)</computeroutput>
<computeroutput moreinfo="none"> </computeroutput></programlisting>

    <para>We can invoke the two commands we just defined to verify that they
    work and see the date parsing in action:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/command-line-parsing/run_cal_add_sub_days.out">Terminal</ulink></para>

    <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">./cal_add_sub_days.native add 2012-12-25 40</userinput>
<computeroutput moreinfo="none">2013-02-03</computeroutput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">./cal_add_sub_days.native diff 2012-12-25 2012-11-01</userinput>
<computeroutput moreinfo="none">54 days</computeroutput></programlisting>
  </sect1>

  <sect1 id="advanced-control-over-parsing">
    <title>Advanced Control over Parsing</title>

    <para>The functions for generating a specification may seem like magic. In
    particular, even if you know how to use them, it's not entirely clear how
    they work, and in particular, why the types work out the way they
    do.<indexterm class="startofrange" id="CLPadv">
        <primary>command-line parsing</primary>

        <secondary>advanced control over</secondary>
      </indexterm></para>

    <para>Understanding the details of how these specifications fit together
    becomes more useful as your command-line interfaces get more complex. In
    particular, you may want to factor out common functionality between
    specifications or interrupt the parsing to perform special processing,
    such as requesting an interactive passphrase from the user before
    proceeding. All of this is helped by a deeper understanding of the Command
    library.</para>

    <para>In the following sections we'll explain the logic behind the
    combinators we've already described and show you some new combinators that
    let you use Command even more effectively.</para>

    <sect2 id="the-types-behind-command.spec">
      <title>The Types Behind Command.Spec</title>

      <para>The Command module's safety relies on the specification's output
      values precisely matching the callback function which invokes the main
      program. In order to prevent any such mismatches, Command uses some
      interesting type machinery to guarantee they remain in sync. You don't
      have to understand this section to use the more advanced combinators,
      but it'll help you debug type errors as you use Command more.<indexterm class="singular">
          <primary>callback function</primary>
        </indexterm><indexterm class="singular">
          <primary>debugging</primary>

          <secondary>Command mode</secondary>
        </indexterm><indexterm class="singular">
          <primary>Command module</primary>
        </indexterm></para>

      <para>The <literal moreinfo="none">Command.Spec.t</literal> type looks
      deceptively simple: <literal moreinfo="none">('a, 'b) t</literal>. You
      can think of <literal moreinfo="none">('a, 'b) t</literal> here as a
      function of type <literal moreinfo="none">'a -&gt; 'b</literal>, but
      embellished with information about:</para>

      <itemizedlist>
        <listitem>
          <para>How to parse the command line</para>
        </listitem>

        <listitem>
          <para>What the command does and how to call it</para>
        </listitem>

        <listitem>
          <para>How to autocomplete a partial command line</para>
        </listitem>
      </itemizedlist>

      <para>The type of a specification transforms a <literal moreinfo="none">'a</literal> to a <literal moreinfo="none">'b</literal>
      value. For instance, a value of <literal moreinfo="none">Spec.t</literal> might have type <literal moreinfo="none">(arg1 -&gt; ... -&gt; argN -&gt; 'r, 'r)
      Spec.t</literal>.</para>

      <para>Such a value transforms a main function of type <literal moreinfo="none">arg1 -&gt; ... -&gt; argN -&gt; 'r</literal> by
      supplying all the argument values, leaving a main function that returns
      a value of type <literal moreinfo="none">'r</literal>. Let's look at
      some examples of specs, and their types:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/command-line-parsing/command_types.topscript">OCaml utop</ulink></para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">Command.Spec.empty ;;</userinput>
<computeroutput moreinfo="none">- : ('m, 'm) Command.Spec.t = &lt;abstr&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Command.Spec.(empty +&gt; anon ("foo" %: int)) ;;</userinput>
<computeroutput moreinfo="none">- : (int -&gt; '_a, '_a) Command.Spec.t = &lt;abstr&gt;</computeroutput></programlisting>

      <para>The empty specification is simple, as it doesn't add any
      parameters to the callback type. The second example adds an <literal moreinfo="none">int</literal> anonymous parameter that is reflected in
      the inferred type. One forms a command by combining a spec of type
      <literal moreinfo="none">('main, unit) Spec.t</literal> with a function
      of type <literal moreinfo="none">'main</literal>. The combinators we've
      shown so far incrementally build the type of <literal moreinfo="none">'main</literal> according to the command-line parameters
      it expects, so the resulting type of <literal moreinfo="none">'main</literal> is something like <literal moreinfo="none">arg1 -&gt; ... -&gt; argN -&gt; unit</literal>.</para>

      <para>The type of <literal moreinfo="none">Command.basic</literal>
      should make more sense now:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/command-line-parsing/basic.topscript">OCaml utop</ulink></para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">Command.basic ;;</userinput>
<computeroutput moreinfo="none">- : summary:string -&gt;</computeroutput>
<computeroutput moreinfo="none">    ?readme:(unit -&gt; string) -&gt;</computeroutput>
<computeroutput moreinfo="none">    ('main, unit -&gt; unit) Command.Spec.t -&gt; 'main -&gt; Command.t</computeroutput>
<computeroutput moreinfo="none">= &lt;fun&gt;</computeroutput></programlisting>

      <para>The parameters to <literal moreinfo="none">Spec.t</literal> are important here. They
        show that the callback function for a spec should consume identical arguments to the
        supplied <literal moreinfo="none">main</literal> function, except for an additional <literal moreinfo="none">unit</literal> argument. This final <literal moreinfo="none">unit</literal> is there to make sure the callback is evaluated as a function, since if
        zero command-line arguments are specified (i.e., <phrase role="keep-together"><literal moreinfo="none">Spec.empty</literal></phrase>), the callback would otherwise have no
        arguments and be evaluated immediately. That's why you have to supply an additional <literal moreinfo="none">()</literal> to the callback function in all the previous examples.</para>
    </sect2>

    <sect2 id="composing-specification-fragments-together">
      <title>Composing Specification Fragments Together</title>

      <para>If you want to factor out common command-line operations, the
      <literal moreinfo="none">++</literal> operator will append two
      specifications together. Let's add some dummy verbosity and debug flags
      to our calendar application to illustrate this.</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/command-line-parsing/cal_append.ml">OCaml</ulink></para>

      <programlisting format="linespecific" language="ocaml">open Core.Std

let add ~common =
  Command.basic ~summary:"Add [days] to the [base] date"
    Command.Spec.(
      empty
      +&gt; anon ("base" %: date)
      +&gt; anon ("days" %: int)
      ++ common
    )
    (fun base span debug verbose () -&gt;
       Date.add_days base span
       |&gt; Date.to_string
       |&gt; print_endline
    )

let diff ~common =
  Command.basic ~summary:"Show days between [date2] and [date1]"
    Command.Spec.(
      empty
      +&gt; anon ("date1" %: date)
      +&gt; anon ("date2" %: date)
      ++ common
    )
    (fun date1 date2 debug verbose () -&gt;
       Date.diff date1 date2
       |&gt; printf "%d days\n"
    )</programlisting>

      <para>The definitions of the specifications are very similar to the
      earlier example, except that they append a <literal moreinfo="none">common</literal> parameter after each specification. We
      can supply these flags when defining the groups.</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/command-line-parsing/cal_append.ml">OCaml</ulink>
      (part 1)</para>

      <programlisting format="linespecific" language="ocaml">let () =
  let common =
    Command.Spec.(
      empty
      +&gt; flag "-d" (optional_with_default false bool) ~doc:" Debug mode"
      +&gt; flag "-v" (optional_with_default false bool) ~doc:" Verbose output"
    )
  in
  List.map ~f:(fun (name, cmd) -&gt; (name, cmd ~common))
    [ "add", add; "diff", diff ]
  |&gt; Command.group ~summary:"Manipulate dates"
  |&gt; Command.run</programlisting>

      <para>Both of these flags will now be applied and passed to all the
      callback functions. This makes code refactoring a breeze by using the
      compiler to spot places where you use commands. Just add a parameter to
      the common definition, run the compiler, and fix type errors until
      everything works again.<indexterm class="singular">
          <primary>refactoring</primary>
        </indexterm></para>

      <para>For example, if we remove the <literal moreinfo="none">verbose</literal> flag and recompile, we'll get this
      impressively long type error:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/command-line-parsing/build_cal_append_broken.out">Terminal</ulink></para>

      <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">corebuild cal_append_broken.native</userinput>
<computeroutput moreinfo="none">File "cal_append_broken.ml", line 38, characters 45-52:</computeroutput>
<computeroutput moreinfo="none">Error: This expression has type</computeroutput>
<computeroutput moreinfo="none">         (bool -&gt; unit -&gt; unit -&gt; unit, unit -&gt; unit -&gt; unit) Command.Spec.t</computeroutput>
<computeroutput moreinfo="none">       but an expression was expected of type</computeroutput>
<computeroutput moreinfo="none">         (bool -&gt; unit -&gt; unit -&gt; unit, unit -&gt; unit) Command.Spec.t</computeroutput>
<computeroutput moreinfo="none">       Type unit -&gt; unit is not compatible with type unit </computeroutput>
<computeroutput moreinfo="none">Command exited with code 2.</computeroutput></programlisting>

      <para>While this does look scary, the key line to scan is the last one,
      where it's telling you that you have supplied too many arguments in the
      callback function (<literal moreinfo="none">unit -&gt; unit</literal>
      versus <literal moreinfo="none">unit</literal>). If you started with a
      working program and made this single change, you typically don't even
      need to read the type error, as the filename and location information is
      sufficient to make the obvious fix.</para>
    </sect2>

    <sect2 id="prompting-for-interactive-input">
      <title>Prompting for Interactive Input</title>

      <para>The <literal moreinfo="none">step</literal> combinator lets you
      control the normal course of parsing by supplying a function that maps
      callback arguments to a new set of values. For instance, let's revisit
      our first calendar application that added a number of days onto a
      supplied base date:<indexterm class="singular">
          <primary>interactive input</primary>

          <secondary>prompts for</secondary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/command-line-parsing/cal_add_days.ml">OCaml</ulink></para>

      <programlisting format="linespecific" language="ocaml">open Core.Std

let add =
  Command.basic
    ~summary:"Add [days] to the [base] date and print day"
    Command.Spec.(
      empty
      +&gt; anon ("base" %: date)
      +&gt; anon ("days" %: int)
    )
    (fun base span () -&gt;
       Date.add_days base span
       |&gt; Date.to_string
       |&gt; print_endline
    )

let () = Command.run add</programlisting>

      <para>This program requires you to specify both the <literal moreinfo="none">base</literal> date and the number of <literal moreinfo="none">days</literal> to add onto it. If <literal moreinfo="none">days</literal> isn't supplied on the command line, an
      error is output. Now let's modify it to interactively prompt for a
      number of days if only the <literal moreinfo="none">base</literal> date
      is supplied:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/command-line-parsing/cal_add_interactive.ml">OCaml</ulink></para>

      <programlisting format="linespecific" language="ocaml">open Core.Std

let add_days base span () =
  Date.add_days base span
  |&gt; Date.to_string
  |&gt; print_endline

let add =
  Command.basic
    ~summary:"Add [days] to the [base] date and print day"
    Command.Spec.( 
      step 
        (fun m base days -&gt;
           match days with
           | Some days -&gt;
             m base days
           | None -&gt;
             print_endline "enter days: ";
             read_int ()
             |&gt; m base
        )
      +&gt; anon ("base" %: date)
      +&gt; anon (maybe ("days" %: int))
    )
    add_days

let () = Command.run add</programlisting>

      <para>The <literal moreinfo="none">days</literal> anonymous argument is
      now an optional integer in the spec, and we want to transform it into a
      nonoptional value before calling our <literal moreinfo="none">add_days</literal> callback. The <literal moreinfo="none">step</literal> combinator lets us perform this
      transformation by applying its supplied callback function first. In the
      example, the callback first checks if <literal moreinfo="none">days</literal> is defined. If it's undefined, then it
      interactively reads an integer from the standard input.</para>

      <para>The first <literal moreinfo="none">m</literal> argument to the
      <literal moreinfo="none">step</literal> callback is the next callback
      function in the chain. The transformation is completed by calling
      <literal moreinfo="none">m base days</literal> to continue processing
      with the new values we've just calculated. The <literal moreinfo="none">days</literal> value that is passed onto the next
      callback now has a nonoptional <literal moreinfo="none">int</literal>
      type:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/command-line-parsing/build_and_run_cal_add_interactive.out">Terminal</ulink></para>

      <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">ocamlbuild -use-ocamlfind -tag thread -pkg core cal_add_interactive.native</userinput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">./cal_add_interactive.native 2013-12-01</userinput>
<computeroutput moreinfo="none">enter days:</computeroutput>
<computeroutput moreinfo="none">35</computeroutput>
<computeroutput moreinfo="none">2014-01-05</computeroutput></programlisting>

      <para>The transformation means that the <literal moreinfo="none">add_days</literal> callback can just keep its original
      definition of <literal moreinfo="none">Date.t -&gt; int -&gt;
      unit</literal>. The <literal moreinfo="none">step</literal> function
      transformed the <literal moreinfo="none">int option</literal> argument
      from the parsing into an <literal moreinfo="none">int</literal> suitable
      for <literal moreinfo="none">add_days</literal>. This transformation is
      explicitly represented in the type of the <literal moreinfo="none">step</literal> return value:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/command-line-parsing/step.topscript">OCaml utop</ulink></para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">open Command.Spec ;;</userinput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">step (fun m (base:Date.t) days -&gt;</userinput>
<userinput moreinfo="none">  match days with</userinput>
<userinput moreinfo="none">  | Some days -&gt; m base days</userinput>
<userinput moreinfo="none">  | None -&gt;</userinput>
<userinput moreinfo="none">     print_endline "enter days: ";</userinput>
<userinput moreinfo="none">     m base (read_int ())) ;;</userinput>
<computeroutput moreinfo="none">- : (Date.t -&gt; int -&gt; '_a, Date.t -&gt; int option -&gt; '_a) t = &lt;abstr&gt;</computeroutput></programlisting>

      <para>The first half of the <literal moreinfo="none">Spec.t</literal>
      shows that the callback type is <literal moreinfo="none">Date.t -&gt;
      int</literal>, whereas the resulting value expected from the next
      specification in the chain is a <literal moreinfo="none">Date.t -&gt;
      int option</literal>.</para>
    </sect2>

    <sect2 id="adding-labeled-arguments-to-callbacks">
      <title>Adding Labeled Arguments to Callbacks</title>

      <para>The <literal moreinfo="none">step</literal> chaining lets you
      control the types of your callbacks very easily. This can help you match
      existing interfaces or make things more explicit by adding labeled
      arguments:<indexterm class="singular">
          <primary>callback function</primary>
        </indexterm><indexterm class="singular">
          <primary>arguments</primary>

          <secondary>labeled arguments</secondary>
        </indexterm><indexterm class="singular">
          <primary>labeled arguments</primary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/command-line-parsing/cal_add_labels.ml">OCaml</ulink></para>

      <programlisting format="linespecific" language="ocaml">open Core.Std

let add_days ~base_date ~num_days () =
  Date.add_days base_date num_days
  |&gt; Date.to_string
  |&gt; print_endline

let add =
  Command.basic
    ~summary:"Add [days] to the [base] date and print day"
    Command.Spec.( 
      step (fun m base days -&gt; m ~base_date:base ~num_days:days)
      +&gt; anon ("base" %: date)
      +&gt; anon ("days" %: int)
    )
    add_days

let () = Command.run add</programlisting>

      <para>This <literal moreinfo="none">cal_add_labels</literal> example goes back to our
        noninteractive calendar addition program, but the <literal moreinfo="none">add_days</literal> main function now expects labeled arguments. The <literal moreinfo="none">step</literal>
        <phrase role="keep-together">function</phrase> in the specification simply converts the
        default <literal moreinfo="none">base</literal> and <literal moreinfo="none">days</literal>
        arguments into a labeled function.</para>

      <para>Labeled arguments are more verbose but can also help prevent
      errors with command-line arguments with similar types but different
      names and purposes. It's good form to use labels when you have a lot of
      otherwise anonymous <literal moreinfo="none">int</literal> and <literal moreinfo="none">string</literal> arguments.<indexterm class="endofrange" startref="CLPadv"/></para>
    </sect2>
  </sect1>

  <sect1 id="command-line-auto-completion-with-bash">
    <title>Command-Line Autocompletion with bash</title>

    <para>Modern UNIX shells usually have a tab-completion feature to
    interactively help you figure out how to build a command line. These work
    by pressing the Tab key in the middle of typing a command, and seeing the
    options that pop up. You've probably used this most often to find the
    files in the current directory, but it can actually be extended for other
    parts of the command, too.<indexterm class="singular">
        <primary>tab-autocompletion</primary>
      </indexterm><indexterm class="singular">
        <primary>autocompletion</primary>
      </indexterm><indexterm class="singular">
        <primary>command-line parsing</primary>

        <secondary>autocompletion with bash</secondary>
      </indexterm></para>

    <para>The precise mechanism for autocompletion varies depending on what
    shell you are using, but we'll assume you are using the most common one:
    <command moreinfo="none">bash</command>. This is the default interactive
    shell on most Linux distributions and Mac OS X, but you may need to switch
    to it on *BSD or Windows (when using Cygwin). The rest of this section
    assumes that you're using <command moreinfo="none">bash</command>.<indexterm class="singular">
        <primary>bash autocompletion</primary>
      </indexterm></para>

    <para>Bash autocompletion isn't always installed by default, so check your
    OS package manager to see if you have it available.</para>

    <informaltable>
      <tgroup cols="3">
        <colspec align="left"/>

        <colspec align="left"/>

        <colspec align="left"/>

        <thead>
          <row>
            <entry>Operating system</entry>

            <entry>Package manager</entry>

            <entry>Package</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry>Debian Linux</entry>

            <entry><literal moreinfo="none">apt</literal></entry>

            <entry><literal moreinfo="none">bash-completion</literal></entry>
          </row>

          <row>
            <entry>Mac OS X</entry>

            <entry>Homebrew</entry>

            <entry><literal moreinfo="none">bash-completion</literal></entry>
          </row>

          <row>
            <entry>FreeBSD</entry>

            <entry>Ports system</entry>

            <entry><filename moreinfo="none">/usr/ports/shells/bash-completion</filename></entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>

    <para>Once <emphasis>bash</emphasis> completion is installed and
    configured, check that it works by typing the <literal moreinfo="none">ssh</literal> command and pressing the Tab key. This
    should show you the list of known hosts from your
    <emphasis>~/.ssh/known_hosts</emphasis> file. If it lists some hosts that
    you've recently connected to, you can continue on. If it lists the files
    in your current directory instead, then check your OS documentation to
    configure completion correctly.</para>

    <para>One last bit of information you'll need to find is the location of
    the <filename moreinfo="none">bash_completion.d</filename> directory. This
    is where all the shell fragments that contain the completion logic are
    held. On Linux, this is often in <filename moreinfo="none">/etc/bash_completion.d</filename>, and in Homebrew on Mac
    OS X, it would be <filename moreinfo="none">/usr/local/etc/bash_completion.d</filename> by
    default.</para>

    <sect2 id="generating-completion-fragments-from-command">
      <title>Generating Completion Fragments from Command</title>

      <para>The Command library has a declarative description of all the
      possible valid options, and it can use this information to generate a
      shell script that provides completion support for that command. To
      generate the fragment, just run the command with the
      <envar>COMMAND_OUTPUT_INSTALLATION_BASH</envar> environment variable set
      to any value.</para>

      <para>For example, let's try it on our MD5 example from earlier,
      assuming that the binary is called <command moreinfo="none">basic_md5_with_flags</command> in the current
      directory:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/command-line-parsing/md5_completion.out">Terminal</ulink></para>

      <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">env COMMAND_OUTPUT_INSTALLATION_BASH=1 ./basic_md5_with_flags.native</userinput>
<computeroutput moreinfo="none">function _jsautocom_23343 {</computeroutput>
<computeroutput moreinfo="none">  export COMP_CWORD</computeroutput>
<computeroutput moreinfo="none">  COMP_WORDS[0]=./basic_md5_with_flags.native</computeroutput>
<computeroutput moreinfo="none">  COMPREPLY=($("${COMP_WORDS[@]}"))</computeroutput>
<computeroutput moreinfo="none">}</computeroutput>
<computeroutput moreinfo="none">complete -F _jsautocom_23343 ./basic_md5_with_flags.native</computeroutput></programlisting>

      <para>Recall that we used the <literal moreinfo="none">Arg_type.file</literal> to specify the argument type.
      This also supplies the completion logic so that you can just press Tab
      to complete files in your current directory.</para>
    </sect2>

    <sect2 id="installing-the-completion-fragment">
      <title>Installing the Completion Fragment</title>

      <para>You don't need to worry about what the preceding output script
      actually does (unless you have an unhealthy fascination with shell
      scripting internals, that is). Instead, redirect the output to a file in
      your current directory and source it into your current shell:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/command-line-parsing/cal_completion.out">Terminal</ulink></para>

      <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">env COMMAND_OUTPUT_INSTALLATION_BASH=1 ./cal_add_sub_days.native &gt; cal.cmd</userinput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">. cal.cmd</userinput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">./cal_add_sub_days.native &lt;tab&gt;</userinput>
<computeroutput moreinfo="none">add      diff     help     version</computeroutput></programlisting>

      <para>Command completion support works for flags and grouped commands
      and is very useful when building larger command-line interfaces. Don't
      forget to install the shell fragment into your global <filename moreinfo="none">bash_completion.d</filename> directory if you want it to
      be loaded in all of your login shells.<indexterm class="singular">
          <primary>completion handlers</primary>
        </indexterm></para>

      <note>
        <title>Installing a Generic Completion Handler</title>

        <para>Sadly, <command moreinfo="none">bash</command> doesn't support
        installing a generic handler for all Command-based applications. This
        means you have to install the completion script for every application,
        but you should be able to automate this in the build and packaging
        system for your application.</para>

        <para>It will help to check out how other applications install
        tab-completion scripts and follow their lead, as the details are very
        OS-specific.</para>
      </note>
    </sect2>
  </sect1>

  <sect1 id="alternative-command-line-parsers">
    <title>Alternative Command-Line Parsers</title>

    <para>This rounds up our tour of the Command library. This isn't the only
    way to parse command-line arguments of course; there are several
    alternatives available on OPAM. Three of the most prominent ones
    follow:<indexterm class="singular">
        <primary>Cmdliner</primary>
      </indexterm><indexterm class="singular">
        <primary>OCaml toolchain</primary>

        <secondary>ocaml-getopt</secondary>
      </indexterm><indexterm class="singular">
        <primary>Arg module</primary>
      </indexterm><indexterm class="singular">
        <primary>command-line parsing</primary>

        <secondary>alternatives to Command library</secondary>
      </indexterm><indexterm class="singular">
        <primary>OPAM package manager</primary>
      </indexterm></para>

    <variablelist>
      <varlistentry>
        <term>The <literal moreinfo="none">Arg</literal> module</term>

        <listitem>
          <para>The<literal> Arg</literal> module is from the OCaml standard
          library, which is used by the compiler itself to handle its
          command-line interface. Command is generally more featureful than
          Arg (mainly via support for subcommands, the <literal moreinfo="none">step</literal> combinator to transform inputs, and
          help generation), but there's absolutely nothing wrong with using
          Arg either.</para>

          <para>You can use the <literal moreinfo="none">Command.Spec.flags_of_args_exn</literal> function to
          convert Arg specifications into ones compatible with Command. This
          is quite often used to help port older non-Core code into the Core
          standard library world.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><ulink url="https://forge.ocamlcore.org/projects/ocaml-getopt/">ocaml-getopt</ulink></term>

        <listitem>
          <para><literal>ocaml-getopt</literal> provides the general
          command-line syntax of GNU <literal moreinfo="none">getopt</literal>
          and <literal moreinfo="none" role="keep-together">getopt_long</literal>. The GNU conventions are
          widely used in the open source world, and this library lets your
          OCaml programs obey the same rules.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><ulink url="http://erratique.ch/software/cmdliner">Cmdliner</ulink></term>

        <listitem>
          <para>Cmdliner is a mix between the Command and Getopt libraries. It
          allows for the declarative definition of command-line interfaces but
          exposes a more <literal moreinfo="none">getopt</literal>-like
          interface. It also automates the generation of UNIX man pages as
          part of the specification. Cmdliner is the parser used by OPAM to
          manage its command line.</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </sect1>
</chapter>

    <chapter id="handling-json-data">
  <title>Handling JSON Data</title>

  <para>Data serialization, i.e., converting data to and from a sequence of
  bytes that's suitable for writing to disk or sending across the network, is
  an important and common programming task. You often have to match someone
  else's data format (such as XML), sometimes you need a highly efficient
  format, and other times you want something that is easy for humans to edit.
  To this end, OCaml libraries provide several techniques for data
  serialization depending on what your problem is.<indexterm class="singular">
      <primary>JSON data</primary>

      <secondary>basics of</secondary>
    </indexterm><indexterm class="startofrange" id="SERjson">
      <primary>serialization formats</primary>

      <secondary>JSON</secondary>
    </indexterm><indexterm class="startofrange" id="DATjson">
      <primary>data serialization</primary>

      <secondary>with JSON</secondary>
    </indexterm></para>

  <para>We'll start by using the popular and simple JSON data format and then
  look at other serialization formats later in the book. This chapter
  introduces you to a couple of new techniques that glue together the basic
  ideas from Part I of the book by using:</para>

  <itemizedlist>
    <listitem>
      <para><emphasis>Polymorphic variants</emphasis> to write more extensible
      libraries and protocols (but still retain the ability to extend them if
      needed)</para>
    </listitem>

    <listitem>
      <para><emphasis>Functional combinators</emphasis> to compose common
      operations over data structures in a type-safe way</para>
    </listitem>

    <listitem>
      <para>External tools to generate boilerplate OCaml modules and
      signatures from external specification files</para>
    </listitem>
  </itemizedlist>

  <sect1 id="json-basics">
    <title>JSON Basics</title>

    <para>JSON is a lightweight data-interchange format often used in web
    services and browsers. It's described in <ulink url="http://www.ietf.org/rfc/rfc4627.txt">RFC4627</ulink> and is easier to
    parse and generate than alternatives such as XML. You'll run into JSON
    very often when working with modern web APIs, so we'll cover several
    different ways to manipulate it in this chapter.<indexterm class="singular">
        <primary>RFC4627</primary>
      </indexterm></para>

    <para>JSON consists of two basic structures: an unordered collection of
    key/value pairs, and an ordered list of values. Values can be strings,
    Booleans, floats, integers, or null. Let's see what a JSON record for an
    example book description looks like:<indexterm class="singular">
        <primary>values</primary>

        <secondary sortas="JSON">in JSON data</secondary>
      </indexterm><indexterm class="singular">
        <primary>key/value pairs</primary>
      </indexterm></para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/json/book.json">JSON</ulink></para>

    <programlisting format="linespecific" language="json">{
  "title": "Real World OCaml",
  "tags" : [ "functional programming", "ocaml", "algorithms" ],
  "pages": 450,
  "authors": [
    { "name": "Jason Hickey", "affiliation": "Google" },
    { "name": "Anil Madhavapeddy", "affiliation": "Cambridge"},
    { "name": "Yaron Minsky", "affiliation": "Jane Street"}
  ],
  "is_online": true
}</programlisting>

    <para>The outermost JSON value is usually a record (delimited by the curly
    braces) and contains an unordered set of key/value pairs. The keys must be
    strings, but values can be any JSON type. In the preceding example,
    <literal moreinfo="none">tags</literal> is a string list, while the
    <literal moreinfo="none">authors</literal> field contains a list of
    records. Unlike OCaml lists, JSON lists can contain multiple different
    JSON types within a single list.</para>

    <para>This free-form nature of JSON types is both a blessing and a curse.
    It's very easy to generate JSON values, but code that parses them also has
    to handle subtle variations in how the values are represented. For
    example, what if the preceding <literal moreinfo="none">pages</literal>
    value is actually represented as a string value of "<literal moreinfo="none">450</literal>" instead of an integer?<indexterm class="singular">
        <primary>JSON data</primary>

        <secondary>benefits and drawbacks of</secondary>
      </indexterm></para>

    <para>Our first task is to parse the JSON into a more structured OCaml
    type so that we can use static typing more effectively. When manipulating
    JSON in Python or Ruby, you might write unit tests to check that you have
    handled unusual inputs. The OCaml model prefers compile-time static
    checking as well as unit tests. For example, using pattern matching can
    warn you if you've not checked that a value can be <literal moreinfo="none">Null</literal> as well as contain an actual
    value.<indexterm class="singular">
        <primary>Yojson library</primary>

        <secondary>installation of</secondary>
      </indexterm><indexterm class="singular">
        <primary>static checking</primary>
      </indexterm><indexterm class="singular">
        <primary>compile-time static checking</primary>
      </indexterm><indexterm class="singular">
        <primary>unit tests</primary>
      </indexterm></para>

    <note>
      <title>Installing the Yojson Library</title>

      <para>There are several JSON libraries available for OCaml. For this
      chapter, we've picked the <ulink url="http://mjambon.com/yojson.html">OCaml</ulink> library by Martin
      Jambon. It's easiest to install via OPAM by running <literal moreinfo="none">opam install yojson</literal>. See <ulink url="http://realworldocaml.org/install">this Real World OCaml page</ulink> for installation instructions if you haven't
      already got OPAM. Once installed, you can open it in the <command moreinfo="none">utop</command> toplevel by:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/json/install.topscript">OCaml utop</ulink></para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">#require "yojson" ;;</userinput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">open Yojson ;;</userinput></programlisting>
    </note>
  </sect1>

  <sect1 id="parsing-json-with-yojson">
    <title>Parsing JSON with Yojson</title>

    <para>The JSON specification has very few data types, and the <literal moreinfo="none">Yojson.Basic.json</literal> type that follows is
    sufficient to express any valid JSON structure:<indexterm class="singular">
        <primary>JSON data</primary>

        <secondary>parsing with Yojson</secondary>
      </indexterm><indexterm class="singular">
        <primary>Yojson library</primary>

        <secondary>parsing JSON with</secondary>
      </indexterm></para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/json/yojson_basic.mli">OCaml</ulink></para>

    <programlisting format="linespecific" language="ocaml">type json = [
  | `Assoc of (string * json) list
  | `Bool of bool
  | `Float of float
  | `Int of int
  | `List of json list
  | `Null
  | `String of string
]</programlisting>

    <para>Some interesting properties should leap out at you after reading
    this definition:</para>

    <itemizedlist>
      <listitem>
        <para>The <literal moreinfo="none">json</literal> type is
        <emphasis>recursive</emphasis>, which is to say that some of the tags
        refer back to the overall <literal moreinfo="none">json</literal>
        type. In particular, <literal moreinfo="none">Assoc</literal> and
        <literal moreinfo="none">List</literal> types can contain references
        to further JSON values of different types. This is unlike the OCaml
        lists, whose contents must be of a uniform type.<indexterm class="singular">
            <primary>recursion</primary>

            <secondary sortas="json">in json types</secondary>
          </indexterm></para>
      </listitem>

      <listitem>
        <para>The definition specifically includes a <literal moreinfo="none">Null</literal> variant for empty fields. OCaml doesn't
        allow null values by default, so this must be encoded
        explicitly.</para>
      </listitem>

      <listitem>
        <para>The type definition uses polymorphic variants and not normal
        variants. This will become significant later, when we extend it with
        custom extensions to the JSON format.<indexterm class="singular">
            <primary>polymorphic variant types</primary>

            <secondary sortas="JSON">in JSON data</secondary>
          </indexterm></para>
      </listitem>
    </itemizedlist>

    <para>Let's parse the earlier JSON example into this type now. The first
    stop is the <literal moreinfo="none">Yojson.Basic</literal> documentation,
    where we find these helpful functions:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/json/yojson_basic.mli">OCaml</ulink>
    (part 1)</para>

    <programlisting format="linespecific" language="ocaml">val from_string : ?buf:Bi_outbuf.t -&gt; ?fname:string -&gt; ?lnum:int -&gt;
   string -&gt; json
(* Read a JSON value from a string.
   [buf]   : use this buffer at will during parsing instead of
             creating a new one. 
   [fname] : data file name to be used in error messages. It does not 
             have to be a real file. 
   [lnum]  : number of the first line of input. Default is 1. *)

val from_file : ?buf:Bi_outbuf.t -&gt; ?fname:string -&gt; ?lnum:int -&gt; 
   string -&gt; json
(* Read a JSON value from a file. See [from_string] for the meaning of the optional
   arguments. *)

val from_channel : ?buf:Bi_outbuf.t -&gt; ?fname:string -&gt; ?lnum:int -&gt;
  in_channel -&gt; json
  (** Read a JSON value from a channel.
      See [from_string] for the meaning of the optional arguments. *)</programlisting>

    <para>When first reading these interfaces, you can generally ignore the
    optional arguments (which have the question marks in the type signature),
    since they should have sensible defaults. In the preceding signature, the
    optional arguments offer finer control over the memory buffer allocation
    and error messages from parsing incorrect JSON.</para>

    <para>The type signature for these functions with the optional elements
    removed makes their purpose much clearer. The three ways of parsing JSON
    are either directly from a string, from a file on a filesystem, or via a
    buffered input channel:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/json/yojson_basic_simple.mli">OCaml</ulink></para>

    <programlisting format="linespecific" language="ocaml">val from_string  : string     -&gt; json
val from_file    : string     -&gt; json
val from_channel : in_channel -&gt; json</programlisting>

    <para>The next example shows both the <literal>string</literal> and
    <literal>file</literal> functions in action, assuming the JSON record is
    stored in a file called <emphasis>book.json</emphasis>:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/json/read_json.ml">OCaml</ulink></para>

    <programlisting format="linespecific" language="ocaml">open Core.Std

let () =
  (* Read JSON file into an OCaml string *)
  let buf = In_channel.read_all "book.json" in
  (* Use the string JSON constructor *)
  let json1 = Yojson.Basic.from_string buf in
  (* Use the file JSON constructor *)
  let json2 = Yojson.Basic.from_file "book.json" in
  (* Test that the two values are the same *)
  print_endline (if json1 = json2 then "OK" else "FAIL")</programlisting>

    <para>You can build this by running <command moreinfo="none">corebuild</command>:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/json/run_read_json.out">Terminal</ulink></para>

    <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">corebuild -pkg yojson read_json.native</userinput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">./read_json.native</userinput>
<computeroutput moreinfo="none">OK</computeroutput></programlisting>

    <para>The <literal moreinfo="none">from_file</literal> function accepts an
    input filename and takes care of opening and closing it for you. It's far
    more common to use <literal moreinfo="none">from_string</literal> to
    construct JSON values though, since these strings come in via a network
    connection (we'll see more of this in <xref linkend="concurrent-programming-with-async"/>) or a database. Finally,
    the example checks that the two input mechanisms actually resulted in the
    same OCaml data structure.</para>
  </sect1>

  <sect1 id="selecting-values-from-json-structures">
    <title>Selecting Values from JSON Structures</title>

    <para>Now that we've figured out how to parse the example JSON into an
    OCaml value, let's manipulate it from OCaml code and extract specific
    fields:<indexterm class="startofrange" id="VALjson">
        <primary>values</primary>

        <secondary>selecting from JSON structures</secondary>
      </indexterm><indexterm class="startofrange" id="JSONselval">
        <primary>JSON data</primary>

        <secondary>selecting values from</secondary>
      </indexterm></para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/json/parse_book.ml">OCaml</ulink></para>

    <programlisting format="linespecific" language="ocaml">open Core.Std

let () =
  (* Read the JSON file *)
  let json = Yojson.Basic.from_file "book.json" in

  (* Locally open the JSON manipulation functions *)
  let open Yojson.Basic.Util in
  let title = json |&gt; member "title" |&gt; to_string in
  let tags = json |&gt; member "tags" |&gt; to_list |&gt; filter_string in
  let pages = json |&gt; member "pages" |&gt; to_int in
  let is_online = json |&gt; member "is_online" |&gt; to_bool_option in
  let is_translated = json |&gt; member "is_translated" |&gt; to_bool_option in
  let authors = json |&gt; member "authors" |&gt; to_list in
  let names = List.map authors ~f:(fun json -&gt; member "name" json |&gt; to_string) in

  (* Print the results of the parsing *)
  printf "Title: %s (%d)\n" title pages;
  printf "Authors: %s\n" (String.concat ~sep:", " names);
  printf "Tags: %s\n" (String.concat ~sep:", " tags);
  let string_of_bool_option =
    function
    | None -&gt; "&lt;unknown&gt;"
    | Some true -&gt; "yes"
    | Some false -&gt; "no" in
  printf "Online: %s\n" (string_of_bool_option is_online);
  printf "Translated: %s\n" (string_of_bool_option is_translated)</programlisting>

    <para>Now build and run this in the same way as the previous
    example:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/json/run_parse_book.out">Terminal</ulink></para>

    <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">corebuild -pkg yojson parse_book.native</userinput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">./parse_book.native</userinput>
<computeroutput moreinfo="none">Title: Real World OCaml (450)</computeroutput>
<computeroutput moreinfo="none">Authors: Jason Hickey, Anil Madhavapeddy, Yaron Minsky</computeroutput>
<computeroutput moreinfo="none">Tags: functional programming, ocaml, algorithms</computeroutput>
<computeroutput moreinfo="none">Online: yes</computeroutput>
<computeroutput moreinfo="none">Translated: &lt;unknown&gt;</computeroutput></programlisting>

    <para>This code introduces the <literal moreinfo="none">Yojson.Basic.Util</literal> module, which contains
    <emphasis>combinator</emphasis> functions that let you easily map a JSON
    object into a more strongly typed OCaml value.<indexterm class="singular">
        <primary>combinators</primary>

        <secondary>functional combinators</secondary>
      </indexterm><indexterm class="singular">
        <primary>functional combinators</primary>
      </indexterm></para>

    <sidebar>
      <title>Functional Combinators</title>

      <para>Combinators are a design pattern that crops up quite often in
      functional programming. John Hughes defines them as "a function which
      builds program fragments from program fragments." In a functional
      language, this generally means higher-order functions that combine other
      functions to apply useful transformations over values.</para>

      <para>You've already run across several of these in the <literal moreinfo="none">List</literal> module:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/json/list_excerpt.mli">OCaml</ulink></para>

      <programlisting format="linespecific" language="ocaml">val map  : 'a list -&gt; f:('a -&gt; 'b)   -&gt; 'b list
val fold : 'a list -&gt; init:'accum -&gt; f:('accum -&gt; 'a -&gt; 'accum) -&gt; 'accum</programlisting>

      <para><literal moreinfo="none">map</literal> and <literal moreinfo="none">fold</literal> are extremely common combinators that
      transform an input list by applying a function to each value of the
      list. The <literal moreinfo="none">map</literal> combinator is simplest,
      with the resulting list being output directly. <literal moreinfo="none">fold</literal> applies each value in the input list to a
      function that accumulates a single result, and returns that
      instead:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/json/list_excerpt.mli">OCaml</ulink>
      (part 1)</para>

      <programlisting format="linespecific" language="ocaml">val iter : 'a list -&gt; f:('a -&gt; unit) -&gt; unit</programlisting>

      <para><literal moreinfo="none">iter</literal> is a more specialized
      combinator that is only useful when writing imperative code. The input
      function is applied to every value, but no result is supplied. The
      function must instead apply some side effect such as changing a mutable
      record field or printing to the standard output.</para>
    </sidebar>

    <para><literal moreinfo="none">Yojson</literal> provides several
    combinators in the <literal moreinfo="none">Yojson.Basic.Util</literal>
    module, some of which are listed in <xref linkend="table15_1"/>.<indexterm class="singular">
        <primary>combinators</primary>

        <secondary sortas="Yojson">in Yojson library</secondary>
      </indexterm><indexterm class="singular">
        <primary>Yojson library</primary>

        <secondary>combinators in</secondary>
      </indexterm></para>

    <table id="table15_1">
      <title>Yojson combinators</title>

      <tgroup cols="3">
        <colspec align="left"/>

        <colspec align="left"/>

        <colspec align="left"/>

        <thead>
          <row>
            <entry>Function</entry>

            <entry>Type</entry>

            <entry>Purpose</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry>member</entry>

            <entry><literal moreinfo="none">string -&gt; json -&gt;
            json</literal></entry>

            <entry>Select a named field from a JSON record.</entry>
          </row>

          <row>
            <entry>to_string</entry>

            <entry><literal moreinfo="none">json -&gt;
            string</literal></entry>

            <entry>Convert a JSON value into an OCaml <literal moreinfo="none">string</literal>. Raises an exception if this is
            impossible.</entry>
          </row>

          <row>
            <entry>to_int</entry>

            <entry><literal moreinfo="none">json -&gt; int</literal></entry>

            <entry>Convert a JSON value into an OCaml <literal moreinfo="none">int</literal>. Raises an exception if this is
            impossible.</entry>
          </row>

          <row>
            <entry>filter_string</entry>

            <entry><literal moreinfo="none">json list -&gt; string
            list</literal></entry>

            <entry>Filter valid strings from a list of JSON fields, and return
            them as an OCaml list of strings.</entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <para>We'll go through each of these uses one by one now. The following
    examples also use the <literal moreinfo="none">|&gt;</literal>
    pipe-forward operator that we explained in <xref linkend="variables-and-functions"/>. This lets us chain together multiple
    JSON selection functions and feed the output from one into the next one,
    without having to create separate <literal moreinfo="none">let</literal>
    bindings for each one.<indexterm class="singular">
        <primary>filter_string function</primary>
      </indexterm><indexterm class="singular">
        <primary>to_init function</primary>
      </indexterm><indexterm class="singular">
        <primary>functions</primary>

        <secondary>to_init function</secondary>
      </indexterm><indexterm class="singular">
        <primary>to_string function</primary>
      </indexterm><indexterm class="singular">
        <primary>functions</primary>

        <secondary>to_string function</secondary>
      </indexterm><indexterm class="singular">
        <primary>functions</primary>

        <secondary>member functions</secondary>
      </indexterm><indexterm class="singular">
        <primary>member function</primary>
      </indexterm></para>

    <para>Let's start with selecting a single <literal moreinfo="none">title</literal> field from the record:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/json/parse_book.topscript">OCaml utop</ulink>
    (part 1)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">open Yojson.Basic.Util ;;</userinput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let title = json |&gt; member "title" |&gt; to_string ;;</userinput>
<computeroutput moreinfo="none">val title : string = "Real World OCaml"</computeroutput></programlisting>

    <para>The <literal moreinfo="none">member</literal> function accepts a JSON object and named key
      and returns the JSON field associated with that key, or <literal moreinfo="none">Null</literal>. Since we know that the <literal moreinfo="none">title</literal> value is
      always a string in our example schema, we want to convert it to an OCaml string. The <literal moreinfo="none">to_string</literal> function performs this conversion and raises an
      exception if there is an unexpected JSON type. The <literal moreinfo="none">|&gt;</literal>
      operator provides a convenient way to chain these operations <phrase role="keep-together">together</phrase>:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/json/parse_book.topscript">OCaml utop</ulink>
    (part 2)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let tags = json |&gt; member "tags" |&gt; to_list |&gt; filter_string ;;</userinput>
<computeroutput moreinfo="none">val tags : string list = ["functional programming"; "ocaml"; "algorithms"]</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let pages = json |&gt; member "pages" |&gt; to_int ;;</userinput>
<computeroutput moreinfo="none">val pages : int = 450</computeroutput></programlisting>

    <para>The <literal moreinfo="none">tags</literal> field is similar to
    <literal moreinfo="none">title</literal>, but the field is a list of
    strings instead of a single one. Converting this to an OCaml <literal moreinfo="none">string list</literal> is a two-stage process. First, we
    convert the JSON <literal moreinfo="none">List</literal> to an OCaml list
    of JSON values and then filter out the <literal moreinfo="none">String</literal> values as an OCaml <literal moreinfo="none">string list</literal>. Remember that OCaml lists must
    contain values of the same type, so any JSON values that cannot be
    converted to a <literal moreinfo="none">string</literal> will be skipped
    from the output of <literal moreinfo="none">filter_string</literal>:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/json/parse_book.topscript">OCaml utop</ulink>
    (part 3)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let is_online = json |&gt; member "is_online" |&gt; to_bool_option ;;</userinput>
<computeroutput moreinfo="none">val is_online : bool option = Some true</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let is_translated = json |&gt; member "is_translated" |&gt; to_bool_option ;;</userinput>
<computeroutput moreinfo="none">val is_translated : bool option = None</computeroutput></programlisting>

    <para>The <literal moreinfo="none">is_online</literal> and <literal moreinfo="none">is_translated</literal> fields are optional in our JSON
    schema, so no error should be raised if they are not present. The OCaml
    type is a <literal moreinfo="none">bool option</literal> to reflect this
    and can be extracted via <literal moreinfo="none">to_bool_option</literal>. In our example JSON, only
    <literal moreinfo="none">is_online</literal> is present and <literal moreinfo="none">is_translated</literal> will be <literal moreinfo="none">None</literal>:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/json/parse_book.topscript">OCaml utop</ulink>
    (part 4)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let authors = json |&gt; member "authors" |&gt; to_list ;;</userinput>
<computeroutput moreinfo="none">val authors : Yojson.Basic.json list =</computeroutput>
<computeroutput moreinfo="none">  [`Assoc</computeroutput>
<computeroutput moreinfo="none">     [("name", `String "Jason Hickey"); ("affiliation", `String "Google")];</computeroutput>
<computeroutput moreinfo="none">   `Assoc</computeroutput>
<computeroutput moreinfo="none">     [("name", `String "Anil Madhavapeddy");</computeroutput>
<computeroutput moreinfo="none">      ("affiliation", `String "Cambridge")];</computeroutput>
<computeroutput moreinfo="none">   `Assoc</computeroutput>
<computeroutput moreinfo="none">     [("name", `String "Yaron Minsky");</computeroutput>
<computeroutput moreinfo="none">      ("affiliation", `String "Jane Street")]]</computeroutput></programlisting>

    <para>The final use of JSON combinators is to extract all the <literal moreinfo="none">name</literal> fields from the list of authors. We first
    construct the <literal moreinfo="none">author list</literal>, and then
    <literal moreinfo="none">map</literal> it into a <literal moreinfo="none">string list</literal>. Notice that the example explicitly
    binds <literal moreinfo="none">authors</literal> to a variable name. It
    can also be written more succinctly using the pipe-forward
    operator:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/json/parse_book.topscript">OCaml utop</ulink>
    (part 5)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let names =</userinput>
<userinput moreinfo="none">  json |&gt; member "authors" |&gt; to_list </userinput>
<userinput moreinfo="none">  |&gt; List.map ~f:(fun json -&gt; member "name" json |&gt; to_string) ;;</userinput>
<computeroutput moreinfo="none">val names : string list =</computeroutput>
<computeroutput moreinfo="none">  ["Jason Hickey"; "Anil Madhavapeddy"; "Yaron Minsky"]</computeroutput></programlisting>

    <para>This style of programming, which omits variable names and chains functions together, is
      known as <emphasis>point-free programming</emphasis>. It's a succinct style but shouldn't be
      overused due to the increased difficulty of debugging intermediate values. If an explicit
        <phrase role="keep-together">name</phrase> is assigned to each stage of the transformations,
      debuggers in particular have an easier time making the program flow simpler to represent to
      the programmer.</para>

    <para>This technique of using statically typed parsing functions is very powerful in combination
      with the OCaml type system. Many errors that don't make sense at runtime (for example, mixing
      up lists and objects) will be caught statically via a type error.<indexterm class="endofrange" startref="JSONselval"/><indexterm class="endofrange" startref="VALjson"/></para>
  </sect1>

  <sect1 id="constructing-json-values">
    <title>Constructing JSON Values</title>

    <para>Building and printing JSON values is pretty straightforward given
    the <literal moreinfo="none">Yojson.Basic.json</literal> type. You can
    just construct values of type <literal moreinfo="none">json</literal> and
    call the <literal moreinfo="none">to_string</literal> function on them.
    Let's remind ourselves of the <literal moreinfo="none">Yojson.Basic.json</literal> type again:<indexterm class="singular">
        <primary>values</primary>

        <secondary sortas="JSON">in JSON data</secondary>
      </indexterm><indexterm class="singular">
        <primary>JSON data</primary>

        <secondary>constructing values</secondary>
      </indexterm></para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/json/yojson_basic.mli">OCaml</ulink></para>

    <programlisting format="linespecific" language="ocaml">type json = [
  | `Assoc of (string * json) list
  | `Bool of bool
  | `Float of float
  | `Int of int
  | `List of json list
  | `Null
  | `String of string
]</programlisting>

    <para>We can directly build a JSON value against this type and use the
    pretty-printing functions in the <literal moreinfo="none">Yojson.Basic</literal> module to display JSON
    output:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/json/build_json.topscript">OCaml utop</ulink>
    (part 1)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let person = `Assoc [ ("name", `String "Anil") ] ;;</userinput>
<computeroutput moreinfo="none">val person : [&gt; `Assoc of (string * [&gt; `String of string ]) list ] =</computeroutput>
<computeroutput moreinfo="none">  `Assoc [("name", `String "Anil")]</computeroutput></programlisting>

    <para>In the preceding example, we've constructed a simple JSON object
    that represents a single person. We haven't actually defined the type of
    <literal moreinfo="none">person</literal> explicitly, as we're relying on
    the magic of polymorphic variants to make this all work.</para>

    <para>The OCaml type system infers a type for <literal moreinfo="none">person</literal> based on how you construct its value. In
    this case, only the <literal moreinfo="none">Assoc</literal> and <literal moreinfo="none">String</literal> variants are used to define the record,
    and so the inferred type only contains these fields without knowledge of
    the other possible allowed variants in JSON records that you haven't used
    yet (e.g. <literal moreinfo="none">Int</literal> or <literal moreinfo="none">Null</literal>):</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/json/build_json.topscript">OCaml utop</ulink>
    (part 2)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">Yojson.Basic.pretty_to_string ;;</userinput>
<computeroutput moreinfo="none">- : ?std:bool -&gt; Yojson.Basic.json -&gt; string = &lt;fun&gt;</computeroutput></programlisting>

    <para>The <literal moreinfo="none">pretty_to_string</literal> function has
    a more explicit signature that requires an argument of type <literal moreinfo="none">Yojson.Basic.json</literal>. When <literal moreinfo="none">person</literal> is applied to <literal moreinfo="none">pretty_to_string</literal>, the inferred type of <literal moreinfo="none">person</literal> is statically checked against the
    structure of the <literal moreinfo="none">json</literal> type to ensure
    that they're compatible:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/json/build_json.topscript">OCaml utop</ulink>
    (part 3)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">Yojson.Basic.pretty_to_string person ;;</userinput>
<computeroutput moreinfo="none">- : string = "{ \"name\": \"Anil\" }"</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Yojson.Basic.pretty_to_channel stdout person ;;</userinput>
<computeroutput moreinfo="none">{ "name": "Anil" }</computeroutput>
<computeroutput moreinfo="none">- : unit = ()</computeroutput></programlisting>

    <para>In this case, there are no problems. Our <literal moreinfo="none">person</literal> value has an inferred type that is a
    valid subtype of <literal moreinfo="none">json</literal>, and so the
    conversion to a string just works without us ever having to explicitly
    specify a type for <literal moreinfo="none">person</literal>. Type
    inference lets you write more succinct code without sacrificing runtime
    reliability, as all the uses of polymorphic variants are still checked at
    compile time.<indexterm class="singular">
        <primary>errors</primary>

        <secondary>type errors</secondary>

        <seealso>error handling</seealso>
      </indexterm><indexterm class="singular">
        <primary>type checking</primary>
      </indexterm><indexterm class="singular">
        <primary>polymorphic variant types</primary>

        <secondary>type checking and</secondary>
      </indexterm><indexterm class="singular">
        <primary>type inference</primary>

        <secondary>benefits of</secondary>
      </indexterm></para>

    <sidebar>
      <title>Polymorphic Variants and Easier Type Checking</title>

      <para>One difficulty you will encounter is that type errors involving
      polymorphic variants can be quite verbose. For example, suppose you
      build an <literal moreinfo="none">Assoc</literal> and mistakenly include
      a single value instead of a list of keys:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/json/build_json.topscript">OCaml utop</ulink>
      (part 4)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let person = `Assoc ("name", `String "Anil");;</userinput>
<computeroutput moreinfo="none">val person : [&gt; `Assoc of string * [&gt; `String of string ] ] =</computeroutput>
<computeroutput moreinfo="none">  `Assoc ("name", `String "Anil")</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Yojson.Basic.pretty_to_string person ;;</userinput>
<computeroutput moreinfo="none">Characters 30-36:</computeroutput>
<computeroutput moreinfo="none">Error: This expression has type</computeroutput>
<computeroutput moreinfo="none">         [&gt; `Assoc of string * [&gt; `String of string ] ]</computeroutput>
<computeroutput moreinfo="none">       but an expression was expected of type Yojson.Basic.json</computeroutput>
<computeroutput moreinfo="none">       Types for tag `Assoc are incompatible</computeroutput></programlisting>

      <para>The type error is more verbose than it needs to be, which can be
      inconvenient to wade through for larger values. You can help the
      compiler to narrow down this error to a shorter form by adding explicit
      type annotations as a hint about your intentions:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/json/build_json.topscript">OCaml utop</ulink>
      (part 5)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let (person : Yojson.Basic.json) =</userinput>
<userinput moreinfo="none">  `Assoc ("name", `String "Anil");;</userinput>
<computeroutput moreinfo="none">Characters 37-68:</computeroutput>
<computeroutput moreinfo="none">Error: This expression has type 'a * 'b</computeroutput>
<computeroutput moreinfo="none">       but an expression was expected of type</computeroutput>
<computeroutput moreinfo="none">         (string * Yojson.Basic.json) list</computeroutput></programlisting>

      <para>We've annotated <literal moreinfo="none">person</literal> as being
      of type <literal moreinfo="none">Yojson.Basic.json</literal>, and as a
      result, the compiler spots that the argument to the <literal moreinfo="none">Assoc</literal> variant has the incorrect type. This
      illustrates the strengths and weaknesses of polymorphic variants:
      they're lightweight and flexible, but the error messages can be quite
      confusing. However, a bit of careful manual type annotation makes
      tracking down such issues much easier.</para>

      <para>We'll discuss more techniques like this that help you interpret
      type errors more easily in <xref linkend="the-compiler-frontend-parsing-and-type-checking"/>.</para>
    </sidebar>
  </sect1>

  <sect1 id="using-non-standard-json-extensions">
    <title>Using Nonstandard JSON Extensions</title>

    <para>The standard JSON types are <emphasis>really</emphasis> basic, and
    OCaml types are far more expressive. Yojson supports an extended JSON
    format for those times when you're not interoperating with external
    systems and just want a convenient human-readable, local format. The
    <literal moreinfo="none">Yojson.Safe.json</literal> type is a superset of
    the <literal moreinfo="none">Basic</literal> polymorphic variant and looks
    like this:<indexterm class="singular">
        <primary>Yojson library</primary>

        <secondary>extended JSON format support</secondary>
      </indexterm><indexterm class="singular">
        <primary>JSON data</primary>

        <secondary>nonstandard extensions for</secondary>
      </indexterm></para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/json/yojson_safe.mli">OCaml</ulink></para>

    <programlisting format="linespecific" language="ocaml">type json = [
  | `Assoc of (string * json) list
  | `Bool of bool
  | `Float of float
  | `Floatlit of string
  | `Int of int
  | `Intlit of string
  | `List of json list
  | `Null
  | `String of string
  | `Stringlit of string
  | `Tuple of json list
  | `Variant of string * json option
]</programlisting>

    <para>The <literal moreinfo="none">Safe.json</literal> type includes all
    of the variants from <literal moreinfo="none">Basic.json</literal> and
    extends it with a few more useful ones. A standard JSON type such as a
    <literal moreinfo="none">String</literal> will type-check against both the
    <literal moreinfo="none">Basic</literal> module and also the nonstandard
    <literal moreinfo="none">Safe</literal> module. If you use the extended
    values with the <literal moreinfo="none">Basic</literal> module, however,
    the compiler will reject your code until you make it compliant with the
    portable subset of JSON.</para>

    <para>Yojson supports the following JSON extensions:<indexterm class="singular">
        <primary>variant types</primary>

        <secondary>Yojson support for</secondary>
      </indexterm><indexterm class="singular">
        <primary>tuples</primary>
      </indexterm><indexterm class="singular">
        <primary>lit suffix</primary>
      </indexterm></para>

    <variablelist>
      <varlistentry>
        <term>The <literal moreinfo="none">lit</literal> suffix</term>

        <listitem>
          <para>Denotes that the value is stored as a JSON string. For
          example, a <literal moreinfo="none">Floatlit</literal> will be
          stored as <literal moreinfo="none">"1.234"</literal> instead of
          <literal moreinfo="none">1.234</literal>.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>The <literal moreinfo="none">Tuple</literal> type</term>

        <listitem>
          <para>Stored as <literal moreinfo="none">("abc", 123)</literal>
          instead of a list.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>The <literal moreinfo="none">Variant</literal> type</term>

        <listitem>
          <para>Encodes OCaml variants more explicitly, as <literal moreinfo="none">&lt;"Foo"&gt;</literal> or <literal moreinfo="none">&lt;"Bar":123&gt;</literal> for a variant with
          parameters.</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <para>The only purpose of these extensions is to have greater control over
    how OCaml values are represented in JSON (for instance, storing a
    floating-point number as a JSON string). The output still obeys the same
    standard format that can be easily exchanged with other languages.</para>

    <para>You can convert a <literal moreinfo="none">Safe.json</literal> to a
    <literal moreinfo="none">Basic.json</literal> type by using the <literal moreinfo="none">to_basic</literal> function as follows:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/json/yojson_safe.mli">OCaml</ulink>
    (part 1)</para>

    <programlisting format="linespecific" language="ocaml">val to_basic : json -&gt; Yojson.Basic.json
(** Tuples are converted to JSON arrays, Variants are converted to
    JSON strings or arrays of a string (constructor) and a json value
    (argument). Long integers are converted to JSON strings.
    Examples:

    `Tuple [ `Int 1; `Float 2.3 ]   -&gt;    `List [ `Int 1; `Float 2.3 ]
    `Variant ("A", None)            -&gt;    `String "A"
    `Variant ("B", Some x)          -&gt;    `List [ `String "B", x ]
    `Intlit "12345678901234567890"  -&gt;    `String "12345678901234567890"
 *)</programlisting>
  </sect1>

  <sect1 id="automatically-mapping-json-to-ocaml-types">
    <title>Automatically Mapping JSON to OCaml Types</title>

    <para>The combinators described previously make it easy to write functions
    that extract fields from JSON records, but the process is still pretty
    manual. When you implement larger specifications, it's much easier to
    generate the mappings from JSON schemas to OCaml values more mechanically
    than writing conversion functions individually.<indexterm class="startofrange" id="MAPjson">
        <primary>mapping</primary>

        <secondary sortas="JSON">of JSON to OCaml types</secondary>
      </indexterm><indexterm class="startofrange" id="JSONautomap">
        <primary>JSON data</primary>

        <secondary>automatic mapping of</secondary>
      </indexterm></para>

    <para>We'll cover an alternative JSON processing method that is better for
    larger-scale JSON handling now, using the <ulink url="http://mjambon.com/atd-biniou-intro.html">OCaml</ulink> tool. This will
    introduce our first <emphasis>Domain Specific Language</emphasis> that
    compiles JSON specifications into OCaml modules, which are then used
    throughout your application.<indexterm class="singular">
        <primary>ATDgen Library</primary>

        <secondary>installation of</secondary>
      </indexterm><indexterm class="singular">
        <primary>Domain Specific Language</primary>
      </indexterm></para>

    <note>
      <title>Installing the ATDgen Library and Tool</title>

      <para>ATDgen installs some OCaml libraries that interface with Yojson,
      and also a command-line tool that generates code. It can all be
      installed via OPAM:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/json/install_atdgen.out">Terminal</ulink></para>

      <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">opam install atdgen</userinput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">atdgen -version</userinput>
<computeroutput moreinfo="none">1.2.3</computeroutput></programlisting>

      <para>The command-line tool will be installed within your <filename moreinfo="none">~/.opam</filename> directory and should already be on
      your <literal moreinfo="none">PATH</literal> from running <command moreinfo="none">opam config env</command>. See <ulink url="http://realworldocaml.org/install">this Real World OCaml page</ulink> if this isn't working.</para>
    </note>

    <sect2 id="atd-basics">
      <title>ATD Basics</title>

      <para>The idea behind ATD is to specify the format of the JSON in a
      separate file and then run a compiler (<command moreinfo="none">atdgen</command>) that outputs OCaml code to construct
      and parse JSON values. This means that you don't need to write any OCaml
      parsing code at all, as it will all be autogenerated for you.<indexterm class="singular">
          <primary>ATDgen Library</primary>

          <secondary>basics of</secondary>
        </indexterm></para>

      <para>Let's go straight into looking at an example of how this works, by
      using a small portion of the GitHub API. GitHub is a popular code
      hosting and sharing website that provides a JSON-based web <ulink url="http://developer.github.com">API</ulink>. The following ATD code
      fragment describes the GitHub authorization API (which is based on a
      pseudostandard web protocol known as OAuth):<indexterm class="singular">
          <primary>GitHub API</primary>
        </indexterm><indexterm class="singular">
          <primary>OAuth web protocol</primary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/json/github.atd">OCaml</ulink></para>

      <programlisting format="linespecific" language="ocaml">type scope = [
    User &lt;json name="user"&gt;
  | Public_repo &lt;json name="public_repo"&gt;
  | Repo &lt;json name="repo"&gt;
  | Repo_status &lt;json name="repo_status"&gt;
  | Delete_repo &lt;json name="delete_repo"&gt;
  | Gist &lt;json name="gist"&gt;
]

type app = {
  name: string;
  url: string;
}  &lt;ocaml field_prefix="app_"&gt;

type authorization_request = {
  scopes: scope list;
  note: string;
} &lt;ocaml field_prefix="auth_req_"&gt;

type authorization_response = {
  scopes: scope list;
  token: string;
  app: app;
  url: string;
  id: int;
  ?note: string option;
  ?note_url: string option;
}</programlisting>

      <para>The ATD specification syntax is deliberately quite similar to
      OCaml type definitions. Every JSON record is assigned a type name (e.g.,
      <literal moreinfo="none">app</literal> in the preceding example). You
      can also define variants that are similar to OCaml's variant types
      (e.g., <literal moreinfo="none">scope</literal> in the example).</para>
    </sect2>

    <sect2 id="atd-annotations">
      <title>ATD Annotations</title>

      <para>ATD does deviate from OCaml syntax due to its support for annotations within the
        specification. The annotations can customize the code that is generated for a particular
        target (of which the OCaml backend is of most interest to us).<indexterm class="singular">
          <primary>ATDgen Library</primary>
          <secondary>annotations in</secondary>
        </indexterm></para>

      <para>For example, the preceding GitHub <literal moreinfo="none">scope</literal> field is defined as a variant type, with
      each option starting with an uppercase letter as is conventional for
      OCaml variants. However, the JSON values that come back from GitHub are
      actually lowercase and so aren't exactly the same as the option
      name.</para>

      <para>The annotation <literal moreinfo="none">&lt;json
      name="user"&gt;</literal> signals that the JSON value of the field is
      <literal moreinfo="none">user</literal>, but that the variable name of
      the parsed variant in OCaml should be <literal moreinfo="none">User</literal>. These annotations are often useful to
      map JSON values to reserved keywords in OCaml (e.g., <literal moreinfo="none">type</literal>).</para>
    </sect2>

    <sect2 id="compiling-atd-specifications-to-ocaml">
      <title>Compiling ATD Specifications to OCaml</title>

      <para>The ATD specification we defined can be compiled to OCaml code
      using the <command moreinfo="none">atdgen</command> command-line tool.
      Let's run the compiler twice to generate some OCaml type definitions and
      a JSON serializing module that converts between input data and those
      type definitions.<indexterm class="singular">
          <primary>ATDgen Library</primary>

          <secondary>compiling specifications to OCaml</secondary>
        </indexterm></para>

      <para>The <command moreinfo="none">atdgen</command> command will generate some new files in
        your current directory. <literal moreinfo="none">github_t.ml</literal> and <literal moreinfo="none">github_t.mli</literal> will contain an OCaml module with types defined
        that correspond to the ATD file:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/json/build_github_atd.out">Terminal</ulink></para>

      <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">atdgen -t github.atd</userinput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">atdgen -j github.atd</userinput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">ocamlfind ocamlc -package atd -i github_t.mli</userinput>
<computeroutput moreinfo="none">type scope =</computeroutput>
<computeroutput moreinfo="none">    [ `Delete_repo | `Gist | `Public_repo | `Repo | `Repo_status | `User ]</computeroutput>
<computeroutput moreinfo="none">type app = { app_name : string; app_url : string; }</computeroutput>
<computeroutput moreinfo="none">type authorization_request = {</computeroutput>
<computeroutput moreinfo="none">  auth_req_scopes : scope list;</computeroutput>
<computeroutput moreinfo="none">  auth_req_note : string;</computeroutput>
<computeroutput moreinfo="none">}</computeroutput>
<computeroutput moreinfo="none">type authorization_response = {</computeroutput>
<computeroutput moreinfo="none">  scopes : scope list;</computeroutput>
<computeroutput moreinfo="none">  token : string;</computeroutput>
<computeroutput moreinfo="none">  app : app;</computeroutput>
<computeroutput moreinfo="none">  url : string;</computeroutput>
<computeroutput moreinfo="none">  id : int;</computeroutput>
<computeroutput moreinfo="none">  note : string option;</computeroutput>
<computeroutput moreinfo="none">  note_url : string option;</computeroutput>
<computeroutput moreinfo="none">}</computeroutput></programlisting>

      <para>There is an obvious correspondence to the ATD definition. Note
      that field names in OCaml records in the same module cannot shadow one
      another, and so we instruct ATDgen to prefix every field with a name
      that distinguishes it from other records in the same module. For
      example, <literal moreinfo="none">&lt;ocaml
      field_prefix="auth_req_"&gt;</literal> in the ATD spec prefixes every
      field name in the generated <literal moreinfo="none">authorization_request</literal> record with <literal moreinfo="none">auth_req</literal>.</para>

      <para>The <literal moreinfo="none">Github_t</literal> module only
      contains the type definitions, while <literal moreinfo="none">Github_j</literal> provides serialization functions to
      and from JSON. You can read the <literal moreinfo="none">github_j.mli</literal> to see the full interface, but
      the important functions for most uses are the conversion functions to
      and from a string. For our preceding example, this looks like:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/json/github_j_excerpt.mli">OCaml</ulink></para>

      <programlisting format="linespecific" language="ocaml">val string_of_authorization_request :
  ?len:int -&gt; authorization_request -&gt; string
  (** Serialize a value of type {!authorization_request}
      into a JSON string.
      @param len specifies the initial length
                 of the buffer used internally.
                 Default: 1024. *)

val string_of_authorization_response :
  ?len:int -&gt; authorization_response -&gt; string
  (** Serialize a value of type {!authorization_response}
      into a JSON string.
      @param len specifies the initial length
                 of the buffer used internally.
                 Default: 1024. *)</programlisting>

      <para>This is pretty convenient! We've now written a single ATD file,
      and all the OCaml boilerplate to convert between JSON and a strongly
      typed record has been generated for us. You can control various aspects
      of the serializer by passing flags to <command moreinfo="none">atdgen</command>. The important ones for JSON
      are:<indexterm class="singular">
          <primary sortas="j-defaults">-j-defaults</primary>
        </indexterm><indexterm class="singular">
          <primary sortas="j-custom">-j-custom-fields FUNCTION</primary>
        </indexterm><indexterm class="singular">
          <primary sortas="j-std">-j-std flag</primary>
        </indexterm><indexterm class="singular">
          <primary>flags</primary>
        </indexterm></para>

      <variablelist>
        <varlistentry>
          <term><literal moreinfo="none">-j-std</literal></term>

          <listitem>
            <para>Converts tuples and variants into standard JSON and refuse
            to print NaN and infinities. You should specify this if you intend
            to interoperate with services that aren't using ATD.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal moreinfo="none">-j-custom-fields
          FUNCTION</literal></term>

          <listitem>
            <para>Calls a custom function for every unknown field encountered,
            instead of raising a parsing exception.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal moreinfo="none">-j-defaults</literal></term>

          <listitem>
            <para>Always explicitly outputs a JSON value if possible. This
            requires the default value for that field to be defined in the ATD
            specification.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>The full <ulink url="http://mjambon.com/atdgen/atdgen-manual.html">ATD
      specification</ulink> is quite sophisticated and documented online. The
      ATD compiler can also target formats other than JSON and outputs code
      for other languages (such as Java) if you need more
      interoperability.</para>

      <para>There are also several similar projects that automate the code
      generation process. <ulink url="http://piqi.org">Piqi</ulink> supports
      conversions between XML, JSON, and the Google protobuf format; and
      <ulink url="http://thrift.apache.org">Thrift</ulink> supports many other
      programming languages and includes OCaml bindings.</para>
    </sect2>

    <sect2 id="example-querying-github-organization-information">
      <title>Example: Querying GitHub Organization Information</title>

      <para>Let's finish up with an example of some live JSON parsing from
      GitHub and build a tool to query organization information via their API.
      Start by looking at the online <ulink url="http://developer.github.com/v3/orgs/">API documentation</ulink> for
      GitHub to see what the JSON schema for retrieving the organization
      information looks like.<indexterm class="singular">
          <primary>GitHub API</primary>
        </indexterm><indexterm class="singular">
          <primary>ATDgen Library</primary>

          <secondary>example of</secondary>
        </indexterm></para>

      <para>Now create an ATD file that covers the fields we need. Any extra
      fields present in the response will be ignored by the ATD parser, so we
      don't need a completely exhaustive specification of every field that
      GitHub might send back:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/json/github_org.atd">OCaml</ulink></para>

      <programlisting format="linespecific" language="ocaml">type org = {
  login: string;
  id: int;
  url: string;
  ?name: string option;
  ?blog: string option;
  ?email: string option;
  public_repos: int
}</programlisting>

      <para>Let's build the OCaml type declaration first by calling <literal moreinfo="none">atdgen -t</literal> on the specification file:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/json/generate_github_org_types.out">Terminal</ulink></para>

      <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">atdgen -t github_org.atd</userinput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">cat github_org_t.mli</userinput>
<computeroutput moreinfo="none">(* Auto-generated from "github_org.atd" *)</computeroutput>
<computeroutput moreinfo="none"> </computeroutput>
<computeroutput moreinfo="none"> </computeroutput>
<computeroutput moreinfo="none">type org = {</computeroutput>
<computeroutput moreinfo="none">  login: string;</computeroutput>
<computeroutput moreinfo="none">  id: int;</computeroutput>
<computeroutput moreinfo="none">  url: string;</computeroutput>
<computeroutput moreinfo="none">  name: string option;</computeroutput>
<computeroutput moreinfo="none">  blog: string option;</computeroutput>
<computeroutput moreinfo="none">  email: string option;</computeroutput>
<computeroutput moreinfo="none">  public_repos: int</computeroutput>
<computeroutput moreinfo="none">}</computeroutput></programlisting>

      <para>The OCaml type has an obvious mapping to the ATD spec, but we
      still need the logic to convert JSON buffers to and from this type.
      Calling <literal moreinfo="none">atdgen -j</literal> will generate this
      serialization code for us in a new file called <literal moreinfo="none">github_org_j.ml</literal>:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/json/generate_github_org_json.out">Terminal</ulink></para>

      <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">atdgen -j github_org.atd</userinput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">cat github_org_j.mli</userinput>
<computeroutput moreinfo="none">(* Auto-generated from "github_org.atd" *)</computeroutput>
<computeroutput moreinfo="none"> </computeroutput>
<computeroutput moreinfo="none"> </computeroutput>
<computeroutput moreinfo="none">type org = Github_org_t.org = {</computeroutput>
<computeroutput moreinfo="none">  login: string;</computeroutput>
<computeroutput moreinfo="none">  id: int;</computeroutput>
<computeroutput moreinfo="none">  url: string;</computeroutput>
<computeroutput moreinfo="none">  name: string option;</computeroutput>
<computeroutput moreinfo="none">  blog: string option;</computeroutput>
<computeroutput moreinfo="none">  email: string option;</computeroutput>
<computeroutput moreinfo="none">  public_repos: int</computeroutput>
<computeroutput moreinfo="none">}</computeroutput>
<computeroutput moreinfo="none"> </computeroutput>
<computeroutput moreinfo="none">val write_org :</computeroutput>
<computeroutput moreinfo="none">  Bi_outbuf.t -&gt; org -&gt; unit</computeroutput>
<computeroutput moreinfo="none">  (** Output a JSON value of type {!org}. *)</computeroutput>
<computeroutput moreinfo="none"> </computeroutput>
<computeroutput moreinfo="none">val string_of_org :</computeroutput>
<computeroutput moreinfo="none">  ?len:int -&gt; org -&gt; string</computeroutput>
<computeroutput moreinfo="none">  (** Serialize a value of type {!org}</computeroutput>
<computeroutput moreinfo="none">      into a JSON string.</computeroutput>
<computeroutput moreinfo="none">      @param len specifies the initial length</computeroutput>
<computeroutput moreinfo="none">                 of the buffer used internally.</computeroutput>
<computeroutput moreinfo="none">                 Default: 1024. *)</computeroutput>
<computeroutput moreinfo="none"> </computeroutput>
<computeroutput moreinfo="none">val read_org :</computeroutput>
<computeroutput moreinfo="none">  Yojson.Safe.lexer_state -&gt; Lexing.lexbuf -&gt; org</computeroutput>
<computeroutput moreinfo="none">  (** Input JSON data of type {!org}. *)</computeroutput>
<computeroutput moreinfo="none"> </computeroutput>
<computeroutput moreinfo="none">val org_of_string :</computeroutput>
<computeroutput moreinfo="none">  string -&gt; org</computeroutput>
<computeroutput moreinfo="none">  (** Deserialize JSON data of type {!org}. *)</computeroutput>
<computeroutput moreinfo="none"> </computeroutput></programlisting>

      <para>The <literal moreinfo="none">Github_org_j</literal> serializer
      interface contains everything we need to map to and from the OCaml types
      and JSON. The easiest way to use this interface is by using the <literal moreinfo="none">string_of_org</literal> and <literal moreinfo="none">org_of_string</literal> functions, but there are also
      more advanced low-level buffer functions available if you need higher
      performance (but we won't go into that in this tutorial).</para>

      <para>All we need to complete our example is an OCaml program that
      fetches the JSON and uses these modules to output a one-line summary.
      Our following example does just that.</para>

      <para>The following code calls the cURL command-line utility by using
      the <literal moreinfo="none">Core_extended.Shell</literal> interface to
      run an external command and capture its output. You'll need to ensure
      that you have cURL installed on your system before running the example.
      You might also need to <literal moreinfo="none">opam install
      core_extended</literal> if you haven't installed it previously:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/json/github_org_info.ml">OCaml</ulink></para>

      <programlisting format="linespecific" language="ocaml">open Core.Std

let print_org file () =
  let url = sprintf "https://api.github.com/orgs/%s" file in
  Core_extended.Shell.run_full "curl" [url]
  |&gt; Github_org_j.org_of_string
  |&gt; fun org -&gt;
  let open Github_org_t in
  let name = Option.value ~default:"???" org.name in
  printf "%s (%d) with %d public repos\n"
    name org.id org.public_repos

let () =
  Command.basic ~summary:"Print Github organization information"
    Command.Spec.(empty +&gt; anon ("organization" %: string))
    print_org
  |&gt; Command.run</programlisting>

      <para>The following is a short shell script that generates all of the
      OCaml code and also builds the final executable:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/json/build_github_org.out">Terminal</ulink></para>

      <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">atdgen -t github_org.atd</userinput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">atdgen -j github_org.atd</userinput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">corebuild -pkg core_extended,yojson,atdgen github_org_info.native</userinput></programlisting>

      <para>You can now run the command-line tool with a single argument to
      specify the name of the organization, and it will dynamically fetch the
      JSON from the web, parse it, and render the summary to your
      console:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/json/run_github_org.out">Terminal</ulink></para>

      <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">./github_org_info.native mirage</userinput>
<computeroutput moreinfo="none">Mirage account (131943) with 37 public repos</computeroutput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">./github_org_info.native janestreet</userinput>
<computeroutput moreinfo="none">??? (3384712) with 34 public repos</computeroutput></programlisting>

      <para>The JSON returned from the <literal moreinfo="none">janestreet</literal> query is missing an organization
      name, but this is explicitly reflected in the OCaml type, since the ATD
      spec marked <literal moreinfo="none">name</literal> as an optional
      field. Our OCaml code explicitly handles this case and doesn't have to
      worry about null-pointer exceptions. Similarly, the JSON integer for the
      <literal moreinfo="none">id</literal> is mapped into a native OCaml
      integer via the ATD conversion.</para>

      <para>While this tool is obviously quite simple, the ability to specify
      optional and default fields is very powerful. Take a look at the full
      ATD specification for the GitHub API in the <ulink url="http://github.com/avsm/ocaml-github"><literal moreinfo="none">ocaml-github</literal></ulink> repository online, which
      has lots of quirks typical in real-world web APIs.<indexterm class="endofrange" startref="MAPjson"/><indexterm class="endofrange" startref="JSONautomap"/><indexterm class="endofrange" startref="SERjson"/><indexterm class="endofrange" startref="DATjson"/></para>

      <para>Our example shells out to <literal moreinfo="none">curl</literal>
      on the command line to obtain the JSON, which is rather inefficient.
      We'll explain how to integrate the HTTP fetch directly into your OCaml
      application in <xref linkend="concurrent-programming-with-async"/>.</para>
    </sect2>
  </sect1>
</chapter>

    <chapter id="parsing-with-ocamllex-and-menhir">
  <title>Parsing with OCamllex and Menhir</title>

  <para>Many programming tasks start with the interpretion of some form of
  structured textual data. <emphasis>Parsing</emphasis> is the process of
  converting such data into data structures that are easy to program against.
  For simple formats, it's often enough to parse the data in an ad hoc way,
  say, by breaking up the data into lines, and then using regular expressions
  for breaking those lines down into their component pieces.</para>

  <para>But this simplistic approach tends to fall down when parsing more
  complicated data, particularly data with the kind of recursive structure you
  find in full-blown programming languages or flexible data formats like JSON
  and XML. Parsing such formats accurately and efficiently while providing
  useful error messages is a complex task.</para>

  <para>Often, you can find an existing parsing library that handles these issues for you. But there
    are tools to simplify the task when you do need to write a parser, in the form of
      <emphasis>parser generators</emphasis>. A parser generator creates a parser from a
    specification of the data format that you want to parse, and uses that to generate a
      parser.<indexterm class="singular">
      <primary>parsing</primary>
      <secondary>parser generators</secondary>
    </indexterm></para>

  <para>Parser generators have a long history, including tools like <command moreinfo="none">lex</command> and <command moreinfo="none">yacc</command> that date back to the early 1970s.
    OCaml has its own alternatives, including <command moreinfo="none">ocamllex</command>, which
    replaces <command moreinfo="none">lex</command>, and <command moreinfo="none">ocamlyacc</command> and <command moreinfo="none">menhir</command>, which replace <command moreinfo="none">yacc</command>. We'll explore these tools in the course of walking through the
    implementation of a parser for the JSON serialization format that we discussed in <xref linkend="handling-json-data"/>.</para>

  <para>Parsing is a broad and often intricate topic, and our purpose here is
  not to teach all of the theoretical issues, but to provide a pragmatic
  introduction of how to build a parser in OCaml.<indexterm class="singular">
      <primary>ocamlyacc parser generator</primary>
    </indexterm><indexterm class="singular">
      <primary>Menhir parser generator</primary>

      <secondary sortas="ocamlyacc">vs. ocamlyacc</secondary>
    </indexterm></para>

  <note>
    <title>Menhir Versus ocamlyacc</title>

    <para>Menhir is an alternative parser generator that is generally superior
    to the venerable <command moreinfo="none">ocamlyacc</command>, which dates
    back quite a few years. Menhir is mostly compatible with <command moreinfo="none">ocamlyacc</command> grammars, and so you can usually just
    switch to Menhir and expect older code to work (with some minor
    differences described in the Menhir manual).</para>

    <para>The biggest advantage of Menhir is that its error messages are
    generally more human-comprehensible, and the parsers that it generates are
    fully reentrant and can be parameterized in OCaml modules more easily. We
    recommend that any new code you develop should use Menhir instead of
    <command moreinfo="none">ocamlyacc</command>.</para>

    <para>Menhir isn't distributed directly with OCaml but is available
    through OPAM by running <literal moreinfo="none">opam install
    menhir</literal>.</para>
  </note>

  <sect1 id="lexing-and-parsing">
    <title>Lexing and Parsing</title>

    <para>Parsing is traditionally broken down into two parts:
    <emphasis>lexical analysis</emphasis>, which is a kind of simplified
    parsing phase that converts a stream of characters into a stream of
    logical tokens; and full-on parsing, which involves converting a stream of
    tokens into the final representation, which is often in the form of a
    tree-like data structure called an <emphasis>abstract syntax
    tree</emphasis>, or AST.<indexterm class="singular">
        <primary>AST (abstract syntax-tree)</primary>
      </indexterm><indexterm class="singular">
        <primary>lexical analysis (lexing)</primary>
      </indexterm></para>

    <para>It's confusing that the term parsing is applied to both the overall
    process of converting textual data to structured data, and also more
    specifically to the second phase of converting a stream of tokens to an
    AST; so from here on out, we'll use the term parsing to refer only to this
    second phase.</para>

    <para>Let's consider lexing and parsing in the context of the JSON format. Here's a snippet of
      text that represents a JSON object containing a string labeled <literal moreinfo="none">title</literal> and an array containing two objects, each with a name and array of zip
      codes:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/parsing/example.json">JSON</ulink></para>

    <programlisting format="linespecific" language="json">{
  "title": "Cities",
  "cities": [
    { "name": "Chicago",  "zips": [60601] },
    { "name": "New York", "zips": [10004] } 
  ]
}</programlisting>

    <para>At a syntactic level, we can think of a JSON file as a series of
    simple logical units, like curly braces, square brackets, commas, colons,
    identifiers, numbers, and quoted strings. Thus, we could represent our
    JSON text as a sequence of tokens of the following type:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/parsing/manual_token_type.ml">OCaml</ulink></para>

    <programlisting format="linespecific" language="ocaml">type token =
  | NULL
  | TRUE
  | FALSE
  | STRING of string
  | INT of int
  | FLOAT of float
  | ID of string
  | LEFT_BRACK
  | RIGHT_BRACK
  | LEFT_BRACE
  | RIGHT_BRACE
  | COMMA
  | COLON
  | EOF</programlisting>

    <para>Note that this representation loses some information about the
    original text. For example, whitespace is not represented. It's common,
    and indeed useful, for the token stream to forget some details of the
    original text that are not required for understanding its meaning.</para>

    <para>If we converted the preceding example into a list of these tokens,
    it would look something like this:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/parsing/tokens.ml">OCaml</ulink></para>

    <programlisting format="linespecific" language="ocaml">[ LEFT_BRACE; ID("title"); COLON; STRING("Cities"); COMMA; ID("cities"); ...</programlisting>

    <para>This kind of representation is easier to work with than the original
    text, since it gets rid of some unimportant syntactic details and adds
    useful structure. But it's still a good deal more low-level than the
    simple AST we used for representing JSON data in <xref linkend="handling-json-data"/>:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/parsing/json.ml">OCaml</ulink></para>

    <programlisting format="linespecific" language="ocaml">type value = [
  | `Assoc of (string * value) list
  | `Bool of bool
  | `Float of float
  | `Int of int
  | `List of value list
  | `Null
  | `String of string
]</programlisting>

    <para>This representation is much richer than our token stream, capturing the fact that JSON
      values can be nested inside each other and that JSON has a variety of value types, including
      numbers, strings, arrays, and objects. The parser we'll write will convert a token stream into
      a value of this AST type, as shown below for our earlier JSON example:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/parsing/parsed_example.ml">OCaml</ulink></para>

    <programlisting format="linespecific" language="ocaml">`Assoc
  ["title", `String "Cities";
   "cities", `List
     [`Assoc ["name", `String "Chicago"; "zips", `List [`Int 60601]];
      `Assoc ["name", `String "New York"; "zips", `List [`Int 10004]]]]</programlisting>
  </sect1>

  <sect1 id="defining-a-parser">
    <title>Defining a Parser</title>

    <para>A parser-specification file has suffix <literal moreinfo="none">.mly</literal> and
      contains two sections that are broken up by separator lines consisting of the characters
        <literal moreinfo="none">%%</literal> on a line by themselves. The first section of the file
      is for declarations, including token and type specifications, precedence directives, and other
      output directives; and the second section is for specifying the grammar of the language to be
        parsed.<indexterm class="singular">
        <primary>files</primary>
        <secondary>mly files</secondary>
      </indexterm><indexterm class="startofrange" id="PARSparsdef">
        <primary>parsing</primary>
        <secondary>parser definition</secondary>
      </indexterm></para>

    <para>We'll start by declaring the list of tokens. A token is declared
    using the syntax <literal moreinfo="none">%token
    &lt;</literal><replaceable>type</replaceable><literal moreinfo="none">&gt;</literal> <replaceable>uid</replaceable>, where the
    <replaceable>&lt;type&gt;</replaceable> is optional and
    <replaceable>uid</replaceable> is a capitalized identifier. For JSON, we
    need tokens for numbers, strings, identifiers, and punctuation:<indexterm class="singular">
        <primary>tokens, declaration of</primary>
      </indexterm></para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/parsing/parser.mly">OCaml</ulink></para>

    <programlisting format="linespecific" language="ocaml">%token &lt;int&gt; INT
%token &lt;float&gt; FLOAT
%token &lt;string&gt; ID
%token &lt;string&gt; STRING
%token TRUE
%token FALSE
%token NULL
%token LEFT_BRACE
%token RIGHT_BRACE
%token LEFT_BRACK
%token RIGHT_BRACK
%token COLON
%token COMMA
%token EOF</programlisting>

    <para>The <literal moreinfo="none">&lt;</literal><replaceable>type</replaceable><literal moreinfo="none">&gt;</literal> specifications mean that a token carries a
    value. The <literal moreinfo="none">INT</literal> token carries an integer
    value with it, <literal moreinfo="none">FLOAT</literal> has a <literal moreinfo="none">float</literal> value, and <literal moreinfo="none">STRING</literal> carries a <literal moreinfo="none">string</literal> value. The remaining tokens, such as
    <literal moreinfo="none">TRUE</literal>, <literal moreinfo="none">FALSE</literal>, or the punctuation, aren't associated
    with any value, and so we can omit the <literal moreinfo="none">&lt;</literal><replaceable>type</replaceable><literal moreinfo="none">&gt;</literal> specification.</para>

    <sect2 id="describing-the-grammar">
      <title>Describing the Grammar</title>

      <para>The next thing we need to do is to specify the grammar of a JSON expression. <command moreinfo="none">menhir</command>, like many parser generators, expresses grammars as
          <emphasis>context-free grammars</emphasis>. (More precisely, <command moreinfo="none">menhir</command> supports LR(1) grammars, but we will ignore that technical distinction
        here.) You can think of a context-free grammar as a set of abstract names, called
          <emphasis>non-terminal symbols</emphasis>, along with a collection of rules for
        transforming a nonterminal symbol into a sequence of tokens and nonterminal symbols. A
        sequence of tokens is parsable by a grammar if you can apply the grammar's rules to produce
        a series of transformations, starting at a distinguished <emphasis>start symbol</emphasis>
        that produces the token sequence in <phrase role="keep-together">question</phrase>.<indexterm class="singular">
          <primary>grammars</primary>
          <secondary>context-free</secondary>
        </indexterm><indexterm class="singular">
          <primary>LR(1) grammars</primary>
        </indexterm><indexterm class="singular">
          <primary>start symbols</primary>
        </indexterm><indexterm class="singular">
          <primary>non-terminal symbols</primary>
        </indexterm><indexterm class="singular">
          <primary>context-free grammars</primary>
        </indexterm><indexterm class="singular">
          <primary>Menhir parser generator</primary>
          <secondary>context-free grammars in</secondary>
        </indexterm></para>

      <para>We'll start describing the JSON grammar by declaring the start
      symbol to be the non-terminal symbol <literal moreinfo="none">prog</literal>, and by declaring that when parsed, a
      <literal moreinfo="none">prog</literal> value should be converted into
      an OCaml value of type <literal moreinfo="none">Json.value
      option</literal>. We then end the declaration section of the parser with
      a <literal moreinfo="none">%%</literal>:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/parsing/parser.mly">OCaml</ulink> (part 1)</para>

      <programlisting format="linespecific" language="ocaml">%start &lt;Json.value option&gt; prog
%%</programlisting>

      <para>Once that's in place, we can start specifying the productions. In <command moreinfo="none">menhir</command>, productions are organized into
          <emphasis>rules</emphasis>, where each rule lists all the possible productions for a given
        nonterminal symbols. Here, for example, is the rule for <literal moreinfo="none">prog</literal>:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/parsing/parser.mly">OCaml</ulink> (part 2)</para>

      <programlisting format="linespecific" language="ocaml">prog:
  | EOF       { None }
  | v = value { Some v }
  ;</programlisting>

      <para>The syntax for this is reminiscent of an OCaml <literal>match</literal> statement. The
        pipes separate the individual productions, and the curly braces contain a <emphasis>semantic
          action</emphasis>: OCaml code that generates the OCaml value corresponding to the
        production in question. Semantic actions are arbitrary OCaml expressions that are evaluated
        during parsing to produce values that are attached to the non-terminal in the
          rule.<indexterm class="singular">
          <primary>semantic actions</primary>
        </indexterm><indexterm class="singular">
          <primary>curly braces ({ })</primary>
        </indexterm></para>

      <para>We have two cases for <literal>prog</literal>: either there's an <literal moreinfo="none">EOF</literal>, which means the text is empty, and so there's no JSON value
        to read, we return the OCaml value <literal moreinfo="none">None</literal>; or we have an
        instance of the <literal moreinfo="none">value</literal> nonterminal, which corresponds to a
        well-formed JSON value, and we wrap the corresponding <literal moreinfo="none">Json.value</literal> in a <literal moreinfo="none">Some</literal> tag. Note that in the
          <literal moreinfo="none">value</literal> case, we wrote <literal moreinfo="none">v =
          value</literal> to bind the OCaml value that corresponds to the variable <literal moreinfo="none">v</literal>, which we can then use within the curly braces for that
        production.</para>

      <para>Now let's consider a more complex example, the rule for the <literal moreinfo="none">value</literal> symbol:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/parsing/parser.mly">OCaml</ulink> (part 3)</para>

      <programlisting format="linespecific" language="ocaml">value:
  | LEFT_BRACE; obj = object_fields; RIGHT_BRACE
    { `Assoc obj }
  | LEFT_BRACK; vl = array_values; RIGHT_BRACK
    { `List vl }
  | s = STRING
    { `String s }
  | i = INT
    { `Int i }
  | x = FLOAT
    { `Float x }
  | TRUE
    { `Bool true }
  | FALSE
    { `Bool false }
  | NULL
    { `Null }
  ;</programlisting>

      <para>According to these rules, a JSON <literal moreinfo="none">value</literal> is either:<indexterm class="singular">
          <primary>values</primary>

          <secondary sortas="JSON">in JSON data</secondary>
        </indexterm></para>

      <itemizedlist>
        <listitem>
          <para>An object bracketed by curly braces</para>
        </listitem>

        <listitem>
          <para>An array bracketed by square braces</para>
        </listitem>

        <listitem>
          <para>A string, integer, float, bool, or null value</para>
        </listitem>
      </itemizedlist>

      <para>In each of the productions, the OCaml code in curly braces shows
      what to transform the object in question to. Note that we still have two
      nonterminals whose definitions we depend on here but have not yet
      defined: <literal moreinfo="none">object_fields</literal> and <literal moreinfo="none">array_values</literal>. We'll look at how these are
      parsed next.</para>
    </sect2>

    <sect2 id="parsing-sequences">
      <title>Parsing Sequences</title>

      <para>The rule for <literal moreinfo="none">object_fields</literal>
      follows, and is really just a thin wrapper that reverses the list
      returned by the following rule for <literal moreinfo="none">rev_object_fields</literal>. Note that the first
      production in <literal moreinfo="none">rev_object_fields</literal> has
      an empty lefthand side, because what we're matching on in this case is
      an empty sequence of tokens. The comment <literal moreinfo="none">(*
      empty *)</literal> is used to make this clear:<indexterm class="singular">
          <primary>rev_object_fields</primary>
        </indexterm><indexterm class="singular">
          <primary>object_fields</primary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/parsing/parser.mly">OCaml</ulink> (part 4)</para>

      <programlisting format="linespecific" language="ocaml">object_fields: obj = rev_object_fields { List.rev obj };

rev_object_fields:
  | (* empty *) { [] }
  | obj = rev_object_fields; COMMA; k = ID; COLON; v = value
    { (k, v) :: obj }
  ;</programlisting>

      <para>The rules are structured as they are because <command moreinfo="none">menhir</command> generates left-recursive parsers, which
      means that the constructed pushdown automaton uses less stack space with
      left-recursive definitions. The following right-recursive rule accepts
      the same input, but during parsing, it requires linear stack space to
      read object field definitions:<indexterm class="singular">
          <primary>Menhir parser generator</primary>

          <secondary>left-recursive definitions</secondary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/parsing/right_rec_rule.mly">OCaml</ulink> (part 4)</para>

      <programlisting format="linespecific" language="ocaml">(* Inefficient right-recursive rule *)
object_fields:
  | (* empty *) { [] }
  | k = ID; COLON; v = value; COMMA; obj = object_fields
    { (k, v) :: obj }</programlisting>

      <para>Alternatively, we could keep the left-recursive definition and
      simply construct the returned value in left-to-right order. This is even
      less efficient, since the complexity of building the list incrementally
      in this way is quadratic in the length of the list:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/parsing/quadratic_rule.mly">OCaml</ulink> (part 4)</para>

      <programlisting format="linespecific" language="ocaml">(* Quadratic left-recursive rule *)
object_fields:
  | (* empty *) { [] }
  | obj = object_fields; COMMA; k = ID; COLON; v = value
    { obj @ [k, v] }
  ;</programlisting>

      <para>Assembling lists like this is a pretty common requirement in most
      realistic grammars, and the preceding rules (while useful for
      illustrating how parsing works) are rather verbose. Menhir features an
      extended standard library of built-in rules to simplify this handling.
      These rules are detailed in the Menhir manual and include optional
      values, pairs of values with optional separators, and lists of elements
      (also with optional separators).<indexterm class="singular">
          <primary>Menhir parser generator</primary>

          <secondary>built-in rules of</secondary>
        </indexterm></para>

      <para>A version of the JSON grammar using these more succinct Menhir
      rules follows. Notice the use of <literal moreinfo="none">separated_list</literal> to parse both JSON objects and
      lists with one rule:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/parsing/short_parser.mly">OCaml</ulink> (part 1)</para>

      <programlisting format="linespecific" language="ocaml">prog:
  | v = value { Some v }
  | EOF       { None   } ;

value:
  | LEFT_BRACE; obj = obj_fields; RIGHT_BRACE { `Assoc obj  }
  | LEFT_BRACK; vl = list_fields; RIGHT_BRACK { `List vl    }
  | s = STRING                                { `String s   }
  | i = INT                                   { `Int i      }
  | x = FLOAT                                 { `Float x    }
  | TRUE                                      { `Bool true  }
  | FALSE                                     { `Bool false }
  | NULL                                      { `Null       } ;

obj_fields:
    obj = separated_list(COMMA, obj_field)    { obj } ;

obj_field:
    k = STRING; COLON; v = value              { (k, v) } ;

list_fields:
    vl = separated_list(COMMA, value)         { vl } ;</programlisting>

      <para>We can invoke <command moreinfo="none">menhir</command> by using
      <command moreinfo="none">corebuild</command> with the <literal moreinfo="none">-use-menhir</literal> flag. This tells the build system
      to switch to using <command moreinfo="none">menhir</command> instead of
      <command moreinfo="none">ocamlyacc</command> to handle files with the
      <literal moreinfo="none">.mly</literal> suffix:<indexterm class="singular">
          <primary sortas="use">-use-menhir flag</primary>
        </indexterm><indexterm class="singular">
          <primary>Menhir parser generator</primary>

          <secondary>invoking</secondary>
        </indexterm><indexterm class="endofrange" startref="PARSparsdef"/></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/parsing/build_short_parser.out">Terminal</ulink></para>

      <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">corebuild -use-menhir short_parser.mli</userinput>
</programlisting>
    </sect2>
  </sect1>

  <sect1 id="defining-a-lexer">
    <title>Defining a Lexer</title>

    <para>Now we can define a lexer, using <command moreinfo="none">ocamllex</command>, to convert our input text into a
    stream of tokens. The specification of the lexer is placed in a file with
    an <literal moreinfo="none">.mll</literal> suffix.<indexterm class="singular">
        <primary>lexers</primary>

        <secondary>specification of</secondary>
      </indexterm><indexterm class="singular">
        <primary>OCaml toolchain</primary>

        <secondary>ocamllex</secondary>
      </indexterm><indexterm class="singular">
        <primary>mll files</primary>
      </indexterm><indexterm class="singular">
        <primary>files</primary>

        <secondary>mll files</secondary>
      </indexterm><indexterm class="startofrange" id="PARlex">
        <primary>parsing</primary>

        <secondary>lexer definition</secondary>
      </indexterm></para>

    <sect2 id="ocaml-prelude">
      <title>OCaml Prelude</title>

      <para>Let's walk through the definition of a lexer section by section.
      The first section is on optional chunk of OCaml code that is bounded by
      a pair of curly braces:<indexterm class="singular">
          <primary>lexers</primary>

          <secondary>optional OCaml code for</secondary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/parsing/lexer.mll">OCaml</ulink></para>

      <programlisting format="linespecific" language="ocaml">{
open Lexing
open Parser

exception SyntaxError of string

let next_line lexbuf =
  let pos = lexbuf.lex_curr_p in
  lexbuf.lex_curr_p &lt;-
    { pos with pos_bol = lexbuf.lex_curr_pos;
               pos_lnum = pos.pos_lnum + 1
    }
}</programlisting>

      <para>This code is there to define utility functions used by later
      snippets of OCaml code and to set up the environment by opening useful
      modules and define an exception, <literal moreinfo="none">SyntaxError</literal>.</para>

      <para>We also define a utility function <literal moreinfo="none">next_line</literal> for tracking the location of tokens
      across line breaks. The <literal moreinfo="none">Lexing</literal> module
      defines a <literal moreinfo="none">lexbuf</literal> structure that holds
      the state of the lexer, including the current location within the source
      file. The <literal moreinfo="none">next_line</literal> function simply
      accesses the <literal moreinfo="none">lex_curr_p</literal> field that
      holds the current location and updates its line number.</para>
    </sect2>

    <sect2 id="regular-expressions">
      <title>Regular Expressions</title>

      <para>The next section of the lexing file is a collection of named
      regular expressions. These look syntactically like ordinary OCaml
      <literal moreinfo="none">let</literal> bindings, but really this is a
      specialized syntax for declaring regular expressions. Here's an
      example:<indexterm class="singular">
          <primary>regular expressions</primary>
        </indexterm><indexterm class="singular">
          <primary>lexers</primary>

          <secondary>regular expressions collection</secondary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/parsing/lexer.mll">OCaml</ulink> (part 1)</para>

      <programlisting format="linespecific" language="ocaml">let int = '-'? ['0'-'9'] ['0'-'9']*</programlisting>

      <para>The syntax here is something of a hybrid between OCaml syntax and
      traditional regular expression syntax. The <literal moreinfo="none">int</literal> regular expression specifies an optional
      leading <literal moreinfo="none">-</literal>, followed by a digit from
      <literal moreinfo="none">0</literal> to <literal moreinfo="none">9</literal>, followed by some number of digits from
      <literal moreinfo="none">0</literal> to <literal moreinfo="none">9</literal>. The question mark is used to indicate an
      optional component of a regular expression; the square brackets are used
      to specify ranges; and the <literal moreinfo="none">*</literal> operator
      is used to indicate a (possibly empty) repetition.</para>

      <para>Floating-point numbers are specified similarly, but we deal with
      decimal points and exponents. We make the expression easier to read by
      building up a sequence of named regular expressions, rather than
      creating one big and impenetrable expression:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/parsing/lexer.mll">OCaml</ulink> (part 2)</para>

      <programlisting format="linespecific" language="ocaml">let digit = ['0'-'9']
let frac = '.' digit*
let exp = ['e' 'E'] ['-' '+']? digit+
let float = digit* frac? exp?</programlisting>

      <para>Finally, we define whitespace, newlines, and identifiers:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/parsing/lexer.mll">OCaml</ulink> (part 3)</para>

      <programlisting format="linespecific" language="ocaml">let white = [' ' '\t']+
let newline = '\r' | '\n' | “\r\n”
let id = ['a'-'z' 'A'-'Z' '_'] ['a'-'z' 'A'-'Z' '0'-'9' '_']*</programlisting>

      <para>The <literal moreinfo="none">newline</literal> introduces the
      <literal moreinfo="none">|</literal> operator, which lets one of several
      alternative regular expressions match (in this case, the various
      carriage-return combinations of CR, LF, or CRLF).</para>
    </sect2>

    <sect2 id="lexing-rules">
      <title>Lexing Rules</title>

      <para>The lexing rules are essentially functions that consume the data,
      producing OCaml expressions that evaluate to tokens. These OCaml
      expressions can be quite complicated, using side effects and invoking
      other rules as part of the body of the rule. Let's look at the <literal moreinfo="none">read</literal> rule for parsing a JSON
      expression:<indexterm class="singular">
          <primary>lexers</primary>

          <secondary>rules for</secondary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/parsing/lexer.mll">OCaml</ulink> (part 4)</para>

      <programlisting format="linespecific" language="ocaml">rule read =
  parse
  | white    { read lexbuf }
  | newline  { next_line lexbuf; read lexbuf }
  | int      { INT (int_of_string (Lexing.lexeme lexbuf)) }
  | float    { FLOAT (float_of_string (Lexing.lexeme lexbuf)) }
  | "true"   { TRUE }
  | "false"  { FALSE }
  | "null"   { NULL }
  | '"'      { read_string (Buffer.create 17) lexbuf }
  | '{'      { LEFT_BRACE }
  | '}'      { RIGHT_BRACE }
  | '['      { LEFT_BRACK }
  | ']'      { RIGHT_BRACK }
  | ':'      { COLON }
  | ','      { COMMA }
  | _ { raise (SyntaxError ("Unexpected char: " ^ Lexing.lexeme lexbuf)) }
  | eof      { EOF }</programlisting>

      <para>The rules are structured very similarly to pattern matches, except
      that the variants are replaced by regular expressions on the lefthand
      side. The righthand-side clause is the parsed OCaml return value of that
      rule. The OCaml code for the rules has a parameter called <literal moreinfo="none">lexbuf</literal> that defines the input, including the
      position in the input file, as well as the text that was matched by the
      regular expression.<indexterm class="singular">
          <primary>pattern matching</primary>

          <secondary>vs. lexing rules</secondary>
        </indexterm></para>

      <para>The first <literal moreinfo="none">white { read lexbuf }</literal>
      calls the lexer recursively. That is, it skips the input whitespace and
      returns the following token. The action <literal moreinfo="none">newline
      { next_line lexbuf; read lexbuf }</literal> is similar, but we use it to
      advance the line number for the lexer using the utility function that we
      defined at the top of the file. Let's skip to the third action:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/parsing/lexer_int_fragment.mll">OCaml</ulink></para>

      <programlisting format="linespecific" language="ocaml">| int { INT (int_of_string (Lexing.lexeme lexbuf)) }</programlisting>

      <para>This action specifies that when the input matches the <literal moreinfo="none">int</literal> regular expression, then the lexer should
      return the expression <literal moreinfo="none">INT (int_of_string
      (Lexing.lexeme lexbuf))</literal>. The expression <literal moreinfo="none">Lexing.lexeme lexbuf</literal> returns the complete
      string matched by the regular expression. In this case, the string
      represents a number, so we use the <literal moreinfo="none">int_of_string</literal> function to convert it to a
      number.</para>

      <para>There are actions for each different kind of token. The string
      expressions like <literal moreinfo="none">"true" { TRUE }</literal> are
      used for keywords, and the special characters have actions, too, like
      <literal moreinfo="none">'{' { LEFT_BRACE }</literal>.</para>

      <para>Some of these patterns overlap. For example, the regular
      expression <literal moreinfo="none">"true"</literal> is also matched by
      the <literal moreinfo="none">id</literal> pattern. <command moreinfo="none">ocamllex</command> used the following disambiguation
      when a prefix of the input is matched by more than one pattern:</para>

      <itemizedlist>
        <listitem>
          <para>The longest match always wins. For example, the first input
          <literal moreinfo="none">trueX: 167</literal> matches the regular
          expression <literal moreinfo="none">"true"</literal> for four
          characters, and it matches <literal moreinfo="none">id</literal> for
          five characters. The longer match wins, and the return value is
          <literal moreinfo="none">ID "trueX"</literal>.</para>
        </listitem>

        <listitem>
          <para>If all matches have the same length, then the first action
          wins. If the input were <literal moreinfo="none">true:
          167</literal>, then both <literal moreinfo="none">"true"</literal>
          and <literal moreinfo="none">id</literal> match the first four
          characters; <literal moreinfo="none">"true"</literal> is first, so
          the return value is <literal moreinfo="none">TRUE</literal>.</para>
        </listitem>
      </itemizedlist>
    </sect2>

    <sect2 id="recursive-rules">
      <title>Recursive Rules</title>

      <para>Unlike many other lexer generators, <command moreinfo="none">ocamllex</command> allows the definition of multiple
      lexers in the same file, and the definitions can be recursive. In this
      case, we use recursion to match string literals using the following rule
      definition:<indexterm class="singular">
          <primary>recursion</primary>

          <secondary>in lexers</secondary>
        </indexterm><indexterm class="singular">
          <primary>lexers</primary>

          <secondary>recursive rules</secondary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/parsing/lexer.mll">OCaml</ulink> (part 5)</para>

      <programlisting format="linespecific" language="ocaml">and read_string buf =
  parse
  | '"'       { STRING (Buffer.contents buf) }
  | '\\' '/'  { Buffer.add_char buf '/'; read_string buf lexbuf }
  | '\\' '\\' { Buffer.add_char buf '\\'; read_string buf lexbuf }
  | '\\' 'b'  { Buffer.add_char buf '\b'; read_string buf lexbuf }
  | '\\' 'f'  { Buffer.add_char buf '\012'; read_string buf lexbuf }
  | '\\' 'n'  { Buffer.add_char buf '\n'; read_string buf lexbuf }
  | '\\' 'r'  { Buffer.add_char buf '\r'; read_string buf lexbuf }
  | '\\' 't'  { Buffer.add_char buf '\t'; read_string buf lexbuf }
  | [^ '"' '\\']+
    { Buffer.add_string buf (Lexing.lexeme lexbuf);
      read_string buf lexbuf
    }
  | _ { raise (SyntaxError ("Illegal string character: " ^ Lexing.lexeme lexbuf)) }
  | eof { raise (SyntaxError ("String is not terminated")) }</programlisting>

      <para>This rule takes a <literal moreinfo="none">buf :
      Buffer.t</literal> as an argument. If we reach the terminating double
      quote <literal moreinfo="none">"</literal>, then we return the contents
      of the buffer as a <literal moreinfo="none">STRING</literal>.</para>

      <para>The other cases are for handling the string contents. The action
      <literal moreinfo="none">[^ '"' '\\']+ { ... }</literal> matches normal
      input that does not contain a double quote or backslash. The actions
      beginning with a backslash <literal moreinfo="none">\</literal> define
      what to do for escape sequences. In each of these cases, the final step
      includes a recursive call to the lexer.</para>

      <para>That covers the lexer. Next, we need to combine the lexer with the
      parser to bring it all together.<indexterm class="singular">
          <primary>lexers</primary>

          <secondary>Unicode parsing</secondary>
        </indexterm><indexterm class="singular">
          <primary>Uutf Unicode codec</primary>
        </indexterm><indexterm class="singular">
          <primary>OCaml toolchain</primary>

          <secondary>ocamllex</secondary>
        </indexterm><indexterm class="singular">
          <primary>Ulex lexer generator</primary>
        </indexterm><indexterm class="singular">
          <primary>Camomile unicode parser</primary>
        </indexterm><indexterm class="singular">
          <primary>Unicode, parsing solutions for</primary>
        </indexterm></para>

      <note>
        <title>Handling Unicode</title>

        <para>We've glossed over an important detail here: parsing Unicode
        characters to handle the full spectrum of the world's writing systems.
        OCaml has several third-party solutions to handling Unicode, with
        varying degrees of flexibility and complexity:</para>

        <itemizedlist>
          <listitem>
            <para><ulink url="http://camomile.sourceforge.net">Camomile</ulink> supports
            the full spectrum of Unicode character types, conversion from
            around 200 encodings, and collation and locale-sensitive case
            mappings.</para>
          </listitem>

          <listitem>
            <para><ulink url="http://www.cduce.org/ulex">Ulex</ulink> is a
            lexer generator for Unicode that can serve as a Unicode-aware
            replacement for <command moreinfo="none">ocamllex</command>.</para>
          </listitem>

          <listitem>
            <para><ulink url="http://erratique.ch/software/uutf">Uutf</ulink>
            is a nonblocking streaming Unicode codec for OCaml, available as a
            standalone library. It is accompanied by the <ulink url="http://erratique.ch/software/uunf">Uunf</ulink> text
            normalization and <ulink url="http://erratique.ch/software/uucd">Uucd</ulink> Unicode
            character database libraries. There is also a robust parser for
            <ulink url="http://erratique.ch/software/jsonm">JSON</ulink>
            available that illustrates the use of Uutf in your own
            libraries.</para>
          </listitem>
        </itemizedlist>

        <para>All of these libraries are available via OPAM under their
        respective names.<indexterm class="endofrange" startref="PARlex"/></para>
      </note>
    </sect2>
  </sect1>

  <sect1 id="bringing-it-all-together">
    <title>Bringing It All Together</title>

    <para>For the final part, we need to compose the lexer and parser. As we saw in the type
      definition in <literal moreinfo="none">parser.mli</literal>, the parsing function expects a
      lexer of type <literal moreinfo="none">Lexing.lexbuf -&gt; token</literal>, and a <literal moreinfo="none">lexbuf</literal>:<indexterm class="singular">
        <primary>parsing</primary>
        <secondary>lexer and parser composition</secondary>
      </indexterm></para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/parsing/prog.mli">OCaml</ulink></para>

    <programlisting format="linespecific" language="ocaml">val prog:(Lexing.lexbuf -&gt; token) -&gt; Lexing.lexbuf -&gt; Json.value option</programlisting>

    <para>Before we start with the lexing, let's first define some functions
    to handle parsing errors. There are currently two errors: <literal moreinfo="none">Parser.Error</literal> and <literal moreinfo="none">Lexer.SyntaxError</literal>. A simple solution when
    encountering an error is to print the error and give up:<indexterm class="singular">
        <primary>errors</primary>

        <secondary sortas="give up on first">"give up on first error"
        approach</secondary>
      </indexterm></para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/parsing-test/test.ml">OCaml</ulink></para>

    <programlisting format="linespecific" language="ocaml">open Core.Std
open Lexer
open Lexing

let print_position outx lexbuf =
  let pos = lexbuf.lex_curr_p in
  fprintf outx "%s:%d:%d" pos.pos_fname
    pos.pos_lnum (pos.pos_cnum - pos.pos_bol + 1)

let parse_with_error lexbuf =
  try Parser.prog Lexer.read lexbuf with
  | SyntaxError msg -&gt;
    fprintf stderr "%a: %s\n" print_position lexbuf msg;
    None
  | Parser.Error -&gt;
    fprintf stderr "%a: syntax error\n" print_position lexbuf;
    exit (-1)</programlisting>

    <para>The "give up on the first error" approach is easy to implement but
    isn't very friendly. In general, error handling can be pretty intricate,
    and we won't discuss it here. However, the Menhir parser defines
    additional mechanisms you can use to try and recover from errors. These
    are described in detail in its reference <ulink url="http://gallium.inria.fr/~fpottier/menhir/">manual</ulink>.<indexterm class="singular">
        <primary>Menhir parser generator</primary>

        <secondary>error handling in</secondary>
      </indexterm></para>

    <para>The standard lexing library <literal moreinfo="none">Lexing</literal> provides a function <literal moreinfo="none">from_channel</literal> to read the input from a channel.
    The following function describes the structure, where the <literal moreinfo="none">Lexing.from_channel</literal> function is used to
    construct a <literal moreinfo="none">lexbuf</literal>, which is passed
    with the lexing function <literal moreinfo="none">Lexer.read</literal> to
    the <literal moreinfo="none">Parser.prog</literal> function. <literal moreinfo="none">Parsing.prog</literal> returns <literal moreinfo="none">None</literal> when it reaches end of file. We define a
    function <literal moreinfo="none">Json.output_value</literal>, not shown
    here, to print a <literal moreinfo="none">Json.value</literal>:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/parsing-test/test.ml">OCaml</ulink>
    (part 1)</para>

    <programlisting format="linespecific" language="ocaml">let rec parse_and_print lexbuf =
  match parse_with_error lexbuf with
  | Some value -&gt;
    printf "%a\n" Json.output_value value;
    parse_and_print lexbuf
  | None -&gt; ()

let loop filename () =
  let inx = In_channel.create filename in
  let lexbuf = Lexing.from_channel inx in
  lexbuf.lex_curr_p &lt;- { lexbuf.lex_curr_p with pos_fname = filename };
  parse_and_print lexbuf;
  In_channel.close inx</programlisting>

    <para>Here's a test input file we can use to test the code we just
    wrote:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/parsing-test/test1.json">JSON</ulink></para>

    <programlisting format="linespecific" language="json">true
false
null
[1, 2, 3., 4.0, .5, 5.5e5, 6.3]
"Hello World"
{ "field1": "Hello",
  "field2": 17e13,
  "field3": [1, 2, 3],
  "field4": { "fieldA": 1, "fieldB": "Hello" }
}</programlisting>

    <para>Now build and run the example using this file, and you can see the
    full parser in action:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/parsing-test/build_test.out">Terminal</ulink></para>

    <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">ocamlbuild -use-menhir -tag thread -use-ocamlfind -quiet -pkg core test.native</userinput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">./test.native test1.json</userinput>
<computeroutput moreinfo="none">true</computeroutput>
<computeroutput moreinfo="none">false</computeroutput>
<computeroutput moreinfo="none">null</computeroutput>
<computeroutput moreinfo="none">[1, 2, 3.000000, 4.000000, 0.500000, 550000.000000, 6.300000]</computeroutput>
<computeroutput moreinfo="none">"Hello World"</computeroutput>
<computeroutput moreinfo="none">{ "field1": "Hello",</computeroutput>
<computeroutput moreinfo="none">  "field2": 170000000000000.000000,</computeroutput>
<computeroutput moreinfo="none">  "field3": [1, 2, 3],</computeroutput>
<computeroutput moreinfo="none">  "field4": { "fieldA": 1,</computeroutput>
<computeroutput moreinfo="none">  "fieldB": "Hello" } }</computeroutput></programlisting>

    <para>With our simple error handling scheme, errors are fatal and cause
    the program to terminate with a nonzero exit code:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/parsing-test/run_broken_test.out">Terminal</ulink></para>

    <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">cat test2.json</userinput>
<computeroutput moreinfo="none">{ "name": "Chicago",</computeroutput>
<computeroutput moreinfo="none">  "zips": [12345,</computeroutput>
<computeroutput moreinfo="none">}</computeroutput>
<computeroutput moreinfo="none">{ "name": "New York",</computeroutput>
<computeroutput moreinfo="none">  "zips": [10004]</computeroutput>
<computeroutput moreinfo="none">}</computeroutput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">./test.native test2.json</userinput>
<computeroutput moreinfo="none">test2.json:3:2: syntax error</computeroutput></programlisting>

    <para>That wraps up our parsing tutorial. As an aside, notice that the
    JSON polymorphic variant type that we defined in this chapter is actually
    structurally compatible with the Yojson representation explained in <xref linkend="handling-json-data"/>. That means that you can take this parser
    and use it with the helper functions in Yojson to build more sophisticated
    applications.</para>
  </sect1>
</chapter>

    <chapter id="data-serialization-with-s-expressions">
  <title>Data Serialization with S-Expressions</title>

  <para>S-expressions are nested parenthetical expressions whose atomic values
  are strings. They were first popularized by the Lisp programming language in
  the 1960s. They have remained one of the simplest and most effective ways to
  encode structured data in a human-readable and editable form.<indexterm class="startofrange" id="SERFORMsexp">
      <primary>serialization formats</primary>

      <secondary>s-expressions</secondary>
    </indexterm><indexterm class="singular">
      <primary>s-expressions</primary>

      <secondary>uses for</secondary>
    </indexterm><indexterm class="singular">
      <primary>data serialization</primary>

      <secondary sortas="s-expressions">with s-expressions</secondary>
    </indexterm></para>

  <para>There's a full definition of s-expressions available <ulink url="http://people.csail.mit.edu/rivest/Sexp.txt">online</ulink>. An example
  s-expression might look like this:</para>

  <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/sexpr/basic.scm">Scheme</ulink></para>

  <programlisting format="linespecific" language="scheme">(this (is an) (s expression))</programlisting>

  <para>S-expressions play a major role in Core, effectively acting as the
  default serialization format. Indeed, we've encountered s-expressions
  multiple times already, including in <xref linkend="error-handling"/>,
  <xref linkend="functors"/>, and <xref linkend="first-class-modules"/>.</para>

  <para>This chapter will go into s-expressions in more depth. In particular,
  we'll discuss:</para>

  <itemizedlist>
    <listitem>
      <para>The details of the s-expression format, including how to parse it while generating good
        error messages for debugging malformed inputs</para>
    </listitem>

    <listitem>
      <para>How to generate s-expressions from arbitrary OCaml types</para>
    </listitem>

    <listitem>
      <para>How to use custom type annotations to control the exact printing
      behavior for s-expression converters</para>
    </listitem>

    <listitem>
      <para>How to integrate s-expressions into your interfaces, in particular how to add
        s-expression converters to a module without breaking abstraction boundaries</para>
    </listitem>
  </itemizedlist>

  <para>We'll tie this together at the end of the chapter with a simple s-expression formatted
    configuration file for a web server</para>

  <sect1 id="basic-usage">
    <title>Basic Usage</title>

    <para>The type used to represent an s-expression is quite
    simple:<indexterm class="singular">
        <primary>s-expressions</primary>

        <secondary>basic usage of</secondary>
      </indexterm></para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/sexpr/sexp.mli">OCaml</ulink></para>

    <programlisting format="linespecific" language="ocaml">module Sexp : sig
  type t =
  | Atom of string
  | List of t list
end</programlisting>

    <para>An s-expression can be thought of as a tree where each node contains
    a list of its children, and where the leaves of the tree are strings. Core
    provides good support for s-expressions in its <literal moreinfo="none">Sexp</literal> module, including functions for converting
    s-expressions to and from strings. Let's rewrite our example s-expression
    in terms of this type:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/sexpr/print_sexp.topscript">OCaml utop</ulink></para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">Sexp.List [</userinput>
<userinput moreinfo="none">    Sexp.Atom "this";</userinput>
<userinput moreinfo="none">    Sexp.List [ Sexp.Atom "is"; Sexp.Atom "an"];</userinput>
<userinput moreinfo="none">    Sexp.List [ Sexp.Atom "s"; Sexp.Atom "expression" ];</userinput>
<userinput moreinfo="none">  ];;</userinput>
<computeroutput moreinfo="none">- : Sexp.t = (this (is an) (s expression))</computeroutput></programlisting>

    <para>This prints out nicely because Core registers a pretty printer with
    the toplevel. This pretty printer is based on the functions in <literal moreinfo="none">Sexp</literal> for converting s-expressions to and from
    strings:<indexterm class="singular">
        <primary>pretty printers</primary>
      </indexterm></para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/sexpr/sexp_printer.topscript">OCaml utop</ulink></para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">Sexp.to_string (Sexp.List [Sexp.Atom "1"; Sexp.Atom "2"]) ;;</userinput>
<computeroutput moreinfo="none">- : string = "(1 2)"</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Sexp.of_string ("(1 2 (3 4))") ;;</userinput>
<computeroutput moreinfo="none">- : Sexp.t = (1 2 (3 4))</computeroutput></programlisting>

    <para>In addition to providing the <literal moreinfo="none">Sexp</literal>
    module, most of the base types in Core support conversion to and from
    s-expressions. For example, we can use the conversion functions defined in
    the respective modules for integers, strings, and exceptions:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/sexpr/to_from_sexp.topscript">OCaml utop</ulink></para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">Int.sexp_of_t 3;;</userinput>
<computeroutput moreinfo="none">- : Sexp.t = 3</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">String.sexp_of_t "hello";;</userinput>
<computeroutput moreinfo="none">- : Sexp.t = hello</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Exn.sexp_of_t (Invalid_argument "foo");;</userinput>
<computeroutput moreinfo="none">- : Sexp.t = (Invalid_argument foo)</computeroutput></programlisting>

    <para>It's also possible to convert more complex types such as lists or
    arrays that are polymorphic across the types that they can contain:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/sexpr/to_from_sexp.topscript">OCaml utop</ulink>
    (part 1)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">List.sexp_of_t;;</userinput>
<computeroutput moreinfo="none">- : ('a -&gt; Sexp.t) -&gt; 'a list -&gt; Sexp.t = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">List.sexp_of_t Int.sexp_of_t [1; 2; 3];;</userinput>
<computeroutput moreinfo="none">- : Sexp.t = (1 2 3)</computeroutput></programlisting>

    <para>Notice that <literal moreinfo="none">List.sexp_of_t</literal> is
    polymorphic and takes as its first argument another conversion function to
    handle the elements of the list to be converted. Core uses this scheme
    more generally for defining sexp converters for polymorphic types.</para>

    <para>The functions that go in the other direction, <emphasis>i.e.</emphasis>, reconstruct an
      OCaml value from an s-expression, use essentially the same trick for handling polymorphic
      types, as shown in the following example. Note that these functions will fail with an
      exception when presented with an s-expression that doesn't match the structure of the OCaml
      type in question.</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/sexpr/to_from_sexp.topscript">OCaml utop</ulink>
    (part 2)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">List.t_of_sexp;;</userinput>
<computeroutput moreinfo="none">- : (Sexp.t -&gt; 'a) -&gt; Sexp.t -&gt; 'a list = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">List.t_of_sexp Int.t_of_sexp (Sexp.of_string "(1 2 3)");;</userinput>
<computeroutput moreinfo="none">- : int list = [1; 2; 3]</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">List.t_of_sexp Int.t_of_sexp (Sexp.of_string "(1 2 three)");;</userinput>
<computeroutput moreinfo="none">Exception:</computeroutput>
<computeroutput moreinfo="none">(Sexplib.Conv.Of_sexp_error (Failure "int_of_sexp: (Failure int_of_string)")</computeroutput>
<computeroutput moreinfo="none"> three).</computeroutput></programlisting>

    <note>
      <title>More on Top-Level Printing</title>

      <para>The values of the s-expressions that we created were printed
      properly as s-expressions in the toplevel, instead of as the tree of
      <literal moreinfo="none">Atom</literal> and <literal moreinfo="none">List</literal> variants that they're actually made
      of.<indexterm class="singular">
          <primary>top-level printers</primary>
        </indexterm></para>

      <para>This is due to OCaml's facility for installing custom
      <emphasis>top-level printers</emphasis> that can rewrite some values
      into more top-level-friendly equivalents. They are generally installed
      as <command moreinfo="none">ocamlfind</command> packages ending in
      <literal moreinfo="none">top</literal>:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/sexpr/list_top_packages.out">Terminal</ulink></para>

      <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">ocamlfind list | grep top</userinput>
<computeroutput moreinfo="none">compiler-libs.toplevel (version: [distributed with Ocaml])</computeroutput>
<computeroutput moreinfo="none">core.top            (version: 109.37.00)</computeroutput>
<computeroutput moreinfo="none">ctypes.top          (version: 0.1)</computeroutput>
<computeroutput moreinfo="none">lwt.simple-top      (version: 2.4.3)</computeroutput>
<computeroutput moreinfo="none">num-top             (version: 1.3.3)</computeroutput>
<computeroutput moreinfo="none">sexplib.top         (version: 109.20.00)</computeroutput>
<computeroutput moreinfo="none">uri.top             (version: 1.3.8)</computeroutput></programlisting>

      <para>The <literal moreinfo="none">core.top</literal> package (which you
      should have loaded by default in your <literal moreinfo="none">.ocamlinit</literal> file) loads in printers for the
      Core extensions already, so you don't need to do anything special to use
      the s-expression printer.</para>
    </note>

    <sect2 id="generating-s-expressions-from-ocaml-types">
      <title>Generating S-Expressions from OCaml Types</title>

      <para>But what if you want a function to convert a brand new type to an
      s-expression? You can of course write it yourself manually. Here's an
      example:<indexterm class="singular">
          <primary>s-expressions</primary>

          <secondary>generating from OCaml types</secondary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/sexpr/manually_making_sexp.topscript">OCaml utop</ulink></para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">type t = { foo: int; bar: float } ;;</userinput>
<computeroutput moreinfo="none">type t = { foo : int; bar : float; }</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let sexp_of_t t =</userinput>
<userinput moreinfo="none">    let a x = Sexp.Atom x and l x = Sexp.List x in</userinput>
<userinput moreinfo="none">    l [ l [a "foo"; Int.sexp_of_t t.foo  ];</userinput>
<userinput moreinfo="none">        l [a "bar"; Float.sexp_of_t t.bar]; ] ;;</userinput>
<computeroutput moreinfo="none">val sexp_of_t : t -&gt; Sexp.t = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">sexp_of_t { foo = 3; bar = -5.5 } ;;</userinput>
<computeroutput moreinfo="none">- : Sexp.t = ((foo 3) (bar -5.5))</computeroutput></programlisting>

      <para>This is somewhat tiresome to write, and it gets more so when you
      consider the parser, i.e., <literal moreinfo="none">t_of_sexp</literal>,
      which is considerably more complex. Writing this kind of parsing and
      printing code by hand is mechanical and error prone, not to mention a
      drag.</para>

      <para>Given how mechanical the code is, you could imagine writing a program that inspected the
        type definition and autogenerated the conversion code for you. As it turns out, Sexplib does
        just that. <literal moreinfo="none">Sexplib</literal>, which is included with Core, provides
        both a library for manipulating s-expressions and a <emphasis>syntax extension</emphasis>
        for generating such conversion functions. With that syntax extension enabled, any type that
        has <literal moreinfo="none">with sexp</literal> as an annotation will trigger the
        generation of the functions we want:<indexterm class="singular">
          <primary>Sexplib package</primary>
          <secondary>syntax extension in</secondary>
        </indexterm><indexterm class="singular">
          <primary>syntax extension</primary>
          <secondary>in Sexplib package</secondary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/sexpr/auto_making_sexp.topscript">OCaml utop</ulink></para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">type t = { foo: int; bar: float } with sexp ;;</userinput>
<computeroutput moreinfo="none">type t = { foo : int; bar : float; }</computeroutput>
<computeroutput moreinfo="none">val t_of_sexp : Sexp.t -&gt; t = &lt;fun&gt;</computeroutput>
<computeroutput moreinfo="none">val sexp_of_t : t -&gt; Sexp.t = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">t_of_sexp (Sexp.of_string "((bar 35) (foo 3))") ;;</userinput>
<computeroutput moreinfo="none">- : t = {foo = 3; bar = 35.}</computeroutput></programlisting>

      <para>The syntax extension can be used outside of type declarations as
      well. As discussed in <xref linkend="error-handling"/>, <literal moreinfo="none">with sexp</literal> can be attached to the declaration
      of an exception, which will improve the ability of Core to generate a
      useful string representation:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/sexpr/auto_making_sexp.topscript">OCaml utop</ulink>
      (part 1)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">exception Bad_message of string list ;;</userinput>
<computeroutput moreinfo="none">exception Bad_message of string list</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Exn.to_string (Bad_message ["1";"2";"3"]) ;;</userinput>
<computeroutput moreinfo="none">- : string = "(\"Bad_message(_)\")"</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">exception Good_message of string list with sexp;;</userinput>
<computeroutput moreinfo="none">exception Good_message of string list</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Exn.to_string (Good_message ["1";"2";"3"]) ;;</userinput>
<computeroutput moreinfo="none">- : string = "(//toplevel//.Good_message (1 2 3))"</computeroutput></programlisting>
<?hard-pagebreak?>
      <para>You don't always have to declare a named type to create an
      s-expression converter. The following syntax lets you create one inline,
      as part of a larger expression:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/sexpr/inline_sexp.topscript">OCaml utop</ulink></para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let l = [(1,"one"); (2,"two")] ;;</userinput>
<computeroutput moreinfo="none">val l : (int * string) list = [(1, "one"); (2, "two")]</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">List.iter l ~f:(fun x -&gt;</userinput>
<userinput moreinfo="none">    &lt;:sexp_of&lt;int * string&gt;&gt; x</userinput>
<userinput moreinfo="none">    |&gt; Sexp.to_string</userinput>
<userinput moreinfo="none">    |&gt; print_endline) ;;</userinput>
<computeroutput moreinfo="none">(1 one)</computeroutput>
<computeroutput moreinfo="none">(2 two)</computeroutput>
<computeroutput moreinfo="none">- : unit = ()</computeroutput></programlisting>

      <para>The declaration <literal moreinfo="none">&lt;:sexp_of&lt;int *
      string&gt;&gt;</literal> simply gets expanded to the sexp converter for
      the type <literal moreinfo="none">int * string</literal>. This is useful
      whenever you need a sexp converter for an anonymous type.</para>

      <para>The syntax extensions bundled with Core almost all have the same
      basic structure: they autogenerate code based on type definitions,
      implementing functionality that you could in theory have implemented by
      hand, but with far less programmer effort.</para>

      <note>
        <title>Syntax Extensions, Camlp4, and Type_conv</title>

        <para>OCaml doesn't directly support generating code from type
        definitions. Instead, it supplies a powerful syntax extension
        mechanism known as Camlp4, which lets you extend the grammar of the
        language. Camlp4 is well integrated into the OCaml toolchain and can
        be activated within the toplevel and also included in compilation
        using the <literal moreinfo="none">-pp</literal> compiler
        flag.<indexterm class="singular">
            <primary>Camlp4 syntax extension mechanism</primary>
          </indexterm><indexterm class="singular">
            <primary>syntax extension</primary>

            <secondary sortas="Camlp4">in Camlp4</secondary>
          </indexterm></para>

        <para>Sexplib is part of a family of syntax extensions, including
        Comparelib, described in <xref linkend="maps-and-hash-tables"/>, and
        Fieldslib, described in <xref linkend="records"/>, that generate code
        based on type declarations and are all based on a common library
        called Type_conv. This library provides a common language for
        annotating types (e.g., using the <literal moreinfo="none">with</literal> notation) and utilities for working
        with type definitions. If you want to build your own type-driven
        syntax extension, you should consider basing it on
        Type_conv.<indexterm class="singular">
            <primary>Type_conv library</primary>
          </indexterm><indexterm class="singular">
            <primary>Sexplib package</primary>

            <secondary>Type_conv library and</secondary>
          </indexterm></para>
      </note>
    </sect2>
  </sect1>

  <sect1 id="the-sexp-format">
    <title>The Sexp Format</title>

    <para>The textual representation of s-expressions is pretty
    straightforward. An s-expression is written down as a nested parenthetical
    expression, with whitespace-separated strings as the atoms. Quotes are
    used for atoms that contain parentheses or spaces themselves; backslash is
    the escape character; and semicolons are used to introduce single-line
    comments. Thus, the following file, <filename moreinfo="none">example.scm</filename>:<indexterm class="singular">
        <primary>s-expressions</primary>

        <secondary>format of</secondary>
      </indexterm></para>
    
    <?hard-pagebreak?>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/sexpr/example.scm">Scheme</ulink></para>

    <programlisting format="linespecific" language="scheme">;; example.scm

((foo 3.3) ;; This is a comment
 (bar "this is () an \" atom"))</programlisting>

    <para>can be loaded using Sexplib. As you can see, the commented data is
    not part of the resulting s-expression:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/sexpr/example_load.topscript">OCaml utop</ulink></para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">Sexp.load_sexp "example.scm" ;;</userinput>
<computeroutput moreinfo="none">- : Sexp.t = ((foo 3.3) (bar "this is () an \" atom"))</computeroutput></programlisting>

    <para>All in, the s-expression format supports three comment
    syntaxes:</para>



    <variablelist>
      <varlistentry>
        <term><literal moreinfo="none">;</literal></term>

        <listitem>
          <para>Comments out everything to the end of line</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal moreinfo="none">#|</literal></term>

        <term><literal moreinfo="none">|#</literal></term>

        <listitem>
          <para>Delimiters for commenting out a block</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal moreinfo="none">#;</literal></term>

        <listitem>
          <para>Comments out the first complete s-expression that
          follows</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <para>The following example shows all of these in action:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/sexpr/comment_heavy.scm">Scheme</ulink></para>

    <programlisting format="linespecific">;; comment_heavy_example.scm
((this is included)
 ; (this is commented out
 (this stays)
 #; (all of this is commented
     out (even though it crosses lines.))
  (and #| block delimiters #| which can be nested |#
     will comment out
    an arbitrary multi-line block))) |#
   now we're done
   ))</programlisting>

    <para>Again, loading the file as an s-expression drops the
    comments:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/sexpr/example_load.topscript">OCaml utop</ulink>
    (part 1)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">Sexp.load_sexp "comment_heavy.scm" ;;</userinput>
<computeroutput moreinfo="none">- : Sexp.t = ((this is included) (this stays) (and now we're done))</computeroutput></programlisting>

    <para>If we introduce an error into our s-expression, by, say, creating a
    file <literal moreinfo="none">broken_example.scm</literal> which is
    <literal moreinfo="none">example.scm</literal>, without open-paren in
    front of <literal moreinfo="none">bar</literal>, we'll get a parse
    error:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/sexpr/example_load.topscript">OCaml utop</ulink>
    (part 2)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">Exn.handle_uncaught ~exit:false (fun () -&gt;</userinput>
<userinput moreinfo="none">    ignore (Sexp.load_sexp "example_broken.scm")) ;;</userinput>
<computeroutput moreinfo="none">Uncaught exception:</computeroutput>
<computeroutput moreinfo="none">  </computeroutput>
<computeroutput moreinfo="none">  (Sexplib.Sexp.Parse_error</computeroutput>
<computeroutput moreinfo="none">   ((location parse) (err_msg "unexpected character: ')'") (text_line 4)</computeroutput>
<computeroutput moreinfo="none">    (text_char 29) (global_offset 78) (buf_pos 78)))</computeroutput>
<computeroutput moreinfo="none">- : unit = ()</computeroutput></programlisting>

    <para>In the preceding example, we use <literal moreinfo="none">Exn.handle_uncaught</literal> to make sure that the
    exception gets printed out in full detail. You should generally wrap every
    Core program in this handler to get good error messages for any unexpected
    exceptions.</para>
  </sect1>

  <sect1 id="preserving-invariants">
    <title>Preserving Invariants</title>

    <para>The most important functionality provided by Sexplib is the
    autogeneration of converters for new types. We've seen a bit of how this
    works already, but let's walk through a complete example. Here's the
    source for a simple library for representing integer intervals, very
    similar to the one described in <xref linkend="functors"/>:<indexterm class="singular">
        <primary>s-expressions</primary>

        <secondary>preserving invariants in</secondary>
      </indexterm></para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/sexpr/int_interval.ml">OCaml</ulink></para>

    <programlisting format="linespecific" language="ocaml">(* Module for representing closed integer intervals *)
open Core.Std

(* Invariant: For any Range (x,y), y &gt;= x *)
type t =
  | Range of int * int
  | Empty
with sexp

let is_empty =
  function 
  | Empty -&gt; true 
  | Range _ -&gt; false

let create x y =
  if x &gt; y then
    Empty 
  else 
    Range (x,y)

let contains i x =
  match i with
  | Empty -&gt; false
  | Range (low,high) -&gt; x &gt;= low &amp;&amp; x &lt;= high</programlisting>

    <para>We can now use this module as follows:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/sexpr/test_interval.ml">OCaml</ulink></para>

    <programlisting format="linespecific" language="ocaml">open Core.Std

let intervals =
  let module I = Int_interval in
  [ I.create 3 4;
    I.create 5 4; (* should be empty *)
    I.create 2 3;
    I.create 1 6;
  ]

let () =
  intervals
  |&gt; List.sexp_of_t Int_interval.sexp_of_t
  |&gt; Sexp.to_string_hum
  |&gt; print_endline</programlisting>

    <para>But we're still missing something: we haven't created an <literal moreinfo="none">mli</literal> signature for <literal moreinfo="none">Int_interval</literal> yet. Note that we need to
    explicitly export the s-expression converters that were created within the
    <literal moreinfo="none">ml</literal> file. For example, here's an
    interface that doesn't export the s-expression functions:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/sexpr/int_interval_nosexp.mli">OCaml</ulink></para>

    <programlisting format="linespecific" language="ocaml">type t

val is_empty : t -&gt; bool
val create : int -&gt; int -&gt; t
val contains : t -&gt; int -&gt; bool</programlisting>

    <para>Building this will give us the following error:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/sexpr/build_test_interval_nosexp.out">Terminal</ulink></para>

    <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">corebuild test_interval_nosexp.native</userinput>
<computeroutput moreinfo="none">File "test_interval_nosexp.ml", line 14, characters 20-42:</computeroutput>
<computeroutput moreinfo="none">Error: Unbound value Int_interval.sexp_of_t</computeroutput>
<computeroutput moreinfo="none">Command exited with code 2.</computeroutput></programlisting>

    <para>We could export the types by hand in the signature, by writing the
    signatures for the extra functions generated by Sexplib:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/sexpr/int_interval_manual_sexp.mli">OCaml</ulink></para>

    <programlisting format="linespecific" language="ocaml">open Core.Std

type t
val t_of_sexp : Sexp.t -&gt; t
val sexp_of_t : t -&gt; Sexp.t

val is_empty : t -&gt; bool
val create : int -&gt; int -&gt; t
val contains : t -&gt; int -&gt; bool</programlisting>

    <para>This isn't an ideal solution, as it makes you repeatedly expose
    these extra functions in every signature you create where you want to
    serialize values. Sexplib solves this by exposing the same syntax
    extension in signature definitions so that we can just use the same
    <literal moreinfo="none">with</literal> shorthand in the <literal moreinfo="none">mli</literal> file. Here's the final version of the
    signature that does just this:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/sexpr/int_interval.mli">OCaml</ulink></para>

    <programlisting format="linespecific" language="ocaml">type t with sexp

val is_empty : t -&gt; bool
val create : int -&gt; int -&gt; t
val contains : t -&gt; int -&gt; bool</programlisting>

    <para>At this point, <literal moreinfo="none">test_interval.ml</literal>
    will compile again, and if we run it, we'll get the following
    output:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/sexpr/build_test_interval.out">Terminal</ulink></para>

    <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">corebuild test_interval.native</userinput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">./test_interval.native</userinput>
<computeroutput moreinfo="none">((Range 3 4) Empty (Range 2 3) (Range 1 6))</computeroutput></programlisting>

    <para>One easy mistake to make when dealing with sexp converters is to
    ignore the fact that those converters can violate the invariants of your
    code. For example, the <literal moreinfo="none">Int_interval</literal>
    module depends for the correctness of the <literal moreinfo="none">is_empty</literal> check on the fact that for any value
    <literal moreinfo="none">Range (x,y)</literal>, <literal moreinfo="none">y</literal> is greater than or equal to <literal moreinfo="none">x</literal>. The <literal moreinfo="none">create</literal>
    function preserves this invariant, but the <literal moreinfo="none">t_of_sexp</literal> function does not.<indexterm class="singular">
        <primary>invariant checks</primary>
      </indexterm></para>

    <para>We can fix this problem by overriding the autogenerated function and
    writing a custom sexp converter that wraps the autogenerated converter
    with whatever invariant checks are necessary:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/sexpr/sexp_override.ml">OCaml</ulink></para>

    <programlisting format="linespecific" language="ocaml">type t =
  | Range of int * int
  | Empty
with sexp

let create x y =
  if x &gt; y then Empty else Range (x,y)

let t_of_sexp sexp =
  let t = t_of_sexp sexp in
  begin match t with
    | Empty -&gt; ()
    | Range (x,y) -&gt;
      if y &lt; x then of_sexp_error "Upper and lower bound of Range swapped" sexp
  end;
  t</programlisting>

    <para>This trick of overriding an existing function definition with a new
    one is perfectly acceptable in OCaml. Since <literal moreinfo="none">t_of_sexp</literal> is defined with an ordinary <literal moreinfo="none">let</literal> rather than a <literal moreinfo="none">let
    rec</literal>, the call to the <literal moreinfo="none">t_of_sexp</literal> goes to the Sexplib-generated version
    of the function, rather than being a recursive call.</para>

    <para>Another important aspect of our definition is that we call the
    function <literal moreinfo="none">of_sexp_error</literal> to raise an
    exception when the parsing process fails. This improves the error
    reporting that Sexplib can provide when a conversion fails, as we'll see
    in the next section.</para>
  </sect1>

  <sect1 id="getting-good-error-messages">
    <title>Getting Good Error Messages</title>

    <para>There are two steps to deserializing a type from an s-expression:
    first, converting the bytes in a file to an s-expression; and the second,
    converting that s-expression into the type in question. One problem with
    this is that it can be hard to localize errors to the right place using
    this scheme. Consider the following example:<indexterm class="singular">
        <primary>debugging</primary>

        <secondary>s-expressions</secondary>
      </indexterm><indexterm class="singular">
        <primary>errors</primary>

        <secondary>error messages with s-expressions</secondary>
      </indexterm><indexterm class="singular">
        <primary>s-expressions</primary>

        <secondary>deserializing a type from</secondary>
      </indexterm></para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/sexpr/read_foo.ml">OCaml</ulink></para>

    <programlisting format="linespecific" language="ocaml">open Core.Std

type t = { 
  a: string;
  b: int;
  c: float option 
} with sexp

let run () =
  let t =
    Sexp.load_sexp "foo_broken_example.scm"
    |&gt; t_of_sexp
  in
  printf "b is: %d\n%!" t.b

let () =
  Exn.handle_uncaught ~exit:true run</programlisting>

    <para>If you were to run this on a malformatted file, say, this
    one:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/sexpr/foo_broken_example.scm">Scheme</ulink></para>

    <programlisting format="linespecific" language="scheme">((a "not-an-integer")
 (b "not-an-integer")
 (c 1.0))</programlisting>

    <para>you'll get the following error:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/sexpr/build_read_foo.out">Terminal</ulink></para>

    <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">corebuild read_foo.native</userinput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">./read_foo.native foo_example_broken.scm</userinput>
<computeroutput moreinfo="none">Uncaught exception:</computeroutput>
<computeroutput moreinfo="none">  </computeroutput>
<computeroutput moreinfo="none">  (Sexplib.Conv.Of_sexp_error</computeroutput>
<computeroutput moreinfo="none">   (Failure "int_of_sexp: (Failure int_of_string)") not-an-integer)</computeroutput>
<computeroutput moreinfo="none"> </computeroutput>
<computeroutput moreinfo="none">Raised at file "lib/conv.ml", line 281, characters 36-72</computeroutput>
<computeroutput moreinfo="none">Called from file "lib/core_int.ml", line 6, characters 7-14</computeroutput>
<computeroutput moreinfo="none">Called from file "lib/std_internal.ml", line 115, characters 7-33</computeroutput>
<computeroutput moreinfo="none">Called from file "read_foo.ml", line 5, characters 2-8</computeroutput>
<computeroutput moreinfo="none">Called from file "read_foo.ml", line 4, characters 2-40</computeroutput>
<computeroutput moreinfo="none">Called from file "read_foo.ml", line 11, characters 4-60</computeroutput>
<computeroutput moreinfo="none">Called from file "lib/exn.ml", line 87, characters 6-10</computeroutput></programlisting>

    <para>If all you have is the error message and the string, it's not
    terribly informative. In particular, you know that the parsing errored out
    on the atom "not-an-integer," but you don't know which one! In a large
    file, this kind of bad error message can be pure misery.</para>

    <para>But there's hope! We can make a small change to the code to improve
    the error message greatly:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/sexpr/read_foo_better_errors.ml">OCaml</ulink></para>

    <programlisting format="linespecific" language="ocaml">open Core.Std

type t = { 
  a: string;
  b: int;
  c: float option 
} with sexp

let run () =
  let t = Sexp.load_sexp_conv_exn "foo_broken_example.scm" t_of_sexp in
  printf "b is: %d\n%!" t.b

let () =
  Exn.handle_uncaught ~exit:true run</programlisting>

    <para>If we run it again, we'll see a much more specific error:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/sexpr/build_read_foo_better_errors.out">Terminal</ulink></para>

    <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">corebuild read_foo_better_errors.native</userinput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">./read_foo_better_errors.native foo_example_broken.scm</userinput>
<computeroutput moreinfo="none">Uncaught exception:</computeroutput>
<computeroutput moreinfo="none">  </computeroutput>
<computeroutput moreinfo="none">  (Sexplib.Conv.Of_sexp_error</computeroutput>
<computeroutput moreinfo="none">   (Sexplib.Sexp.Annotated.Conv_exn foo_broken_example.scm:2:5</computeroutput>
<computeroutput moreinfo="none">    (Failure "int_of_sexp: (Failure int_of_string)"))</computeroutput>
<computeroutput moreinfo="none">   not-an-integer)</computeroutput>
<computeroutput moreinfo="none"> </computeroutput>
<computeroutput moreinfo="none">Raised at file "lib/pre_sexp.ml", line 1145, characters 12-58</computeroutput>
<computeroutput moreinfo="none">Called from file "read_foo_better_errors.ml", line 10, characters 10-68</computeroutput>
<computeroutput moreinfo="none">Called from file "lib/exn.ml", line 87, characters 6-10</computeroutput></programlisting>

    <para>In the preceding error, <computeroutput moreinfo="none">foo_broken_example.scm:2:5</computeroutput> tells us that
    the error occurred in the file <computeroutput moreinfo="none">"foo_broken_example.scm"</computeroutput> on line 2,
    character 5. This is a much better start for figuring out what went wrong.
    The ability to find the precise location of the error depends on the sexp
    converter reporting errors using the function <literal moreinfo="none">of_sexp_error</literal>. This is already done by
    converters generated by Sexplib, but you should make sure to do the same
    when you write custom converters.</para>
  </sect1>

  <sect1 id="sexp-conversion-directives">
    <title>Sexp-Conversion Directives</title>

    <para>Sexplib supports a collection of directives for modifying the
    default behavior of the autogenerated sexp converters. These directives
    allow you to customize the way in which types are represented as
    s-expressions without having to write a custom converter.<indexterm class="singular">
        <primary>s-expressions</primary>

        <secondary>modifying default behavior of</secondary>
      </indexterm></para>

    <para>Note that the extra directives aren't part of the standard OCaml
    syntax, but are added via the Sexplib syntax extension. However, since
    Sexplib is used throughout Core and is part of the standard bundle
    activated by <command moreinfo="none">corebuild</command>, you can use
    these in your own Core code without any special effort.</para>

    <sect2 id="sexp_opaque">
      <title>sexp_opaque</title>

      <para>The most commonly used directive is <literal moreinfo="none">sexp_opaque</literal>, whose purpose is to mark a given
      component of a type as being unconvertible. Anything marked with
      <literal moreinfo="none">sexp_opaque</literal> will be presented as the
      atom <literal moreinfo="none">&lt;opaque&gt;</literal> by the to-sexp
      converter, and will trigger an exception from the from-sexp
      converter.<indexterm class="singular">
          <primary>Sexplib package</primary>

          <secondary>sexp_opaque</secondary>
        </indexterm></para>

      <para>Note that the type of a component marked as opaque doesn't need to
      have a sexp converter defined. Here, if we define a type without a sexp
      converter and then try to use another type with a sexp converter, we'll
      error out:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/sexpr/sexp_opaque.topscript">OCaml utop</ulink></para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">type no_converter = int * int ;;</userinput>
<computeroutput moreinfo="none">type no_converter = int * int</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">type t = { a: no_converter; b: string } with sexp ;;</userinput>
<computeroutput moreinfo="none">Characters 14-26:</computeroutput>
<computeroutput moreinfo="none">Error: Unbound value no_converter_of_sexp</computeroutput></programlisting>

      <para>But with <literal moreinfo="none">sexp_opaque</literal>, we can
      embed our opaque <literal moreinfo="none">no_converter</literal> type
      within the other data structure without an error.</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/sexpr/sexp_opaque.topscript">OCaml utop</ulink>
      (part 1)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">type t = { a: no_converter sexp_opaque; b: string } with sexp ;;</userinput>
<computeroutput moreinfo="none">type t = { a : no_converter; b : string; }</computeroutput>
<computeroutput moreinfo="none">val t_of_sexp : Sexp.t -&gt; t = &lt;fun&gt;</computeroutput>
<computeroutput moreinfo="none">val sexp_of_t : t -&gt; Sexp.t = &lt;fun&gt;</computeroutput></programlisting>

      <para>And if we now convert a value of this type to an s-expression,
      we'll see the contents of field <literal moreinfo="none">a</literal>
      marked as opaque:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/sexpr/sexp_opaque.topscript">OCaml utop</ulink>
      (part 2)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">sexp_of_t { a = (3,4); b = "foo" } ;;</userinput>
<computeroutput moreinfo="none">- : Sexp.t = ((a &lt;opaque&gt;) (b foo))</computeroutput></programlisting>

      <para>Note that the <literal moreinfo="none">t_of_sexp</literal>
      function for an opaque type is generated, but will fail at runtime if it
      is used:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/sexpr/sexp_opaque.topscript">OCaml utop</ulink>
      (part 3)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">t_of_sexp (Sexp.of_string "((a whatever) (b foo))") ;;</userinput>
<computeroutput moreinfo="none">Exception:</computeroutput>
<computeroutput moreinfo="none">(Sexplib.Conv.Of_sexp_error</computeroutput>
<computeroutput moreinfo="none"> (Failure "opaque_of_sexp: cannot convert opaque values") whatever).</computeroutput></programlisting>

      <para>This is there to allow for s-expression converters to be created
      for types containing <literal moreinfo="none">sexp_opaque</literal>
      values. This is useful because the resulting converters won't
      necessarily fail on all inputs. For example, if you have a record
      containing a <literal moreinfo="none">no_converter list</literal>, the
      <literal moreinfo="none">t_of_sexp</literal> function would still
      succeed when the list is empty:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/sexpr/sexp_opaque.topscript">OCaml utop</ulink>
      (part 4)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">type t = { a: no_converter sexp_opaque list; b: string } with sexp ;;</userinput>
<computeroutput moreinfo="none">type t = { a : no_converter list; b : string; }</computeroutput>
<computeroutput moreinfo="none">val t_of_sexp : Sexp.t -&gt; t = &lt;fun&gt;</computeroutput>
<computeroutput moreinfo="none">val sexp_of_t : t -&gt; Sexp.t = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">t_of_sexp (Sexp.of_string "((a ()) (b foo))") ;;</userinput>
<computeroutput moreinfo="none">- : t = {a = []; b = "foo"}</computeroutput></programlisting>

      <para>If you really only want to generate one direction of converter,
      one can do this by annotating the type with <literal moreinfo="none">with sexp_of</literal> or <literal moreinfo="none">with
      of_sexp</literal> instead of <literal moreinfo="none">with
      sexp</literal>:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/sexpr/sexp_opaque.topscript">OCaml utop</ulink>
      (part 5)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">type t = { a: no_converter sexp_opaque; b: string } with sexp_of ;;</userinput>
<computeroutput moreinfo="none">type t = { a : no_converter; b : string; }</computeroutput>
<computeroutput moreinfo="none">val sexp_of_t : t -&gt; Sexp.t = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">type t = { a: no_converter sexp_opaque; b: string } with of_sexp ;;</userinput>
<computeroutput moreinfo="none">type t = { a : no_converter; b : string; }</computeroutput>
<computeroutput moreinfo="none">val t_of_sexp : Sexp.t -&gt; t = &lt;fun&gt;</computeroutput></programlisting>
    </sect2>

    <sect2 id="sexp_list">
      <title>sexp_list</title>

      <para>Sometimes, sexp converters have more parentheses than one would
      ideally like. Consider, for example, the following variant
      type:<indexterm class="singular">
          <primary>Sexplib package</primary>

          <secondary>sexp_list</secondary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/sexpr/sexp_list.topscript">OCaml utop</ulink></para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">type compatible_versions =</userinput>
<userinput moreinfo="none">  | Specific of string list</userinput>
<userinput moreinfo="none">  | All with sexp ;;</userinput>
<computeroutput moreinfo="none">type compatible_versions = Specific of string list | All</computeroutput>
<computeroutput moreinfo="none">val compatible_versions_of_sexp : Sexp.t -&gt; compatible_versions = &lt;fun&gt;</computeroutput>
<computeroutput moreinfo="none">val sexp_of_compatible_versions : compatible_versions -&gt; Sexp.t = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">sexp_of_compatible_versions</userinput>
<userinput moreinfo="none">  (Specific ["3.12.0"; "3.12.1"; "3.13.0"]) ;;</userinput>
<computeroutput moreinfo="none">- : Sexp.t = (Specific (3.12.0 3.12.1 3.13.0))</computeroutput></programlisting>

      <para>You might prefer to make the syntax a bit less parenthesis-laden
      by dropping the parentheses around the list. We can replace the <literal moreinfo="none">string list</literal> in the type declaration with
      <literal moreinfo="none">string sexp_list</literal> to give us this
      alternate syntax:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/sexpr/sexp_list.topscript">OCaml utop</ulink>
      (part 1)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">type compatible_versions =</userinput>
<userinput moreinfo="none">  | Specific of string sexp_list</userinput>
<userinput moreinfo="none">  | All with sexp ;;</userinput>
<computeroutput moreinfo="none">type compatible_versions = Specific of string list | All</computeroutput>
<computeroutput moreinfo="none">val compatible_versions_of_sexp : Sexp.t -&gt; compatible_versions = &lt;fun&gt;</computeroutput>
<computeroutput moreinfo="none">val sexp_of_compatible_versions : compatible_versions -&gt; Sexp.t = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">sexp_of_compatible_versions</userinput>
<userinput moreinfo="none">  (Specific ["3.12.0"; "3.12.1"; "3.13.0"]) ;;</userinput>
<computeroutput moreinfo="none">- : Sexp.t = (Specific 3.12.0 3.12.1 3.13.0)</computeroutput></programlisting>
    </sect2>

    <sect2 id="sexp_option">
      <title>sexp_option</title>

      <para>Another common directive is <literal moreinfo="none">sexp_option</literal>, which is used to make a record
      field optional in the s-expression. Normally, optional values are
      represented either as <literal moreinfo="none">()</literal> for <literal moreinfo="none">None</literal>, or as <literal moreinfo="none">(x)</literal> for <literal moreinfo="none">Some
      x</literal>, and a record field containing an option would be rendered
      accordingly. For example:<indexterm class="singular">
          <primary>Sexplib package</primary>

          <secondary>sexp_option</secondary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/sexpr/sexp_option.topscript">OCaml utop</ulink></para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">type t = { a: int option; b: string } with sexp ;;</userinput>
<computeroutput moreinfo="none">type t = { a : int option; b : string; }</computeroutput>
<computeroutput moreinfo="none">val t_of_sexp : Sexp.t -&gt; t = &lt;fun&gt;</computeroutput>
<computeroutput moreinfo="none">val sexp_of_t : t -&gt; Sexp.t = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">sexp_of_t { a = None; b = "hello" } ;;</userinput>
<computeroutput moreinfo="none">- : Sexp.t = ((a ()) (b hello))</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">sexp_of_t { a = Some 3; b = "hello" } ;;</userinput>
<computeroutput moreinfo="none">- : Sexp.t = ((a (3)) (b hello))</computeroutput></programlisting>

      <para>But what if we want a field to be optional, i.e., we want to allow
      it to be omitted from the record entirely? In that case, we can mark it
      with <literal moreinfo="none">sexp_option</literal>:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/sexpr/sexp_option.topscript">OCaml utop</ulink>
      (part 1)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">type t = { a: int sexp_option; b: string } with sexp ;;</userinput>
<computeroutput moreinfo="none">type t = { a : int option; b : string; }</computeroutput>
<computeroutput moreinfo="none">val t_of_sexp : Sexp.t -&gt; t = &lt;fun&gt;</computeroutput>
<computeroutput moreinfo="none">val sexp_of_t : t -&gt; Sexp.t = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">sexp_of_t { a = Some 3; b = "hello" } ;;</userinput>
<computeroutput moreinfo="none">- : Sexp.t = ((a 3) (b hello))</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">sexp_of_t { a = None; b = "hello" } ;;</userinput>
<computeroutput moreinfo="none">- : Sexp.t = ((b hello))</computeroutput></programlisting>
    </sect2>

    <sect2 id="specifying-defaults">
      <title>Specifying Defaults</title>

      <para>The <literal moreinfo="none">sexp_option</literal> declaration is
      really just an example of specifying a default behavior for dealing with
      an unspecified field. In particular, <literal moreinfo="none">sexp_option</literal> fills in absent fields with
      <literal moreinfo="none">None</literal>. But you might want to allow
      other ways of filling in default values.<indexterm class="singular">
          <primary>s-expressions</primary>

          <secondary>specifying defaults in</secondary>
        </indexterm></para>

      <para>Consider the following type, which represents the configuration of
      a very simple web server:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/sexpr/sexp_default.topscript">OCaml utop</ulink></para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">type http_server_config = {</userinput>
<userinput moreinfo="none">     web_root: string;</userinput>
<userinput moreinfo="none">     port: int;</userinput>
<userinput moreinfo="none">     addr: string;</userinput>
<userinput moreinfo="none">  } with sexp ;;</userinput>
<computeroutput moreinfo="none">type http_server_config = { web_root : string; port : int; addr : string; }</computeroutput>
<computeroutput moreinfo="none">val http_server_config_of_sexp : Sexp.t -&gt; http_server_config = &lt;fun&gt;</computeroutput>
<computeroutput moreinfo="none">val sexp_of_http_server_config : http_server_config -&gt; Sexp.t = &lt;fun&gt;</computeroutput></programlisting>

      <para>One could imagine making some of these parameters optional; in
      particular, by default, we might want the web server to bind to port 80,
      and to listen as localhost. We can do this as follows:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/sexpr/sexp_default.topscript">OCaml utop</ulink>
      (part 1)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">type http_server_config = {</userinput>
<userinput moreinfo="none">     web_root: string;</userinput>
<userinput moreinfo="none">     port: int with default(80);</userinput>
<userinput moreinfo="none">     addr: string with default("localhost");</userinput>
<userinput moreinfo="none">  } with sexp ;;</userinput>
<computeroutput moreinfo="none">type http_server_config = { web_root : string; port : int; addr : string; }</computeroutput>
<computeroutput moreinfo="none">val http_server_config_of_sexp : Sexp.t -&gt; http_server_config = &lt;fun&gt;</computeroutput>
<computeroutput moreinfo="none">val sexp_of_http_server_config : http_server_config -&gt; Sexp.t = &lt;fun&gt;</computeroutput></programlisting>

      <para>Now, if we try to convert an s-expression that specifies only the
      <literal moreinfo="none">web_root</literal>, we'll see that the other
      values are filled in with the desired defaults:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/sexpr/sexp_default.topscript">OCaml utop</ulink>
      (part 2)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let cfg = http_server_config_of_sexp</userinput>
<userinput moreinfo="none">   (Sexp.of_string "((web_root /var/www/html))") ;;</userinput>
<computeroutput moreinfo="none">val cfg : http_server_config =</computeroutput>
<computeroutput moreinfo="none">  {web_root = "/var/www/html"; port = 80; addr = "localhost"}</computeroutput></programlisting>

      <para>If we convert the configuration back out to an s-expression,
      you'll notice that all of the fields are present, even though they're
      not strictly necessary:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/sexpr/sexp_default.topscript">OCaml utop</ulink>
      (part 3)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">sexp_of_http_server_config cfg ;;</userinput>
<computeroutput moreinfo="none">- : Sexp.t = ((web_root /var/www/html) (port 80) (addr localhost))</computeroutput></programlisting>

      <para>We could make the generated s-expression also drop exported
      values, by using the <literal moreinfo="none">sexp_drop_default</literal> directive:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/sexpr/sexp_default.topscript">OCaml utop</ulink>
      (part 4)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">type http_server_config = {</userinput>
<userinput moreinfo="none">     web_root: string;</userinput>
<userinput moreinfo="none">     port: int with default(80), sexp_drop_default;</userinput>
<userinput moreinfo="none">     addr: string with default("localhost"), sexp_drop_default;</userinput>
<userinput moreinfo="none">  } with sexp ;;</userinput>
<computeroutput moreinfo="none">type http_server_config = { web_root : string; port : int; addr : string; }</computeroutput>
<computeroutput moreinfo="none">val http_server_config_of_sexp : Sexp.t -&gt; http_server_config = &lt;fun&gt;</computeroutput>
<computeroutput moreinfo="none">val sexp_of_http_server_config : http_server_config -&gt; Sexp.t = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let cfg = http_server_config_of_sexp</userinput>
<userinput moreinfo="none">  (Sexp.of_string "((web_root /var/www/html))") ;;</userinput>
<computeroutput moreinfo="none">val cfg : http_server_config =</computeroutput>
<computeroutput moreinfo="none">  {web_root = "/var/www/html"; port = 80; addr = "localhost"}</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">sexp_of_http_server_config cfg ;;</userinput>
<computeroutput moreinfo="none">- : Sexp.t = ((web_root /var/www/html))</computeroutput></programlisting>

      <para>As you can see, the fields that are at their default values are
      simply omitted from the s-expression. On the other hand, if we convert a
      config with other values, then those values will be included in the
      s-expression:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/sexpr/sexp_default.topscript">OCaml utop</ulink>
      (part 5)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">sexp_of_http_server_config { cfg with port = 8080 } ;;</userinput>
<computeroutput moreinfo="none">- : Sexp.t = ((web_root /var/www/html) (port 8080))</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">sexp_of_http_server_config</userinput>
<userinput moreinfo="none">  { cfg with port = 8080; addr = "192.168.0.1" } ;;</userinput>
<computeroutput moreinfo="none">- : Sexp.t = ((web_root /var/www/html) (port 8080) (addr 192.168.0.1))</computeroutput></programlisting>

      <para>This can be very useful in designing config file formats that are
      both reasonably terse and easy to generate and maintain. It can also be
      useful for backwards compatibility: if you add a new field to your
      config record, but you make that field optional, then you should still
      be able to parse older version of your config.<indexterm class="endofrange" startref="SERFORMsexp"/><indexterm class="singular">
          <primary>files</primary>

          <secondary>config files</secondary>
        </indexterm><indexterm class="singular">
          <primary>config file formats</primary>
        </indexterm></para>
    </sect2>
  </sect1>
</chapter>

    <chapter id="concurrent-programming-with-async">
  <title>Concurrent Programming with Async</title>

  <para>The logic of building programs that interact with the outside world is often dominated by
    waiting: waiting for the click of a mouse, or for data to be fetched from disk, or for space to
    be available on an outgoing network buffer. Even mildly sophisticated interactive applications
    are typically <emphasis>concurrent</emphasis>: needing to wait for multiple different events at
    the same time, responding immediately to whatever event happens first.<indexterm class="singular">
      <primary>interactive input</primary>
      <secondary>concurrent programming for</secondary>
    </indexterm><indexterm class="singular">
      <primary>concurrent programming</primary>
    </indexterm><indexterm class="singular">
      <primary>programming</primary>
      <secondary>concurrent programming with Async</secondary>
    </indexterm></para>

  <para>One approach to concurrency is to use preemptive system threads, which
  is the dominant approach in languages like Java or C#. In this model, each
  task that may require simultaneous waiting is given an operating system
  thread of its own so it can block without stopping the entire
  program.<indexterm class="singular">
      <primary>threads</primary>

      <secondary>preemptive vs. single-threaded programs</secondary>
    </indexterm></para>

  <para>Another approach is to have a single-threaded program, where that single thread runs an
      <emphasis>event loop</emphasis> whose job is to react to external events like timeouts or
    mouse clicks by invoking a callback function that has been registered for that purpose. This
    approach shows up in languages like JavaScript that have single-threaded runtimes, as well as in
    many GUI toolkits.<indexterm class="singular">
      <primary>event loops</primary>
    </indexterm><indexterm class="singular">
      <primary>system threads</primary>
      <seealso>threads</seealso>
    </indexterm></para>

  <para>Each of these mechanisms has its own trade-offs. System threads
  require significant memory and other resources per thread. Also, the
  operating system can arbitrarily interleave the execution of system threads,
  requiring the programmer to carefully protect shared resources with locks
  and condition variables, which is exceedingly error-prone.</para>

  <para>Single-threaded event-driven systems, on the other hand, execute a
  single task at a time and do not require the same kind of complex
  synchronization that preemptive threads do. However, the inverted control
  structure of an event-driven program often means that your own control flow
  has to be threaded awkwardly through the system's event loop, leading to a
  maze of event callbacks.</para>

  <para>This chapter covers the Async library, which offers a hybrid model
  that aims to provide the best of both worlds, avoiding the performance
  compromises and synchronization woes of preemptive threads without the
  confusing inversion of control that usually comes with event-driven
  systems.<indexterm class="singular">
      <primary>Async library</primary>

      <secondary>benefits of</secondary>
    </indexterm></para>

  <sect1 id="async-basics">
    <title>Async Basics</title>

    <para>Recall how I/O is typically done in Core. Here's a simple
    example:<indexterm class="startofrange" id="ALbas">
        <primary>Async library</primary>

        <secondary>basics of</secondary>
      </indexterm></para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/async/main.topscript">OCaml utop</ulink>
    (part 1)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">In_channel.read_all;;</userinput>
<computeroutput moreinfo="none">- : string -&gt; string = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Out_channel.write_all "test.txt" ~data:"This is only a test.";;</userinput>
<computeroutput moreinfo="none">- : unit = ()</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">In_channel.read_all "test.txt";;</userinput>
<computeroutput moreinfo="none">- : string = "This is only a test."</computeroutput></programlisting>

    <para>From the type of <literal moreinfo="none">In_channel.read_all</literal>, you can see that it must be
    a blocking operation. In particular, the fact that it returns a concrete
    string means it can't return until the read has completed. The blocking
    nature of the call means that no progress can be made on anything else
    until the read is completed.<indexterm class="singular">
        <primary>blocking</primary>
      </indexterm></para>

    <para>In Async, well-behaved functions never block. Instead, they return a
    value of type <literal moreinfo="none">Deferred.t</literal> that acts as a
    placeholder that will eventually be filled in with the result. As an
    example, consider the signature of the Async equivalent of <literal moreinfo="none">In_channel.read_all</literal>:<indexterm class="singular">
        <primary>Deferred.t</primary>
      </indexterm></para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/async/main.topscript">OCaml utop</ulink>
    (part 3)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">#require "async";;</userinput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">open Async.Std;;</userinput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Reader.file_contents;;</userinput>
<computeroutput moreinfo="none">- : string -&gt; string Deferred.t = &lt;fun&gt;</computeroutput></programlisting>

    <para>We first load the Async package in the toplevel using <literal moreinfo="none">#require</literal>, and then open <literal moreinfo="none">Async.Std</literal>, which adds a number of new
    identifiers and modules into our environment that make using Async more
    convenient. Opening <literal moreinfo="none">Async.Std</literal> is
    standard practice for writing programs using Async, much like opening
    <literal moreinfo="none">Core.Std</literal> is for using Core.</para>

    <para>A deferred is essentially a handle to a value that may be computed
    in the future. As such, if we call <literal moreinfo="none">Reader.file_contents</literal>, the resulting deferred
    will initially be empty, as you can see by calling <literal moreinfo="none">Deferred.peek</literal> on the resulting
    deferred:<indexterm class="singular">
        <primary>Deferred.peek</primary>
      </indexterm></para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/async/main.topscript">OCaml utop</ulink>
    (part 4)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let contents = Reader.file_contents "test.txt";;</userinput>
<computeroutput moreinfo="none">val contents : string Deferred.t = &lt;abstr&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Deferred.peek contents;;</userinput>
<computeroutput moreinfo="none">- : string option = None</computeroutput></programlisting>

    <para>The value in <literal moreinfo="none">contents</literal> isn't yet determined partly
      because nothing running could do the necessary I/O. When using Async, processing of I/O and
      other events is handled by the Async scheduler. When writing a standalone program, you need to
      start the scheduler explicitly, but <command moreinfo="none">utop</command> knows about Async
      and can start the scheduler automatically. More than that, <command moreinfo="none">utop</command> knows about deferred values, and when you type in an expression of type
        <literal moreinfo="none">Deferred.t</literal>, it will make sure the scheduler is running
      and block until the deferred is determined. Thus, we can write:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/async/main.topscript">OCaml utop</ulink>
    (part 5)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">contents;;</userinput>
<computeroutput moreinfo="none">- : string = "This is only a test."</computeroutput></programlisting>

    <para>If we peek again, we'll see that the value of <literal moreinfo="none">contents</literal> has been determined:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/async/main.topscript">OCaml utop</ulink>
    (part 6)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">Deferred.peek contents;;</userinput>
<computeroutput moreinfo="none">- : string option = Some "This is only a test."</computeroutput></programlisting>

    <para>In order to do real work with deferreds, we need a way of waiting for a deferred
      computation to finish, which we do using <literal moreinfo="none">Deferred.bind</literal>.
      First, let's consider the type-signature of <literal>bind</literal>:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/async/main.topscript">OCaml utop</ulink>
    (part 7)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">Deferred.bind ;;</userinput>
<computeroutput moreinfo="none">- : 'a Deferred.t -&gt; ('a -&gt; 'b Deferred.t) -&gt; 'b Deferred.t = &lt;fun&gt;</computeroutput></programlisting>

    <para><literal moreinfo="none">Deferred.bind d f</literal> takes a
    deferred value <literal moreinfo="none">d</literal> and a function
    <literal moreinfo="none">f</literal> that is to be run with the value of
    <literal moreinfo="none">d</literal> once it's determined. You can think
    of <literal moreinfo="none">Deferred.bind</literal> as a kind of
    sequencing operator, and what we're doing is essentially taking an
    asynchronous computation <literal moreinfo="none">d</literal> and tacking
    on another stage comprised by the actions of the function <literal moreinfo="none">f</literal>.<indexterm class="singular">
        <primary>Deferred.bind</primary>
      </indexterm></para>

    <para>At a more concrete level, the call to <literal moreinfo="none">Deferred.bind</literal> returns a new deferred that
    becomes determined when the deferred returned by <literal moreinfo="none">f</literal> is determined. It also implicitly registers
    with the scheduler an <emphasis>Async job</emphasis> that is responsible
    for running <literal moreinfo="none">f</literal> once <literal moreinfo="none">d</literal> is determined.</para>

    <para>Here's a simple use of <literal>bind</literal> for a function that replaces a file with an
      uppercase version of its contents:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/async/main.topscript">OCaml utop</ulink>
    (part 8)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let uppercase_file filename =</userinput>
<userinput moreinfo="none">    Deferred.bind (Reader.file_contents filename)</userinput>
<userinput moreinfo="none">     (fun text -&gt;</userinput>
<userinput moreinfo="none">         Writer.save filename ~contents:(String.uppercase text))</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val uppercase_file : string -&gt; unit Deferred.t = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">uppercase_file "test.txt";;</userinput>
<computeroutput moreinfo="none">- : unit = ()</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Reader.file_contents "test.txt";;</userinput>
<computeroutput moreinfo="none">- : string = "THIS IS ONLY A TEST."</computeroutput></programlisting>

    <para>Writing out <literal moreinfo="none">Deferred.bind</literal>
    explicitly can be rather verbose, and so <literal moreinfo="none">Async.Std</literal> includes an infix operator for it:
    <literal moreinfo="none">&gt;&gt;=</literal>. Using this operator, we can
    rewrite <literal moreinfo="none">uppercase_file</literal> as
    follows:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/async/main.topscript">OCaml utop</ulink>
    (part 9)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let uppercase_file filename =</userinput>
<userinput moreinfo="none">    Reader.file_contents filename</userinput>
<userinput moreinfo="none">    &gt;&gt;= fun text -&gt;</userinput>
<userinput moreinfo="none">    Writer.save filename ~contents:(String.uppercase text)</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val uppercase_file : string -&gt; unit Deferred.t = &lt;fun&gt;</computeroutput></programlisting>

    <para>In the preceding code, we've dropped the parentheses around the function on the righthand
      side of the bind, and we didn't add a level of indentation for the contents of that function.
      This is standard practice for using the <literal>bind</literal> operator.<indexterm class="singular">
        <primary>bind function</primary>
      </indexterm></para>

    <para>Now let's look at another potential use of <literal>bind</literal>. In this case, we'll
      write a function that counts the number of lines in a file:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/async/main.topscript">OCaml utop</ulink>
    (part 10)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let count_lines filename =</userinput>
<userinput moreinfo="none">    Reader.file_contents filename</userinput>
<userinput moreinfo="none">    &gt;&gt;= fun text -&gt;</userinput>
<userinput moreinfo="none">    List.length (String.split text ~on:'\n')</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">Characters 85-125:</computeroutput>
<computeroutput moreinfo="none">Error: This expression has type int but an expression was expected of type</computeroutput>
<computeroutput moreinfo="none">         'a Deferred.t</computeroutput></programlisting>

    <para>This looks reasonable enough, but as you can see, the compiler is unhappy. The issue here
      is that <literal>bind</literal> expects a function that returns a deferred, but we've provided
      it a function that returns the nondeferred result directly. To make these signatures match, we
      need a function for taking an ordinary value and wrapping it in a deferred. This function is a
      standard part of Async and is called <literal moreinfo="none">return</literal>:<indexterm class="singular">
        <primary>return function</primary>
      </indexterm></para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/async/main.topscript">OCaml utop</ulink>
    (part 11)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">return;;</userinput>
<computeroutput moreinfo="none">- : 'a -&gt; 'a Deferred.t = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let three = return 3;;</userinput>
<computeroutput moreinfo="none">val three : int Deferred.t = &lt;abstr&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">three;;</userinput>
<computeroutput moreinfo="none">- : int = 3</computeroutput></programlisting>

    <para>Using <literal moreinfo="none">return</literal>, we can make
    <literal moreinfo="none">count_lines</literal> compile:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/async/main.topscript">OCaml utop</ulink>
    (part 12)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let count_lines filename =</userinput>
<userinput moreinfo="none">    Reader.file_contents filename</userinput>
<userinput moreinfo="none">    &gt;&gt;= fun text -&gt;</userinput>
<userinput moreinfo="none">    return (List.length (String.split text ~on:'\n'))</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val count_lines : string -&gt; int Deferred.t = &lt;fun&gt;</computeroutput></programlisting>

    <para>Together, <literal moreinfo="none">bind</literal> and <literal moreinfo="none">return</literal> form a design pattern in functional
    programming known as a <emphasis>monad</emphasis>. You'll run across this
    signature in many applications beyond just threads. Indeed, we already ran
    across monads in <xref linkend="bind-and-other-error-handling-idioms"/>.<indexterm class="singular">
        <primary>monads</primary>
      </indexterm></para>

    <para>Calling <literal moreinfo="none">bind</literal> and <literal moreinfo="none">return</literal> together is a fairly common pattern, and
    as such there is a standard shortcut for it called <literal moreinfo="none">Deferred.map</literal>, which has the following
    signature:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/async/main.topscript">OCaml utop</ulink>
    (part 13)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">Deferred.map;;</userinput>
<computeroutput moreinfo="none">- : 'a Deferred.t -&gt; f:('a -&gt; 'b) -&gt; 'b Deferred.t = &lt;fun&gt;</computeroutput></programlisting>

    <para>and comes with its own infix equivalent, <literal moreinfo="none">&gt;&gt;|</literal>. Using it, we can rewrite <literal moreinfo="none">count_lines</literal> again a bit more succinctly:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/async/main.topscript">OCaml utop</ulink>
    (part 14)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let count_lines filename =</userinput>
<userinput moreinfo="none">    Reader.file_contents filename</userinput>
<userinput moreinfo="none">    &gt;&gt;| fun text -&gt;</userinput>
<userinput moreinfo="none">    List.length (String.split text ~on:'\n')</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val count_lines : string -&gt; int Deferred.t = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">count_lines "/etc/hosts";;</userinput>
<computeroutput moreinfo="none">- : int = 12</computeroutput></programlisting>

    <para>Note that <literal moreinfo="none">count_lines</literal> returns a
    deferred, but <command moreinfo="none">utop</command> waits for that
    deferred to become determined, and shows us the contents of the deferred
    instead.</para>

    <sect2 id="ivars-and-upon">
      <title>Ivars and Upon</title>

      <para>Deferreds are usually built using combinations of <literal moreinfo="none">bind</literal>, <literal moreinfo="none">map</literal> and <literal moreinfo="none">return</literal>, but sometimes you want to construct a deferred that you can determine
        explicitly with usercode. This is done using an <emphasis>ivar</emphasis>. (The term ivar
        dates back to a language called Concurrent ML that was developed by John Reppy in the early
        '90s. The "i" in ivar stands for incremental.)<indexterm class="singular">
          <primary>ivars</primary>
        </indexterm><indexterm class="singular">
          <primary>Async library</primary>
          <secondary>ivars</secondary>
        </indexterm></para>

      <para>There are three fundamental operations for working with an ivar:
      you can create one, using <literal moreinfo="none">Ivar.create</literal>; you can read off the deferred
      that corresponds to the ivar in question, using <literal moreinfo="none">Ivar.read</literal>; and you can fill an ivar, thus
      causing the corresponding deferred to become determined, using <literal moreinfo="none">Ivar.fill</literal>. These operations are
      illustrated below:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/async/main.topscript">OCaml utop</ulink>
      (part 15)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let ivar = Ivar.create ();;</userinput>
<computeroutput moreinfo="none">val ivar : '_a Ivar.t = &lt;abstr&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let def = Ivar.read ivar;;</userinput>
<computeroutput moreinfo="none">val def : '_a Deferred.t = &lt;abstr&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Deferred.peek def;;</userinput>
<computeroutput moreinfo="none">- : '_a option = None</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Ivar.fill ivar "Hello";;</userinput>
<computeroutput moreinfo="none">- : unit = ()</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Deferred.peek def;;</userinput>
<computeroutput moreinfo="none">- : string option = Some "Hello"</computeroutput></programlisting>

      <para>Ivars are something of a low-level feature; operators like <literal>map</literal>,
          <literal>bind</literal> and <literal>return</literal> are typically easier to use and
        think about. But ivars can be useful when you want to build a synchronization pattern that
        isn't already well supported.</para>

      <para>As an example, imagine we wanted a way of scheduling a sequence of
      actions that would run after a fixed delay. In addition, we'd like to
      guarantee that these delayed actions are executed in the same order they
      were scheduled in. Here's a reasonable signature that captures this
      idea:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/async/main.topscript">OCaml utop</ulink>
      (part 16)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">module type Delayer_intf = sig</userinput>
<userinput moreinfo="none">    type t</userinput>
<userinput moreinfo="none">    val create : Time.Span.t -&gt; t</userinput>
<userinput moreinfo="none">    val schedule : t -&gt; (unit -&gt; 'a Deferred.t) -&gt; 'a Deferred.t</userinput>
<userinput moreinfo="none">  end;;</userinput>
<computeroutput moreinfo="none">module type Delayer_intf =</computeroutput>
<computeroutput moreinfo="none">  sig</computeroutput>
<computeroutput moreinfo="none">    type t</computeroutput>
<computeroutput moreinfo="none">    val create : Core.Span.t -&gt; t</computeroutput>
<computeroutput moreinfo="none">    val schedule : t -&gt; (unit -&gt; 'a Deferred.t) -&gt; 'a Deferred.t</computeroutput>
<computeroutput moreinfo="none">  end</computeroutput></programlisting>

      <para>An action is handed to <literal moreinfo="none">schedule</literal>
      in the form of a deferred-returning thunk (a thunk is a function whose
      argument is of type <literal moreinfo="none">unit</literal>). A deferred
      is handed back to the caller of <literal moreinfo="none">schedule</literal> that will eventually be filled with
      the contents of the deferred value returned by the thunk. To implement
      this, we'll use an operator called <literal moreinfo="none">upon</literal>, which has the following
      signature:<indexterm class="singular">
          <primary>thunks</primary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/async/main.topscript">OCaml utop</ulink>
      (part 17)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">upon;;</userinput>
<computeroutput moreinfo="none">- : 'a Deferred.t -&gt; ('a -&gt; unit) -&gt; unit = &lt;fun&gt;</computeroutput></programlisting>

      <para>Like <literal moreinfo="none">bind</literal> and <literal moreinfo="none">return</literal>, <literal moreinfo="none">upon</literal> schedules a callback to be executed when
      the deferred it is passed is determined; but unlike those calls, it
      doesn't create a new deferred for this callback to fill.</para>

      <para>Our delayer implementation is organized around a queue of thunks,
      where every call to <literal moreinfo="none">schedule</literal> adds a
      thunk to the queue and also schedules a job in the future to grab a
      thunk off the queue and run it. The waiting will be done using the
      function <literal moreinfo="none">after</literal>, which takes a time
      span and returns a deferred which becomes determined after that time
      span elapses:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/async/main.topscript">OCaml utop</ulink>
      (part 18)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">module Delayer : Delayer_intf = struct</userinput>
<userinput moreinfo="none">    type t = { delay: Time.Span.t;</userinput>
<userinput moreinfo="none">               jobs: (unit -&gt; unit) Queue.t;</userinput>
<userinput moreinfo="none">             }</userinput>
<userinput moreinfo="none"/>
<userinput moreinfo="none">    let create delay =</userinput>
<userinput moreinfo="none">      { delay; jobs = Queue.create () }</userinput>
<userinput moreinfo="none"/>
<userinput moreinfo="none">    let schedule t thunk =</userinput>
<userinput moreinfo="none">      let ivar = Ivar.create () in</userinput>
<userinput moreinfo="none">      Queue.enqueue t.jobs (fun () -&gt;</userinput>
<userinput moreinfo="none">        upon (thunk ()) (fun x -&gt; Ivar.fill ivar x));</userinput>
<userinput moreinfo="none">      upon (after t.delay) (fun () -&gt;</userinput>
<userinput moreinfo="none">        let job = Queue.dequeue_exn t.jobs in</userinput>
<userinput moreinfo="none">        job ());</userinput>
<userinput moreinfo="none">      Ivar.read ivar</userinput>
<userinput moreinfo="none">  end;;</userinput>
<computeroutput moreinfo="none">module Delayer : Delayer_intf</computeroutput></programlisting>

      <para>This code isn't particularly long, but it is subtle. In
      particular, note how the queue of thunks is used to ensure that the
      enqueued actions are run in order, even if the thunks scheduled by
      <literal moreinfo="none">upon</literal> are run out of order. This kind
      of subtlety is typical of code that involves ivars and <literal moreinfo="none">upon</literal>, and because of this, you should stick to
      the simpler map/bind/return style of working with deferreds when you
      can.<indexterm class="endofrange" startref="ALbas"/></para>
    </sect2>
  </sect1>

  <sect1 id="examples-an-echo-server">
    <title>Examples: An Echo Server</title>

    <para>Now that we have the basics of Async under our belt, let's look at a
    small standalone Async program. In particular, we'll write an echo server,
    i.e., a program that accepts connections from clients and spits back
    whatever is sent to it.<indexterm class="startofrange" id="echo">
        <primary>echo servers</primary>
      </indexterm><indexterm class="startofrange" id="ALecho">
        <primary>Async library</primary>

        <secondary>echo server example</secondary>
      </indexterm></para>

    <para>The first step is to create a function that can copy data from an input to an output.
      Here, we'll use Async's <literal moreinfo="none">Reader</literal> and <literal moreinfo="none">Writer</literal> modules, which provide a convenient abstraction for working with input and
      output channels:<indexterm class="singular">
        <primary>Writer module</primary>
      </indexterm><indexterm class="singular">
        <primary>Reader module</primary>
      </indexterm><indexterm class="singular">
        <primary>I/O (input/output) operations</primary>
        <secondary>copying data</secondary>
      </indexterm></para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/async/echo.ml">OCaml</ulink></para>

    <programlisting format="linespecific" language="ocaml">open Core.Std
open Async.Std

(* Copy data from the reader to the writer, using the provided buffer
   as scratch space *)
let rec copy_blocks buffer r w =
  Reader.read r buffer
  &gt;&gt;= function
  | `Eof -&gt; return ()
  | `Ok bytes_read -&gt;
    Writer.write w buffer ~len:bytes_read;
    Writer.flushed w
    &gt;&gt;= fun () -&gt;
    copy_blocks buffer r w</programlisting>

    <para>Bind is used in the code to sequence the operations: first, we call
    <literal moreinfo="none">Reader.read</literal> to get a block of input.
    Then, when that's complete and if a new block was returned, we write that
    block to the writer. Finally, we wait until the writer's buffers are
    flushed, waiting on the deferred returned by <literal moreinfo="none">Writer.flushed</literal>, at which point we recurse. If we
    hit an end-of-file condition, the loop is ended. The deferred returned by
    a call to <literal moreinfo="none">copy_blocks</literal> becomes
    determined only once the end-of-file condition is hit.<indexterm class="singular">
        <primary>end-of-file condition</primary>
      </indexterm></para>

    <para>One important aspect of how this is written is that it uses
    <emphasis>pushback</emphasis>, which is to say that if the writer can't
    make progress writing, the reader will stop reading. If you don't
    implement pushback in your servers, then a stopped client can cause your
    program to leak memory, since you'll need to allocate space for the data
    that's been read in but not yet written out.<indexterm class="singular">
        <primary>pushback</primary>
      </indexterm></para>

    <para>You might also be concerned that the chain of deferreds that is
    built up as you go through the loop would lead to a memory leak. After
    all, this code constructs an ever-growing chain of binds, each of which
    creates a deferred. In this case, however, all of the deferreds should
    become determined precisely when the final deferred in the chain is
    determined, in this case, when the <literal moreinfo="none">Eof</literal>
    condition is hit. Because of this, we could safely replace all of these
    deferreds with a single deferred. Async has logic to do just this, and so
    there's no memory leak after all. This is essentially a form of tail-call
    optimization, lifted to the Async monad.<indexterm class="singular">
        <primary>tail calls</primary>
      </indexterm></para>

    <para><literal moreinfo="none">copy_blocks</literal> provides the logic
    for handling a client connection, but we still need to set up a server to
    receive such connections and dispatch to <literal moreinfo="none">copy_blocks</literal>. For this, we'll use Async's
    <literal moreinfo="none">Tcp</literal> module, which has a collection of
    utilities for creating TCP clients and servers:<indexterm class="singular">
        <primary>TCP clients/servers</primary>
      </indexterm></para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/async/echo.ml">OCaml</ulink>
    (part 1)</para>

    <programlisting format="linespecific" language="ocaml">(** Starts a TCP server, which listens on the specified port, invoking
    copy_blocks every time a client connects. *)
let run () =
  let host_and_port =
    Tcp.Server.create
      ~on_handler_error:`Raise
      (Tcp.on_port 8765)
      (fun _addr r w -&gt;
         let buffer = String.create (16 * 1024) in
         copy_blocks buffer r w)
  in
  ignore (host_and_port : (Socket.Address.Inet.t, int) Tcp.Server.t Deferred.t)</programlisting>

    <para>The result of calling <literal moreinfo="none">Tcp.Server.create</literal> is a <literal moreinfo="none">Tcp.Server.t</literal>, which is a handle to the server that lets you shut
      the server down. We don't use that functionality here, so we explicitly ignore <literal moreinfo="none">server</literal> to suppress the unused-variables error. We put in a type
      annotation around the ignored value to make the nature of the value we're ignoring <phrase role="keep-together">explicit</phrase>.</para>

    <para>The most important argument to <literal moreinfo="none">Tcp.Server.create</literal> is the final one, which is the
    client connection handler. Notably, the preceding code does nothing
    explicit to close down the client connections when the communication is
    done. That's because the server will automatically shut down the
    connection once the deferred returned by the handler becomes
    determined.</para>

    <para>Finally, we need to initiate the server and start the Async
    scheduler:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/async/echo.ml">OCaml</ulink>
    (part 2)</para>

    <programlisting format="linespecific" language="ocaml">(* Call [run], and then start the scheduler *)
let () =
  run ();
  never_returns (Scheduler.go ())</programlisting>

    <para>One of the most common newbie errors with Async is to forget to run
    the scheduler. It can be a bewildering mistake, because without the
    scheduler, your program won't do anything at all; even calls to <literal moreinfo="none">printf</literal> won't reach the terminal.</para>

    <para>It's worth noting that even though we didn't spend much explicit
    effort on thinking about multiple clients, this server is able to handle
    many concurrent clients without further modification.</para>

    <para>Now that we have the echo server, we can connect to the echo server
    using the netcat tool, which is invoked as <literal moreinfo="none">nc</literal>:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/async/run_echo.out">Terminal</ulink></para>

    <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">./echo.native &amp;</userinput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">nc 127.0.0.1 8765</userinput>
<computeroutput moreinfo="none">This is an echo server</computeroutput>
<computeroutput moreinfo="none">This is an echo server</computeroutput>
<computeroutput moreinfo="none">It repeats whatever I write.</computeroutput>
<computeroutput moreinfo="none">It repeats whatever I write.</computeroutput></programlisting>

    <sidebar>
      <title>Functions that Never Return</title>

      <para>You might wonder what's going on with the call to <literal moreinfo="none">never_returns</literal>. <literal moreinfo="none">never_returns</literal> is an idiom
        that comes from Core that is used to mark functions that don't return. Typically, a function
        that doesn't return is inferred as having return type <literal moreinfo="none">'a</literal>:<indexterm class="singular">
          <primary>Scheduler.go</primary>
        </indexterm><indexterm class="singular">
          <primary>loop_forever</primary>
        </indexterm><indexterm class="singular">
          <primary>never_returns</primary>
        </indexterm><indexterm class="singular">
          <primary>functions</primary>
          <secondary>non-returning</secondary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/async/main.topscript">OCaml utop</ulink>
      (part 19)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let rec loop_forever () = loop_forever ();;</userinput>
<computeroutput moreinfo="none">val loop_forever : unit -&gt; 'a = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let always_fail () = assert false;;</userinput>
<computeroutput moreinfo="none">val always_fail : unit -&gt; 'a = &lt;fun&gt;</computeroutput></programlisting>

      <para>This can be surprising when you call a function like this expecting it to return
          <literal>unit</literal>. The type-checker won't necessarily complain in such a
        case:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/async/main.topscript">OCaml utop</ulink>
      (part 20)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let do_stuff n =</userinput>
<userinput moreinfo="none">    let x = 3 in</userinput>
<userinput moreinfo="none">    if n &gt; 0 then loop_forever ();</userinput>
<userinput moreinfo="none">    x + n</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val do_stuff : int -&gt; int = &lt;fun&gt;</computeroutput></programlisting>

      <para>With a name like <literal moreinfo="none">loop_forever</literal>,
      the meaning is clear enough. But with something like <literal moreinfo="none">Scheduler.go</literal>, the fact that it never returns
      is less clear, and so we use the type system to make it more explicit by
      giving it a return type of <literal moreinfo="none">never_returns</literal>. Let's do the same trick with
      <literal moreinfo="none">loop_forever</literal>:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/async/main.topscript">OCaml utop</ulink>
      (part 21)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let rec loop_forever () : never_returns = loop_forever ();;</userinput>
<computeroutput moreinfo="none">val loop_forever : unit -&gt; never_returns = &lt;fun&gt;</computeroutput></programlisting>

      <para>The type <literal moreinfo="none">never_returns</literal> is uninhabited, so a function
        can't return a value of type <literal moreinfo="none">never_returns</literal>, which means
        only a function that never returns can have <literal moreinfo="none">never_returns</literal>
        as its return type! Now, if we rewrite our <literal moreinfo="none">do_stuff</literal>
        function, we'll get a helpful type error:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/async/main.topscript">OCaml utop</ulink>
      (part 22)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let do_stuff n =</userinput>
<userinput moreinfo="none">    let x = 3 in</userinput>
<userinput moreinfo="none">    if n &gt; 0 then loop_forever ();</userinput>
<userinput moreinfo="none">    x + n</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">Characters 38-67:</computeroutput>
<computeroutput moreinfo="none">Error: This expression has type unit but an expression was expected of type</computeroutput>
<computeroutput moreinfo="none">         never_returns</computeroutput></programlisting>

      <para>We can resolve the error by calling the function <literal moreinfo="none">never_returns</literal>:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/async/main.topscript">OCaml utop</ulink>
      (part 23)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">never_returns;;</userinput>
<computeroutput moreinfo="none">- : never_returns -&gt; 'a = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let do_stuff n =</userinput>
<userinput moreinfo="none">    let x = 3 in</userinput>
<userinput moreinfo="none">    if n &gt; 0 then never_returns (loop_forever ());</userinput>
<userinput moreinfo="none">    x + n</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val do_stuff : int -&gt; int = &lt;fun&gt;</computeroutput></programlisting>

      <para>Thus, we got the compilation to go through by explicitly marking
      in the source that the call to <literal moreinfo="none">loop_forever</literal> never returns.</para>
    </sidebar>

    <sect2 id="improving-the-echo-server">
      <title>Improving the Echo Server</title>

      <para>Let's try to go a little bit farther with our echo server by
      walking through a few improvements. In particular, we will:</para>

      <itemizedlist>
        <listitem>
          <para>Add a proper command-line interface with <literal moreinfo="none">Command</literal></para>
        </listitem>

        <listitem>
          <para>Add a flag to specify the port to listen on and a flag to make
          the server echo back the capitalized version of whatever was sent to
          it</para>
        </listitem>

        <listitem>
          <para>Simplify the code using Async's <literal moreinfo="none">Pipe</literal> interface</para>
        </listitem>
      </itemizedlist>

      <para>The following code does all of this:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/async/better_echo.ml">OCaml</ulink></para>

      <programlisting format="linespecific" language="ocaml">open Core.Std
open Async.Std

let run ~uppercase ~port =
  let host_and_port =
    Tcp.Server.create
      ~on_handler_error:`Raise
      (Tcp.on_port port)
      (fun _addr r w -&gt;
        Pipe.transfer (Reader.pipe r) (Writer.pipe w)
           ~f:(if uppercase then String.uppercase else Fn.id))
  in
  ignore (host_and_port : (Socket.Address.Inet.t, int) Tcp.Server.t Deferred.t);
  Deferred.never ()

let () =
  Command.async_basic
    ~summary:"Start an echo server"
    Command.Spec.(
      empty
      +&gt; flag "-uppercase" no_arg
        ~doc:" Convert to uppercase before echoing back"
      +&gt; flag "-port" (optional_with_default 8765 int)
        ~doc:" Port to listen on (default 8765)"
    )
    (fun uppercase port () -&gt; run ~uppercase ~port)
  |&gt; Command.run</programlisting>

      <para>Note the use of <literal moreinfo="none">Deferred.never</literal>
      in the <literal moreinfo="none">run</literal> function. As you might
      guess from the name, <literal moreinfo="none">Deferred.never</literal>
      returns a deferred that is never determined. In this case, that
      indicates that the echo server doesn't ever shut down.<indexterm class="singular">
          <primary>Deferred.never</primary>
        </indexterm></para>

      <para>The biggest change in the preceding code is the use of Async's
      <literal moreinfo="none">Pipe</literal>. A <literal moreinfo="none">Pipe</literal> is an asynchronous communication channel
      that's used for connecting different parts of your program. You can
      think of it as a consumer/producer queue that uses deferreds for
      communicating when the pipe is ready to be read from or written to. Our
      use of pipes is fairly minimal here, but they are an important part of
      Async, so it's worth discussing them in some detail.<indexterm class="singular">
          <primary>pipes</primary>
        </indexterm></para>

      <para>Pipes are created in connected read/write pairs:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/async/main.topscript">OCaml utop</ulink>
      (part 24)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let (r,w) = Pipe.create ();;</userinput>
<computeroutput moreinfo="none">val r : '_a Pipe.Reader.t = &lt;abstr&gt;</computeroutput>
<computeroutput moreinfo="none">val w : '_a Pipe.Writer.t = &lt;abstr&gt;</computeroutput></programlisting>

      <para><literal moreinfo="none">r</literal> and <literal moreinfo="none">w</literal> are really
        just read and write handles to the same underlying object. Note that <literal moreinfo="none">r</literal> and <literal moreinfo="none">w</literal> have weakly
        polymorphic types, as discussed in <xref linkend="imperative-programming"/>, and so can only
        contain values of a single, yet-to-be-determined type.</para>

      <para>If we just try and write to the writer, we'll see that we block indefinitely in <command moreinfo="none">utop</command>. You can break out of the wait by hitting
          <userinput>Control-C</userinput>:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/async/pipe_write_break.rawscript">OCaml utop</ulink></para>

      <programlisting format="linespecific" language="ocaml"><userinput moreinfo="none"># Pipe.write w "Hello World!";;</userinput>
<computeroutput moreinfo="none">Interrupted.</computeroutput></programlisting>

      <para>The deferred returned by write completes on its own once the value
      written into the pipe has been read out:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/async/main.topscript">OCaml utop</ulink>
      (part 25)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let (r,w) = Pipe.create ();;</userinput>
<computeroutput moreinfo="none">val r : '_a Pipe.Reader.t = &lt;abstr&gt;</computeroutput>
<computeroutput moreinfo="none">val w : '_a Pipe.Writer.t = &lt;abstr&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let write_complete = Pipe.write w "Hello World!";;</userinput>
<computeroutput moreinfo="none">val write_complete : unit Deferred.t = &lt;abstr&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Pipe.read r;;</userinput>
<computeroutput moreinfo="none">- : [ `Eof | `Ok of string ] = `Ok "Hello World!"</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">write_complete;;</userinput>
<computeroutput moreinfo="none">- : unit = ()</computeroutput></programlisting>

      <para>In the function <literal moreinfo="none">run</literal>, we're
      taking advantage of one of the many utility functions provided for pipes
      in the <literal moreinfo="none">Pipe</literal> module. In particular,
      we're using <literal moreinfo="none">Pipe.transfer</literal> to set up a
      process that takes data from a reader-pipe and moves it to a
      writer-pipe. Here's the type of <literal moreinfo="none">Pipe.transfer</literal>:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/async/main.topscript">OCaml utop</ulink>
      (part 26)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">Pipe.transfer;;</userinput>
<computeroutput moreinfo="none">- : 'a Pipe.Reader.t -&gt; 'b Pipe.Writer.t -&gt; f:('a -&gt; 'b) -&gt; unit Deferred.t =</computeroutput>
<computeroutput moreinfo="none">&lt;fun&gt;</computeroutput></programlisting>

      <para>The two pipes being connected are generated by the <literal moreinfo="none">Reader.pipe</literal> and <literal moreinfo="none">Writer.pipe</literal> call respectively. Note that
      pushback is preserved throughout the process, so that if the writer gets
      blocked, the writer's pipe will stop pulling data from the reader's
      pipe, which will prevent the reader from reading in more data.</para>

      <para>Importantly, the deferred returned by <literal moreinfo="none">Pipe.transfer</literal> becomes determined once the
      reader has been closed and the last element is transferred from the
      reader to the writer. Once that deferred becomes determined, the server
      will shut down that client connection. So, when a client disconnects,
      the rest of the shutdown happens transparently.</para>

      <para>The command-line parsing for this program is based on the Command library that we
        introduced in <xref linkend="command-line-parsing"/>. Opening <literal moreinfo="none">Async.Std</literal>, shadows the <literal moreinfo="none">Command</literal> module with
        an extended version that contains the <literal moreinfo="none">async_basic</literal>
        call:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/async/main.topscript">OCaml utop</ulink>
      (part 27)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">Command.async_basic;;</userinput>
<computeroutput moreinfo="none">- : summary:string -&gt;</computeroutput>
<computeroutput moreinfo="none">    ?readme:(unit -&gt; string) -&gt;</computeroutput>
<computeroutput moreinfo="none">    ('a, unit -&gt; unit Deferred.t) Command.Spec.t -&gt; 'a -&gt; Command.t</computeroutput>
<computeroutput moreinfo="none">= &lt;fun&gt;</computeroutput></programlisting>

      <para>This differs from the ordinary <literal moreinfo="none">Command.basic</literal> call in
        that the main function must return a <literal moreinfo="none">Deferred.t</literal>, and that
        the running of the command (using <literal moreinfo="none">Command.run</literal>)
        automatically starts the Async scheduler, without requiring an explicit call to <literal moreinfo="none">Scheduler.go</literal>.<indexterm class="endofrange" startref="echo"/><indexterm class="endofrange" startref="ALecho"/></para>
    </sect2>
  </sect1>

  <sect1 id="example-searching-definitions-with-duckduckgo">
    <title>Example: Searching Definitions with DuckDuckGo</title>

    <para>DuckDuckGo is a search engine with a freely available search
    interface. In this section, we'll use Async to write a small command-line
    utility for querying DuckDuckGo to extract definitions for a collection of
    terms.<indexterm class="singular">
        <primary>cohttp library</primary>
      </indexterm><indexterm class="singular">
        <primary>uri library</primary>
      </indexterm><indexterm class="singular">
        <primary>textwrap library</primary>
      </indexterm><indexterm class="singular">
        <primary>DuckDuckGo search engine</primary>

        <secondary>additional libraries needed</secondary>
      </indexterm><indexterm class="singular">
        <primary>search engines</primary>
      </indexterm></para>

    <para>Our code is going to rely on a number of other libraries, all of
      which can be installed using OPAM. Refer to <ulink url="http://realworldocaml.org/install">this Real World OCaml page</ulink>
    if you need help on the installation. Here's the list of libraries we'll
    need:<indexterm class="startofrange" id="ALduckduck">
        <primary>Async library</primary>

        <secondary>DuckDuckGo searching example</secondary>
      </indexterm></para>

    <variablelist>
      <varlistentry>
        <term><literal moreinfo="none">textwrap</literal></term>

        <listitem>
          <para>A library for wrapping long lines. We'll use this for printing
          out our results.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal moreinfo="none">uri</literal></term>

        <listitem>
          <para>A library for handling URIs, or "Uniform Resource Identifiers," of which HTTP URLs
            are an example.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal moreinfo="none">yojson</literal></term>

        <listitem>
          <para>A JSON parsing library that was described in <xref linkend="handling-json-data"/>.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal moreinfo="none">cohttp</literal></term>

        <listitem>
          <para>A library for creating HTTP clients and servers. We need Async
          support, which comes with the <literal moreinfo="none">cohttp.async</literal> package.</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <para>Now let's dive into the implementation.</para>

    <sect2 id="uri-handling">
      <title>URI Handling</title>

      <para>HTTP URLs, which identify endpoints across the Web, are actually part of a more general
        family known as Uniform Resource Identifiers (URIs). The full URI specification is defined
        in <ulink url="http://tools.ietf.org/html/rfc3986">RFC3986</ulink> and is rather
        complicated. Luckily, the <literal moreinfo="none">uri</literal> library provides a strongly
        typed interface that takes care of much of the hassle.<indexterm class="singular">
          <primary>RFC3986</primary>
        </indexterm><indexterm class="singular">
          <primary>Uniform Resource Identifiers (URIs)</primary>
        </indexterm><indexterm class="singular">
          <primary>DuckDuckGo search engine</primary>
          <secondary>URI handling in</secondary>
        </indexterm></para>

      <para>We'll need a function for generating the URIs that we're going to
      use to query the DuckDuckGo servers:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/async/search.ml">OCaml</ulink></para>

      <programlisting format="linespecific" language="ocaml">open Core.Std
open Async.Std

(* Generate a DuckDuckGo search URI from a query string *)
let query_uri query =
  let base_uri = Uri.of_string "http://api.duckduckgo.com/?format=json" in
  Uri.add_query_param base_uri ("q", [query])</programlisting>

      <para>A <literal moreinfo="none">Uri.t</literal> is constructed from the
      <literal moreinfo="none">Uri.of_string</literal> function, and a query
      parameter <literal moreinfo="none">q</literal> is added with the desired
      search query. The library takes care of encoding the URI correctly when
      outputting it in the network protocol.</para>
    </sect2>

    <sect2 id="parsing-json-strings">
      <title>Parsing JSON Strings</title>

      <para>The HTTP response from DuckDuckGo is in JSON, a common (and
      thankfully simple) format that is specified in <ulink url="http://www.ietf.org/rfc/rfc4627.txt">RFC4627</ulink>. We'll parse
      the JSON data using the Yojson library, which was introduced in <xref linkend="handling-json-data"/>.<indexterm class="singular">
          <primary>Yojson library</primary>

          <secondary>parsing JSON with</secondary>
        </indexterm><indexterm class="singular">
          <primary>DuckDuckGo search engine</primary>

          <secondary>parsing JSON strings in</secondary>
        </indexterm><indexterm class="singular">
          <primary>RFC4627</primary>
        </indexterm></para>

      <para>We expect the response from DuckDuckGo to come across as a JSON
      record, which is represented by the <literal moreinfo="none">Assoc</literal> tag in Yojson's JSON variant. We expect
      the definition itself to come across under either the key "Abstract" or
      "Definition," and so the following code looks under both keys, returning
      the first one for which a nonempty value is defined:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/async/search.ml">OCaml</ulink>
      (part 1)</para>

      <programlisting format="linespecific" language="ocaml">(* Extract the "Definition" or "Abstract" field from the DuckDuckGo results *)
let get_definition_from_json json =
  match Yojson.Safe.from_string json with
  | `Assoc kv_list -&gt;
    let find key =
      begin match List.Assoc.find kv_list key with
      | None | Some (`String "") -&gt; None
      | Some s -&gt; Some (Yojson.Safe.to_string s)
      end
    in
    begin match find "Abstract" with
    | Some _ as x -&gt; x
    | None -&gt; find "Definition"
    end
  | _ -&gt; None</programlisting>
    </sect2>

    <sect2 id="executing-an-http-client-query">
      <title>Executing an HTTP Client Query</title>

      <para>Now let's look at the code for dispatching the search queries over
      HTTP, using the Cohttp library:<indexterm class="singular">
          <primary>query-handlers</primary>

          <secondary>executing an HTTP client query</secondary>
        </indexterm><indexterm class="singular">
          <primary>client queries</primary>
        </indexterm><indexterm class="singular">
          <primary>HTTP client queries</primary>
        </indexterm><indexterm class="singular">
          <primary>DuckDuckGo search engine</primary>

          <secondary>executing an HTTP client query in</secondary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/async/search.ml">OCaml</ulink>
      (part 2)</para>

      <programlisting format="linespecific" language="ocaml">(* Execute the DuckDuckGo search *)
let get_definition word =
  Cohttp_async.Client.get (query_uri word)
  &gt;&gt;= fun (_, body) -&gt;
  Pipe.to_list body
  &gt;&gt;| fun strings -&gt;
  (word, get_definition_from_json (String.concat strings))</programlisting>

      <para>To better understand what's going on, it's useful to look at the
      type for <literal moreinfo="none">Cohttp_async.Client.get</literal>,
      which we can do in <command moreinfo="none">utop</command>:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/async/main.topscript">OCaml utop</ulink>
      (part 28)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">#require "cohttp.async";;</userinput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Cohttp_async.Client.get;;</userinput>
<computeroutput moreinfo="none">- : ?interrupt:unit Deferred.t -&gt;</computeroutput>
<computeroutput moreinfo="none">    ?headers:Cohttp.Header.t -&gt;</computeroutput>
<computeroutput moreinfo="none">    Uri.t -&gt; (Cohttp.Response.t * string Pipe.Reader.t) Deferred.t</computeroutput>
<computeroutput moreinfo="none">= &lt;fun&gt;</computeroutput></programlisting>

      <para>The <literal moreinfo="none">get</literal> call takes as a
      required argument a URI and returns a deferred value containing a
      <literal moreinfo="none">Cohttp.Response.t</literal> (which we ignore)
      and a pipe reader to which the body of the request will be
      written.</para>

      <para>In this case, the HTTP body probably isn't very large, so we call
      <literal moreinfo="none">Pipe.to_list</literal> to collect the strings
      from the pipe as a single deferred list of strings. We then join those
      strings using <literal moreinfo="none">String.concat</literal> and pass
      the result through our parsing function.</para>

      <para>Running a single search isn't that interesting from a concurrency
      perspective, so let's write code for dispatching multiple searches in
      parallel. First, we need code for formatting and printing out the search
      result:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/async/search.ml">OCaml</ulink>
      (part 3)</para>

      <programlisting format="linespecific" language="ocaml">(* Print out a word/definition pair *)
let print_result (word,definition) =
  printf "%s\n%s\n\n%s\n\n"
    word
    (String.init (String.length word) ~f:(fun _ -&gt; '-'))
    (match definition with
    | None -&gt; "No definition found"
    | Some def -&gt;
      String.concat ~sep:"\n"
        (Wrapper.wrap (Wrapper.make 70) def))</programlisting>

      <para>We use the <literal moreinfo="none">Wrapper</literal> module from
      the <literal moreinfo="none">textwrap</literal> package to do the line
      wrapping. It may not be obvious that this routine is using Async, but it
      does: the version of <literal moreinfo="none">printf</literal> that's
      called here is actually Async's specialized <literal moreinfo="none">printf</literal> that goes through the Async scheduler
      rather than printing directly. The original definition of <literal moreinfo="none">printf</literal> is shadowed by this new one when you
      open <literal moreinfo="none">Async.Std</literal>. An important side
      effect of this is that if you write an Async program and forget to start
      the scheduler, calls like <literal moreinfo="none">printf</literal>
      won't actually generate any output!</para>

      <para>The next function dispatches the searches in parallel, waits for
      the results, and then prints:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/async/search.ml">OCaml</ulink>
      (part 4)</para>

      <programlisting format="linespecific" language="ocaml">(* Run many searches in parallel, printing out the results after they're all
   done. *)
let search_and_print words =
  Deferred.all (List.map words ~f:get_definition)
  &gt;&gt;| fun results -&gt;
  List.iter results ~f:print_result</programlisting>

      <para>We used <literal moreinfo="none">List.map</literal> to call
      <literal moreinfo="none">get_definition</literal> on each word, and
      <literal moreinfo="none">Deferred.all</literal> to wait for all the
      results. Here's the type of <literal moreinfo="none">Deferred.all</literal>:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/async/main.topscript">OCaml utop</ulink>
      (part 29)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">Deferred.all;;</userinput>
<computeroutput moreinfo="none">- : 'a Deferred.t list -&gt; 'a list Deferred.t = &lt;fun&gt;</computeroutput></programlisting>

      <para>Note that the list returned by <literal moreinfo="none">Deferred.all</literal> reflects
        the order of the deferreds passed to it. As such, the definitions will be printed out in the
        same order that the search words are passed in, no matter what order the queries return in.
        We could rewrite this code to print out the results as they're received (and thus
        potentially out of order) as follows:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/async/search_out_of_order.ml">OCaml</ulink>
      (part 1)</para>

      <programlisting format="linespecific" language="ocaml">(* Run many searches in parallel, printing out the results as you go *)
let search_and_print words =
  Deferred.all_unit (List.map words ~f:(fun word -&gt;
    get_definition word &gt;&gt;| print_result))</programlisting>

      <para>The difference is that we both dispatch the query and print out
      the result in the closure passed to <literal moreinfo="none">map</literal>, rather than wait for all of the results
      to get back and then print them out together. We use <literal moreinfo="none">Deferred.all_unit</literal>, which takes a list of
      <literal moreinfo="none">unit</literal> deferreds and returns a single
      <literal moreinfo="none">unit</literal> deferred that becomes determined
      when every deferred on the input list is determined. We can see the type
      of this function in <command moreinfo="none">utop</command>:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/async/main.topscript">OCaml utop</ulink>
      (part 30)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">Deferred.all_unit;;</userinput>
<computeroutput moreinfo="none">- : unit Deferred.t list -&gt; unit Deferred.t = &lt;fun&gt;</computeroutput></programlisting>

      <para>Finally, we create a command-line interface using <literal moreinfo="none">Command.async_basic</literal>:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/async/search.ml">OCaml</ulink>
      (part 5)</para>

      <programlisting format="linespecific" language="ocaml">let () =
  Command.async_basic
    ~summary:"Retrieve definitions from duckduckgo search engine"
    Command.Spec.(
      empty
      +&gt; anon (sequence ("word" %: string))
    )
    (fun words () -&gt; search_and_print words)
  |&gt; Command.run</programlisting>

      <para>And that's all we need for a simple but usable definition
      searcher:<indexterm class="endofrange" startref="ALduckduck"/></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/async/run_search.out">Terminal</ulink></para>

      <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">corebuild -pkg cohttp.async,yojson,textwrap search.native</userinput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">./search.native "Concurrent Programming" "OCaml"</userinput>
<computeroutput moreinfo="none">Concurrent Programming</computeroutput>
<computeroutput moreinfo="none">----------------------</computeroutput>
<computeroutput moreinfo="none"> </computeroutput>
<computeroutput moreinfo="none">"Concurrent computing is a form of computing in which programs are</computeroutput>
<computeroutput moreinfo="none">designed as collections of interacting computational processes that</computeroutput>
<computeroutput moreinfo="none">may be executed in parallel."</computeroutput>
<computeroutput moreinfo="none"> </computeroutput>
<computeroutput moreinfo="none">OCaml</computeroutput>
<computeroutput moreinfo="none">-----</computeroutput>
<computeroutput moreinfo="none"> </computeroutput>
<computeroutput moreinfo="none">"OCaml, originally known as Objective Caml, is the main implementation</computeroutput>
<computeroutput moreinfo="none">of the Caml programming language, created by Xavier Leroy, Jérôme</computeroutput>
<computeroutput moreinfo="none">Vouillon, Damien Doligez, Didier Rémy and others in 1996."</computeroutput>
<computeroutput moreinfo="none"> </computeroutput></programlisting>
    </sect2>
  </sect1>

  <sect1 id="exception-handling">
    <title>Exception Handling</title>

    <para>When programming with external resources, errors are everywhere:
    everything from a flaky server to a network outage to exhausting of local
    resources can lead to a runtime error. When programming in OCaml, some of
    these errors will show up explicitly in a function's return type, and some
    of them will show up as exceptions. We covered exception handling in OCaml
    in <xref linkend="exceptions"/>, but as we'll see, exception handling in a
    concurrent program presents some new challenges.<indexterm class="singular">
        <primary>exceptions</primary>

        <secondary>in concurrent programming</secondary>
      </indexterm><indexterm class="singular">
        <primary>concurrent programming</primary>
      </indexterm><indexterm class="startofrange" id="ALexcept">
        <primary>Async library</primary>

        <secondary>exception handling in</secondary>
      </indexterm></para>

    <para>Let's get a better sense of how exceptions work in Async by creating an asynchronous
      computation that (sometimes) fails with an exception. The function <literal moreinfo="none">maybe_raise</literal> <phrase role="keep-together">blocks for half a second,</phrase> and then either throws an exception or
      returns <literal>unit</literal>, alternating between the two behaviors on subsequent
      calls:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/async/main.topscript">OCaml utop</ulink>
    (part 31)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let maybe_raise =</userinput>
<userinput moreinfo="none">    let should_fail = ref false in</userinput>
<userinput moreinfo="none">    fun () -&gt;</userinput>
<userinput moreinfo="none">      let will_fail = !should_fail in</userinput>
<userinput moreinfo="none">      should_fail := not will_fail;</userinput>
<userinput moreinfo="none">      after (Time.Span.of_sec 0.5)</userinput>
<userinput moreinfo="none">      &gt;&gt;= fun () -&gt;</userinput>
<userinput moreinfo="none">      if will_fail then raise Exit else return ()</userinput>
<userinput moreinfo="none"> ;;</userinput>
<computeroutput moreinfo="none">val maybe_raise : unit -&gt; unit Deferred.t = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">maybe_raise ();;</userinput>
<computeroutput moreinfo="none">- : unit = ()</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">maybe_raise ();;</userinput>
<computeroutput moreinfo="none">Exception:</computeroutput>
<computeroutput moreinfo="none">(lib/monitor.ml.Error_</computeroutput>
<computeroutput moreinfo="none"> ((exn Exit) (backtrace (""))</computeroutput>
<computeroutput moreinfo="none">  (monitor</computeroutput>
<computeroutput moreinfo="none">   (((name block_on_async) (here ()) (id 55) (has_seen_error true)</computeroutput>
<computeroutput moreinfo="none">     (someone_is_listening true) (kill_index 0))</computeroutput>
<computeroutput moreinfo="none">    ((name main) (here ()) (id 1) (has_seen_error false)</computeroutput>
<computeroutput moreinfo="none">     (someone_is_listening false) (kill_index 0)))))).</computeroutput></programlisting>

    <para>In <command moreinfo="none">utop</command>, the exception thrown by
    <literal moreinfo="none">maybe_raise ()</literal> terminates the
    evaluation of just that expression, but in a standalone program, an
    uncaught exception would bring down the entire process.</para>

    <para>So, how could we capture and handle such an exception? You might try
    to do this using OCaml's built-in <literal moreinfo="none">try/with</literal> statement, but as you can see that
    doesn't quite do the trick:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/async/main.topscript">OCaml utop</ulink>
    (part 32)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let handle_error () =</userinput>
<userinput moreinfo="none">    try</userinput>
<userinput moreinfo="none">      maybe_raise ()</userinput>
<userinput moreinfo="none">      &gt;&gt;| fun () -&gt; "success"</userinput>
<userinput moreinfo="none">    with _ -&gt; return "failure"</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val handle_error : unit -&gt; string Deferred.t = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">handle_error ();;</userinput>
<computeroutput moreinfo="none">- : string = "success"</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">handle_error ();;</userinput>
<computeroutput moreinfo="none">Exception:</computeroutput>
<computeroutput moreinfo="none">(lib/monitor.ml.Error_</computeroutput>
<computeroutput moreinfo="none"> ((exn Exit) (backtrace (""))</computeroutput>
<computeroutput moreinfo="none">  (monitor</computeroutput>
<computeroutput moreinfo="none">   (((name block_on_async) (here ()) (id 59) (has_seen_error true)</computeroutput>
<computeroutput moreinfo="none">     (someone_is_listening true) (kill_index 0))</computeroutput>
<computeroutput moreinfo="none">    ((name main) (here ()) (id 1) (has_seen_error false)</computeroutput>
<computeroutput moreinfo="none">     (someone_is_listening false) (kill_index 0)))))).</computeroutput></programlisting>

    <para>This didn't work because <literal moreinfo="none">try/with</literal>
    only captures exceptions that are thrown in the code directly executed
    within it, while <literal moreinfo="none">maybe_raise</literal> schedules
    an Async job to run in the future, and it's that job that throws an
    exception.</para>

    <para>We can capture this kind of asynchronous error using the <literal moreinfo="none">try_with</literal> function provided by Async:<indexterm class="singular">
        <primary>exceptions</primary>
        <secondary>asynchronous errors</secondary>
      </indexterm></para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/async/main.topscript">OCaml utop</ulink>
    (part 33)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let handle_error () =</userinput>
<userinput moreinfo="none">    try_with (fun () -&gt; maybe_raise ())</userinput>
<userinput moreinfo="none">    &gt;&gt;| function</userinput>
<userinput moreinfo="none">    | Ok ()   -&gt; "success"</userinput>
<userinput moreinfo="none">    | Error _ -&gt; "failure"</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val handle_error : unit -&gt; string Deferred.t = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">handle_error ();;</userinput>
<computeroutput moreinfo="none">- : string = "success"</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">handle_error ();;</userinput>
<computeroutput moreinfo="none">- : string = "failure"</computeroutput></programlisting>

    <para><literal moreinfo="none">try_with f</literal> takes as its argument
    a deferred-returning thunk <literal moreinfo="none">f</literal> and
    returns a deferred that becomes determined either as <literal moreinfo="none">Ok</literal> of whatever <literal moreinfo="none">f</literal> returned, or <literal moreinfo="none">Error
    exn</literal> if <literal moreinfo="none">f</literal> threw an exception
    before its return value became determined.</para>

    <sect2 id="monitors">
      <title>Monitors</title>

      <para><literal moreinfo="none">try_with</literal> is a great way of
      handling exceptions in Async, but it's not the whole story. All of
      Async's exception-handling mechanisms, <literal moreinfo="none">try_with</literal> included, are built on top of Async's
      system of <emphasis>monitors</emphasis>, which are inspired by the
      error-handling mechanism in Erlang of the same name. Monitors are fairly
      low-level and are only occasionally used directly, but it's nonetheless
      worth understanding how they work.<indexterm class="singular">
          <primary>monitors</primary>
        </indexterm></para>

      <para>In Async, a monitor is a context that determines what to do when
      there is an unhandled exception. Every Async job runs within the context
      of some monitor, which, when the job is running, is referred to as the
      current monitor. When a new Async job is scheduled, say, using <literal moreinfo="none">bind</literal> or <literal moreinfo="none">map</literal>, it inherits the current monitor of the
      job that spawned it.</para>

      <para>Monitors are arranged in a tree—when a new monitor is created
      (say, using <literal moreinfo="none">Monitor.create</literal>), it is a
      child of the current monitor. You can explicitly run jobs within a
      monitor using <literal moreinfo="none">within</literal>, which takes a
      thunk that returns a nondeferred value, or <literal moreinfo="none">within'</literal>, which takes a thunk that returns a
      deferred. Here's an example:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/async/main.topscript">OCaml utop</ulink>
      (part 34)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let blow_up () =</userinput>
<userinput moreinfo="none">    let monitor = Monitor.create ~name:"blow up monitor" () in</userinput>
<userinput moreinfo="none">    within' ~monitor maybe_raise</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val blow_up : unit -&gt; unit Deferred.t = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">blow_up ();;</userinput>
<computeroutput moreinfo="none">- : unit = ()</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">blow_up ();;</userinput>
<computeroutput moreinfo="none">Exception:</computeroutput>
<computeroutput moreinfo="none">(lib/monitor.ml.Error_</computeroutput>
<computeroutput moreinfo="none"> ((exn Exit) (backtrace (""))</computeroutput>
<computeroutput moreinfo="none">  (monitor</computeroutput>
<computeroutput moreinfo="none">   (((name "blow up monitor") (here ()) (id 71) (has_seen_error true)</computeroutput>
<computeroutput moreinfo="none">     (someone_is_listening false) (kill_index 0))</computeroutput>
<computeroutput moreinfo="none">    ((name block_on_async) (here ()) (id 70) (has_seen_error false)</computeroutput>
<computeroutput moreinfo="none">     (someone_is_listening true) (kill_index 0))</computeroutput>
<computeroutput moreinfo="none">    ((name main) (here ()) (id 1) (has_seen_error false)</computeroutput>
<computeroutput moreinfo="none">     (someone_is_listening false) (kill_index 0)))))).</computeroutput></programlisting>

      <para>In addition to the ordinary stack-trace, the exception displays
      the trace of monitors through which the exception traveled, starting at
      the one we created, called "blow up monitor." The other monitors you see
      come from <command moreinfo="none">utop</command>'s special handling of
      deferreds.</para>

      <para>Monitors can do more than just augment the error-trace of an exception. You can also use
        a monitor to explicitly handle errors delivered to that monitor. The <literal moreinfo="none">Monitor.errors</literal> call is a particularly important one. It detaches
        the monitor from its parent, handing back the stream of errors that would otherwise have
        been delivered to the parent monitor. This allows one to do custom handling of errors, which
        may include reraising errors to the parent. Here is a very simple example of a function that
        captures and ignores errors in the processes it spawns:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/async/main-35.rawscript">OCaml utop</ulink></para>

      <programlisting format="linespecific" language="ocaml"><userinput moreinfo="none"># let swallow_error () =
    let monitor = Monitor.create () in
    Stream.iter (Monitor.errors monitor) ~f:(fun _exn -&gt;
      printf "an error happened\n");
    within' ~monitor (fun () -&gt;
      after (Time.Span.of_sec 0.5) &gt;&gt;= fun () -&gt; failwith "Kaboom!")
  ;;</userinput>
<computeroutput moreinfo="none">val swallow_error : unit -&gt; 'a Deferred.t = &lt;fun&gt;</computeroutput>
<userinput moreinfo="none"># swallow_error ();;</userinput>
<computeroutput moreinfo="none">an error happened
</computeroutput></programlisting>

      <para>The message "an error happened" is printed out, but the deferred
      returned by <literal moreinfo="none">swallow_error</literal> is never
      determined. This makes sense, since the calculation never actually
      completes, so there's no value to return. You can break out of this in
      <command moreinfo="none">utop</command> by hitting <userinput>Control+C</userinput>
        .</para>

      <para>Here's an example of a monitor that passes some exceptions through to the parent and
        handles others. Exceptions are sent to the parent using <literal moreinfo="none">Monitor.send_exn</literal>, with <literal moreinfo="none">Monitor.current</literal> being
        called to find the current monitor, which is the parent of the newly created monitor:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/async/main.topscript">OCaml utop</ulink>
      (part 36)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">exception Ignore_me;;</userinput>
<computeroutput moreinfo="none">exception Ignore_me</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let swallow_some_errors exn_to_raise =</userinput>
<userinput moreinfo="none">    let child_monitor  = Monitor.create  () in</userinput>
<userinput moreinfo="none">    let parent_monitor = Monitor.current () in</userinput>
<userinput moreinfo="none">    Stream.iter (Monitor.errors child_monitor) ~f:(fun error -&gt;</userinput>
<userinput moreinfo="none">      match Monitor.extract_exn error with</userinput>
<userinput moreinfo="none">      | Ignore_me -&gt; printf "ignoring exn\n"</userinput>
<userinput moreinfo="none">      | _ -&gt; Monitor.send_exn parent_monitor error);</userinput>
<userinput moreinfo="none">    within' ~monitor:child_monitor (fun () -&gt;</userinput>
<userinput moreinfo="none">       after (Time.Span.of_sec 0.5)</userinput>
<userinput moreinfo="none">       &gt;&gt;= fun () -&gt; raise exn_to_raise)</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val swallow_some_errors : exn -&gt; 'a Deferred.t = &lt;fun&gt;</computeroutput></programlisting>

      <para>Note that we use <literal moreinfo="none">Monitor.extract_exn</literal> to grab the underlying
      exception that was thrown. Async wraps exceptions it catches with extra
      information, including the monitor trace, so you need to grab the
      underlying exception to match on it.</para>

      <para>If we pass in an exception other than <literal moreinfo="none">Ignore_me</literal>, like, say, the built-in exception
      <literal moreinfo="none">Not_found</literal>, then the exception will be
      passed to the parent monitor and delivered as usual:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/async/main.topscript">OCaml utop</ulink>
      (part 37)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">swallow_some_errors Not_found;;</userinput>
<computeroutput moreinfo="none">Exception:</computeroutput>
<computeroutput moreinfo="none">(lib/monitor.ml.Error_</computeroutput>
<computeroutput moreinfo="none"> ((exn Not_found) (backtrace (""))</computeroutput>
<computeroutput moreinfo="none">  (monitor</computeroutput>
<computeroutput moreinfo="none">   (((name (id 75)) (here ()) (id 75) (has_seen_error true)</computeroutput>
<computeroutput moreinfo="none">     (someone_is_listening true) (kill_index 0))</computeroutput>
<computeroutput moreinfo="none">    ((name block_on_async) (here ()) (id 74) (has_seen_error true)</computeroutput>
<computeroutput moreinfo="none">     (someone_is_listening true) (kill_index 0))</computeroutput>
<computeroutput moreinfo="none">    ((name main) (here ()) (id 1) (has_seen_error false)</computeroutput>
<computeroutput moreinfo="none">     (someone_is_listening false) (kill_index 0)))))).</computeroutput></programlisting>

      <para>If instead we use <literal>Ignore_me</literal>, the exception will be ignorred, and the deferred never becomes determined:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/async/main-38.rawscript">OCaml utop</ulink></para>

      <programlisting format="linespecific" language="ocaml"><userinput moreinfo="none"># swallow_some_errors Ignore_me;;</userinput>
<computeroutput moreinfo="none">ignoring exn</computeroutput></programlisting>

      <para>In practice, you should rarely use monitors directly, and instead use functions like
          <literal moreinfo="none">try_with</literal> and <literal moreinfo="none">Monitor.protect</literal> that are built on top of monitors. One example of a library
        that uses monitors directly is <literal moreinfo="none">Tcp.Server.create</literal>, which
        tracks both exceptions thrown by the logic that handles the network connection and by the
        callback for responding to an individual request, in either case responding to an exception
        by closing the connection. It is for building this kind of custom error handling that
        monitors can be helpful.</para>
    </sect2>

    <sect2 id="example-handling-exceptions-with-duckduckgo">
      <title>Example: Handling Exceptions with DuckDuckGo</title>

      <para>Let's now go back and improve the exception handling of our DuckDuckGo client. In
        particular, we'll change it so that any query that fails is reported without preventing
        other queries from completing.<indexterm class="singular">
          <primary>exceptions</primary>
          <secondary>search engine example</secondary>
        </indexterm><indexterm class="singular">
          <primary>DuckDuckGo search engine</primary>
          <secondary>exception handling in</secondary>
        </indexterm></para>

      <para>The search code as it is fails rarely, so let's make a change that
      allows us to trigger failures more predictably. We'll do this by making
      it possible to distribute the requests over multiple servers. Then,
      we'll handle the errors that occur when one of those servers is
      misspecified.</para>

      <para>First we'll need to change <literal moreinfo="none">query_uri</literal> to take an argument specifying the
      server to connect to:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/async/search_with_configurable_server.ml">OCaml</ulink>
      (part 1)</para>

      <programlisting format="linespecific" language="ocaml">(* Generate a DuckDuckGo search URI from a query string *)
let query_uri ~server query =
  let base_uri =
    Uri.of_string (String.concat ["http://";server;"/?format=json"])
  in
  Uri.add_query_param base_uri ("q", [query])</programlisting>

      <para>In addition, we'll make the necessary changes to get the list of servers on the
        command-line, and to distribute the search qeuries round-robin across the list of servers.
        Now, let's see what happens if we rebuild the application and run it giving it a list of
        servers, some of which won't respond to the query:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/async/run_search_with_configurable_server.out">Terminal</ulink></para>

      <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">corebuild -pkg cohttp.async,yojson,textwrap \</userinput>
<computeroutput moreinfo="none">    search_with_configurable_server.native</computeroutput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">./search_with_configurable_server.native \</userinput>
<computeroutput moreinfo="none">    -servers localhost,api.duckduckgo.com \</computeroutput>
<computeroutput moreinfo="none">    "Concurrent Programming" OCaml</computeroutput>
<computeroutput moreinfo="none">("unhandled exception"</computeroutput>
<computeroutput moreinfo="none"> ((lib/monitor.ml.Error_</computeroutput>
<computeroutput moreinfo="none">   ((exn (Unix.Unix_error "Connection refused" connect 127.0.0.1:80))</computeroutput>
<computeroutput moreinfo="none">    (backtrace</computeroutput>
<computeroutput moreinfo="none">     ("Raised by primitive operation at file \"lib/unix_syscalls.ml\", line 797,
       characters 12-69"</computeroutput>
<computeroutput moreinfo="none">      "Called from file \"lib/deferred.ml\", line 20, characters 62-65"</computeroutput>
<computeroutput moreinfo="none">      "Called from file \"lib/scheduler.ml\", line 125, characters 6-17"</computeroutput>
<computeroutput moreinfo="none">      "Called from file \"lib/jobs.ml\", line 65, characters 8-13" ""))</computeroutput>
<computeroutput moreinfo="none">    (monitor</computeroutput>
<computeroutput moreinfo="none">     (((name Tcp.close_sock_on_error) (here ()) (id 5) (has_seen_error true)</computeroutput>
<computeroutput moreinfo="none">       (someone_is_listening true) (kill_index 0))</computeroutput>
<computeroutput moreinfo="none">      ((name main) (here ()) (id 1) (has_seen_error true)</computeroutput>
<computeroutput moreinfo="none">       (someone_is_listening false) (kill_index 0))))))</computeroutput>
<computeroutput moreinfo="none">  (Pid 15971)))</computeroutput></programlisting>

      <para>As you can see, we got a "Connection refused" failure, which ends the entire program,
        even though one of the two queries would have gone through successfully on its own. We can
        handle the failures of individual connections separately by using the <literal moreinfo="none">try_with</literal> function within each call to <literal moreinfo="none">get_definition</literal>, as follows:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/async/search_with_error_handling.ml">OCaml</ulink>
      (part 1)</para>

      <programlisting format="linespecific" language="ocaml">(* Execute the DuckDuckGo search *)
let get_definition ~server word =
  try_with (fun () -&gt;
    Cohttp_async.Client.get (query_uri ~server word)
    &gt;&gt;= fun  (_, body) -&gt;
    Pipe.to_list body
    &gt;&gt;| fun strings -&gt;
    (word, get_definition_from_json (String.concat strings)))
  &gt;&gt;| function
  | Ok (word,result) -&gt; (word, Ok result)
  | Error _          -&gt; (word, Error "Unexpected failure")</programlisting>

      <para>Here, we first use <literal moreinfo="none">try_with</literal> to
      capture the exception, and then use map (the <literal moreinfo="none">&gt;&gt;|</literal> operator) to convert the error into
      the form we want: a pair whose first element is the word being searched
      for, and the second element is the (possibly erroneous) result.</para>

      <para>Now we just need to change the code for <literal moreinfo="none">print_result</literal> so that it can handle the new
      type:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/async/search_with_error_handling.ml">OCaml</ulink>
      (part 2)</para>

      <programlisting format="linespecific" language="ocaml">(* Print out a word/definition pair *)
let print_result (word,definition) =
  printf "%s\n%s\n\n%s\n\n"
    word
    (String.init (String.length word) ~f:(fun _ -&gt; '-'))
    (match definition with
     | Error s -&gt; "DuckDuckGo query failed: " ^ s
     | Ok None -&gt; "No definition found"
     | Ok (Some def) -&gt;
       String.concat ~sep:"\n"
         (Wrapper.wrap (Wrapper.make 70) def))</programlisting>

      <para>Now, if we run that same query, we'll get individualized handling
      of the connection failures:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/async/run_search_with_error_handling.out">Terminal</ulink></para>

      <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">corebuild -pkg cohttp.async,yojson,textwrap \</userinput>
<computeroutput moreinfo="none">    search_with_error_handling.native</computeroutput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">./search_with_error_handling.native \</userinput>
<computeroutput moreinfo="none">    -servers localhost,api.duckduckgo.com \</computeroutput>
<computeroutput moreinfo="none">    "Concurrent Programming" OCaml</computeroutput>
<computeroutput moreinfo="none">Concurrent Programming</computeroutput>
<computeroutput moreinfo="none">----------------------</computeroutput>
<computeroutput moreinfo="none"> </computeroutput>
<computeroutput moreinfo="none">DuckDuckGo query failed: Unexpected failure</computeroutput>
<computeroutput moreinfo="none"> </computeroutput>
<computeroutput moreinfo="none">OCaml</computeroutput>
<computeroutput moreinfo="none">-----</computeroutput>
<computeroutput moreinfo="none"> </computeroutput>
<computeroutput moreinfo="none">"OCaml, originally known as Objective Caml, is the main implementation</computeroutput>
<computeroutput moreinfo="none">of the Caml programming language, created by Xavier Leroy, Jérôme</computeroutput>
<computeroutput moreinfo="none">Vouillon, Damien Doligez, Didier Rémy and others in 1996."</computeroutput>
<computeroutput moreinfo="none"> </computeroutput></programlisting>

      <para>Now, only the query that went to <literal moreinfo="none">localhost</literal> failed.</para>

      <para>Note that in this code, we're relying on the fact that <literal moreinfo="none">Cohttp_async.Client.get</literal> will clean up after
      itself after an exception, in particular by closing its file
      descriptors. If you need to implement such functionality directly, you
      may want to use the <literal moreinfo="none">Monitor.protect</literal>
      call, which is analogous to the <literal moreinfo="none">protect</literal> call described in <xref linkend="cleaning-up-in-the-presence-of-exceptions"/>.<indexterm class="endofrange" startref="ALexcept"/></para>
    </sect2>
  </sect1>

  <sect1 id="timeouts-cancellation-and-choices">
    <title>Timeouts, Cancellation, and Choices</title>

    <para>In a concurrent program, one often needs to combine results from
    multiple, distinct concurrent subcomputations going on in the same
    program. We already saw this in our DuckDuckGo example, where we used
    <literal moreinfo="none">Deferred.all</literal> and <literal moreinfo="none">Deferred.all_unit</literal> to wait for a list of
    deferreds to become determined. Another useful primitive is <literal moreinfo="none">Deferred.both</literal>, which lets you wait until two
    deferreds of different types have returned, returning both values as a
    tuple. Here, we use the function <literal moreinfo="none">sec</literal>,
    which is shorthand for creating a time-span equal to a given number of
    seconds:<indexterm class="singular">
        <primary>errors</primary>

        <secondary>timeouts and cancellations</secondary>
      </indexterm><indexterm class="singular">
        <primary>Deferred.both</primary>
      </indexterm><indexterm class="singular">
        <primary>cancellations</primary>
      </indexterm><indexterm class="singular">
        <primary>timeouts</primary>
      </indexterm><indexterm class="singular">
        <primary>Async library</primary>

        <secondary>timeouts and cancellations</secondary>
      </indexterm></para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/async/main.topscript">OCaml utop</ulink>
    (part 39)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let string_and_float = Deferred.both</userinput>
<userinput moreinfo="none">   (after (sec 0.5)  &gt;&gt;| fun () -&gt; "A")</userinput>
<userinput moreinfo="none">   (after (sec 0.25) &gt;&gt;| fun () -&gt; 32.33);;</userinput>
<computeroutput moreinfo="none">val string_and_float : (string * float) Deferred.t = &lt;abstr&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">string_and_float;;</userinput>
<computeroutput moreinfo="none">- : string * float = ("A", 32.33)</computeroutput></programlisting>

    <para>Sometimes, however, we want to wait only for the first of multiple
    events to occur. This happens particularly when dealing with timeouts. In
    that case, we can use the call <literal moreinfo="none">Deferred.any</literal>, which, given a list of deferreds,
    returns a single deferred that will become determined once any of the
    values on the list is determined:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/async/main.topscript">OCaml utop</ulink>
    (part 40)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">Deferred.any [ (after (sec 0.5) &gt;&gt;| fun () -&gt; "half a second")</userinput>
<userinput moreinfo="none">               ; (after (sec 10.) &gt;&gt;| fun () -&gt; "ten seconds") ] ;;</userinput>
<computeroutput moreinfo="none">- : string = "half a second"</computeroutput></programlisting>

    <para>Let's use this to add timeouts to our DuckDuckGo searches. The
    following code is a wrapper for <literal moreinfo="none">get_definition</literal> that takes a timeout (in the form
    of a <literal moreinfo="none">Time.Span.t</literal>) and returns either
    the definition, or, if that takes too long, an error:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/async/search_with_timeout.ml">OCaml</ulink>
    (part 1)</para>

    <programlisting format="linespecific" language="ocaml">let get_definition_with_timeout ~server ~timeout word =
  Deferred.any
    [ (after timeout &gt;&gt;| fun () -&gt; (word,Error "Timed out"))
    ; (get_definition ~server word
       &gt;&gt;| fun (word,result) -&gt;
       let result' = match result with
         | Ok _ as x -&gt; x
         | Error _ -&gt; Error "Unexpected failure"
       in
       (word,result')
      )
    ]</programlisting>

    <para>We use <literal moreinfo="none">&gt;&gt;|</literal> above to
    transform the deferred values we're waiting for so that <literal moreinfo="none">Deferred.any</literal> can choose between values of the
    same type.</para>

    <para>A problem with this code is that the HTTP query kicked off by <literal moreinfo="none">get_definition</literal> is not actually shut down when the timeout fires. As such,
        <literal moreinfo="none">get_definition_with_timeout</literal> can leak an open connection.
      Happily, Cohttp does provide a way of shutting down a client. You can pass a deferred under
      the label <literal moreinfo="none">interrupt</literal> to <literal moreinfo="none">Cohttp_async.Client.get</literal>. Once <literal moreinfo="none">interrupt</literal> is
      determined, the client connection will be shut down.</para>

    <para>The following code shows how you can change <literal moreinfo="none">get_definition</literal> and <literal moreinfo="none">get_definition_with_timeout</literal> to cancel the
    <literal moreinfo="none">get</literal> call if the timeout expires:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/async/search_with_timeout_no_leak_simple.ml">OCaml</ulink>
    (part 1)</para>

    <programlisting format="linespecific" language="ocaml">(* Execute the DuckDuckGo search *)
let get_definition ~server ~interrupt word =
  try_with (fun () -&gt;
    Cohttp_async.Client.get ~interrupt (query_uri ~server word)
    &gt;&gt;= fun  (_, body) -&gt;
    Pipe.to_list body
    &gt;&gt;| fun strings -&gt;
    (word, get_definition_from_json (String.concat strings)))
  &gt;&gt;| function
  | Ok (word,result) -&gt; (word, Ok result)
  | Error exn        -&gt; (word, Error exn)</programlisting>

    <para>Next, we'll modify <literal moreinfo="none">get_definition_with_timeout</literal> to create a deferred
    to pass in to <literal moreinfo="none">get_definition</literal>, which
    will become determined when our timeout expires:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/async/search_with_timeout_no_leak_simple.ml">OCaml</ulink>
    (part 2)</para>

    <programlisting format="linespecific" language="ocaml">let get_definition_with_timeout ~server ~timeout word =
  get_definition ~server ~interrupt:(after timeout) word
  &gt;&gt;| fun (word,result) -&gt;
  let result' = match result with
    | Ok _ as x -&gt; x
    | Error _ -&gt; Error "Unexpected failure"
  in
  (word,result')</programlisting>

    <para>This will work and will cause the connection to shutdown cleanly
    when we time out; but our code no longer explicitly knows whether or not
    the timeout has kicked in. In particular, the error message on a timeout
    will now be <literal moreinfo="none">"Unexpected failure"</literal> rather
    than <literal moreinfo="none">"Timed out"</literal>, which it was in our
    previous implementation.</para>

    <para>We can get more precise handling of timeouts using Async's <literal moreinfo="none">choose</literal> function. <literal moreinfo="none">choose</literal> lets you pick among a
      collection of different deferreds, reacting to exactly one of them. Each deferred is paired,
      using the function <literal moreinfo="none">choice</literal>, with a function that is called
      if and only if that deferred is chosen. Here's the type signature of <literal moreinfo="none">choice</literal> and <literal moreinfo="none">choose</literal>:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/async/main.topscript">OCaml utop</ulink>
    (part 41)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">choice;;</userinput>
<computeroutput moreinfo="none">- : 'a Deferred.t -&gt; ('a -&gt; 'b) -&gt; 'b Deferred.choice = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">choose;;</userinput>
<computeroutput moreinfo="none">- : 'a Deferred.choice list -&gt; 'a Deferred.t = &lt;fun&gt;</computeroutput></programlisting>

    <para>Note that there's no guarantee that the winning deferred will be the
    one that becomes determined first. But <literal moreinfo="none">choose</literal> does guarantee that only one <literal moreinfo="none">choice</literal> will be chosen, and only the chosen
    <literal moreinfo="none">choice</literal> will execute the attached
    function.</para>

    <para>In the following example, we use <literal moreinfo="none">choose</literal> to ensure that
      the <literal moreinfo="none">interrupt</literal> deferred becomes determined if and only if
      the timeout deferred is chosen. Here's the code:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/async/search_with_timeout_no_leak.ml">OCaml</ulink>
    (part 2)</para>

    <programlisting format="linespecific" language="ocaml">let get_definition_with_timeout ~server ~timeout word =
  let interrupt = Ivar.create () in
  choose
    [ choice (after timeout) (fun () -&gt;
       Ivar.fill interrupt ();
       (word,Error "Timed out"))
    ; choice (get_definition ~server ~interrupt:(Ivar.read interrupt) word)
        (fun (word,result) -&gt;
           let result' = match result with
             | Ok _ as x -&gt; x
             | Error _ -&gt; Error "Unexpected failure"
           in
           (word,result')
        )
    ]</programlisting>

    <para>Now, if we run this with a suitably small timeout, we'll see that
    one query succeeds and the other fails reporting a timeout:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/async/run_search_with_timeout_no_leak.out">Terminal</ulink></para>

    <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">corebuild -pkg cohttp.async,yojson,textwrap \</userinput>
<computeroutput moreinfo="none">     search_with_timeout_no_leak.native</computeroutput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">./search_with_timeout_no_leak.native \</userinput>
<computeroutput moreinfo="none">     "concurrent programming" ocaml -timeout 0.2s</computeroutput>
<computeroutput moreinfo="none">concurrent programming</computeroutput>
<computeroutput moreinfo="none">----------------------</computeroutput>
<computeroutput moreinfo="none"> </computeroutput>
<computeroutput moreinfo="none">DuckDuckGo query failed: Timed out</computeroutput>
<computeroutput moreinfo="none"> </computeroutput>
<computeroutput moreinfo="none">ocaml</computeroutput>
<computeroutput moreinfo="none">-----</computeroutput>
<computeroutput moreinfo="none"> </computeroutput>
<computeroutput moreinfo="none">"OCaml or Objective Caml, is the main implementation of the Caml</computeroutput>
<computeroutput moreinfo="none">programming language, created by Xavier Leroy, Jérôme Vouillon,</computeroutput>
<computeroutput moreinfo="none">Damien Doligez, Didier Rémy and others in 1996."</computeroutput></programlisting>
  </sect1>

  <sect1 id="working-with-system-threads">
    <title>Working with System Threads</title>

    <para>Although we haven't worked with them yet, OCaml does have built-in
    support for true system threads, i.e., kernel-level threads whose
    interleaving is controlled by the operating system. We discussed in the
    beginning of the chapter why Async is generally a better choice than
    system threads, but even if you mostly use Async, OCaml's system threads
    are sometimes necessary, and it's worth understanding them.<indexterm class="singular">
        <primary>parallelism</primary>
      </indexterm><indexterm class="singular">
        <primary>kernel-level threads</primary>
      </indexterm><indexterm class="singular">
        <primary>threads</primary>

        <secondary>kernel-level threads</secondary>
      </indexterm><indexterm class="startofrange" id="systhrd">
        <primary>system threads</primary>
      </indexterm><indexterm class="startofrange" id="ALsysthr">
        <primary>Async library</primary>

        <secondary>system threads and</secondary>
      </indexterm></para>

    <para>The most surprising aspect of OCaml's system threads is that they
    don't afford you any access to physical parallelism. That's because
    OCaml's runtime has a single runtime lock that at most one thread can be
    holding at a time.</para>

    <para>Given that threads don't provide physical parallelism, why are they
    useful at all?</para>

    <para>The most common reason for using system threads is that there are
    some operating system calls that have no nonblocking alternative, which
    means that you can't run them directly in a system like Async without
    blocking your entire program. For this reason, Async maintains a thread
    pool for running such calls. Most of the time, as a user of Async you
    don't need to think about this, but it is happening under the
    covers.<indexterm class="singular">
        <primary>threads</primary>

        <secondary>benefits of</secondary>
      </indexterm></para>

    <para>Another reason to have multiple threads is to deal with non-OCaml
    libraries that have their own event loop or for another reason need their
    own threads. In that case, it's sometimes useful to run some OCaml code on
    the foreign thread as part of the communication to your main program.
    OCaml's foreign function interface is discussed in more detail in <xref linkend="foreign-function-interface"/>.</para>

    <para>Another occasional use for system threads is to better interoperate with compute-intensive
      OCaml code. In Async, if you have a long-running computation that never calls <literal moreinfo="none">bind</literal> or <literal moreinfo="none">map</literal>, then that
      computation will block out the Async runtime until it completes.</para>

    <para>One way of dealing with this is to explicitly break up the
    calculation into smaller pieces that are separated by binds. But sometimes
    this explicit yielding is impractical, since it may involve intrusive
    changes to an existing codebase. Another solution is to run the code in
    question in a separate thread. Async's <literal moreinfo="none">In_thread</literal> module provides multiple facilities
    for doing just this, <literal moreinfo="none">In_thread.run</literal>
    being the simplest. We can simply write:<indexterm class="singular">
        <primary>In_thread module</primary>
      </indexterm></para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/async/main.topscript">OCaml utop</ulink>
    (part 42)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let def = In_thread.run (fun () -&gt; List.range 1 10);;</userinput>
<computeroutput moreinfo="none">val def : int list Deferred.t = &lt;abstr&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">def;;</userinput>
<computeroutput moreinfo="none">- : int list = [1; 2; 3; 4; 5; 6; 7; 8; 9]</computeroutput></programlisting>

    <para>to cause <literal moreinfo="none">List.range 1 10</literal> to be
    run on one of Async's worker threads. When the computation is complete,
    the result is placed in the deferred, where it can be used in the ordinary
    way from Async.</para>

    <para>Interoperability between Async and system threads can be quite
    tricky. Consider the following function for testing how responsive Async
    is. The function takes a deferred-returning thunk, and it first runs that
    thunk, and then uses <literal moreinfo="none">Clock.every</literal> to
    wake up every 100 milliseconds and print out a timestamp, until the
    returned deferred becomes determined, at which point it prints out one
    last timestamp:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/async/main.topscript">OCaml utop</ulink>
    (part 43)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let log_delays thunk =</userinput>
<userinput moreinfo="none">    let start = Time.now () in</userinput>
<userinput moreinfo="none">    let print_time () =</userinput>
<userinput moreinfo="none">      let diff = Time.diff (Time.now ()) start in</userinput>
<userinput moreinfo="none">      printf "%s, " (Time.Span.to_string diff)</userinput>
<userinput moreinfo="none">    in</userinput>
<userinput moreinfo="none">    let d = thunk () in</userinput>
<userinput moreinfo="none">    Clock.every (sec 0.1) ~stop:d print_time;</userinput>
<userinput moreinfo="none">    d &gt;&gt;| fun () -&gt; print_time (); printf "\n"</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val log_delays : (unit -&gt; unit Deferred.t) -&gt; unit Deferred.t = &lt;fun&gt;</computeroutput></programlisting>

    <para>If we feed this function a simple timeout deferred, it works as you
    might expect, waking up roughly every 100 milliseconds:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/async/main-44.rawscript">OCaml utop</ulink></para>

    <programlisting format="linespecific" language="ocaml"><userinput moreinfo="none"># log_delays (fun () -&gt; after (sec 0.5));;</userinput>
<computeroutput moreinfo="none">0.154972ms, 102.126ms, 203.658ms, 305.73ms, 407.903ms, 501.563ms,
- : unit = ()</computeroutput></programlisting>

    <para>Now see what happens if, instead of waiting on a clock event, we wait for a busy loop to
      finish running:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/async/main-45.rawscript">OCaml utop</ulink></para>

    <programlisting format="linespecific" language="ocaml"><userinput moreinfo="none"># let busy_loop () =
    let x = ref None in
    for i = 1 to 100_000_000 do x := Some i done
  ;;</userinput>
<computeroutput moreinfo="none">val busy_loop : unit -&gt; unit = &lt;fun&gt;</computeroutput>
<userinput moreinfo="none"># log_delays (fun () -&gt; return (busy_loop ()));;</userinput>
<computeroutput moreinfo="none">19.2185s,
- : unit = ()</computeroutput></programlisting>

    <para>As you can see, instead of waking up 10 times a second, <literal moreinfo="none">log_delays</literal> is blocked out entirely while
    <literal moreinfo="none">busy_loop</literal> churns away.</para>

    <para>If, on the other hand, we use <literal moreinfo="none">In_thread.run</literal> to offload this to a different
    system thread, the behavior will be different:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/async/main-46.rawscript">OCaml utop</ulink></para>

    <programlisting format="linespecific" language="ocaml"><userinput moreinfo="none"># log_delays (fun () -&gt; In_thread.run busy_loop);;</userinput>
<computeroutput moreinfo="none">0.332117ms, 16.6319s, 18.8722s,
- : unit = ()</computeroutput></programlisting>

    <para>Now <literal moreinfo="none">log_delays</literal> does get a chance to run, but not nearly
      as often as every 100 milliseconds. The reason is that now that we're using system threads, we
      are at the mercy of the operating system to decide when each thread gets scheduled. The
      behavior of threads is very much dependent on the operating system and how it is
      configured.</para>

    <para>Another tricky aspect of dealing with OCaml threads has to do with allocation. When
      compiling to native code, OCaml's threads only get a chance to give up the runtime lock when
      they interact with the allocator, so if there's a piece of code that doesn't allocate at all,
      then it will never allow another OCaml thread to run. Bytecode doesn't have this behavior, so
      if we run a nonallocating loop in bytecode, our timer process will get to run:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/async/main-47.rawscript">OCaml utop</ulink></para>

    <programlisting format="linespecific" language="ocaml"><userinput moreinfo="none"># let noalloc_busy_loop () =
    for i = 0 to 100_000_000 do () done
;;</userinput>
<computeroutput moreinfo="none">val noalloc_busy_loop : unit -&gt; unit = &lt;fun&gt;</computeroutput>
<userinput moreinfo="none"># log_delays (fun () -&gt; In_thread.run noalloc_busy_loop);;</userinput>
<computeroutput moreinfo="none">0.169039ms, 4.58345s, 4.77866s, 4.87957s, 12.4723s, 15.0134s,
- : unit = ()</computeroutput></programlisting>

    <para>But if we compile this to a native-code executable, then the nonallocating busy loop will
      block anything else from running:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/async/run_native_code_log_delays.out">Terminal</ulink></para>

    <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">corebuild -pkg async native_code_log_delays.native</userinput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">./native_code_log_delays.native</userinput>
<computeroutput moreinfo="none">15.5686s, </computeroutput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none"/></programlisting>

    <para>The takeaway from these examples is that predicting thread
    interleavings is a subtle business. Staying within the bounds of Async has
    its limitations, but it leads to more predictable behavior.</para>

    <sect2 id="thread-safety-and-locking">
      <title>Thread-Safety and Locking</title>

      <para>Once you start working with system threads, you'll need to be
      careful about mutable data structures. Most mutable OCaml data
      structures do not have well-defined semantics when accessed concurrently
      by multiple threads. The issues you can run into range from runtime
      exceptions to corrupted data structures to, in some rare cases,
      segfaults. That means you should always use mutexes when sharing mutable
      data between different systems threads. Even data structures that seem
      like they should be safe but are mutable under the covers, like lazy
      values, can have undefined behavior when accessed from multiple
      threads.<indexterm class="singular">
          <primary>mutexes</primary>
        </indexterm><indexterm class="singular">
          <primary>segfaults</primary>
        </indexterm><indexterm class="singular">
          <primary>threads</primary>

          <secondary>locking and</secondary>
        </indexterm><indexterm class="singular">
          <primary>threads</primary>

          <secondary>thread-safety</secondary>
        </indexterm></para>

      <para>There are two commonly available mutex packages for OCaml: the
      <literal moreinfo="none">Mutex</literal> module that's part of the
      standard library, which is just a wrapper over OS-level mutexes and
      <literal moreinfo="none">Nano_mutex</literal>, a more efficient
      alternative that takes advantage of some of the locking done by the
      OCaml runtime to avoid needing to create an OS-level mutex much of the
      time. As a result, creating a <literal moreinfo="none">Nano_mutex.t</literal> is 20 times faster than creating
      a <literal moreinfo="none">Mutex.t</literal>, and acquiring the mutex is
      about 40 percent faster.</para>

      <para>Overall, combining Async and threads is quite tricky, but it can be done safely if the
        following hold:</para>

      <itemizedlist>
        <listitem>
          <para>There is no shared mutable state between the various threads involved.</para>
        </listitem>

        <listitem>
          <para>The computations executed by <literal moreinfo="none">In_thread.run</literal> do not
            make any calls to the Async library.</para>
        </listitem>
      </itemizedlist>

      <para>It is possible to safely use threads in ways that violate these
      constraints. In particular, foreign threads can acquire the Async lock
      using calls from the <literal moreinfo="none">Thread_safe</literal>
      module in Async, and thereby run Async computations safely. This is a
      very flexible way of connecting threads to the Async world, but it's a
      complex use case that is beyond the scope of this chapter.<indexterm class="endofrange" startref="systhrd"/><indexterm class="endofrange" startref="ALsysthr"/></para>
    </sect2>
  </sect1>
</chapter>
  </part>

  <part>
    <title>The Runtime System</title>

    <partintro>
      <para>Writing good OCaml code is only one half of the typical software engineering
      workflow—you also need to understand how OCaml executes this code, and how to debug and
      profile your production applications. Part III is thus all about understanding the compiler
      toolchain and runtime system in OCaml. It is a remarkably simple system in comparison to other
      language runtimes such as Java or the .NET CLR, so this chapter should be accessible to even
      the casual OCaml programmer.</para>

      <para>We open by a guided tour through the Ctypes library for binding your OCaml code to
      foreign C libraries. We use a terminal interface and POSIX functions of increasing complexity
      to show the more advanced features of the library.</para>
    <para>OCaml has a very predictable memory representation of values, which we explain in the next
      chapter by walking through the various datatypes. We then illustrate how the memory regions in
      OCaml are automatically managed by a garbage collector to ensure no memory leaks occur.</para>
    <para>The part closes with two bigger chapters that explain the tools that comprise the OCaml
      compiler, breaking it up into two logical pieces. The first part covers the parser and type
      checker and highlights various tips to help you solve common problems in your source code. The
      second part covers code generation into bytecode and native code, and also explains how to
      debug and profile production binaries.</para>
    </partintro>

    <chapter id="foreign-function-interface">
  <title>Foreign Function Interface</title>

  <para>OCaml has several options available to interact with non-OCaml code. The compiler can link
    with external system libraries via C code and also can produce standalone native object files
    that can be embedded within other non-OCaml applications.<indexterm class="singular">
      <primary>programming</primary>
      <secondary>language interfaces</secondary>
    </indexterm><indexterm class="singular">
      <primary>foreign function interface (FFI)</primary>
      <secondary>basics of</secondary>
    </indexterm><indexterm class="startofrange" id="INTERffi">
      <primary>interfaces</primary>
      <secondary>foreign function interface (FFI)</secondary>
    </indexterm></para>

  <para>The mechanism by which code in one programming language can invoke routines in a different
    programming language is called a <emphasis>foreign function interface</emphasis>. This chapter
    will:</para>

  <itemizedlist>
    <listitem>
      <para>Show how to call routines in C libraries directly from your OCaml
      code</para>
    </listitem>

    <listitem>
      <para>Teach you how to build higher-level abstractions in OCaml from the
      low-level C bindings</para>
    </listitem>

    <listitem>
      <para>Work through some full examples for binding a terminal interface
      and UNIX date/time functions</para>
    </listitem>
  </itemizedlist>

  <para>The simplest foreign function interface in OCaml doesn't even require
  you to write any C code at all! The Ctypes library lets you define the C
  interface in pure OCaml, and the library then takes care of loading the C
  symbols and invoking the foreign function call.<indexterm class="singular">
      <primary>libffi library</primary>
    </indexterm><indexterm class="singular">
      <primary>Ncurses terminal toolkit</primary>
    </indexterm><indexterm class="singular">
      <primary>Ctypes library</primary>

      <secondary>installation of</secondary>
    </indexterm></para>

  <para>Let's dive straight into a realistic example to show you how the
  library looks. We'll create a binding to the Ncurses terminal toolkit, as
  it's widely available on most systems and doesn't have any complex
  dependencies.</para>

  <note>
    <title>Installing the Ctypes Library</title>

    <para>You'll need to install the <ulink url="https://github.com/atgreen/libffi"><literal moreinfo="none">libffi</literal></ulink> library as a prerequisite to
    using Ctypes. It's a fairly popular library and should be available in
    your OS package manager.</para>

    <para>A special note for Mac users: the version of <literal moreinfo="none">libffi</literal> installed by default in Mac OS X 10.8 is
    too old for some of the features that Ctypes needs. Use Homebrew to
    <literal moreinfo="none">brew install libffi</literal> to get the latest
    version before installing the OCaml library.</para>

    <para>Once that's done, Ctypes is available via OPAM as usual:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/ffi/install.out">Terminal</ulink></para>

    <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">brew install libffi     # for MacOS X users</userinput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">opam install ctypes</userinput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">utop</userinput>
<computeroutput moreinfo="none"># require "ctypes.foreign" ;;</computeroutput></programlisting>

    <para>You'll also need the Ncurses library for the first example. This comes preinstalled on
      many operating systems such as Mac OS X, and Debian Linux provides it as the <literal moreinfo="none">libncurses5-dev</literal> package.</para>
  </note>

  <sect1 id="example-a-terminal-interface">
    <title>Example: A Terminal Interface</title>

    <para>Ncurses is a library to help build terminal-independent text
    interfaces in a reasonably efficient way. It's used in console mail
    clients like Mutt and Pine, and console web browsers such as
    Lynx.<indexterm class="startofrange" id="FFItermint">
        <primary>foreign function interface (FFI)</primary>

        <secondary>terminal interface example</secondary>
      </indexterm></para>

    <para>The full C interface is quite large and is explained in the online
    <ulink url="http://www.gnu.org/software/ncurses/">documentation</ulink>.
    We'll just use the small excerpt, since we just want to demonstrate Ctypes
    in action:<indexterm class="singular">
        <primary>Ctypes library</primary>

        <secondary>terminal interface example</secondary>
      </indexterm></para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/ffi/ncurses.h">C</ulink></para>

    <programlisting format="linespecific" language="c">typedef struct _win_st WINDOW;
typedef unsigned int chtype;

WINDOW *initscr   (void);
WINDOW *newwin    (int, int, int, int);
void    endwin    (void);
void    refresh   (void);
void    wrefresh  (WINDOW *);
void    addstr (const char *);
int     mvwaddch  (WINDOW *, int, int, const chtype);
void    mvwaddstr (WINDOW *, int, int, char *);
void    box (WINDOW *, chtype, chtype);
int     cbreak (void);</programlisting>

    <para>The Ncurses functions either operate on the current pseudoterminal
    or on a window that has been created via <literal moreinfo="none">newwin</literal>. The <literal moreinfo="none">WINDOW</literal> structure holds the internal library
    state and is considered abstract outside of Ncurses. Ncurses clients just
    need to store the pointer somewhere and pass it back to Ncurses library
    calls, which in turn dereference its contents.</para>

    <para>Note that there are over 200 library calls in Ncurses, so we're only
    binding a select few for this example. The <literal moreinfo="none">initscr</literal> and <literal moreinfo="none">newwin</literal> create <literal moreinfo="none">WINDOW</literal> pointers for the global and subwindows,
    respectively. The <literal moreinfo="none">mvwaddrstr</literal> takes a
    window, x/y offsets, and a string and writes to the screen at that
    location. The terminal is only updated after <literal moreinfo="none">refresh</literal> or <literal moreinfo="none">wrefresh</literal> are called.</para>

    <para>Ctypes provides an OCaml interface that lets you map these C
    functions to equivalent OCaml functions. The library takes care of
    converting OCaml function calls and arguments into the C calling
    convention, invoking the foreign call within the C library and finally
    returning the result as an OCaml value.</para>

    <para>Let's begin by defining the basic values we need, starting with the
    <literal moreinfo="none">WINDOW</literal> state pointer:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/ffi/ncurses.ml">OCaml</ulink></para>

    <programlisting format="linespecific" language="ocaml">open Ctypes

type window = unit ptr
let window : window typ = ptr void</programlisting>

    <para>We don't know the internal representation of the window pointer, so we treat it as a C
      void pointer. We'll improve on this later on in the chapter, but it's good enough for now. The
      second statement defines an OCaml value that represents the <literal moreinfo="none">WINDOW</literal> C pointer. This value is used later in the Ctypes function
      definitions:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/ffi/ncurses.ml">OCaml</ulink>
    (part 1)</para>

    <programlisting format="linespecific" language="ocaml">open Foreign

let initscr =
  foreign "initscr" (void @-&gt; returning window)</programlisting>

    <para>That's all we need to invoke our first function call to <literal moreinfo="none">initscr</literal> to initialize the terminal. The <literal moreinfo="none">foreign</literal> function accepts two parameters:</para>

    <itemizedlist>
      <listitem>
        <para>The C function call name, which is looked up using the <literal moreinfo="none">dlsym</literal> POSIX function.</para>
      </listitem>

      <listitem>
        <para>A value that defines the complete set of C function arguments
        and its return type. The <literal moreinfo="none">@-&gt;</literal>
        operator adds an argument to the C parameter list, and <literal moreinfo="none">returning</literal> terminates the parameter list with
        the return type.</para>
      </listitem>
    </itemizedlist>

    <para>The remainder of the Ncurses binding simply expands on these
    definitions:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/ffi/ncurses.ml">OCaml</ulink>
    (part 2)</para>

    <programlisting format="linespecific" language="ocaml">let newwin =
  foreign "newwin" 
    (int @-&gt; int @-&gt; int @-&gt; int @-&gt; returning window)

let endwin =
  foreign "endwin" (void @-&gt; returning void)

let refresh =
  foreign "refresh" (void @-&gt; returning void)

let wrefresh =
  foreign "wrefresh" (window @-&gt; returning void)

let addstr =
  foreign "addstr" (string @-&gt; returning void)

let mvwaddch =
  foreign "mvwaddch"
    (window @-&gt; int @-&gt; int @-&gt; char @-&gt; returning void)

let mvwaddstr =
  foreign "mvwaddstr"
    (window @-&gt; int @-&gt; int @-&gt; string @-&gt; returning void)

let box =
  foreign "box" (window @-&gt; char @-&gt; char @-&gt; returning void)

let cbreak =
  foreign "cbreak" (void @-&gt; returning int)</programlisting>

    <para>These definitions are all straightforward mappings from the C
    declarations in the Ncurses header file. Note that the <literal moreinfo="none">string</literal> and <literal moreinfo="none">int</literal> values here are nothing to do with OCaml
    type declarations; instead, they are values that come from opening the
    <literal moreinfo="none">Ctypes</literal> module at the top of the
    file.</para>

    <para>Most of the parameters in the Ncurses example represent fairly
    simple scalar C types, except for <literal moreinfo="none">window</literal> (a pointer to the library state) and
    <literal moreinfo="none">string</literal>, which maps from OCaml strings
    that have a specific length onto C character buffers whose length is
    defined by a terminating null character that immediately follows the
    string data.</para>

    <para>The module signature for <literal moreinfo="none">ncurses.mli</literal> looks much like a normal OCaml
    signature. You can infer it directly from the <literal moreinfo="none">ncurses.ml</literal> by running a special build
    target:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/ffi/infer_ncurses.out">Terminal</ulink></para>

    <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">corebuild -pkg ctypes.foreign ncurses.inferred.mli</userinput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">cp _build/ncurses.inferred.mli .</userinput></programlisting>

    <para>The <literal moreinfo="none">inferred.mli</literal> target instructs the compiler to
      generate the default signature for a module file and places it in the <literal moreinfo="none">_build</literal> directory as a normal output. You should normally copy it out into your
      source directory and customize it to improve its safety for external callers by making some of
      its internals more abstract.</para>

    <para>Here's the customized interface that we can safely use from other
    libraries:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/ffi/ncurses.mli">OCaml</ulink></para>

    <programlisting format="linespecific" language="ocaml">type window
val window : window Ctypes.typ
val initscr : unit -&gt; window
val endwin : unit -&gt; unit
val refresh : unit -&gt; unit
val wrefresh : window -&gt; unit
val newwin : int -&gt; int -&gt; int -&gt; int -&gt; window
val mvwaddch : window -&gt; int -&gt; int -&gt; char -&gt; unit
val addstr : string -&gt; unit
val mvwaddstr : window -&gt; int -&gt; int -&gt; string -&gt; unit
val box : window -&gt; char -&gt; char -&gt; unit
val cbreak : unit -&gt; int</programlisting>

    <para>The <literal moreinfo="none">window</literal> type is left abstract
    in the signature to ensure that window pointers can only be constructed
    via the <literal moreinfo="none">Ncurses.initscr</literal> function. This
    prevents void pointers obtained from other sources from being mistakenly
    passed to an Ncurses library call.</para>

    <para>Now compile a "hello world" terminal drawing program to tie this all
    together:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/ffi/hello.ml">OCaml</ulink></para>

    <programlisting format="linespecific" language="ocaml">open Ncurses

let () =
  let main_window = initscr () in
  ignore(cbreak ());
  let small_window = newwin 10 10 5 5 in
  mvwaddstr main_window 1 2 "Hello";
  mvwaddstr small_window 2 2 "World";
  box small_window '\000' '\000';
  refresh ();
  Unix.sleep 1;
  wrefresh small_window;
  Unix.sleep 5;
  endwin ()</programlisting>

    <para>The <literal moreinfo="none">hello</literal> executable is compiled
    by linking with the <literal moreinfo="none">ctypes.foreign</literal>
    OCamlfind package:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/ffi/build_hello.out">Terminal</ulink></para>

    <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">corebuild -pkg ctypes.foreign -lflags -cclib,-lncurses hello.native </userinput>
</programlisting>

    <para>Running <literal moreinfo="none">./hello.native</literal> should now
    display a Hello World in your terminal!<indexterm class="singular">
        <primary>Ctypes library</primary>

        <secondary>build directives for</secondary>
      </indexterm></para>

    <note>
      <title>On Build Directives for Ctypes</title>

      <para>The preceding command line includes some important extra link
      directives. The <literal moreinfo="none">-lflags</literal> instructs
      <command moreinfo="none">ocamlbuild</command> to pass the next
      comma-separated set of arguments through to the <command moreinfo="none">ocaml</command> command when linking a binary. OCaml in
      turn uses <literal moreinfo="none">-cclib</literal> to pass directives
      through to the system compiler (normally <command moreinfo="none">gcc</command> or <command moreinfo="none">clang</command>). We first need to link to the <literal moreinfo="none">ncurses</literal> C library to make the symbols
      available to Ctypes, and <phrase role="keep-together"><literal moreinfo="none">-cclib,</literal></phrase><literal>-lncurses</literal> does that.</para>
      
      <para>On some distributions such as Ubuntu 11.10 upwards, you'll also need to add <literal moreinfo="none">-cclib,-Xlinker,-cclib, and --no-as-needed</literal> to the <phrase role="keep-together"><literal moreinfo="none">-lflags</literal></phrase> directive.
          <literal moreinfo="none">-Xlinker</literal> is interpreted by the compiler as a directive
        for the system linker <command moreinfo="none">ld</command>, to which it passes <literal moreinfo="none">--no-as-needed</literal>. <phrase role="keep-together">Several</phrase>
        modern OS distributions (such as Ubuntu 11.10 onwards) configure the system linker to only
        link in libraries that directly contain symbols used by the program. However, when we use
        Ctypes, those symbols are not referenced until runtime, which results an exception due to
        the library not being available.</para>

      <para>The <literal moreinfo="none">--no-as-needed</literal> flag
      disables this behavior and ensures all the specified libraries are
      linked despite not being directly used. The flag unfortunately doesn't
      work everywhere (notably, Mac OS X should <emphasis>not</emphasis> have
      this passed to it).</para>
    </note>

    <para>Ctypes wouldn't be very useful if it were limited to only defining
    simple C types, of course. It provides full support for C pointer
    arithmetic, pointer conversions, and reading and writing through pointers,
    using OCaml functions as function pointers to C code, as well as struct
    and union definitions.</para>

    <para>We'll go over some of these features in more detail for the
    remainder of the chapter by using some POSIX date functions as running
    examples.<indexterm class="endofrange" startref="FFItermint"/></para>
  </sect1>

  <sect1 id="basic-scalar-c-types">
    <title>Basic Scalar C Types</title>

    <para>First, let's look at how to define basic scalar C types. Every C
    type is represented by an OCaml equivalent via the single type
    definition:<indexterm class="singular">
        <primary>scalar C types</primary>
      </indexterm><indexterm class="singular">
        <primary>foreign function interface (FFI)</primary>

        <secondary>basic scalar C types</secondary>
      </indexterm></para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/ctypes/ctypes.mli">OCaml</ulink></para>

    <programlisting format="linespecific" language="ocaml">type 'a typ</programlisting>

    <para><literal moreinfo="none">Ctypes.typ</literal> is the type of values
    that represents C types to OCaml. There are two types associated with each
    instance of <literal moreinfo="none">typ</literal>:</para>

    <itemizedlist>
      <listitem>
        <para>The C type used to store and pass values to the foreign
        library.</para>
      </listitem>

      <listitem>
        <para>The corresponding OCaml type. The <literal moreinfo="none">'a</literal> type parameter contains the OCaml type
        such that a value of type <literal moreinfo="none">t typ</literal> is
        used to read and write OCaml values of type <literal moreinfo="none">t</literal>.</para>
      </listitem>
    </itemizedlist>

    <para>There are various other uses of <literal moreinfo="none">typ</literal> values within Ctypes, such as:</para>

    <itemizedlist>
      <listitem>
        <para>Constructing function types for binding native functions</para>
      </listitem>

      <listitem>
        <para>Constructing pointers for reading and writing locations in
        C-managed storage</para>
      </listitem>

      <listitem>
        <para>Describing component fields of structures, unions, and
        arrays</para>
      </listitem>
    </itemizedlist>

    <para>Here are the definitions for most of the standard C99 scalar types,
    including some platform-dependent ones<indexterm class="singular">
        <primary>C99 scalar types</primary>
      </indexterm>:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/ctypes/ctypes.mli">OCaml</ulink>
    (part 1)</para>

    <programlisting format="linespecific" language="ocaml">val void      : unit typ
val char      : char typ
val schar     : int typ
val short     : int typ
val int       : int typ
val long      : long typ
val llong     : llong typ
val nativeint : nativeint typ

val int8_t    : int typ
val int16_t   : int typ
val int32_t   : int32 typ
val int64_t   : int64 typ
val uchar     : uchar typ
val uchar     : uchar typ
val uint8_t   : uint8 typ
val uint16_t  : uint16 typ
val uint32_t  : uint32 typ
val uint64_t  : uint64 typ
val size_t    : size_t typ
val ushort    : ushort typ
val uint      : uint typ
val ulong     : ulong typ
val ullong    : ullong typ

val float     : float typ
val double    : float typ

val complex32 : Complex.t typ
val complex64 : Complex.t typ</programlisting>

    <para>These values are all of type <literal moreinfo="none">'a
    typ</literal>, where the value name (e.g., <literal moreinfo="none">void</literal>) tells you the C type and the <literal moreinfo="none">'a</literal> component (e.g., <literal moreinfo="none">unit</literal>) is the OCaml representation of that C
    type. Most of the mappings are straightforward, but some of them need a
    bit more explanation:</para>

    <itemizedlist>
      <listitem>
        <para>Void values appear in OCaml as the <literal moreinfo="none">unit</literal> type. Using <literal moreinfo="none">void</literal> in an argument or result type
        specification produces an OCaml function that accepts or returns
        <literal>unit</literal>. Dereferencing a pointer to <literal moreinfo="none">void</literal> is an error, as in C, and will raise
        the <literal moreinfo="none">IncompleteType</literal>
        exception.</para>
      </listitem>

      <listitem>
        <para>The C <literal moreinfo="none">size_t</literal> type is an alias
        for one of the unsigned integer types. The actual size and alignment
        requirements for <literal moreinfo="none">size_t</literal> varies
        between platforms. Ctypes provides an OCaml <literal moreinfo="none">size_t</literal> type that is aliased to the
        appropriate integer type.</para>
      </listitem>

      <listitem>
        <para>OCaml only supports double-precision floating-point numbers, and
        so the C <literal moreinfo="none">float</literal> and <literal moreinfo="none">double</literal> types both map onto the OCaml
        <literal moreinfo="none">float</literal> type, and the C <literal moreinfo="none">float complex</literal> and <literal moreinfo="none">double complex</literal> types both map onto the OCaml
        double-precision <literal moreinfo="none">Complex.t</literal>
        type.</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 id="pointers-and-arrays">
    <title>Pointers and Arrays</title>

    <para>Pointers are at the heart of C, so they are necessarily part of
    Ctypes, which provides support for pointer arithmetic, pointer
    conversions, reading and writing through pointers, and passing and
    returning pointers to and from functions.<indexterm class="singular">
        <primary>POSIX functions</primary>
      </indexterm><indexterm class="singular">
        <primary>arrays</primary>

        <secondary>pointers and</secondary>
      </indexterm><indexterm class="singular">
        <primary>pointers</primary>

        <secondary>support for in Ctypes</secondary>
      </indexterm><indexterm class="singular">
        <primary>foreign function interface (FFI)</primary>

        <secondary>pointers and arrays</secondary>
      </indexterm></para>

    <para>We've already seen a simple use of pointers in the Ncurses example.
    Let's start a new example by binding the following POSIX functions:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/ffi/posix_headers.h">C</ulink></para>

    <programlisting format="linespecific" language="c">time_t time(time_t *);
double difftime(time_t, time_t);
char *ctime(const time_t *timep);</programlisting>

    <para>The <literal moreinfo="none">time</literal> function returns the
    current calendar time and is a simple start. The first step is to open
    some of the Ctypes modules:</para>

    <variablelist>
      <varlistentry>
        <term><literal moreinfo="none">Ctypes</literal></term>

        <listitem>
          <para>The <literal moreinfo="none">Ctypes</literal> module provides
          functions for describing C types in OCaml.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal moreinfo="none">PosixTypes</literal></term>

        <listitem>
          <para>The <literal moreinfo="none">PosixTypes</literal> module
          includes some extra POSIX-specific types (such as <literal moreinfo="none">time_t</literal>).</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal moreinfo="none">Foreign</literal></term>

        <listitem>
          <para>The <literal moreinfo="none">Foreign</literal> module exposes
          the <literal moreinfo="none">foreign</literal> function that makes
          it possible to invoke C functions.</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <para>We can now create a binding to <literal moreinfo="none">time</literal> directly from the toplevel.</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/ffi/posix.topscript">OCaml utop</ulink></para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">#require "ctypes.foreign" ;;</userinput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">#require "ctypes.top" ;;</userinput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">open Ctypes ;;</userinput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">open PosixTypes ;;</userinput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">open Foreign ;;</userinput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let time = foreign "time" (ptr time_t @-&gt; returning time_t) ;;</userinput>
<computeroutput moreinfo="none">val time : time_t ptr -&gt; time_t = &lt;fun&gt;</computeroutput></programlisting>

    <para>The <literal moreinfo="none">foreign</literal> function is the main
    link between OCaml and C. It takes two arguments: the name of the C
    function to bind, and a value describing the type of the bound function.
    In the <literal moreinfo="none">time</literal> binding, the function type
    specifies one argument of type <literal moreinfo="none">ptr
    time_t</literal> and a return type of <literal moreinfo="none">time_t</literal>.</para>

    <para>We can now call <literal moreinfo="none">time</literal> immediately
    in the same toplevel. The argument is actually optional, so we'll just
    pass a null pointer that has been coerced into becoming a null pointer to
    <literal moreinfo="none">time_t</literal>:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/ffi/posix.topscript">OCaml utop</ulink>
    (part 1)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let cur_time = time (from_voidp time_t null) ;;</userinput>
<computeroutput moreinfo="none">val cur_time : time_t = 1376834134</computeroutput></programlisting>

    <para>Since we're going to call <literal moreinfo="none">time</literal> a
    few times, let's create a wrapper function that passes the null pointer
    through:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/ffi/posix.topscript">OCaml utop</ulink>
    (part 2)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let time' () = time (from_voidp time_t null) ;;</userinput>
<computeroutput moreinfo="none">val time' : unit -&gt; time_t = &lt;fun&gt;</computeroutput></programlisting>

    <para>Since <literal moreinfo="none">time_t</literal> is an abstract type,
    we can't actually do anything useful with it directly. We need to bind a
    second function to do anything useful with the return values from <literal moreinfo="none">time</literal>. We'll move on to <literal moreinfo="none">difftime</literal>; the second C function in our prototype
    list:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/ffi/posix.topscript">OCaml utop</ulink>
    (part 3)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let difftime =</userinput>
<userinput moreinfo="none">    foreign "difftime" (time_t @-&gt; time_t @-&gt; returning double) ;;</userinput>
<computeroutput moreinfo="none">val difftime : time_t -&gt; time_t -&gt; float = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let t1 =</userinput>
<userinput moreinfo="none">    time' () in</userinput>
<userinput moreinfo="none">    Unix.sleep 2;</userinput>
<userinput moreinfo="none">    let t2 = time' () in </userinput>
<userinput moreinfo="none">    difftime t2 t1 ;;</userinput>
<computeroutput moreinfo="none">- : float = 2.</computeroutput></programlisting>

    <para>The binding to <literal moreinfo="none">difftime</literal> above is
    sufficient to compare two <literal moreinfo="none">time_t</literal>
    values.</para>

    <sect2 id="allocating-typed-memory-for-pointers">
      <title>Allocating Typed Memory for Pointers</title>

      <para>Let's look at a slightly less trivial example where we pass a
      nonnull pointer to a function. Continuing with the theme from earlier,
      we'll bind to the <literal moreinfo="none">ctime</literal> function,
      which converts a <literal moreinfo="none">time_t</literal> value to a
      human-readable string:<indexterm class="singular">
          <primary>memory</primary>

          <secondary>allocation for pointers</secondary>
        </indexterm><indexterm class="singular">
          <primary>pointers</primary>

          <secondary>allocating typed memory for</secondary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/ffi/posix.topscript">OCaml utop</ulink>
      (part 4)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let ctime = foreign "ctime" (ptr time_t @-&gt; returning string) ;;</userinput>
<computeroutput moreinfo="none">val ctime : time_t ptr -&gt; string = &lt;fun&gt;</computeroutput></programlisting>

      <para>The binding is continued in the toplevel to add to our growing
      collection. However, we can't just pass the result of <literal moreinfo="none">time</literal> to <literal moreinfo="none">ctime</literal>:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/ffi/posix.topscript">OCaml utop</ulink>
      (part 5)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">ctime (time' ()) ;;</userinput>
<computeroutput moreinfo="none">Characters 7-15:</computeroutput>
<computeroutput moreinfo="none">Error: This expression has type time_t but an expression was expected of type</computeroutput>
<computeroutput moreinfo="none">         time_t ptr</computeroutput></programlisting>

      <para>This is because <literal moreinfo="none">ctime</literal> needs a
      pointer to the <literal moreinfo="none">time_t</literal> rather than
      passing it by value. We thus need to allocate some memory for the
      <literal moreinfo="none">time_t</literal> and obtain its memory
      address:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/ffi/posix.topscript">OCaml utop</ulink>
      (part 6)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let t_ptr = allocate time_t (time' ()) ;;</userinput>
<computeroutput moreinfo="none">val t_ptr : time_t ptr = (int64_t*) 0x238ac30</computeroutput></programlisting>

      <para>The <literal moreinfo="none">allocate</literal> function takes the
      type of the memory to be allocated and the initial value and it returns
      a suitably typed pointer. We can now call <literal moreinfo="none">ctime</literal> passing the pointer as an
      argument:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/ffi/posix.topscript">OCaml utop</ulink>
      (part 7)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">ctime t_ptr ;;</userinput>
<computeroutput moreinfo="none">- : string = "Sun Aug 18 14:55:36 2013\n"</computeroutput></programlisting>
    </sect2>

    <sect2 id="using-views-to-map-complex-values">
      <title>Using Views to Map Complex Values</title>

      <para>While scalar types typically have a 1:1 representation, other C
      types require extra work to convert them into OCaml. Views create new C
      type descriptions that have special behavior when used to read or write
      C values.<indexterm class="singular">
          <primary>mapping</primary>

          <secondary>complex values with views</secondary>
        </indexterm><indexterm class="singular">
          <primary>values</primary>

          <secondary>mapping complex with views</secondary>
        </indexterm></para>

      <para>We've already used one view in the definition of <literal moreinfo="none">ctime</literal> earlier. The <literal moreinfo="none">string</literal> view wraps the C type <literal moreinfo="none">char *</literal> (written in OCaml as <literal moreinfo="none">ptr char</literal>) and converts between the C and OCaml
      string representations each time the value is written or read.</para>

      <para>Here is the type signature of the <literal moreinfo="none">Ctypes.view</literal> function:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/ctypes/ctypes.mli">OCaml</ulink>
      (part 2)</para>

      <programlisting format="linespecific" language="ocaml">val view :
  read:('a -&gt; 'b) -&gt;
  write:('b -&gt; 'a) -&gt;
  'a typ -&gt; 'b typ</programlisting>

      <para>Ctypes has some internal low-level conversion functions that map
      between an OCaml <literal moreinfo="none">string</literal> and a C
      character buffer by copying the contents into the respective data
      structure. They have the following type signature:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/ctypes/ctypes.mli">OCaml</ulink>
      (part 3)</para>

      <programlisting format="linespecific" language="ocaml">val string_of_char_ptr : char ptr -&gt; string
val char_ptr_of_string : string -&gt; char ptr</programlisting>

      <para>Given these functions, the definition of the <literal moreinfo="none">Ctypes.string</literal> value that uses views is quite
      simple:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/ctypes/ctypes_impl.ml">OCaml</ulink></para>

      <programlisting format="linespecific" language="ocaml">let string = 
  view (char ptr)
    ~read:string_of_char_ptr 
    ~write:char_ptr_of_string</programlisting>

      <para>The type of this <literal moreinfo="none">string</literal>
      function is a normal <literal moreinfo="none">typ</literal> with no
      external sign of the use of the view function:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/ctypes/ctypes.mli">OCaml</ulink>
      (part 4)<indexterm class="singular">
          <primary>memory</primary>

          <secondary>strings vs. C character buffers</secondary>

          <seealso>runtime memory representation</seealso>
        </indexterm><indexterm class="singular">
          <primary>strings</primary>

          <secondary sortas="C character buffers">vs. C character
          buffers</secondary>
        </indexterm></para>

      <programlisting format="linespecific" language="ocaml">val string    : string.typ</programlisting>

      <note>
        <title>OCaml Strings Versus C Character Buffers</title>

        <para>Although OCaml strings may look like C character buffers from an
        interface perspective, they're very different in terms of their memory
        representations.</para>

        <para>OCaml strings are stored in the OCaml heap with a header that
        explicitly defines their length. C buffers are also fixed-length, but
        by convention, a C string is terminated by a null (a <literal moreinfo="none">\0</literal> byte) character. The C string functions
        calculate their length by scanning the buffer until the first null
        character is encountered.</para>

        <para>This means that you need to be careful that OCaml strings that
        you pass to C functions don't contain any null values, since the first
        occurrence of a null character will be treated as the end of the C
        string. Ctypes also defaults to a <emphasis>copying</emphasis>
        interface for strings, which means that you shouldn't use them when
        you want the library to mutate the buffer in-place. In that situation,
        use the Ctypes <literal moreinfo="none">Bigarray</literal> support to
        pass memory by reference instead.</para>
      </note>
    </sect2>
  </sect1>

  <sect1 id="structs-and-unions">
    <title>Structs and Unions</title>

    <para>The C constructs <literal moreinfo="none">struct</literal> and
    <literal moreinfo="none">union</literal> make it possible to build new
    types from existing types. Ctypes contains counterparts that work
    similarly.<indexterm class="singular">
        <primary>unions</primary>

        <see>structs and unions</see>
      </indexterm><indexterm class="singular">
        <primary>structs and unions</primary>

        <secondary>structure definition</secondary>
      </indexterm><indexterm class="singular">
        <primary>foreign function interface (FFI)</primary>

        <secondary>structs and unions</secondary>
      </indexterm></para>

    <sect2 id="defining-a-structure">
      <title>Defining a Structure</title>

      <para>Let's improve the timer function that we wrote earlier. The POSIX
      function <literal moreinfo="none">gettimeofday</literal> retrieves the
      time with microsecond resolution. The signature of <literal moreinfo="none">gettimeofday</literal> is as follows, including the
      structure definitions:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/ffi/timeval_headers.h">C</ulink></para>

      <programlisting format="linespecific" language="c">struct timeval {
  long tv_sec;
  long tv_usec;
};

int gettimeofday(struct timeval *, struct timezone *tv);</programlisting>

      <para>Using Ctypes, we can describe this type as follows in our
      toplevel, continuing on from the previous definitions:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/ffi/posix.topscript">OCaml utop</ulink>
      (part 8)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">type timeval ;;</userinput>
<computeroutput moreinfo="none">type timeval</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let timeval : timeval structure typ = structure "timeval" ;;</userinput>
<computeroutput moreinfo="none">val timeval : timeval structure typ = struct timeval</computeroutput></programlisting>

      <para>The first command defines a new OCaml type <literal moreinfo="none">timeval</literal> that we'll use to instantiate the
      OCaml version of the struct. This is a <emphasis>phantom type</emphasis>
      that exists only to distinguish the underlying C type from other pointer
      types. The particular <literal moreinfo="none">timeval</literal>
      structure now has a distinct type from other structures we define
      elsewhere, which helps to avoid getting them mixed up.</para>

      <para>The second command calls <literal moreinfo="none">structure</literal> to create a fresh structure type. At
      this point, the structure type is incomplete: we can add fields but
      cannot yet use it in <literal moreinfo="none">foreign</literal> calls or
      use it to create values.</para>
    </sect2>

    <sect2 id="adding-fields-to-structures">
      <title>Adding Fields to Structures</title>

      <para>The <literal moreinfo="none">timeval</literal> structure
      definition still doesn't have any fields, so we need to add those
      next:<indexterm class="singular">
          <primary>fields</primary>

          <secondary>adding to structures</secondary>
        </indexterm><indexterm class="singular">
          <primary>structs and unions</primary>

          <secondary>field addition</secondary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/ffi/posix.topscript">OCaml utop</ulink>
      (part 9)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let tv_sec  = field timeval "tv_sec" long ;;</userinput>
<computeroutput moreinfo="none">val tv_sec : (Signed.long, (timeval, [ `Struct ]) structured) field = &lt;abstr&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let tv_usec = field timeval "tv_usec" long ;;</userinput>
<computeroutput moreinfo="none">val tv_usec : (Signed.long, (timeval, [ `Struct ]) structured) field =</computeroutput>
<computeroutput moreinfo="none">  &lt;abstr&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">seal timeval ;;</userinput>
<computeroutput moreinfo="none">- : unit = ()</computeroutput></programlisting>

      <para>The <literal moreinfo="none">field</literal> function appends a
      field to the structure, as shown with <literal moreinfo="none">tv_sec</literal> and <literal moreinfo="none">tv_usec</literal>. Structure fields are typed accessors
      that are associated with a particular structure, and they correspond to
      the labels in C.</para>

      <para>Every field addition mutates the structure variable and records a
      new size (the exact value of which depends on the type of the field that
      was just added). Once we <literal moreinfo="none">seal</literal> the
      structure, we will be able to create values using it, but adding fields
      to a sealed structure is an error.</para>
    </sect2>

    <sect2 id="incomplete-structure-definitions">
      <title>Incomplete Structure Definitions</title>

      <para>Since <literal moreinfo="none">gettimeofday</literal> needs a
      <literal moreinfo="none">struct timezone</literal> pointer for its
      second argument, we also need to define a second structure
      type:<indexterm class="singular">
          <primary>structs and unions</primary>

          <secondary>incomplete structure definitions</secondary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/ffi/posix.topscript">OCaml utop</ulink>
      (part 10)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">type timezone ;;</userinput>
<computeroutput moreinfo="none">type timezone</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let timezone : timezone structure typ = structure "timezone" ;;</userinput>
<computeroutput moreinfo="none">val timezone : timezone structure typ = struct timezone</computeroutput></programlisting>

      <para>We don't ever need to create <literal moreinfo="none">struct
      timezone</literal> values, so we can leave this struct as incomplete
      without adding any fields or sealing it. If you ever try to use it in a
      situation where its concrete size needs to be known, the library will
      raise an <literal moreinfo="none">IncompleteType</literal>
      exception.</para>

      <para>We're finally ready to bind to <literal moreinfo="none">gettimeofday</literal> now:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/ffi/posix.topscript">OCaml utop</ulink>
      (part 11)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let gettimeofday = foreign "gettimeofday"</userinput>
<userinput moreinfo="none">    (ptr timeval @-&gt; ptr timezone @-&gt; returning_checking_errno int) ;;</userinput>
<computeroutput moreinfo="none">val gettimeofday : timeval structure ptr -&gt; timezone structure ptr -&gt; int =</computeroutput>
<computeroutput moreinfo="none">  &lt;fun&gt;</computeroutput></programlisting>

      <para>There's one other new feature here: the <literal moreinfo="none">returning_checking_errno</literal> function behaves like
      <literal moreinfo="none">returning</literal>, except that it checks
      whether the bound C function modifies the C error flag. Changes to
      <literal moreinfo="none">errno</literal> are mapped into OCaml
      exceptions and raise a <literal moreinfo="none">Unix.Unix_error</literal> exception just as the standard
      library functions do.</para>

      <para>As before, we can create a wrapper to make <literal moreinfo="none">gettimeofday</literal> easier to use. The functions
      <literal moreinfo="none">make</literal>, <literal moreinfo="none">addr</literal>, and <literal moreinfo="none">getf</literal> create a structure value, retrieve the
      address of a structure value, and retrieve the value of a field from a
      structure:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/ffi/posix.topscript">OCaml utop</ulink>
      (part 12)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let gettimeofday' () =</userinput>
<userinput moreinfo="none">  let tv = make timeval in</userinput>
<userinput moreinfo="none">  ignore(gettimeofday (addr tv) (from_voidp timezone null));</userinput>
<userinput moreinfo="none">  let secs = Signed.Long.(to_int (getf tv tv_sec)) in</userinput>
<userinput moreinfo="none">  let usecs = Signed.Long.(to_int (getf tv tv_usec)) in</userinput>
<userinput moreinfo="none">  Pervasives.(float secs +. float usecs /. 1000000.0) ;;</userinput>
<computeroutput moreinfo="none">val gettimeofday' : unit -&gt; float = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">gettimeofday' () ;;</userinput>
<computeroutput moreinfo="none">- : float = 1376834137.14</computeroutput></programlisting>

      <para>You need to be a little careful not to get all the open modules
      mixed up here. Both <literal moreinfo="none">Pervasives</literal> and
      <literal moreinfo="none">Ctypes</literal> define different <literal moreinfo="none">float</literal> functions. The <literal moreinfo="none">Ctypes</literal> module we opened up earlier overrides
      the <literal moreinfo="none">Pervasives</literal> definition. As seen
      previously though, you just need to locally open <literal moreinfo="none">Pervasives</literal> again to bring the usual <literal moreinfo="none">float</literal> function back in scope.</para>

      <sect3 id="recap-a-time-printing-command">
        <title>Recap: A time-printing command</title>

        <para>We built up a lot of bindings in the previous section, so let's
        recap them with a complete example that ties it together with a
        command-line frontend:<indexterm class="singular">
            <primary>structs and unions</primary>

            <secondary>time-printing command</secondary>
          </indexterm></para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/ffi/datetime.ml">OCaml</ulink></para>

        <programlisting format="linespecific" language="ocaml">open Core.Std
open Ctypes
open PosixTypes
open Foreign

let time     = foreign "time" (ptr time_t @-&gt; returning time_t)
let difftime = foreign "difftime" (time_t @-&gt; time_t @-&gt; returning double)
let ctime    = foreign "ctime" (ptr time_t @-&gt; returning string)

type timeval
let timeval : timeval structure typ = structure "timeval"
let tv_sec   = field timeval "tv_sec" long
let tv_usec  = field timeval "tv_usec" long
let ()       = seal timeval

type timezone
let timezone : timezone structure typ = structure "timezone"

let gettimeofday = foreign "gettimeofday"
    (ptr timeval @-&gt; ptr timezone @-&gt; returning_checking_errno int)

let time' () = time (from_voidp time_t null)

let gettimeofday' () =
  let tv = make timeval in
  ignore(gettimeofday (addr tv) (from_voidp timezone null));
  let secs = Signed.Long.(to_int (getf tv tv_sec)) in
  let usecs = Signed.Long.(to_int (getf tv tv_usec)) in
  Pervasives.(float secs +. float usecs /. 1_000_000.)

let float_time () = printf "%f%!\n" (gettimeofday' ())

let ascii_time () =
  let t_ptr = allocate time_t (time' ()) in
  printf "%s%!" (ctime t_ptr)

let () =
  let open Command in
  basic ~summary:"Display the current time in various formats"
    Spec.(empty +&gt; flag "-a" no_arg ~doc:" Human-readable output format")
    (fun human -&gt; if human then ascii_time else float_time)
  |&gt; Command.run</programlisting>

        <para>This can be compiled and run in the usual way:<indexterm class="singular">
            <primary>returning function</primary>
          </indexterm></para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/ffi/build_datetime.out">Terminal</ulink></para>

        <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">corebuild -pkg ctypes.foreign datetime.native</userinput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">./datetime.native</userinput>
<computeroutput moreinfo="none">1376833554.984496</computeroutput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">./datetime.native -a</userinput>
<computeroutput moreinfo="none">Sun Aug 18 14:45:55 2013</computeroutput></programlisting>

        <sidebar>
          <title>Why Do We Need to Use returning?</title>

          <para>The alert reader may be curious about why all these function
          definitions have to be terminated by <literal moreinfo="none">returning</literal>:</para>

          <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/ffi/return_frag.ml">OCaml</ulink></para>

          <programlisting format="linespecific" language="ocaml">(* correct types *)
val time: ptr time_t @-&gt; returning time_t
val difftime: time_t @-&gt; time_t @-&gt; returning double</programlisting>

          <para>The <literal moreinfo="none">returning</literal> function may
          appear superfluous here. Why couldn't we simply give the types as
          follows?</para>

          <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/ffi/return_frag.ml">OCaml</ulink>
          (part 1)</para>

          <programlisting format="linespecific" language="ocaml">(* incorrect types *)
val time: ptr time_t @-&gt; time_t
val difftime: time_t @-&gt; time_t @-&gt; double</programlisting>

          <para>The reason involves higher types and two differences between
          the way that functions are treated in OCaml and C. Functions are
          first-class values in OCaml, but not in C. For example, in C it is
          possible to return a function pointer from a function, but not to
          return an actual function.</para>

          <para>Secondly, OCaml functions are typically defined in a curried
          style. The signature of a two-argument function is written as
          follows:</para>

          <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/ffi/return_frag.ml">OCaml</ulink>
          (part 2)</para>

          <programlisting format="linespecific" language="ocaml">val curried : int -&gt; int -&gt; int</programlisting>

          <para>but this really means:</para>

          <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/ffi/return_frag.ml">OCaml</ulink>
          (part 3)</para>

          <programlisting format="linespecific" language="ocaml">val curried : int -&gt; (int -&gt; int)</programlisting>

          <para>and the arguments can be supplied one at a time to create a
          closure. In contrast, C functions receive their arguments all at
          once. The equivalent C function type is the following:</para>

          <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/ffi/return_c_frag.h">C</ulink></para>

          <programlisting format="linespecific" language="c">int uncurried_C(int, int);</programlisting>

          <para>and the arguments must always be supplied together:</para>

          <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/ffi/return_c_frag.c">C</ulink></para>

          <programlisting format="linespecific" language="c">uncurried_C(3, 4);</programlisting>

          <para>A C function that's written in curried style looks very
          different:</para>

          <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/ffi/return_c_uncurried.c">C</ulink></para>

          <programlisting format="linespecific" language="c">/* A function that accepts an int, and returns a function
   pointer that accepts a second int and returns an int. */
typedef int (function_t)(int);
function_t *curried_C(int);

/* supply both arguments */
curried_C(3)(4);

/* supply one argument at a time */
function_t *f = curried_C(3); f(4);</programlisting>

          <para>The OCaml type of <literal moreinfo="none">uncurried_C</literal> when bound by Ctypes is
          <literal moreinfo="none">int -&gt; int -&gt; int</literal>: a
          two-argument function. The OCaml type of <literal moreinfo="none">curried_C</literal> when bound by <literal moreinfo="none">ctypes</literal> is <literal moreinfo="none">int
          -&gt; (int -&gt; int)</literal>: a one-argument function that
          returns a one-argument function.</para>

          <para>In OCaml, of course, these types are absolutely equivalent.
          Since the OCaml types are the same but the C semantics are quite
          different, we need some kind of marker to distinguish the cases.
          This is the purpose of <literal moreinfo="none">returning</literal>
          in function definitions.</para>
        </sidebar>
      </sect3>
    </sect2>

    <sect2 id="defining-arrays">
      <title>Defining Arrays</title>

      <para>Arrays in C are contiguous blocks of the same type of value. Any
      of the basic types defined previously can be allocated as blocks via the
      <literal moreinfo="none">Array</literal> module:<indexterm class="singular">
          <primary>arrays</primary>

          <secondary>definition of</secondary>
        </indexterm><indexterm class="singular">
          <primary>structs and unions</primary>

          <secondary>array definition</secondary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/ctypes/ctypes.mli">OCaml</ulink>
      (part 5)</para>

      <programlisting format="linespecific" language="ocaml">module Array : sig
  type 'a t = 'a array

  val get : 'a t -&gt; int -&gt; 'a
  val set : 'a t -&gt; int -&gt; 'a -&gt; unit
  val of_list : 'a typ -&gt; 'a list -&gt; 'a t
  val to_list : 'a t -&gt; 'a list
  val length : 'a t -&gt; int
  val start : 'a t -&gt; 'a ptr
  val from_ptr : 'a ptr -&gt; int -&gt; 'a t
  val make : 'a typ -&gt; ?initial:'a -&gt; int -&gt; 'a t
end</programlisting>

      <para>The array functions are similar to those in the standard library
      <literal moreinfo="none">Array</literal> module except that they operate
      on arrays stored using the flat C representation rather than the OCaml
      representation described in <xref linkend="memory-representation-of-values"/>.</para>

      <para>As with standard OCaml arrays, the conversion between arrays and
      lists requires copying the values, which can be expensive for large data
      structures. Notice that you can also convert an array into a <literal moreinfo="none">ptr</literal> pointer to the head of the underlying
      buffer, which can be useful if you need to pass the pointer and size
      arguments separately to a C function.</para>

      <para>Unions in C are named structures that can be mapped onto the same
      underlying memory. They are also fully supported in Ctypes, but we won't
      go into more detail here.<indexterm class="singular">
          <primary>operators</primary>

          <secondary>controlling pointers</secondary>
        </indexterm><indexterm class="singular">
          <primary>pointers</primary>

          <secondary>operators controlling</secondary>
        </indexterm></para>
<?hard-pagebreak?>
      <sidebar>
        <title>Pointer Operators for Dereferencing and Arithmetic</title>

        <para>Ctypes defines a number of operators that let you manipulate
        pointers and arrays just as you would in C. The Ctypes equivalents do
        have the benefit of being more strongly typed, of course (see <xref linkend="Table19sub1"/>).</para>

        <table id="Table19sub1">
          <title>Operators for manipulating pointers and arrays</title>
          <tgroup cols="2">
            <colspec align="left"/>

            <colspec align="left"/>

            <thead>
              <row>
                <entry>Operator</entry>

                <entry>Purpose</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><literal moreinfo="none">!@ p</literal></entry>

                <entry>Dereference the pointer <literal moreinfo="none">p</literal>.</entry>
              </row>

              <row>
                <entry><literal moreinfo="none">p &lt;-@ v</literal></entry>

                <entry>Write the value <literal moreinfo="none">v</literal> to
                the address <literal moreinfo="none">p</literal>.</entry>
              </row>

              <row>
                <entry><literal moreinfo="none">p +@ n</literal></entry>

                <entry>If <literal moreinfo="none">p</literal> points to an
                array element, then compute the address of the <literal moreinfo="none">n</literal>th next element.</entry>
              </row>

              <row>
                <entry><literal moreinfo="none">p -@ n</literal></entry>

                <entry>If <literal moreinfo="none">p</literal> points to an
                array element, then compute the address of the <literal moreinfo="none">n</literal>th previous element.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <para>There are also other useful nonoperator functions available (see the Ctypes
          documentation), such as pointer differencing and comparison.</para>
      </sidebar>
    </sect2>
  </sect1>

  <sect1 id="passing-functions-to-c">
    <title>Passing Functions to C</title>

    <para>It's also straightforward to pass OCaml function values to C. The C standard library
      function <literal moreinfo="none">qsort</literal> sorts arrays of elements using a comparison
      function passed in as a function pointer. The signature for <literal moreinfo="none">qsort</literal> is:<indexterm class="singular">
        <primary>functions</primary>
        <secondary>passing to C</secondary>
      </indexterm><indexterm class="singular">
        <primary>foreign function interface (FFI)</primary>
        <secondary>passing functions to C</secondary>
      </indexterm></para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/ffi/qsort.h">C</ulink></para>

    <programlisting format="linespecific" language="c">void qsort(void *base, size_t nmemb, size_t size,
           int(*compar)(const void *, const void *));</programlisting>

    <para>C programmers often use <literal moreinfo="none">typedef</literal>
    to make type definitions involving function pointers easier to read. Using
    a typedef, the type of <literal moreinfo="none">qsort</literal> looks a
    little more palatable:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/ffi/qsort_typedef.h">C:</ulink></para>

    <programlisting format="linespecific" language="c">typedef int(compare_t)(const void *, const void *);

void qsort(void *base, size_t nmemb, size_t size, compare_t *);</programlisting>

    <para>This also happens to be a close mapping to the corresponding Ctypes
    definition. Since type descriptions are regular values, we can just use
    <literal moreinfo="none">let</literal> in place of <literal moreinfo="none">typedef</literal> and end up with working OCaml bindings
    to <literal moreinfo="none">qsort</literal>:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/ffi/qsort.topscript">OCaml utop</ulink></para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">#require "ctypes.foreign" ;;</userinput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">open Ctypes ;;</userinput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">open PosixTypes ;;</userinput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">open Foreign ;;</userinput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let compare_t = ptr void @-&gt; ptr void @-&gt; returning int ;;</userinput>
<computeroutput moreinfo="none">val compare_t : (unit ptr -&gt; unit ptr -&gt; int) fn = &lt;abstr&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let qsort = foreign "qsort"</userinput>
<userinput moreinfo="none">   (ptr void @-&gt; size_t @-&gt; size_t @-&gt;</userinput>
<userinput moreinfo="none">    funptr compare_t @-&gt; returning void) ;;</userinput>
<computeroutput moreinfo="none">val qsort :</computeroutput>
<computeroutput moreinfo="none">  unit ptr -&gt; size_t -&gt; size_t -&gt; (unit ptr -&gt; unit ptr -&gt; int) -&gt; unit =</computeroutput>
<computeroutput moreinfo="none">  &lt;fun&gt;</computeroutput></programlisting>

    <para>We only use <literal moreinfo="none">compare_t</literal> once (in the <literal moreinfo="none">qsort</literal> definition), so you can choose to inline it in the OCaml
      code if you prefer. As the type shows, the resulting <literal moreinfo="none">qsort</literal>
      value is a higher-order function, since the fourth argument is itself a function. As before,
      let's define a wrapper function to make <literal moreinfo="none">qsort</literal> easier to
      use. The second and third arguments to <literal moreinfo="none">qsort</literal> specify the
      length (number of elements) of the array and the element size.</para>

    <para>Arrays created using Ctypes have a richer runtime structure than C
    arrays, so we don't need to pass size information around. Furthermore, we
    can use OCaml polymorphism in place of the unsafe <literal moreinfo="none">void ptr</literal> type.</para>

    <sect2 id="example-a-command-line-quicksort">
      <title>Example: A Command-Line Quicksort</title>

      <para>The following is a command-line tool that uses the <literal moreinfo="none">qsort</literal> binding to sort all of the integers
      supplied on the standard input:<indexterm class="singular">
          <primary>qsort binding</primary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/ffi/qsort.ml">OCaml</ulink></para>

      <programlisting format="linespecific" language="ocaml">open Core.Std
open Ctypes
open PosixTypes
open Foreign

let compare_t = ptr void @-&gt; ptr void @-&gt; returning int

let qsort = foreign "qsort"
    (ptr void @-&gt; size_t @-&gt; size_t @-&gt; funptr compare_t @-&gt; 
       returning void)

let qsort' cmp arr =
  let open Unsigned.Size_t in
  let ty = Array.element_type arr in
  let len = of_int (Array.length arr) in
  let elsize = of_int (sizeof ty) in
  let start = to_voidp (Array.start arr) in
  let compare l r = cmp (!@ (from_voidp ty l)) (!@ (from_voidp ty r)) in
  qsort start len elsize compare;
  arr

let sort_stdin () =
  In_channel.input_lines stdin
  |&gt; List.map ~f:int_of_string
  |&gt; Array.of_list int
  |&gt; qsort' Int.compare
  |&gt; Array.to_list
  |&gt; List.iter ~f:(fun a -&gt; printf "%d\n" a)

let () =
  Command.basic ~summary:"Sort integers on standard input"
    Command.Spec.empty sort_stdin
  |&gt; Command.run</programlisting>

      <para>Compile it in the usual way with <emphasis>corebuild</emphasis> and test it against some
        input data, and also build the inferred interface so we can examine it more closely:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/ffi/build_qsort.out">Terminal</ulink></para>

      <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">corebuild -pkg ctypes.foreign qsort.native</userinput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">cat input.txt</userinput>
<computeroutput moreinfo="none">5</computeroutput>
<computeroutput moreinfo="none">3</computeroutput>
<computeroutput moreinfo="none">2</computeroutput>
<computeroutput moreinfo="none">1</computeroutput>
<computeroutput moreinfo="none">4</computeroutput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">./qsort.native &lt; input.txt</userinput>
<computeroutput moreinfo="none">1</computeroutput>
<computeroutput moreinfo="none">2</computeroutput>
<computeroutput moreinfo="none">3</computeroutput>
<computeroutput moreinfo="none">4</computeroutput>
<computeroutput moreinfo="none">5</computeroutput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">corebuild -pkg ctypes.foreign qsort.inferred.mli</userinput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">cp _build/qsort.inferred.mli qsort.mli</userinput></programlisting>

      <para>The inferred interface shows us the types of the raw <literal moreinfo="none">qsort</literal> binding and also the <literal moreinfo="none">qsort'</literal> wrapper function:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/ffi/qsort.mli">OCaml</ulink></para>

      <programlisting format="linespecific" language="ocaml">val compare_t : (unit Ctypes.ptr -&gt; unit Ctypes.ptr -&gt; int) Ctypes.fn
val qsort :
  unit Ctypes.ptr -&gt;
  PosixTypes.size_t -&gt;
  PosixTypes.size_t -&gt; (unit Ctypes.ptr -&gt; unit Ctypes.ptr -&gt; int) -&gt; unit
val qsort' : ('a -&gt; 'a -&gt; int) -&gt; 'a Ctypes.array -&gt; 'a Ctypes.array
val sort_stdin : unit -&gt; unit</programlisting>

      <para>The <literal moreinfo="none">qsort'</literal> wrapper function has
      a much more canonical OCaml interface than the raw binding. It accepts a
      comparator function and a Ctypes array, and returns the same Ctypes
      array. It's not strictly required that it returns the array, since it
      modifies it in-place, but it makes it easier to chain the function using
      the <literal moreinfo="none">|&gt;</literal> operator (as <literal moreinfo="none">sort_stdin</literal> does in the example).</para>

      <para>Using <literal moreinfo="none">qsort'</literal> to sort arrays is
      straightforward. Our example code reads the standard input as a list,
      converts it to a C array, passes it through qsort, and outputs the
      result to the standard output. Again, remember to not confuse the
      <literal moreinfo="none">Ctypes.Array</literal> module with the <literal moreinfo="none">Core.Std.Array</literal> module: the former is in scope
      since we opened <literal moreinfo="none">Ctypes</literal> at the start
      of the file.<indexterm class="singular">
          <primary>memory</primary>

          <secondary sortas="allocated Ctypes">and allocated
          Ctypes</secondary>
        </indexterm><indexterm class="singular">
          <primary>Ctypes library</primary>

          <secondary>lifetime of allocated Ctypes</secondary>
        </indexterm><indexterm class="singular">
          <primary>garbage collection</primary>

          <secondary>of allocated Ctypes</secondary>
        </indexterm></para>

      <sidebar>
        <title>Lifetime of Allocated Ctypes</title>

        <para>Values allocated via Ctypes (i.e., using <literal moreinfo="none">allocate</literal>,
            <literal moreinfo="none">Array.make</literal>, and so on) will not be garbage-collected
          as long as they are reachable from OCaml values. The system memory they occupy is freed
          when they do become unreachable, via a finalizer function registered with the garbage
          collector (GC).</para>

        <para>The definition of reachability for Ctypes values is a little
        different from conventional OCaml values, though. The allocation
        functions return an OCaml-managed pointer to the value, and as long as
        some derivative pointer is still reachable by the GC, the value won't
        be collected.</para>

        <para>"Derivative" means a pointer that's computed from the original
        pointer via arithmetic, so a reachable reference to an array element
        or a structure field protects the whole object from collection.</para>

        <para>A corollary of the preceding rule is that pointers written into the C heap don't have
          any effect on reachability. For example, if you have a C-managed array of pointers to
          structs, then you'll need some additional way of keeping the structs themselves around to
          protect them from collection. You could achieve this via a global array of values on the
          OCaml side that would keep them live until they're no longer needed.</para>

        <para>Functions passed to C have similar considerations regarding lifetime. On the OCaml
          side, functions created at runtime may be collected when they become unreachable. As we've
          seen, OCaml functions passed to C are converted to function pointers, and function
          pointers written into the C heap have no effect on the reachability of the OCaml functions
          they reference. With <literal moreinfo="none">qsort</literal> things are straightforward,
          since the comparison function is only used during the call to <literal moreinfo="none">qsort</literal> itself. However, other C libraries may store function pointers in
          global variables or elsewhere, in which case you'll need to take care that the OCaml
          functions you pass to them aren't prematurely garbage-collected.</para>
      </sidebar>
    </sect2>
  </sect1>

  <sect1 id="learning-more-about-c-bindings">
    <title>Learning More About C Bindings</title>

    <para>The Ctypes <ulink url="http://github.com/ocamllabs/ocaml-ctypes">distribution</ulink>
    contains a number of larger-scale examples, including:<indexterm class="singular">
        <primary>foreign function interface (FFI)</primary>

        <secondary>C bindings</secondary>
      </indexterm></para>

    <itemizedlist>
      <listitem>
        <para>Bindings to the POSIX <literal moreinfo="none">fts</literal>
        API, which demonstrates C callbacks more comprehensively</para>
      </listitem>

      <listitem>
        <para>A more complete Ncurses binding than the example we opened the
        chapter with</para>
      </listitem>

      <listitem>
        <para>A comprehensive test suite that covers the complete library, and
        can provide useful snippets for your own bindings</para>
      </listitem>
    </itemizedlist>

    <para>This chapter hasn't really needed you to understand the innards of OCaml at all. Ctypes
      does its best to make function bindings easy, but the rest of this part will also fill you in
      about interactions with OCaml memory layout in <xref linkend="memory-representation-of-values"/> and automatic memory management in <xref linkend="understanding-the-garbage-collector"/>.</para>

    <para>Ctypes gives OCaml programs access to the C representation of
    values, shielding you from the details of the OCaml value representation,
    and introduces an abstraction layer that hides the details of foreign
    calls. While this covers a wide variety of situations, it's sometimes
    necessary to look behind the abstraction to obtain finer control over the
    details of the interaction between the two languages.</para>

    <para>You can find more information about the C interface in several
    places:</para>

    <itemizedlist>
      <listitem>
        <para>The standard OCaml foreign function interface allows you to glue OCaml and C together
          from the other side of the boundary, by writing C functions that operate on the OCaml
          representation of values. You can find details of the standard interface in the <ulink url="http://caml.inria.fr/pub/docs/manual-ocaml-4.00/manual033.html">OCaml
            manual</ulink> and in the book <ulink url="http://caml.inria.fr/pub/docs/oreilly-book/ocaml-ora-book.pdf"><emphasis>Developing
              Applications with Objective Caml</emphasis></ulink>.</para>
      </listitem>

      <listitem>
        <para>Florent Monnier maintains an excellent online <ulink url="http://www.linux-nantes.org/~fmonnier/ocaml/ocaml-wrapping-c.html">OCaml</ulink>
        that provides examples of how to call OCaml functions from C. This
        covers a wide variety of OCaml data types and also more complex
        callbacks between C and OCaml.</para>
      </listitem>

      <listitem>
        <para><ulink url="http://www.swig.org">SWIG</ulink> is a tool that
        connects programs written in C/C++ to a variety of higher-level
        programming languages, including OCaml. The SWIG manual has examples
        of converting library specifications into OCaml bindings.</para>
      </listitem>
    </itemizedlist>

    <sect2 id="struct-memory-layout">
      <title>Struct Memory Layout</title>

      <para>The C language gives implementations a certain amount of freedom
      in choosing how to lay out structs in memory. There may be padding
      between members and at the end of the struct, in order to satisfy the
      memory alignment requirements of the host platform. Ctypes uses
      platform-appropriate size and alignment information to replicate the
      struct layout process. OCaml and C will have consistent views about the
      layout of the struct as long as you declare the fields of a struct in
      the same order and with the same types as the C library you're binding
      to.<indexterm class="singular">
          <primary>memory</primary>

          <secondary>layout for structs</secondary>
        </indexterm><indexterm class="singular">
          <primary>structs and unions</primary>

          <secondary>memory layout of</secondary>
        </indexterm></para>

      <para>However, this approach can lead to difficulties when the fields of
      a struct aren't fully specified in the interface of a library. The
      interface may list the fields of a structure without specifying their
      order, or make certain fields available only on certain platforms, or
      insert undocumented fields into struct definitions for performance
      reasons. For example, the <literal moreinfo="none">struct
      timeval</literal> definition used in this chapter accurately describes
      the layout of the struct on common platforms, but implementations on
      some more unusual architectures include additional padding members that
      will lead to strange behavior in the examples.</para>

      <para>The Cstubs subpackage of Ctypes addresses this issue. Rather than
      simply assuming that struct definitions given by the user accurately
      reflect the actual definitions of structs used in C libraries, Cstubs
      generates code that uses the C library headers to discover the layout of
      the struct. The good news is that the code that you write doesn't need
      to change much. Cstubs provides alternative implementations of the
      <literal moreinfo="none">field</literal> and <literal moreinfo="none">seal</literal> functions that you've already used to
      describe <literal moreinfo="none">struct timeval</literal>; instead of
      computing member offsets and sizes appropriate for the platform, these
      implementations obtain them directly from C.</para>

      <para>The details of using Cstubs are available in the online <ulink url="https://ocamllabs.github.io/ocaml-ctypes">documentation</ulink>,
      along with instructions on integration with <command moreinfo="none">autoconf</command> platform portability
      instructions.<indexterm class="endofrange" startref="INTERffi"/></para>
    </sect2>
  </sect1>
</chapter>

    <chapter id="memory-representation-of-values">
  <title>Memory Representation of Values</title>

  <para>The FFI interface we described in <xref linkend="foreign-function-interface"/> hides the precise details of how
  values are exchanged across C libraries and the OCaml runtime. There is a
  simple reason for this: using this interface directly is a delicate
  operation that requires understanding a few different moving parts before
  you can get it right. You first need to know the mapping between OCaml types
  and their runtime memory representation. You also need to ensure that your
  code is interfacing correctly with OCaml runtime's memory
  management.<indexterm class="singular">
      <primary>runtime memory representation</primary>

      <secondary>importance of</secondary>
    </indexterm><indexterm class="startofrange" id="VALmemory">
      <primary>values</primary>

      <secondary>memory representation of</secondary>
    </indexterm></para>

  <para>However, knowledge of the OCaml internals is useful beyond just
  writing foreign function interfaces. As you build and maintain more complex
  OCaml applications, you'll need to interface with various external system
  tools that operate on compiled OCaml binaries. For example, profiling tools
  report output based on the runtime memory layout, and debuggers execute
  binaries without any knowledge of the static OCaml types. To use these tools
  effectively, you'll need to do some translation between the OCaml and C
  worlds.<indexterm class="singular">
      <primary>interfaces</primary>

      <secondary sortas="OCaml">with OCaml binaries</secondary>
    </indexterm></para>

  <para>Luckily, the OCaml toolchain is very predictable. The compiler
  minimizes the amount of optimization magic that it performs, and relies
  instead on its straightforward execution model for good performance. With
  some experience, you can know rather precisely where a block of
  performance-critical OCaml code is spending its time.<indexterm class="singular">
      <primary>OCaml toolchain</primary>

      <secondary>benefits of</secondary>
    </indexterm></para>

  <note>
    <title>Why Do OCaml Types Disappear at Runtime?</title>

    <para>The OCaml compiler runs through several phases during the compilation process. The first
      phase is syntax checking, during which source files are parsed into abstract syntax trees
      (ASTs). The next stage is a <emphasis>type checking</emphasis> pass over the AST. In a validly
      typed program, a function cannot be applied with an unexpected type. For example, the <literal moreinfo="none">print_endline</literal> function must receive a single <literal moreinfo="none">string</literal> argument, and an <literal moreinfo="none">int</literal>
      will result in a type error.<indexterm class="singular">
        <primary>type checking</primary>
      </indexterm><indexterm class="singular">
        <primary>AST (abstract syntax-tree)</primary>
      </indexterm><indexterm class="singular">
        <primary>compilation process</primary>
        <secondary>phases of</secondary>
      </indexterm></para>

    <para>Since OCaml verifies these properties at compile time, it doesn't
    need to keep track of as much information at runtime. Thus, later stages
    of the compiler can discard and simplify the type declarations to a much
    more minimal subset that's actually required to distinguish polymorphic
    values at runtime. This is a major performance win versus something like a
    Java or .NET method call, where the runtime must look up the concrete
    instance of the object and dispatch the method call. Those languages
    amortize some of the cost via "Just-in-Time" dynamic patching, but OCaml
    prefers runtime simplicity instead.<indexterm class="singular">
        <primary sortas="Just">"Just-in-Time" dynamic patching</primary>
      </indexterm><indexterm class="singular">
        <primary>dynamic type checking</primary>
      </indexterm><indexterm class="singular">
        <primary>compile-time static checking</primary>
      </indexterm></para>

    <para>We'll explain this compilation pipeline in more detail in <xref linkend="the-compiler-frontend-parsing-and-type-checking"/> and <xref linkend="the-compiler-backend-byte-code-and-native-code"/>.</para>
  </note>

  <para>This chapter covers the precise mapping from OCaml types to runtime
  values and walks you through them via the toplevel. We'll cover how these
  values are managed by the runtime later on in <xref linkend="understanding-the-garbage-collector"/>.<indexterm class="startofrange" id="MAPocaml">
      <primary>mapping</primary>

      <secondary sortas="OCaml">of OCaml types to runtime values</secondary>
    </indexterm></para>

  <sect1 id="ocaml-blocks-and-values">
    <title>OCaml Blocks and Values</title>

    <para>A running OCaml program uses blocks of memory (i.e., contiguous
    sequences of words in RAM) to represent values such as tuples, records,
    closures, or arrays. An OCaml program implicitly allocates a block of
    memory when such a value is created:<indexterm class="startofrange" id="blck">
        <primary>blocks (of memory)</primary>
      </indexterm></para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/memory-repr/simple_record.topscript">OCaml utop</ulink></para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">type t = { foo: int; bar: int } ;;</userinput>
<computeroutput moreinfo="none">type t = { foo : int; bar : int; }</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let x = { foo = 13; bar = 14 } ;;</userinput>
<computeroutput moreinfo="none">val x : t = {foo = 13; bar = 14}</computeroutput></programlisting>

    <para>The type declaration <literal moreinfo="none">t</literal> doesn't
    take up any memory at runtime, but the subsequent <literal moreinfo="none">let</literal> binding allocates a new block of memory with
    two words of available space. One word holds the <literal moreinfo="none">foo</literal> field, and the other word holds the <literal moreinfo="none">bar</literal> field. The OCaml compiler translates such an
    expression into an explicit allocation for the block from OCaml's runtime
    system.</para>

    <para>OCaml uses a uniform memory representation in which every OCaml
    variable is stored as a <emphasis>value</emphasis>. An OCaml value is a
    single memory word that is either an immediate integer or a pointer to
    some other memory. The OCaml runtime tracks all values so that it can free
    them when they are no longer needed. It thus needs to be able to
    distinguish between integer and pointer values, since it scans pointers to
    find further values but doesn't follow integers that don't point to
    anything meaningful beyond their immediate value.<indexterm class="singular">
        <primary>pointers</primary>

        <secondary>values for</secondary>
      </indexterm><indexterm class="singular">
        <primary>integers</primary>
      </indexterm><indexterm class="singular">
        <primary>values</primary>

        <secondary>integer vs. pointer</secondary>
      </indexterm></para>

    <sect2 id="distinguishing-integer-and-pointers-at-runtime">
      <title>Distinguishing Integers and Pointers at Runtime</title>

      <para>Wrapping primitives types (such as integers) inside another data structure that records
        extra metadata about the value is known as <emphasis>boxing</emphasis>. Values are boxed in
        order to make it easier for the garbage collector (GC) to do its job, but at the expense of
        an extra level of indirection to access the data within the boxed value.<indexterm class="singular">
          <primary>garbage collection</primary>
          <secondary sortas="boxed">and boxed values</secondary>
        </indexterm><indexterm class="singular">
          <primary>boxing (of values)</primary>
        </indexterm><indexterm class="singular">
          <primary>values</primary>
          <secondary>boxing of</secondary>
        </indexterm></para>

      <para>OCaml values don't all have to be boxed at runtime. Instead,
      values use a single tag bit per word to distinguish integers and
      pointers at runtime. The value is an integer if the lowest bit of the
      block word is nonzero, and a pointer if the lowest bit of the block word
      is zero. Several OCaml types map onto this integer representation,
      including <literal moreinfo="none">bool</literal>, <literal moreinfo="none">int</literal>, the empty list, <literal moreinfo="none">unit</literal>, and variants without
      constructors.</para>

      <para>This representation means that integers are unboxed runtime values
      in OCaml so that they can be stored directly without having to allocate
      a wrapper block. They can be passed directly to other function calls in
      registers and are generally the cheapest and fastest values to use in
      OCaml.</para>

      <para>A value is treated as a memory pointer if its lowest bit is zero.
      A pointer value can still be stored unmodified despite this, since
      pointers are guaranteed to be word-aligned (with the bottom bits always
      being zero).</para>

      <para>The only problem that remains with this memory representation is distinguishing between
        pointers to OCaml values (which should be followed by the GC) and pointers into the system
        heap to C values (which shouldn't be followed).</para>

      <para>The mechanism for this is simple, since the runtime system keeps
      track of the heap blocks it has allocated for OCaml values. If the
      pointer is inside a heap chunk that is marked as being managed by the
      OCaml runtime, it is assumed to point to an OCaml value. If it points
      outside the OCaml runtime area, it is treated as an opaque C pointer to
      some other system resource.<indexterm class="singular">
          <primary>word-aligned pointers</primary>
        </indexterm><indexterm class="singular">
          <primary>pointers</primary>

          <secondary>word-aligned</secondary>
        </indexterm></para>

      <note>
        <title>Some History About OCaml's Word-Aligned Pointers</title>

        <para>The alert reader may be wondering how OCaml can guarantee that
        all of its pointers are word-aligned. In the old days, when RISC chips
        such as Sparc, MIPS, and Alpha were commonplace, unaligned memory
        accesses were forbidden by the instruction set architecture and would
        result in a CPU exception that terminated the program. Thus, all
        pointers were historically rounded off to the architecture word size
        (usually 32 or 64 bits).<indexterm class="singular">
            <primary>unaligned memory access</primary>
          </indexterm></para>

        <para>Modern CISC processors such as the Intel x86 do support
        unaligned memory accesses, but the chip still runs faster if accesses
        are word-aligned. OCaml therefore simply mandates that all pointers be
        word-aligned, which guarantees that the bottom few bits of any valid
        pointer will be zero. Setting the bottom bit to a nonzero value is a
        simple way to mark an integer, at the cost of losing that single bit
        of precision.</para>

        <para>An even more alert reader will be wondering about the
        performance implications are for integer arithmetic using this tagged
        representation. Since the bottom bit is set, any operation on the
        integer has to shift the bottom bit right to recover the "native"
        value. The native code OCaml compiler generates efficient x86 assembly
        code in this case, taking advantage of modern processor instructions
        to hide the extra shifts where possible. Addition is a single <literal moreinfo="none">LEA</literal> x86 instruction, subtraction can be two
        instructions, and multiplication is only a few more.</para>
      </note>
    </sect2>
  </sect1>

  <sect1 id="blocks-and-values">
    <title>Blocks and Values</title>

    <para>An OCaml <emphasis>block</emphasis> is the basic unit of allocation
    on the heap. A block consists of a one-word header (either 32 or 64 bits
    depending on the CPU architecture) followed by variable-length data that
    is either opaque bytes or an array of <emphasis>fields</emphasis>. The
    header has a multipurpose tag byte that defines whether to interpret the
    subsequent data as opaque bytes or OCaml fields.<indexterm class="singular">
        <primary>runtime memory representation</primary>

        <secondary>blocks and values</secondary>
      </indexterm></para>

    <para>The GC never inspects opaque bytes. If the tag indicates an array of OCaml fields are
      present, their contents are all treated as more valid OCaml values. The GC always inspects fields and follows them as part of the
      collection process described earlier.<indexterm class="singular">
        <primary>garbage collection</primary>
        <secondary>opaque bytes and</secondary>
      </indexterm><indexterm class="singular">
        <primary>opaque bytes</primary>
      </indexterm></para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/memory-repr/block.ascii">Diagram</ulink></para>
    
    <informalfigure>
     
      <mediaobject>
        <imageobject role="web">
          <imagedata fileref="images/rwoc_2001.png" format="PNG"/>
        </imageobject>
      </mediaobject>
    </informalfigure>

    <para>The <literal moreinfo="none">size</literal> field records the length
    of the block in memory words. This is 22 bits on 32-bit platforms, which
    is the reason OCaml strings are limited to 16 MB on that architecture. If
    you need bigger strings, either switch to a 64-bit host, or use the
    <literal moreinfo="none">Bigarray</literal> module.</para>

    <para>The 2-bit <literal moreinfo="none">color</literal> field is used by the GC to keep track
      of its state during mark-and-sweep collection. We'll come back to this field in <xref linkend="understanding-the-garbage-collector"/>. This tag isn't exposed to OCaml source code
      in any case.</para>

    <para>A block's tag byte is multipurpose, and indicates whether the data
    array represents opaque bytes or fields. If a block's tag is greater than
    or equal to <literal moreinfo="none">No_scan_tag</literal> (251), then the
    block's data are all opaque bytes, and are not scanned by the collector.
    The most common such block is the <literal moreinfo="none">string</literal> type, which we describe in more detail
    later in this chapter.</para>

    <para>The exact representation of values inside a block depends on their static OCaml type. All
      OCaml types are distilled down into <literal moreinfo="none">values</literal>, and summarized
      in <xref linkend="table20-1_ocaml"/>.<indexterm class="endofrange" startref="blck"/></para>

    <table id="table20-1_ocaml"><title>OCaml values</title>
      <tgroup cols="2">
        <colspec align="left"/>

        <colspec align="left"/>

        <thead>
          <row>
            <entry>OCaml value</entry>

            <entry>Representation</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry><literal moreinfo="none">int</literal> or <literal moreinfo="none">char</literal></entry>

            <entry>Directly as a value, shifted left by 1 bit, with the least significant bit set to
              1.</entry>
          </row>

          <row>
            <entry><literal moreinfo="none">unit</literal>, <literal moreinfo="none">[]</literal>, <literal moreinfo="none">false</literal></entry>

            <entry>As OCaml <literal moreinfo="none">int</literal> 0.</entry>
          </row>

          <row>
            <entry><literal moreinfo="none">true</literal></entry>

            <entry>As OCaml <literal moreinfo="none">int</literal> 1.</entry>
          </row>

          <row>
            <entry><literal moreinfo="none">Foo | Bar</literal></entry>

            <entry>As ascending OCaml <literal moreinfo="none">int</literal>s, starting from
              0.</entry>
          </row>

          <row>
            <entry><literal moreinfo="none">Foo | Bar of int</literal></entry>

            <entry>Variants with parameters are boxed, while variants with no parameters are
              unboxed.</entry>
          </row>

          <row>
            <entry>Polymorphic variants</entry>

            <entry>Variable space usage depending on the number of parameters.</entry>
          </row>

          <row>
            <entry>Floating-point number</entry>

            <entry>As a block with a single field containing the double-precision float.</entry>
          </row>

          <row>
            <entry>String</entry>

            <entry>Word-aligned byte arrays with an explicit length.</entry>
          </row>

          <row>
            <entry><literal moreinfo="none">[1; 2; 3]</literal></entry>

            <entry>As <literal moreinfo="none">1::2::3::[]</literal> where <literal moreinfo="none">[]</literal> is an int, and <literal moreinfo="none">h::t</literal> a block with
              tag 0 and two parameters.</entry>
          </row>

          <row>
            <entry>Tuples, records, and arrays</entry>

            <entry>An array of values. Arrays can be variable size, but tuples and records are
              fixed-size.</entry>
          </row>

          <row>
            <entry>Records or arrays, all float</entry>

            <entry>Special tag for unboxed arrays of floats, or records that only have <literal moreinfo="none">float</literal> fields.</entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <sect2 id="integers-characters-and-other-basic-types">
      <title>Integers, Characters, and Other Basic Types</title>

      <para>Many basic types are efficiently stored as unboxed integers at runtime. The native
          <literal moreinfo="none">int</literal> type is the most obvious, although it drops a
        single bit of precision due to the tag bit. Other atomic types such as <literal moreinfo="none">unit</literal> and the empty list <literal moreinfo="none">[]</literal>
        value are stored as constant integers. Boolean values have a value of <literal moreinfo="none">1</literal> and <literal moreinfo="none">0</literal> for <literal moreinfo="none">true</literal> and <literal moreinfo="none">false</literal>,
          respectively.<indexterm class="singular">
          <primary>integers</primary>
        </indexterm><indexterm class="singular">
          <primary>unboxed integers</primary>
        </indexterm></para>

      <para>These basic types such as empty lists and <literal moreinfo="none">unit</literal> are
        very efficient to use, since integers are never allocated on the heap. They can be passed
        directly in registers and not appear on the stack if you don't have too many parameters to
        your functions. Modern architectures such as <literal moreinfo="none">x86_64</literal> have
        a lot of spare registers to further improve the efficiency of using unboxed integers.</para>
    </sect2>
  </sect1>

  <sect1 id="tuples-records-and-arrays">
    <title>Tuples, Records, and Arrays</title>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/memory-repr/tuple_layout.ascii">Diagram</ulink></para>
    

    <informalfigure>
      <mediaobject>
        <imageobject role="web">
          <imagedata fileref="images/rwoc_2002.png" format="PNG"/>
        </imageobject>
      </mediaobject>
    </informalfigure>

    <para>Tuples, records, and arrays are all represented identically at
    runtime as a block with tag <literal moreinfo="none">0</literal>. Tuples
    and records have constant sizes determined at compile time, whereas arrays
    can be of variable length. While arrays are restricted to containing a
    single type of element in the OCaml type system, this is not required by
    the memory representation.<indexterm class="singular">
        <primary>arrays</primary>

        <secondary>memory representation of</secondary>
      </indexterm><indexterm class="singular">
        <primary>records</primary>

        <secondary>memory representation of</secondary>
      </indexterm><indexterm class="singular">
        <primary>tuples</primary>
      </indexterm><indexterm class="singular">
        <primary>runtime memory representation</primary>

        <secondary>tuples, records, and arrays</secondary>
      </indexterm></para>

    <para>You can check the difference between a block and a direct integer
    yourself using the <literal moreinfo="none">Obj</literal> module, which
    exposes the internal representation of values to OCaml code:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/memory-repr/reprs.topscript">OCaml utop</ulink></para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">Obj.is_block (Obj.repr (1,2,3)) ;;</userinput>
<computeroutput moreinfo="none">- : bool = true</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Obj.is_block (Obj.repr 1) ;;</userinput>
<computeroutput moreinfo="none">- : bool = false</computeroutput></programlisting>

    <para>The <literal moreinfo="none">Obj.repr</literal> function retrieves
    the runtime representation of any OCaml value. <literal moreinfo="none">Obj.is_block</literal> checks the bottom bit to determine
    if the value is a block header or an unboxed integer.</para>

    <sect2 id="floating-point-numbers-and-arrays">
      <title>Floating-Point Numbers and Arrays</title>

      <para>Floating-point numbers in OCaml are always stored as full, double-precision values.
        Individual floating-point values are stored as a block with a single field that contains the
        number. This block has the <literal moreinfo="none">Double_tag</literal> set, which signals
        to the collector that the floating-point value is not to be scanned:<indexterm class="singular">
          <primary>floating-point values</primary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/memory-repr/reprs.topscript">OCaml utop</ulink>
      (part 1)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">Obj.tag (Obj.repr 1.0) ;;</userinput>
<computeroutput moreinfo="none">- : int = 253</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Obj.double_tag ;;</userinput>
<computeroutput moreinfo="none">- : int = 253</computeroutput></programlisting>

      <para>Since each floating-point value is boxed in a separate memory block, it can be
        inefficient to handle large arrays of floats in comparison to unboxed integers. OCaml
        therefore special-cases records or arrays that contain <emphasis>only</emphasis>
        <literal moreinfo="none">float</literal> types. These are stored in a block that contains
        the floats packed directly in the data section, with <literal moreinfo="none">Double_array_tag</literal> set to signal to the collector that the contents are not OCaml
        values.</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/memory-repr/float_array_layout.ascii">Diagram</ulink></para>

      <informalfigure>
        <mediaobject>
          <imageobject role="web">
            <imagedata fileref="images/rwoc_2003.png" format="PNG"/>
          </imageobject>
        </mediaobject>
      </informalfigure>

      <para>First, let's check that float arrays do in fact have a different
      tag number from normal floating-point values:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/memory-repr/reprs.topscript">OCaml utop</ulink>
      (part 2)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">Obj.double_tag ;;</userinput>
<computeroutput moreinfo="none">- : int = 253</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Obj.double_array_tag ;;</userinput>
<computeroutput moreinfo="none">- : int = 254</computeroutput></programlisting>

      <para>This tells us that float arrays have a tag value of 254. Now let's
      test some sample values using the <literal moreinfo="none">Obj.tag</literal> function to check that the allocated
      block has the expected runtime tag, and also use <literal moreinfo="none">Obj.double_field</literal> to retrieve a float from
      within the block:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/memory-repr/reprs.topscript">OCaml utop</ulink>
      (part 3)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">Obj.tag (Obj.repr [| 1.0; 2.0; 3.0 |]) ;;</userinput>
<computeroutput moreinfo="none">- : int = 254</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Obj.tag (Obj.repr (1.0, 2.0, 3.0) ) ;;</userinput>
<computeroutput moreinfo="none">- : int = 0</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Obj.double_field (Obj.repr [| 1.1; 2.2; 3.3 |]) 1 ;;</userinput>
<computeroutput moreinfo="none">- : float = 2.2</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Obj.double_field (Obj.repr 1.234) 0 ;;</userinput>
<computeroutput moreinfo="none">- : float = 1.234</computeroutput></programlisting>

      <para>The first thing we tested was that a float array has the correct unboxed float array tag
        value (254). However, the next line tests a tuple of floating-point values instead, which
        are <emphasis>not</emphasis> optimized in the same way and have the normal tuple tag value
        (0).</para>

      <para>Only records and arrays can have the float array optimization, and
      for records, every single field must be a float.</para>
    </sect2>
  </sect1>

  <sect1 id="variants-and-lists">
    <title>Variants and Lists</title>

    <para>Basic variant types with no extra parameters for any of their
    branches are simply stored as an OCaml integer, starting with <literal moreinfo="none">0</literal> for the first option and in ascending
    order:<indexterm class="singular">
        <primary>variant types</primary>

        <secondary>memory representation of</secondary>
      </indexterm><indexterm class="singular">
        <primary>lists</primary>

        <secondary>memory representation of</secondary>
      </indexterm><indexterm class="singular">
        <primary>runtime memory representation</primary>

        <secondary>variants and lists</secondary>
      </indexterm></para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/memory-repr/reprs.topscript">OCaml utop</ulink>
    (part 4)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">type t = Apple | Orange | Pear ;;</userinput>
<computeroutput moreinfo="none">type t = Apple | Orange | Pear</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">((Obj.magic (Obj.repr Apple)) : int) ;;</userinput>
<computeroutput moreinfo="none">- : int = 0</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">((Obj.magic (Obj.repr Pear)) : int) ;;</userinput>
<computeroutput moreinfo="none">- : int = 2</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Obj.is_block (Obj.repr Apple) ;;</userinput>
<computeroutput moreinfo="none">- : bool = false</computeroutput></programlisting>

    <para><literal moreinfo="none">Obj.magic</literal> unsafely forces a type
    cast between any two OCaml types; in this example, the <literal moreinfo="none">int</literal> type hint retrieves the runtime integer
    value. The <literal moreinfo="none">Obj.is_block</literal> confirms that
    the value isn't a more complex block, but just an OCaml <literal moreinfo="none">int</literal>.</para>

    <para>Variants that have parameters arguments are a little more complex.
    They are stored as blocks, with the value <emphasis>tags</emphasis>
    ascending from 0 (counting from leftmost variants with parameters). The
    parameters are stored as words in the block:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/memory-repr/reprs.topscript">OCaml utop</ulink>
    (part 5)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">type t = Apple | Orange of int | Pear of string | Kiwi ;;</userinput>
<computeroutput moreinfo="none">type t = Apple | Orange of int | Pear of string | Kiwi</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Obj.is_block (Obj.repr (Orange 1234)) ;;</userinput>
<computeroutput moreinfo="none">- : bool = true</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Obj.tag (Obj.repr (Orange 1234)) ;;</userinput>
<computeroutput moreinfo="none">- : int = 0</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Obj.tag (Obj.repr (Pear "xyz")) ;;</userinput>
<computeroutput moreinfo="none">- : int = 1</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">(Obj.magic (Obj.field (Obj.repr (Orange 1234)) 0) : int) ;;</userinput>
<computeroutput moreinfo="none">- : int = 1234</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">(Obj.magic (Obj.field (Obj.repr (Pear "xyz")) 0) : string) ;;</userinput>
<computeroutput moreinfo="none">- : string = "xyz"</computeroutput></programlisting>

    <para>In the preceding example, the <literal moreinfo="none">Apple</literal> and <literal moreinfo="none">Kiwi</literal> values are still stored as normal OCaml integers with values
        <literal moreinfo="none">0</literal> and <literal moreinfo="none">1</literal>, respectively.
      The <literal moreinfo="none">Orange</literal> and <literal moreinfo="none">Pear</literal>
      values both have parameters and are stored as blocks whose tags ascend from <literal moreinfo="none">0</literal> (and so <literal moreinfo="none">Pear</literal> has a tag of
        <literal moreinfo="none">1</literal>, as the use of <literal moreinfo="none">Obj.tag</literal> verifies). Finally, the parameters are fields that contain OCaml values
      within the block, and <literal moreinfo="none">Obj.field</literal> can be used to retrieve
      them.</para>

    <para>Lists are stored with a representation that is exactly the same as if the list was written
      as a variant type with <literal moreinfo="none">Nil</literal> and <literal moreinfo="none">Cons</literal>. The empty list <literal moreinfo="none">[]</literal> is an integer <literal moreinfo="none">0</literal>, and subsequent blocks have tag <literal moreinfo="none">0</literal> and two parameters: a block with the current value, and a pointer to the rest
      of the list.<indexterm class="singular">
        <primary>debugging</primary>
        <secondary>Obj module warning</secondary>
      </indexterm><indexterm class="singular">
        <primary>security issues</primary>
        <secondary>Obj module warning</secondary>
      </indexterm><indexterm class="singular">
        <primary>Obj module</primary>
      </indexterm></para>

    <warning>
      <title>Obj Module Considered Harmful</title>

      <para><literal moreinfo="none">Obj</literal> is an undocumented module that exposes the
        internals of the OCaml compiler and runtime. It is very useful for examining and
        understanding how your code will behave at runtime but should <emphasis>never</emphasis> be
        used for production code unless you understand the implications. The module bypasses the
        OCaml type system, making memory corruption and segmentation faults possible.</para>

      <para>Some theorem provers such as Coq do output code that uses <literal moreinfo="none">Obj</literal> internally, but the external module signatures never expose it. Unless you
        too have a machine proof of correctness to accompany your use of <literal moreinfo="none">Obj</literal>, stay away from it except for debugging!</para>
    </warning>

    <para>Due to this encoding, there is a limit around 240 variants with
    parameters that applies to each type definition, but the only limit on the
    number of variants without parameters is the size of the native integer
    (either 31 or 63 bits). This limit arises because of the size of the tag
    byte, and that some of the high-numbered tags are reserved.</para>
  </sect1>

  <sect1 id="polymorphic-variants-1">
    <title>Polymorphic Variants</title>

    <para>Polymorphic variants are more flexible than normal variants when
    writing code but are slightly less efficient at runtime. This is because
    there isn't as much static compile-time information available to optimize
    their memory layout.<indexterm class="singular">
        <primary>polymorphic variant types</primary>

        <secondary>memory representation of</secondary>
      </indexterm><indexterm class="singular">
        <primary>runtime memory representation</primary>

        <secondary>polymorphic variants</secondary>
      </indexterm></para>

    <para>A polymorphic variant without any parameters is stored as an unboxed
    integer and so only takes up one word of memory, just like a normal
    variant. This integer value is determined by applying a hash function to
    the <emphasis>name</emphasis> of the variant. The hash function isn't
    exposed directly by the compiler, but the <literal moreinfo="none">type_conv</literal> library from Core provides an
    alternative implementation:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/memory-repr/reprs.topscript">OCaml utop</ulink>
    (part 6)</para>

    <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">Pa_type_conv.hash_variant "Foo" ;;</userinput>
<computeroutput moreinfo="none">- : int = 3505894</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">(Obj.magic (Obj.repr `Foo) : int) ;;</userinput>
<computeroutput moreinfo="none">- : int = 3505894</computeroutput></programlisting>

    <para>The hash function is designed to give the same results on 32-bit and
    64-bit architectures, so the memory representation is stable across
    different CPUs and host types.</para>

    <para>Polymorphic variants use more memory space than normal variants when parameters are
      included in the data type constructors. Normal variants use the tag byte to encode the variant
      value and save the fields for the contents, but this single byte is insufficient to encode the
      hashed value for polymorphic variants. They must allocate a new block (with tag <literal moreinfo="none">0</literal>) and store the value in there instead. Polymorphic variants with
      constructors thus use one word of memory more than normal variant constructors.</para>

    <para>Another inefficiency over normal variants is when a polymorphic variant constructor has
      more than one parameter. Normal variants hold parameters as a single flat block with multiple
      fields for each entry, but polymorphic variants must adopt a more flexible uniform memory
      representation, since they may be reused in a different context across compilation units. They
      allocate a tuple block for the parameters that is pointed to from the argument field of the
      variant. There are thus three additional words for such variants, along with an extra memory
      indirection due to the tuple.</para>

    <para>The extra space usage is generally not significant in a typical
    application, and polymorphic variants offer a great deal more flexibility
    than normal variants. However, if you're writing code that demands high
    performance or must run within tight memory bounds, the runtime layout is
    at least very predictable. The OCaml compiler never switches memory
    representation due to optimization passes. This lets you predict the
    precise runtime layout by referring to these guidelines and your source
    code.</para>
  </sect1>

  <sect1 id="string-values">
    <title>String Values</title>

    <para>Strings are standard OCaml blocks with the header size defining the
    size of the string in machine words. The <literal moreinfo="none">String_tag</literal> (252) is higher than the <literal moreinfo="none">No_scan_tag</literal>, indicating that the contents of the
    block are opaque to the collector. The block contents are the contents of
    the string, with padding bytes to align the block on a word
    boundary.<indexterm class="singular">
        <primary>strings</primary>

        <secondary>memory representation of</secondary>
      </indexterm><indexterm class="singular">
        <primary>runtime memory representation</primary>

        <secondary>string values</secondary>
      </indexterm></para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/memory-repr/string_block.ascii">Diagram</ulink></para>

    <informalfigure>
      <mediaobject>
        <imageobject role="web">
          <imagedata fileref="images/rwoc_2004.png" format="PNG"/>
        </imageobject>
      </mediaobject>
    </informalfigure>

    <para>On a 32-bit machine, the padding is calculated based on the modulo of the string length
      and word size to ensure the result is word-aligned. A 64-bit machine extends the potential
      padding up to 7 bytes instead of 3 (see <xref linkend="chapter_20_table"/>).</para>

    <table id="chapter_20_table">
      <title>String length and padding</title>
      <tgroup cols="2">
        <colspec align="left"/>

        <colspec align="left"/>

        <thead>
          <row>
            <entry>String length mod 4</entry>

            <entry>Padding</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry>0</entry>

            <entry><literal moreinfo="none">00 00 00 03</literal></entry>
          </row>

          <row>
            <entry>1</entry>

            <entry><literal moreinfo="none">00 00 02</literal></entry>
          </row>

          <row>
            <entry>2</entry>

            <entry><literal moreinfo="none">00 01</literal></entry>
          </row>

          <row>
            <entry>3</entry>

            <entry><literal moreinfo="none">00</literal></entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <para>This string representation is a clever way to ensure that the
    contents are always zero-terminated by the padding word and to still
    compute its length efficiently without scanning the whole string. The
    following formula is used:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/memory-repr/string_size_calc.ascii">Diagram</ulink></para>

    <informalfigure>
      <mediaobject>
        <imageobject role="web">
          <imagedata fileref="images/rwoc_2005.png" format="PNG"/>
        </imageobject>
      </mediaobject>
    </informalfigure>

    <para>The guaranteed <literal moreinfo="none">NULL</literal> termination comes in handy when
      passing a string to C, but is not relied upon to compute the length from OCaml code. OCaml
      strings can thus contain <literal moreinfo="none">NULL</literal> bytes at any point within the
      string.</para>

    <para>Care should be taken that any C library functions that receive these buffers can also cope
      with arbitrary bytes within the buffer contents and are not expecting C strings. For instance,
      the C <literal moreinfo="none">memcopy</literal> or <literal moreinfo="none">memmove</literal>
      standard library functions can operate on arbitrary data, but <literal moreinfo="none">strlen</literal> or <literal moreinfo="none">strcpy</literal> both require a <literal moreinfo="none">NULL</literal>-terminated buffer, and neither has a mechanism for encoding a
        <literal moreinfo="none">NULL</literal> value within its contents.</para>
  </sect1>

  <sect1 id="custom-heap-blocks">
    <title>Custom Heap Blocks</title>

    <para>OCaml supports <emphasis>custom</emphasis> heap blocks via a <literal moreinfo="none">Custom_tag</literal> that lets the runtime perform user-defined operations over OCaml
      values. A custom block lives in the OCaml heap like an ordinary block and can be of whatever
      size the user desires. The <literal moreinfo="none">Custom_tag</literal> (255) is higher than
        <literal moreinfo="none">No_scan_tag</literal> and so isn't scanned by the GC.<indexterm class="singular">
        <primary>custom heap blocks</primary>
      </indexterm><indexterm class="singular">
        <primary>runtime memory representation</primary>
        <secondary>custom heap blocks</secondary>
      </indexterm></para>

    <para>The first word of the data within the custom block is a C pointer to a <literal moreinfo="none">struct</literal> of custom operations. The custom block cannot have pointers
      to OCaml blocks and is opaque to the GC:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/memory-repr/custom_ops.c">C</ulink></para>

    <programlisting format="linespecific" language="c">struct custom_operations {
  char *identifier;
  void (*finalize)(value v);
  int (*compare)(value v1, value v2);
  intnat (*hash)(value v);
  void (*serialize)(value v,
                    /*out*/ uintnat * wsize_32 /*size in bytes*/,
                    /*out*/ uintnat * wsize_64 /*size in bytes*/);
  uintnat (*deserialize)(void * dst);
  int (*compare_ext)(value v1, value v2);
};</programlisting>

    <para>The custom operations specify how the runtime should perform polymorphic comparison,
      hashing and binary marshaling. They also optionally contain a <emphasis>finalizer</emphasis>
      that the runtime calls just before the block is garbage-collected. This finalizer has nothing
      to do with ordinary OCaml finalizers (as created by <literal moreinfo="none">Gc.finalize</literal> and explained in <xref linkend="understanding-the-garbage-collector"/>). They are instead used to call C cleanup functions such as <literal moreinfo="none">free</literal>.<indexterm class="singular">
        <primary>finalizers</primary>
        <secondary>for C cleanup functions</secondary>
      </indexterm></para>

    <sect2 id="managing-external-memory-with-bigarray">
      <title>Managing External Memory with Bigarray</title>

      <para>A common use of custom blocks is to manage external system memory
      directly from within OCaml. The Bigarray interface was originally
      intended to exchange data with Fortran code, and maps a block of system
      memory as a multidimensional array that can be accessed from OCaml.
      Bigarray operations work directly on the external memory without
      requiring it to be copied into the OCaml heap (which is a potentially
      expensive operation for large arrays).<indexterm class="singular">
          <primary>Fortran libraries</primary>
        </indexterm><indexterm class="singular">
          <primary>linear algebra</primary>
        </indexterm><indexterm class="singular">
          <primary>LAPACK mathematical library</primary>
        </indexterm><indexterm class="singular">
          <primary>BLAS mathematical library</primary>
        </indexterm><indexterm class="singular">
          <primary>Lacaml library</primary>
        </indexterm><indexterm class="singular">
          <primary>Bigstring module</primary>
        </indexterm><indexterm class="singular">
          <primary>Iobuf module</primary>
        </indexterm><indexterm class="singular">
          <primary>external memory</primary>
        </indexterm><indexterm class="singular">
          <primary>memory</primary>

          <secondary>managing external</secondary>
        </indexterm><indexterm class="singular">
          <primary>bigarrays</primary>
        </indexterm></para>

      <para>Bigarray sees a lot of use beyond just scientific computing, and
      several Core libraries use it for general-purpose I/O:</para>

      <variablelist>
        <varlistentry>
          <term><literal moreinfo="none">Iobuf</literal></term>

          <listitem>
            <para>The <literal moreinfo="none">Iobuf</literal> module maps I/O
            buffers as a one-dimensional array of bytes. It provides a sliding
            window interface that lets consumer processes read from the buffer
            while it's being filled by producers. This lets OCaml use I/O
            buffers that have been externally allocated by the operating
            system without any extra data copying.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal moreinfo="none">Bigstring</literal></term>

          <listitem>
            <para>The <literal moreinfo="none">Bigstring</literal> module
            provides a <literal moreinfo="none">String</literal>-like
            interface that uses <literal moreinfo="none">Bigarray</literal>
            internally. The <literal moreinfo="none">Bigbuffer</literal>
            collects these into extensible string buffers that can operate
            entirely on external system memory.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>The <ulink url="https://bitbucket.org/mmottl/lacaml">OCaml</ulink> library isn't
      part of Core but provides the recommended interfaces to the widely used
      BLAS and LAPACK mathematical Fortran libraries. These allow developers
      to write high-performance numerical code for applications that require
      linear algebra. It supports large vectors and matrices, but with static
      typing safety of OCaml to make it easier to write safe
      algorithms.<indexterm class="endofrange" startref="MAPocaml"/><indexterm class="endofrange" startref="VALmemory"/></para>
    </sect2>
  </sect1>
</chapter>

    <chapter id="understanding-the-garbage-collector">
  <title>Understanding the Garbage Collector</title>

  <para>We've described the runtime format of individual OCaml variables earlier, in <xref linkend="memory-representation-of-values"/>. When you execute your program, OCaml manages the
    lifecycle of these variables by regularly scanning allocated values and freeing them when
    they're no longer needed. This in turn means that your applications don't need to manually
    implement memory management, and it greatly reduces the likelihood of memory leaks creeping into
    your code.<indexterm class="singular">
      <primary>memory</primary>
      <secondary>memory management</secondary>
    </indexterm></para>

  <para>The OCaml runtime is a C library that provides routines that can be
  called from running OCaml programs. The runtime manages a
  <emphasis>heap</emphasis>, which is a collection of memory regions that it
  obtains from the operating system. The runtime uses this memory to hold
  <emphasis>heap blocks</emphasis> that it fills up with OCaml values in
  response to allocation requests by the OCaml program.<indexterm class="singular">
      <primary>values</primary>

      <secondary>allocation requests and</secondary>
    </indexterm><indexterm class="singular">
      <primary>heaps</primary>

      <secondary>heap blocks</secondary>
    </indexterm><indexterm class="singular">
      <primary>heaps</primary>

      <secondary>definition of</secondary>
    </indexterm></para>

  <sect1 id="mark-and-sweep-garbage-collection">
    <title>Mark and Sweep Garbage Collection</title>

    <para>When there isn't enough memory available to satisfy an allocation request from the pool of
      allocated heap blocks, the runtime system invokes the garbage collector (GC). An OCaml program
      can't explicitly free a value when it is done with it. Instead, the GC regularly determines
      which values are <emphasis>live</emphasis> and which values are <emphasis>dead</emphasis>,
      i.e., no longer in use. Dead values are collected and their memory made available for reuse by
      the application.<indexterm class="singular">
        <primary>mark and sweep garbage collection</primary>
      </indexterm><indexterm class="singular">
        <primary>garbage collection</primary>
        <secondary>mark and sweep collection</secondary>
      </indexterm></para>

    <para>The GC doesn't keep constant track of values as they are allocated and used. Instead, it
      regularly scans them by starting from a set of <emphasis>root</emphasis> values that the
      application always has access to (such as the stack). The GC maintains a directed graph in
      which heap blocks are nodes, and there is an edge from heap block <literal moreinfo="none">b1</literal> to heap block <literal moreinfo="none">b2</literal> if some field of <literal moreinfo="none">b1</literal> is a pointer to <literal moreinfo="none">b2</literal>.</para>

    <para>All blocks reachable from the roots by following edges in the graph
    must be retained, and unreachable blocks can be reused by the application.
    The algorithm used by OCaml to perform this heap traversal is commonly
    known as <emphasis>mark and sweep</emphasis> garbage collection, and we'll
    explain it further now.</para>
  </sect1>

  <sect1 id="generational-garbage-collection">
    <title>Generational Garbage Collection</title>

    <para>The usual OCaml programming style involves allocating many small variables that are used
      for a short period of time and then never accessed again. OCaml takes advantage of this fact
      to improve performance by using a <emphasis>generational</emphasis> GC.<indexterm class="singular">
        <primary>generational garbage collection</primary>
      </indexterm><indexterm class="singular">
        <primary>garbage collection</primary>
        <secondary>generational collection</secondary>
      </indexterm></para>

    <para>A generational GC maintains separate memory regions to hold blocks based on how long the
      blocks have been live. OCaml's heap is split into two such regions:<indexterm class="singular">
        <primary>heaps</primary>
        <secondary>regions of</secondary>
      </indexterm></para>

    <itemizedlist>
      <listitem>
        <para>A small, fixed-size <emphasis>minor heap</emphasis> where most
        blocks are initially allocated</para>
      </listitem>

      <listitem>
        <para>A larger, variable-size <emphasis>major heap</emphasis> for blocks that have been live
          longer</para>
      </listitem>
    </itemizedlist>

    <para>A typical functional programming style means that young blocks tend
    to die young and old blocks tend to stay around for longer than young
    ones. This is often referred to as the <emphasis>generational
    hypothesis</emphasis>.<indexterm class="singular">
        <primary>generational hypothesis</primary>
      </indexterm></para>

    <para>OCaml uses different memory layouts and garbage-collection algorithms for the major and
      minor heaps to account for this generational difference. We'll explain how they differ in more
      detail next.<indexterm class="singular">
        <primary>OCAMLRUNPARAM</primary>
      </indexterm><indexterm class="singular">
        <primary>Gc module</primary>
        <seealso>garbage collection</seealso>
      </indexterm></para>

    <sidebar>
      <title>The Gc Module and OCAMLRUNPARAM</title>

      <para>OCaml provides several mechanisms to query and alter the behavior
      of the runtime system. The <literal moreinfo="none">Gc</literal> module
      provides this functionality from within OCaml code, and we'll frequently
      refer to it in the rest of the chapter. As with several other standard
      library modules, Core alters the <literal moreinfo="none">Gc</literal>
      interface from the standard OCaml library. We'll assume that you've
      opened <literal moreinfo="none">Core.Std</literal> in our
      explanations.</para>

      <para>You can also control the behavior of OCaml programs by setting the <literal moreinfo="none">OCAMLRUNPARAM</literal> environment variable before launching your
        application. This lets you set GC parameters without recompiling, for example to benchmark
        the effects of different settings. The format of <literal moreinfo="none">OCAMLRUNPARAM</literal> is documented in the <ulink url="http://caml.inria.fr/pub/docs/manual-ocaml/manual024.html">OCaml
        manual</ulink>.</para>
    </sidebar>
  </sect1>

  <sect1 id="the-fast-minor-heap">
    <title>The Fast Minor Heap</title>

    <para>The minor heap is where most of your short-lived values are held. It
    consists of one contiguous chunk of virtual memory containing a sequence
    of OCaml blocks. If there is space, allocating a new block is a fast,
    constant-time operation that requires just a couple of CPU
    instructions.<indexterm class="singular">
        <primary>heaps</primary>

        <secondary>minor heaps</secondary>
      </indexterm><indexterm class="singular">
        <primary>minor heaps</primary>

        <secondary>garbage collection in</secondary>
      </indexterm><indexterm class="singular">
        <primary>copying collection</primary>
      </indexterm><indexterm class="singular">
        <primary>garbage collection</primary>

        <secondary sortas="short">of short-lived values</secondary>
      </indexterm></para>

    <para>To garbage-collect the minor heap, OCaml uses <emphasis>copying collection</emphasis> to
      move all live blocks in the minor heap to the major heap. This takes work proportional to the
      number of live blocks in the minor heap, which is typically small according to the
      generational hypothesis. The minor collection <emphasis>stops the world</emphasis> (that it,
      halts the application) while it runs, which is why it's so important that it complete quickly
      to let the application resume running with minimal interruption.</para>

    <sect2 id="allocating-on-the-minor-heap">
      <title>Allocating on the Minor Heap</title>

      <para>The minor heap is a contiguous chunk of virtual memory that is usually a few megabytes
        in size so that it can be scanned quickly.<indexterm class="singular">
          <primary>minor heaps</primary>
          <secondary>allocating on</secondary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/gc/minor_heap.ascii">Diagram</ulink></para>
      

      <informalfigure> 
        <mediaobject>
          <imageobject role="web">
            <imagedata fileref="images/rwoc_2101.png" format="PNG"/>
          </imageobject>
        </mediaobject>
      </informalfigure>

      <para>The runtime stores the boundaries of the minor heap in two
      pointers that delimit the start and end of the heap region (<literal moreinfo="none">caml_young_start</literal> and <literal moreinfo="none">caml_young_end</literal>, but we will drop the <literal moreinfo="none">caml_young</literal> prefix for brevity). The <literal moreinfo="none">base</literal> is the memory address returned by the
      system <literal moreinfo="none">malloc</literal>, and <literal moreinfo="none">start</literal> is aligned against the next nearest word
      boundary from <literal moreinfo="none">base</literal> to make it easier
      to store OCaml values.</para>

      <para>In a fresh minor heap, the <literal moreinfo="none">limit</literal> equals the <literal moreinfo="none">start</literal>, and the current <literal moreinfo="none">ptr</literal> will equal the <literal moreinfo="none">end</literal>. <literal moreinfo="none">ptr</literal>
      decreases as blocks are allocated until it reaches <literal moreinfo="none">limit</literal>, at which point a minor garbage
      collection is triggered.</para>

      <para>Allocating a block in the minor heap just requires <literal moreinfo="none">ptr</literal> to be decremented by the size of the block (including the header) and a
        check that it's not less than <literal moreinfo="none">limit</literal>. If there isn't
        enough space left for the block without decrementing past <literal moreinfo="none">limit</literal>, a minor garbage collection is triggered. This is a very fast check (with
        no branching) on most CPU architectures.</para>

      <para>You may wonder why <literal moreinfo="none">limit</literal> is
      required at all, since it always seems to equal <literal moreinfo="none">start</literal>. It's because the easiest way for the
      runtime to schedule a minor heap collection is by setting <literal moreinfo="none">limit</literal> to equal <literal moreinfo="none">end</literal>. The next allocation will never have
      enough space after this is done and will always trigger a garbage
      collection. There are various internal reasons for such early
      collections, such as handling pending UNIX signals, and they don't
      ordinarily matter for application code.<indexterm class="singular">
          <primary>minor heaps</primary>

          <secondary>setting size of</secondary>
        </indexterm></para>

      <note>
        <title>Setting the Size of the Minor Heap</title>

        <para>The default minor heap size in OCaml is normally 2 MB on 64-bit platforms, but this is
          increased to 8 MB if you use Core (which generally prefers default settings that improve
          performance, but at the cost of a bigger memory profile). This setting can be overridden
          via the <literal moreinfo="none">s=&lt;words&gt;</literal> argument to <literal moreinfo="none">OCAMLRUNPARAM</literal>. You can change it after the program has started
          by calling the <literal moreinfo="none">Gc.set</literal> function:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/gc/tune.topscript">OCaml utop</ulink></para>

        <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let c = Gc.get () ;;</userinput>
<computeroutput moreinfo="none">val c : Gc.control =</computeroutput>
<computeroutput moreinfo="none">  {Core.Std.Gc.Control.minor_heap_size = 1000000;</computeroutput>
<computeroutput moreinfo="none">   major_heap_increment = 1000448; space_overhead = 100; verbose = 0;</computeroutput>
<computeroutput moreinfo="none">   max_overhead = 500; stack_limit = 1048576; allocation_policy = 0}</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Gc.tune ~minor_heap_size:(262144 * 2) () ;;</userinput>
<computeroutput moreinfo="none">- : unit = ()</computeroutput></programlisting>

        <para>Changing the GC size dynamically will trigger an immediate minor
        heap collection. Note that Core increases the default minor heap size
        from the standard OCaml installation quite significantly, and you'll
        want to reduce this if running in very memory-constrained
        environments.</para>
      </note>
    </sect2>
  </sect1>

  <sect1 id="the-long-lived-major-heap">
    <title>The Long-Lived Major Heap</title>

    <para>The major heap is where the bulk of the longer-lived and larger
    values in your program are stored. It consists of any number of
    noncontiguous chunks of virtual memory, each containing live blocks
    interspersed with regions of free memory. The runtime system maintains a
    free-list data structure that indexes all the free memory that it has
    allocated, and uses it to satisfy allocation requests for OCaml
    blocks.<indexterm class="singular">
        <primary>garbage collection</primary>

        <secondary>mark and sweep collection</secondary>
      </indexterm><indexterm class="singular">
        <primary>mark and sweep garbage collection</primary>
      </indexterm><indexterm class="singular">
        <primary>major heaps</primary>

        <secondary>garbage collection in</secondary>
      </indexterm><indexterm class="startofrange" id="Hmh">
        <primary>heaps</primary>

        <secondary>major heaps</secondary>
      </indexterm><indexterm class="singular">
        <primary>garbage collection</primary>

        <secondary sortas="longer-lived">of longer-lived values</secondary>
      </indexterm></para>

    <para>The major heap is typically much larger than the minor heap and can
    scale to gigabytes in size. It is cleaned via a mark-and-sweep garbage
    collection algorithm that operates in several phases:</para>

    <itemizedlist>
      <listitem>
        <para>The <emphasis>mark</emphasis> phase scans the block graph and
        marks all live blocks by setting a bit in the tag of the block header
        (known as the <emphasis>color</emphasis> tag).</para>
      </listitem>

      <listitem>
        <para>The <emphasis>sweep</emphasis> phase sequentially scans the heap
        chunks and identifies dead blocks that weren't marked earlier.</para>
      </listitem>

      <listitem>
        <para>The <emphasis>compact</emphasis> phase relocates live blocks into a freshly allocated
          heap to eliminate gaps in the free list. This prevents the fragmentation of heap blocks in
          long-running programs and normally occurs much less frequently than the mark and sweep
            <phrase role="keep-together">phases</phrase>.</para>
      </listitem>
    </itemizedlist>

    <para>A major garbage collection must also stop the world to ensure that blocks can be moved
      around without this being observed by the live application. The mark-and-sweep phases run
      incrementally over slices of the heap to avoid pausing the application for long <phrase role="keep-together">periods</phrase> of time, and also precede each slice with a fast minor
      collection. Only the compaction phase touches all the memory in one go, and is a relatively
      rare operation.</para>

    <sect2 id="allocating-on-the-major-heap">
      <title>Allocating on the Major Heap</title>

      <para>The major heap consists of a singly linked list of contiguous memory chunks sorted in
        increasing order of virtual address. Each chunk is a single memory region allocated via
          <emphasis>malloc(3)</emphasis> and consists of a header and data area which contains OCaml
        heap chunks. A heap chunk header contains:<indexterm class="singular">
          <primary>malloc(3)</primary>
        </indexterm><indexterm class="singular">
          <primary>major heaps</primary>
          <secondary>allocating on</secondary>
        </indexterm></para>

      <itemizedlist>
        <listitem>
          <para>The <emphasis>malloc</emphasis>ed virtual address of the memory region containing
            the chunk</para>
        </listitem>

        <listitem>
          <para>The size in bytes of the data area</para>
        </listitem>

        <listitem>
          <para>An allocation size in bytes used during heap compaction to
          merge small blocks to defragment the heap</para>
        </listitem>

        <listitem>
          <para>A link to the next heap chunk in the list</para>
        </listitem>
      </itemizedlist>

      <para>Each chunk's data area starts on a page boundary, and its size is a multiple of the page
        size (4 KB). It contains a contiguous sequence of heap blocks that can be as small as one or
        two 4 KB pages, but are usually allocated in 1 MB chunks (or 512 KB on 32-bit
          architectures).<indexterm class="singular">
          <primary>major heaps</primary>
          <secondary>controlling growth of</secondary>
        </indexterm></para>

      <note>
        <title>Controlling Major Heap Growth</title>

        <para>The <literal moreinfo="none">Gc</literal> module uses the
        <literal moreinfo="none">major_heap_increment</literal> value to
        control the major heap growth. This defines the number of words to add
        to the major heap per expansion and is the only memory allocation
        operation that the operating system observes from the OCaml runtime
        after initial startup (since the minor is fixed in size).</para>

        <para>If you anticipate allocating some large OCaml values or many small values in one go,
          then setting the heap increment to a larger value will improve performance by reducing the
          amount of heap resizing required in order to satisfy the allocation requests. A small
          increment may result in lots of smaller heap chunks spread across different regions of
          virtual memory that require more housekeeping in the OCaml runtime to keep track of
          them:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/gc/tune.topscript">OCaml utop</ulink>
        (part 1)</para>

        <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">Gc.tune ~major_heap_increment:(1000448 * 4) () ;;</userinput>
<computeroutput moreinfo="none">- : unit = ()</computeroutput></programlisting>
      </note>

      <para>Allocating an OCaml value on the major heap first checks the free
      list of blocks for a suitable region to place it. If there isn't enough
      room on the free list, the runtime expands the major heap by allocating
      a fresh heap chunk that will be large enough. That chunk is then added
      to the free list, and the free list is checked again (and this time will
      definitely succeed).</para>

      <para>Remember that most allocations to the major heap will go via the
      minor heap and only be promoted if they are still used by the program
      after a minor collection. The one exception to this is for values larger
      than 256 words (that is, 2 KB on 64-bit platforms). These will be
      allocated directly on the major heap, since an allocation on the minor
      heap would likely trigger an immediate collection and copy it to the
      major heap anyway.</para>
    </sect2>

    <sect2 id="memory-allocation-strategies">
      <title>Memory Allocation Strategies</title>

      <para>The major heap does its best to manage memory allocation as
      efficiently as possible and relies on heap compaction to ensure that
      memory stays contiguous and unfragmented. The default allocation policy
      normally works fine for most applications, but it's worth bearing in
      mind that there are other options, too.<indexterm class="singular">
          <primary>memory</primary>

          <secondary>major heap allocation strategies</secondary>
        </indexterm><indexterm class="singular">
          <primary>major heaps</primary>

          <secondary>memory allocation strategies</secondary>
        </indexterm></para>

      <para>The free list of blocks is always checked first when allocating a
      new block in the major heap. The default free list search is called
      <emphasis>next-fit allocation</emphasis>, with an alternative
      <emphasis>first-fit</emphasis> algorithm also available.<indexterm class="singular">
          <primary>first-fit allocation</primary>
        </indexterm><indexterm class="singular">
          <primary>next-fit allocation</primary>
        </indexterm></para>

      <sect3 id="next-fit-allocation">
        <title>Next-fit allocation</title>

        <para>Next-fit allocation keeps a pointer to the block in the free list that was most
          recently used to satisfy a request. When a new request comes in, the allocator searches
          from the next block to the end of the free list, and then from the beginning of the free
          list up to that block.</para>

        <para>Next-fit allocation is the default allocation strategy. It's
        quite a cheap allocation mechanism, since the same heap chunk can be
        reused across allocation requests until it runs out. This in turn
        means that there is good memory locality to use CPU caches
        better.</para>
      </sect3>

      <sect3 id="first-fit-allocation">
        <title>First-fit allocation</title>

        <para>If your program allocates values of many varied sizes, you may sometimes find that
          your free list becomes fragmented. In this situation, the GC is forced to perform an
          expensive compaction despite there being free chunks, since none of the chunks alone are
          big enough to satisfy the request.</para>

        <para>First-fit allocation focuses on reducing memory fragmentation
        (and hence the number of compactions), but at the expense of slower
        memory allocation. Every allocation scans the free list from the
        beginning for a suitable free chunk, instead of reusing the most
        recent heap chunk as the next-fit allocator does.<indexterm class="singular">
            <primary>memory</primary>

            <secondary>reducing fragmentation of</secondary>
          </indexterm></para>

        <para>For some workloads that need more real-time behavior under load, the reduction in the
          frequency of heap compaction will outweigh the extra allocation cost.</para>

        <note>
          <title>Controlling the Heap Allocation Policy</title>

          <para>You can set the heap allocation policy via the <literal moreinfo="none">Gc.allocation_policy</literal> field. A value of
          <literal moreinfo="none">0</literal> (the default) sets it to
          next-fit, and <literal moreinfo="none">1</literal> to the first-fit
          allocator.</para>

          <para>The same behavior can be controlled at runtime by setting
          <literal moreinfo="none">a=0</literal> or <literal moreinfo="none">a=1</literal> in <literal moreinfo="none">OCAMLRUNPARAM</literal>.</para>
        </note>
      </sect3>
    </sect2>

    <sect2 id="marking-and-scanning-the-heap">
      <title>Marking and Scanning the Heap</title>

      <para>The marking process can take a long time to run over the complete
      major heap and has to pause the main application while it's active. It
      therefore runs incrementally by marking the heap in
      <emphasis>slices</emphasis>. Each value in the heap has a 2-bit
      <emphasis>color</emphasis> field in its header that is used to store
      information about whether the value has been marked so that the GC can
      resume easily between slices.<indexterm class="singular">
          <primary>major heaps</primary>

          <secondary>marking and scanning</secondary>
        </indexterm></para>

      <table><title>Tag color statuses</title>
        <tgroup cols="2">
          <colspec align="left"/>

          <colspec align="left"/>

          <thead>
            <row>
              <entry>Tag color</entry>

              <entry>Block status</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>Blue</entry>

              <entry>On the free list and not currently in use</entry>
            </row>

            <row>
              <entry>White (during marking)</entry>

              <entry>Not reached yet, but possibly reachable</entry>
            </row>

            <row>
              <entry>White (during sweeping)</entry>

              <entry>Unreachable and can be freed</entry>
            </row>

            <row>
              <entry>Gray</entry>

              <entry>Reachable, but its fields have not been scanned</entry>
            </row>

            <row>
              <entry>Black</entry>

              <entry>Reachable, and its fields have been scanned</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>The color tags in the value headers store most of the state of the
      marking process, allowing it to be paused and resumed later. The GC and
      application alternate between marking a slice of the major heap and
      actually getting on with executing the program logic. The OCaml runtime
      calculates a sensible value for the size of each major heap slice based
      on the rate of allocation and available memory.</para>

      <para>The marking process starts with a set of <emphasis>root</emphasis>
      values that are always live (such as the application stack). All values
      on the heap are initially marked as white values that are possibly
      reachable but haven't been scanned yet. It recursively follows all the
      fields in the roots via a depth-first search, and pushes newly
      encountered white blocks onto an intermediate stack of <emphasis>gray
      values</emphasis> while it follows their fields. When a gray value's
      fields have all been followed, it is popped off the stack and colored
      black.<indexterm class="singular">
          <primary>root values</primary>
        </indexterm><indexterm class="singular">
          <primary>gray values</primary>
        </indexterm></para>

      <para>This process is repeated until the gray value stack is empty and
      there are no further values to mark. There's one important edge case in
      this process, though. The gray value stack can only grow to a certain
      size, after which the GC can no longer recurse into intermediate values
      since it has nowhere to store them while it follows their fields. If
      this happens, the heap is marked as <emphasis>impure</emphasis> and a
      more expensive check is initiated once the existing gray values have
      been processed.<indexterm class="singular">
          <primary>impure heaps</primary>
        </indexterm></para>

      <para>To mark an impure heap, the GC first marks it as pure and walks
      through the entire heap block-by-block in increasing order of memory
      address. If it finds a gray block, it adds it to the gray list and
      recursively marks it using the usual strategy for a pure heap. Once the
      scan of the complete heap is finished, the mark phase checks again
      whether the heap has again become impure and repeats the scan until it
      is pure again. These full-heap scans will continue until a successful
      scan completes without overflowing the gray list.<indexterm class="singular">
          <primary>major heaps</primary>

          <secondary>controlling collections</secondary>
        </indexterm></para>

      <note>
        <title>Controlling Major Heap Collections</title>

        <para>You can trigger a single slice of the major GC via the <literal moreinfo="none">major_slice</literal> call. This performs a minor
        collection first, and then a single slice. The size of the slice is
        normally automatically computed by the GC to an appropriate value and
        returns this value so that you can modify it in future calls if
        necessary:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/gc/tune.topscript">OCaml utop</ulink>
        (part 2)</para>

        <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">Gc.major_slice 0 ;;</userinput>
<computeroutput moreinfo="none">- : int = 260440</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Gc.full_major () ;;</userinput>
<computeroutput moreinfo="none">- : unit = ()</computeroutput></programlisting>

        <para>The <literal moreinfo="none">space_overhead</literal> setting
        controls how aggressive the GC is about setting the slice size to a
        large size. This represents the proportion of memory used for live
        data that will be "wasted" because the GC doesn't immediately collect
        unreachable blocks. Core defaults this to <literal moreinfo="none">100</literal> to reflect a typical system that isn't
        overly memory-constrained. Set this even higher if you have lots of
        memory, or lower to cause the GC to work harder and collect blocks
        faster at the expense of using more CPU time.</para>
      </note>
    </sect2>

    <sect2 id="heap-compaction">
      <title>Heap Compaction</title>

      <para>After a certain number of major GC cycles have completed, the heap
      may begin to be fragmented due to values being deallocated out of order
      from how they were allocated. This makes it harder for the GC to find a
      contiguous block of memory for fresh allocations, which in turn would
      require the heap to be grown unnecessarily.<indexterm class="singular">
          <primary>memory</primary>

          <secondary>reducing fragmentation of</secondary>
        </indexterm><indexterm class="singular">
          <primary>compaction</primary>
        </indexterm><indexterm class="singular">
          <primary>major heaps</primary>

          <secondary>heap compaction</secondary>
        </indexterm></para>

      <para>The heap compaction cycle avoids this by relocating all the values in the major heap
        into a fresh heap that places them all contiguously in memory again. A naive implementation
        of the algorithm would require extra memory to store the new heap, but OCaml performs the
        compaction in place within the existing heap.</para>

      <note>
        <title>Controlling Frequency of Compactions</title>

        <para>The <literal moreinfo="none">max_overhead</literal> setting in
        the <literal moreinfo="none">Gc</literal> module defines the
        connection between free memory and allocated memory after which
        compaction is activated.</para>

        <para>A value of <literal moreinfo="none">0</literal> triggers a
        compaction after every major garbage collection cycle, whereas the
        maximum value of <literal moreinfo="none">1000000</literal> disables
        heap compaction completely. The default settings should be fine unless
        you have unusual allocation patterns that are causing a
        higher-than-usual rate of compactions:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/gc/tune.topscript">OCaml utop</ulink>
        (part 3)</para>

        <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">Gc.tune ~max_overhead:0 () ;;</userinput>
<computeroutput moreinfo="none">- : unit = ()</computeroutput></programlisting>
      </note>
    </sect2>

    <sect2 id="inter-generational-pointers">
      <title>Intergenerational Pointers</title>

      <para>One complexity of generational collection arises from the fact
      that minor heap sweeps are much more frequent than major heap
      collections. In order to know which blocks in the minor heap are live,
      the collector must track which minor-heap blocks are directly pointed to
      by major-heap blocks. Without this information, each minor collection
      would also require scanning the much larger major heap.<indexterm class="singular">
          <primary>pointers</primary>

          <secondary>intergenerational pointers</secondary>
        </indexterm><indexterm class="singular">
          <primary>intergenerational pointers</primary>
        </indexterm><indexterm class="singular">
          <primary>major heaps</primary>

          <secondary>intergenerational pointers in</secondary>
        </indexterm></para>

      <para>OCaml maintains a set of such <emphasis>intergenerational
      pointers</emphasis> to avoid this dependency between a major and minor
      heap collection. The compiler introduces a write barrier to update this
      so-called <emphasis>remembered set</emphasis> whenever a major-heap
      block is modified to point at a minor-heap block.<indexterm class="singular">
          <primary>write barriers</primary>
        </indexterm><indexterm class="singular">
          <primary>remembered sets</primary>
        </indexterm></para>

      <sect3 id="the-mutable-write-barrier">
        <title>The mutable write barrier</title>

        <para>The write barrier can have profound implications for the
        structure of your code. It's one of the reasons using immutable data
        structures and allocating a fresh copy with changes can sometimes be
        faster than mutating a record in place.</para>

        <para>The OCaml compiler keeps track of any mutable types and adds a call to the runtime
            <literal moreinfo="none">caml_modify</literal> function before making the change. This
          checks the location of the target write and the value it's being changed to, and ensures
          that the remembered set is consistent. Although the write barrier is reasonably efficient,
          it can sometimes be slower than simply allocating a fresh value on the fast minor heap and
          doing some extra minor collections.</para>

        <para>Let's see this for ourselves with a simple test program. You'll
        need to install the Core benchmarking suite via <literal moreinfo="none">opam install core_bench</literal> before you compile
        this code:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/gc/barrier_bench.ml">OCaml</ulink></para>

        <programlisting format="linespecific" language="ocaml">open Core.Std
open Core_bench.Std

type t1 = { mutable iters1: int; mutable count1: float }
type t2 = { iters2: int; count2: float }

let rec test_mutable t1 =
  match t1.iters1 with
  |0 -&gt; ()
  |_ -&gt;
    t1.iters1 &lt;- t1.iters1 - 1;
    t1.count1 &lt;- t1.count1 +. 1.0;
    test_mutable t1

let rec test_immutable t2 =
  match t2.iters2 with
  |0 -&gt; ()
  |n -&gt;
    let iters2 = n - 1 in
    let count2 = t2.count2 +. 1.0 in
    test_immutable { iters2; count2 }

let () =
  let iters = 1000000 in
  let tests = [
    Bench.Test.create ~name:"mutable" 
      (fun () -&gt; test_mutable { iters1=iters; count1=0.0 });
    Bench.Test.create ~name:"immutable"
      (fun () -&gt; test_immutable { iters2=iters; count2=0.0 })
  ] in
  Bench.make_command tests |&gt; Command.run</programlisting>

        <para>This program defines a type <literal moreinfo="none">t1</literal> that is mutable and <literal moreinfo="none">t2</literal> that is immutable. The benchmark loop
        iterates over both fields and increments a counter. Compile and
        execute this with some extra options to show the amount of garbage
        collection occurring:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/gc/run_barrier_bench.out">Terminal</ulink></para>

        <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">corebuild -pkg core_bench barrier_bench.native</userinput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">./barrier_bench.native -ascii name alloc</userinput>
<computeroutput moreinfo="none">Estimated testing time 20s (change using -quota SECS).</computeroutput>
<computeroutput moreinfo="none">                                                                   </computeroutput>
<computeroutput moreinfo="none">  Name        Time (ns)       Minor   Major   Promoted   % of max  </computeroutput>
<computeroutput moreinfo="none"> ----------- ----------- ----------- ------- ---------- ---------- </computeroutput>
<computeroutput moreinfo="none">  mutable     6_304_612   2_000_004    9.05       9.05     100.00  </computeroutput>
<computeroutput moreinfo="none">  immutable   4_775_718   5_000_005    0.03       0.03      75.75  </computeroutput>
<computeroutput moreinfo="none">                                                                   </computeroutput></programlisting>

        <para>There is a stark space/time trade-off here. The mutable version takes significantly
          longer to complete than the immutable one but allocates many fewer minor-heap words than
          the immutable version. Minor allocation in OCaml is very fast, and so it is often better
          to use immutable data structures in preference to the more conventional mutable versions.
          On the other hand, if you only rarely mutate a value, it can be faster to take the
          write-barrier hit and not allocate at all.</para>

        <para>The only way to know for sure is to benchmark your program under real-world scenarios
          using <literal moreinfo="none">Core_bench</literal> and experiment with the trade-offs.
          The command-line benchmark binaries have a number of useful options that affect garbage
          collection behavior:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/gc/show_barrier_bench_help.out">Terminal</ulink></para>

        <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">./barrier_bench.native -help</userinput>
<computeroutput moreinfo="none">Benchmark for mutable, immutable</computeroutput>
<computeroutput moreinfo="none"> </computeroutput>
<computeroutput moreinfo="none">  barrier_bench.native [COLUMN ...]</computeroutput>
<computeroutput moreinfo="none"> </computeroutput>
<computeroutput moreinfo="none">Columns that can be specified are:</computeroutput>
<computeroutput moreinfo="none">	name       - Name of the test.</computeroutput>
<computeroutput moreinfo="none">	cycles     - Number of CPU cycles (RDTSC) taken.</computeroutput>
<computeroutput moreinfo="none">	cycles-err - 95% confidence interval and R^2 error for cycles.</computeroutput>
<computeroutput moreinfo="none">	~cycles    - Cycles taken excluding major GC costs.</computeroutput>
<computeroutput moreinfo="none">	time       - Number of nano secs taken.</computeroutput>
<computeroutput moreinfo="none">	time-err   - 95% confidence interval and R^2 error for time.</computeroutput>
<computeroutput moreinfo="none">	~time      - Time (ns) taken excluding major GC costs.</computeroutput>
<computeroutput moreinfo="none">	alloc      - Allocation of major, minor and promoted words.</computeroutput>
<computeroutput moreinfo="none">	gc         - Show major and minor collections per 1000 runs.</computeroutput>
<computeroutput moreinfo="none">	percentage - Relative execution time as a percentage.</computeroutput>
<computeroutput moreinfo="none">	speedup    - Relative execution cost as a speedup.</computeroutput>
<computeroutput moreinfo="none">	samples    - Number of samples collected for profiling.</computeroutput>
<computeroutput moreinfo="none"> </computeroutput>
<computeroutput moreinfo="none">R^2 error indicates how noisy the benchmark data is. A value of</computeroutput>
<computeroutput moreinfo="none">1.0 means the amortized cost of benchmark is almost exactly predicated</computeroutput>
<computeroutput moreinfo="none">and 0.0 means the reported values are not reliable at all.</computeroutput>
<computeroutput moreinfo="none">Also see: http://en.wikipedia.org/wiki/Coefficient_of_determination</computeroutput>
<computeroutput moreinfo="none"> </computeroutput>
<computeroutput moreinfo="none">Major and Minor GC stats indicate how many collections happen per 1000</computeroutput>
<computeroutput moreinfo="none">runs of the benchmarked function.</computeroutput>
<computeroutput moreinfo="none"> </computeroutput>
<computeroutput moreinfo="none">The following columns will be displayed by default:</computeroutput>
<computeroutput moreinfo="none">	+name time percentage</computeroutput>
<computeroutput moreinfo="none"> </computeroutput>
<computeroutput moreinfo="none">To specify that a column should be displayed only if it has a non-trivial value,</computeroutput>
<computeroutput moreinfo="none">prefix the column name with a '+'.</computeroutput>
<computeroutput moreinfo="none"> </computeroutput>
<computeroutput moreinfo="none">=== flags ===</computeroutput>
<computeroutput moreinfo="none"> </computeroutput>
<computeroutput moreinfo="none">  [-ascii]             Display data in simple ascii based tables.</computeroutput>
<computeroutput moreinfo="none">  [-clear-columns]     Don't display default columns. Only show user specified</computeroutput>
<computeroutput moreinfo="none">                       ones.</computeroutput>
<computeroutput moreinfo="none">  [-display STYLE]     Table style (short, tall, line, blank or column). Default</computeroutput>
<computeroutput moreinfo="none">                       short.</computeroutput>
<computeroutput moreinfo="none">  [-geometric SCALE]   Use geometric sampling. (default 1.01)</computeroutput>
<computeroutput moreinfo="none">  [-linear INCREMENT]  Use linear sampling to explore number of runs, example 1.</computeroutput>
<computeroutput moreinfo="none">  [-no-compactions]    Disable GC compactions.</computeroutput>
<computeroutput moreinfo="none">  [-quota SECS]        Time quota allowed per test (default 10s).</computeroutput>
<computeroutput moreinfo="none">  [-save]              Save benchmark data to &lt;test name&gt;.txt files.</computeroutput>
<computeroutput moreinfo="none">  [-stabilize-gc]      Stabilize GC between each sample capture.</computeroutput>
<computeroutput moreinfo="none">  [-v]                 High verbosity level.</computeroutput>
<computeroutput moreinfo="none">  [-width WIDTH]       width limit on column display (default 150).</computeroutput>
<computeroutput moreinfo="none">  [-build-info]        print info about this build and exit</computeroutput>
<computeroutput moreinfo="none">  [-version]           print the version of this build and exit</computeroutput>
<computeroutput moreinfo="none">  [-help]              print this help text and exit</computeroutput>
<computeroutput moreinfo="none">                       (alias: -?)</computeroutput>
<computeroutput moreinfo="none"> </computeroutput></programlisting>

        <para>The <literal moreinfo="none">-no-compactions</literal> and <literal moreinfo="none">-stabilize-gc</literal> options can help force a situation where your application has
          fragmented memory. This can simulate the behavior of a long-running application without
          you having to actually wait that long to re-create the behavior in a performance unit
            test.<indexterm class="endofrange" startref="Hmh"/></para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="attaching-finalizer-functions-to-values">
    <title>Attaching Finalizer Functions to Values</title>

    <para>OCaml's automatic memory management guarantees that a value will eventually be freed when
      it's no longer in use, either via the GC sweeping it or the program terminating. It's
      sometimes useful to run extra code just before a value is freed by the GC, for example, to
      check that a file descriptor has been closed, or that a log message is recorded.<indexterm class="singular">
        <primary>values</primary>
        <secondary>finalizer functions for</secondary>
      </indexterm><indexterm class="singular">
        <primary>finalizers</primary>
        <secondary sortas="garbage collection">in grabage collection</secondary>
      </indexterm><indexterm class="singular">
        <primary>garbage collection</primary>
        <secondary>finalizer functions</secondary>
      </indexterm></para>

    <note>
      <title>What Values Can Be Finalized?</title>

      <para>Various values cannot have finalizers attached since they aren't heap-allocated. Some
        examples of values that are not heap-allocated are integers, constant constructors,
        Booleans, the empty array, the empty list, and the unit value. The exact list of what is
        heap-allocated or not is implementation-dependent, which is why Core provides the <literal moreinfo="none">Heap_block</literal> module to explicitly check before attaching the
        finalizer.</para>

      <para>Some constant values can be heap-allocated but never deallocated during the lifetime of
        the program, for example, a list of integer constants. <literal moreinfo="none">Heap_block</literal> explicitly checks to see if the value is in the major or minor heap,
        and rejects most constant values. Compiler optimizations may also duplicate some immutable
        values such as floating-point values in arrays. These may be finalized while another <phrase role="keep-together">duplicate</phrase> copy is being used by the program.</para>

      <para>For this reason, attach finalizers only to values that you are explicitly sure are
        heap-allocated and aren't immutable. A common use is to attach them to file descriptors to
        ensure they are closed. However, the finalizer normally shouldn't be the primary way of
        closing the file descriptor, since it depends on the GC running in order to collect the
        value. For a busy system, you can easily run out of a scarce resource such as file
        descriptors before the GC catches up.</para>
    </note>

    <para>Core provides a <literal moreinfo="none">Heap_block</literal> module
    that dynamically checks if a given value is suitable for finalizing. This
    block is then passed to Async's <literal moreinfo="none">Gc.add_finalizer</literal> function that schedules the
    finalizer safely with respect to all the other concurrent program
    threads.<indexterm class="singular">
        <primary>heaps</primary>

        <secondary>Heap_block module</secondary>
      </indexterm></para>

    <para>Let's explore this with a small example that finalizes values of
    different types, some of which are heap-allocated and others which are
    compile-time constants:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/gc/finalizer.ml">OCaml</ulink></para>

    <programlisting format="linespecific" language="ocaml">open Core.Std
open Async.Std

let attach_finalizer n v =
  match Heap_block.create v with
  | None -&gt; printf "%20s: FAIL\n%!" n
  | Some hb -&gt;
    let final _ = printf "%20s: OK\n%!" n in
    Gc.add_finalizer hb final

type t = { foo: bool }

let main () =
  let alloced_float = Unix.gettimeofday () in
  let alloced_bool = alloced_float &gt; 0.0 in
  let alloced_string = String.create 4 in
  attach_finalizer "immediate int" 1;
  attach_finalizer "immediate float" 1.0;
  attach_finalizer "immediate variant" (`Foo "hello");
  attach_finalizer "immediate string" "hello world";
  attach_finalizer "immediate record" { foo=false };
  attach_finalizer "allocated float" alloced_float;
  attach_finalizer "allocated bool" alloced_bool;
  attach_finalizer "allocated variant" (`Foo alloced_bool);
  attach_finalizer "allocated string" alloced_string;
  attach_finalizer "allocated record" { foo=alloced_bool };
  Gc.compact ();
  return ()

let () =
  Command.async_basic ~summary:"Testing finalizers"
    Command.Spec.empty main
  |&gt; Command.run</programlisting>

    <para>Building and running this should show the following output:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/gc/run_finalizer.out">Terminal</ulink></para>

    <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">corebuild -pkg async finalizer.native</userinput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">./finalizer.native</userinput>
<computeroutput moreinfo="none">       immediate int: FAIL</computeroutput>
<computeroutput moreinfo="none">     immediate float: FAIL</computeroutput>
<computeroutput moreinfo="none">   immediate variant: FAIL</computeroutput>
<computeroutput moreinfo="none">    immediate string: FAIL</computeroutput>
<computeroutput moreinfo="none">    immediate record: FAIL</computeroutput>
<computeroutput moreinfo="none">      allocated bool: FAIL</computeroutput>
<computeroutput moreinfo="none">    allocated record: OK</computeroutput>
<computeroutput moreinfo="none">    allocated string: OK</computeroutput>
<computeroutput moreinfo="none">   allocated variant: OK</computeroutput>
<computeroutput moreinfo="none">     allocated float: OK</computeroutput></programlisting>

    <para>The GC calls the finalization functions in the order of the deallocation. If several
      values become unreachable during the same GC cycle, the finalization functions will be called
      in the reverse order of the corresponding calls to <literal moreinfo="none">add_finalizer</literal>. Each call to <literal moreinfo="none">add_finalizer</literal> adds
      to the set of functions, which are run when the value becomes unreachable. You can have many
      finalizers all pointing to the same heap block if you wish.</para>

    <para>After a garbage collection determines that a heap block <literal moreinfo="none">b</literal> is unreachable, it removes from the set of
    finalizers all the functions associated with <literal moreinfo="none">b</literal>, and serially applies each of those functions
    to <literal moreinfo="none">b</literal>. Thus, every finalizer function
    attached to <literal moreinfo="none">b</literal> will run at most once.
    However, program termination will not cause all the finalizers to be run
    before the runtime exits.</para>

    <para>The finalizer can use all features of OCaml, including assignments that make the value
      reachable again and thus prevent it from being garbage-collected. It can also loop forever,
      which will cause other finalizers to be interleaved with it.</para>
  </sect1>
</chapter>

    <chapter id="the-compiler-frontend-parsing-and-type-checking">
  <title>The Compiler Frontend: Parsing and <phrase role="keep-together">Type
    Checking</phrase></title>

  <para>Compiling source code into executable programs is a fairly complex
  libraries, linkers, and assemblers. It's important to understand how these
  fit together to help with your day-to-day workflow of developing, debugging,
  and deploying applications.<indexterm class="singular">
      <primary>compilation process</primary>

      <secondary>toolchain for</secondary>
    </indexterm></para>

  <para>OCaml has a strong emphasis on static type safety and rejects source
  code that doesn't meet its requirements as early as possible. The compiler
  does this by running the source code through a series of checks and
  transformations. Each stage performs its job (e.g., type checking,
  optimization, or code generation) and discards some information from the
  previous stage. The final native code output is low-level assembly code that
  doesn't know anything about the OCaml modules or objects that the compiler
  started with.<indexterm class="singular">
      <primary>static checking</primary>
    </indexterm><indexterm class="singular">
      <primary>compile-time static checking</primary>
    </indexterm></para>

  <para>You don't have to do all of this manually, of course. The compiler frontends (<literal moreinfo="none">ocamlc</literal> and <literal moreinfo="none">ocamlopt</literal>) are invoked
    via the command line and chain the stages together for you. Sometimes though, you'll need to
    dive into the toolchain to hunt down a bug or investigate a performance problem. This chapter
    explains the compiler pipeline in more depth so you understand how to harness the command-line
    tools effectively.<indexterm class="singular">
      <primary>OCaml toolchain</primary>
      <secondary>ocamlc</secondary>
    </indexterm><indexterm class="singular">
      <primary>OCaml toolchain</primary>
      <secondary>ocamlopt</secondary>
    </indexterm></para>

  <para>In this chapter, we'll cover the following topics:</para>

  <itemizedlist>
    <listitem>
      <para>The compilation pipeline and what each stage represents</para>
    </listitem>

    <listitem>
      <para>Source preprocessing via Camlp4 and the intermediate forms</para>
    </listitem>

    <listitem>
      <para>The type-checking process, including module resolution</para>
    </listitem>
  </itemizedlist>

  <para>The details of the compilation process into executable code can be found next, in <xref linkend="the-compiler-backend-byte-code-and-native-code"/>.</para>

  <sect1 id="an-overview-of-the-toolchain">
    <title>An Overview of the Toolchain</title>

    <para>The OCaml tools accept textual source code as input, using the filename extensions
        <literal moreinfo="none">.ml</literal> and <literal moreinfo="none">.mli</literal> for
      modules and signatures, respectively. We explained the basics of the build process in <xref linkend="files-modules-and-programs"/>, so we'll assume you've built a few OCaml programs
      already by this point.<indexterm class="singular">
        <primary>OCaml toolchain</primary>
        <secondary>overview of</secondary>
      </indexterm></para>

    <para>Each source file represents a <emphasis>compilation unit</emphasis>
    that is built separately. The compiler generates intermediate files with
    different filename extensions to use as it advances through the
    compilation stages. The linker takes a collection of compiled units and
    produces a standalone executable or library archive that can be reused by
    other applications.<indexterm class="singular">
        <primary>compilation units</primary>
      </indexterm></para>

    <para>The overall compilation pipeline looks like this:<indexterm class="singular">
        <primary>compilation process</primary>

        <secondary>diagram of</secondary>
      </indexterm></para>


    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/front-end/pipeline.ascii">Diagram</ulink></para>

    <informalfigure>
      <mediaobject>
        <imageobject role="web">
          <imagedata fileref="images/rwoc_2201.png" format="PNG"/>
        </imageobject>
      </mediaobject>
    </informalfigure>

    <para>Notice that the pipeline branches toward the end. OCaml has multiple compiler backends
      that reuse the early stages of compilation but produce very different final outputs. The
        <emphasis>bytecode</emphasis> can be run by a portable interpreter and can even be
      transformed into JavaScript (via <ulink url="http://ocsigen.org/js_of_ocaml">js_of_ocaml</ulink>) or C source code (via <ulink url="https://github.com/ocaml-bytes/ocamlcc">OCamlCC</ulink>). The <emphasis>native
        code</emphasis> compiler generates specialized executable binaries suitable for
      high-performance applications.<indexterm class="singular">
        <primary>compilation process</primary>
        <secondary>compiler source code</secondary>
      </indexterm><indexterm class="singular">
        <primary>code compilers</primary>
        <secondary>bytecode vs. native code</secondary>
      </indexterm></para>

    <sidebar>
      <title>Obtaining the Compiler Source Code</title>

      <para>Although it's not necessary to understand the examples, you may
      find it useful to have a copy of the OCaml source tree checked out while
      you read through this chapter. The source code is available from
      multiple places:</para>

      <itemizedlist>
        <listitem>
          <para>Stable releases as <filename>zip</filename> and <filename>tar</filename> archives
            from the <ulink url="http://caml.inria.fr/download.en.html">OCaml download
            site</ulink></para>
        </listitem>

        <listitem>
          <para>A Subversion anonymous mirror of the main development sources
          available on the <ulink url="http://caml.inria.fr/ocaml/anonsvn.en.html">development
          resources</ulink> page online</para>
        </listitem>

        <listitem>
          <para>A Git mirror of the Subversion repository with all the history and development
            branches included, browsable online at <ulink url="https://github.com/ocaml/ocaml">GitHub</ulink></para>
        </listitem>
      </itemizedlist>

      <para>The source tree is split up into subdirectories. The core compiler
      consists of:</para>

      <variablelist>
        <varlistentry>
          <term><literal moreinfo="none">config/</literal></term>

          <listitem>
            <para>Configuration directives to tailor OCaml for your operating
            system and architecture.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal moreinfo="none">bytecomp/</literal> and <literal moreinfo="none">byterun/</literal></term>

          <listitem>
            <para>Bytecode compiler and runtime, including the garbage collector (GC).</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal moreinfo="none">asmcomp/</literal> and <literal moreinfo="none">asmrun/</literal></term>

          <listitem>
            <para>Native-code compiler and runtime. The native runtime symlinks many modules from
              the <literal moreinfo="none">byterun</literal> directory to share code, most notably
              the GC.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal moreinfo="none">parsing/</literal></term>

          <listitem>
            <para>The OCaml lexer, parser, and libraries for manipulating
            them.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal moreinfo="none">typing/</literal></term>

          <listitem>
            <para>The static type checking implementation and type
            definitions.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal moreinfo="none">camlp4/</literal></term>

          <listitem>
            <para>The source code macro preprocessor.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal moreinfo="none">driver/</literal></term>

          <listitem>
            <para>Command-line interfaces for the compiler tools.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>A number of tools and scripts are also built alongside the core compiler:</para>

      <variablelist>
        <varlistentry>
          <term><literal moreinfo="none">debugger/</literal></term>

          <listitem>
            <para>The interactive bytecode debugger.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal moreinfo="none">toplevel/</literal></term>

          <listitem>
            <para>Interactive top-level console.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal moreinfo="none">emacs/</literal></term>

          <listitem>
            <para>: A <emphasis>caml-mode</emphasis> for the Emacs
            editor.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal moreinfo="none">stdlib/</literal></term>

          <listitem>
            <para>The compiler standard library, including the <literal moreinfo="none">Pervasives</literal> module.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal moreinfo="none">ocamlbuild/</literal></term>

          <listitem>
            <para>Build system that automates common OCaml compilation
            modes.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal moreinfo="none">otherlibs/</literal></term>

          <listitem>
            <para>Optional libraries such as the Unix and graphics
            modules.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal moreinfo="none">tools/</literal></term>

          <listitem>
            <para>Command-line utilities such as <literal moreinfo="none">ocamldep</literal> that are installed with the
            compiler.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal moreinfo="none">testsuite/</literal></term>

          <listitem>
            <para>Regression tests for the core compiler.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </sidebar>

    <para>We'll go through each of the compilation stages now and explain how they will be useful to
      you during day-to-day OCaml development.</para>
  </sect1>

  <sect1 id="parsing-source-code">
    <title>Parsing Source Code</title>

    <para>When a source file is passed to the OCaml compiler, its first task is to parse the text
      into a more structured abstract syntax tree (AST). The parsing logic is implemented in OCaml
      itself using the techniques described earlier in <xref linkend="parsing-with-ocamllex-and-menhir"/>. The lexer and parser rules can be found in the
        <literal moreinfo="none">parsing</literal> directory in the source distribution.<indexterm class="singular">
        <primary>AST (abstract syntax-tree)</primary>
      </indexterm><indexterm class="startofrange" id="SCpras">
        <primary>source code</primary>
        <secondary>parsing of</secondary>
      </indexterm><indexterm class="startofrange" id="PARSsource">
        <primary>parsing</primary>
        <secondary>of source code</secondary>
      </indexterm><indexterm class="startofrange" id="CPpars">
        <primary>compilation process</primary>
        <secondary>parsing source code</secondary>
      </indexterm></para>

    <sect2 id="syntax-errors">
      <title>Syntax Errors</title>

      <para>The OCaml parser's goal is to output a well-formed AST data structure to the next phase
        of compilation, and so it any source code that doesn't match basic syntactic requirements.
        The compiler emits a <emphasis>syntax error</emphasis> in this situation, with a pointer to
        the filename and line and character number that's as close to the error as
          possible.<indexterm class="singular">
          <primary>errors</primary>
          <secondary>syntax errors</secondary>
        </indexterm><indexterm class="singular">
          <primary>syntax errors</primary>
        </indexterm></para>

      <para>Here's an example syntax error that we obtain by performing a module assignment as a
        statement instead of as a <literal>let</literal> binding:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/front-end/broken_module.ml">OCaml</ulink></para>

      <programlisting format="linespecific" language="ocaml">let () =
  module MyString = String;
  ()</programlisting>

      <para>The code results in a syntax error when compiled:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/front-end/build_broken_module.out">Terminal</ulink></para>

      <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">ocamlc -c broken_module.ml</userinput>
<computeroutput moreinfo="none">File "broken_module.ml", line 2, characters 2-8:</computeroutput>
<computeroutput moreinfo="none">Error: Syntax error</computeroutput></programlisting>

      <para>The correct version of this source code creates the <literal moreinfo="none">MyString</literal> module correctly via a local open,
      and compiles successfully:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/front-end/fixed_module.ml">OCaml</ulink></para>

      <programlisting format="linespecific" language="ocaml">let () =
  let module MyString = String in
  ()</programlisting>

      <para>The syntax error points to the line and character number of the
      first token that couldn't be parsed. In the broken example, the <literal moreinfo="none">module</literal> keyword isn't a valid token at that
      point in parsing, so the error location information is correct.</para>
    </sect2>

    <sect2 id="automatically-indenting-source-code">
      <title>Automatically Indenting Source Code</title>

      <para>Sadly, syntax errors do get more inaccurate sometimes, depending
      on the nature of your mistake. Try to spot the deliberate error in the
      following function definitions:<indexterm class="singular">
          <primary>source code</primary>

          <secondary>automatically indenting</secondary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/front-end/follow_on_function.ml">OCaml</ulink></para>

      <programlisting format="linespecific" language="ocaml">let concat_and_print x y =
  let v = x ^ y in
  print_endline v;
  v;

let add_and_print x y =
  let v = x + y in
  print_endline (string_of_int v);
  v

let () =
  let _x = add_and_print 1 2 in
  let _y = concat_and_print "a" "b" in
  ()</programlisting>

      <para>When you compile this file, you'll get a syntax error
      again:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/front-end/build_follow_on_function.out">Terminal</ulink></para>

      <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">ocamlc -c follow_on_function.ml</userinput>
<computeroutput moreinfo="none">File "follow_on_function.ml", line 11, characters 0-3:</computeroutput>
<computeroutput moreinfo="none">Error: Syntax error</computeroutput></programlisting>

      <para>The line number in the error points to the end of the <literal moreinfo="none">add_and_print</literal> function, but the actual error
      is at the end of the <emphasis>first</emphasis> function definition.
      There's an extra semicolon at the end of the first definition that
      causes the second definition to become part of the first <literal moreinfo="none">let</literal> binding. This eventually results in a
      parsing error at the very end of the second function.</para>

      <para>This class of bug (due to a single errant character) can be hard
      to spot in a large body of code. Luckily, there's a great tool available
      via OPAM called <command moreinfo="none">ocp-indent</command> that
      applies structured indenting rules to your source code on a line-by-line
      basis. This not only beautifies your code layout, but it also makes this
      syntax error much easier to locate.<indexterm class="singular">
          <primary>debugging</primary>

          <secondary>single errant characters</secondary>
        </indexterm></para>

      <para>Let's run our erroneous file through <command moreinfo="none">ocp-indent</command> and see how it processes it:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/front-end/indent_follow_on_function.out">Terminal</ulink></para>

      <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">ocp-indent follow_on_function.ml</userinput>
<computeroutput moreinfo="none">let concat_and_print x y =</computeroutput>
<computeroutput moreinfo="none">  let v = x ^ y in</computeroutput>
<computeroutput moreinfo="none">  print_endline v;</computeroutput>
<computeroutput moreinfo="none">  v;</computeroutput>
<computeroutput moreinfo="none"> </computeroutput>
<computeroutput moreinfo="none">  let add_and_print x y =</computeroutput>
<computeroutput moreinfo="none">    let v = x + y in</computeroutput>
<computeroutput moreinfo="none">    print_endline (string_of_int v);</computeroutput>
<computeroutput moreinfo="none">    v</computeroutput>
<computeroutput moreinfo="none"> </computeroutput>
<computeroutput moreinfo="none">let () =</computeroutput>
<computeroutput moreinfo="none">  let _x = add_and_print 1 2 in</computeroutput>
<computeroutput moreinfo="none">  let _y = concat_and_print "a" "b" in</computeroutput>
<computeroutput moreinfo="none">  ()</computeroutput></programlisting>

      <para>The <literal moreinfo="none">add_and_print</literal> definition has been indented as if
        it were part of the first <literal moreinfo="none">concat_and_print</literal> definition,
        and the errant semicolon is now much easier to spot. We just need to remove that semicolon
        and rerun <command moreinfo="none">ocp-indent</command> to verify that the syntax is
        correct:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/front-end/indent_follow_on_function_fixed.out">Terminal</ulink></para>

      <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">ocp-indent follow_on_function_fixed.ml</userinput>
<computeroutput moreinfo="none">let concat_and_print x y =</computeroutput>
<computeroutput moreinfo="none">  let v = x ^ y in</computeroutput>
<computeroutput moreinfo="none">  print_endline v;</computeroutput>
<computeroutput moreinfo="none">  v</computeroutput>
<computeroutput moreinfo="none"> </computeroutput>
<computeroutput moreinfo="none">let add_and_print x y =</computeroutput>
<computeroutput moreinfo="none">  let v = x + y in</computeroutput>
<computeroutput moreinfo="none">  print_endline (string_of_int v);</computeroutput>
<computeroutput moreinfo="none">  v</computeroutput>
<computeroutput moreinfo="none"> </computeroutput>
<computeroutput moreinfo="none">let () =</computeroutput>
<computeroutput moreinfo="none">  let _x = add_and_print 1 2 in</computeroutput>
<computeroutput moreinfo="none">  let _y = concat_and_print "a" "b" in</computeroutput>
<computeroutput moreinfo="none">  ()</computeroutput></programlisting>

      <para>The <command moreinfo="none">ocp-indent</command>
        <ulink url="https://github.com/OCamlPro/ocp-indent">home page</ulink> documents how to
        integrate it with your favorite editor. All the Core libraries are formatted using it to
        ensure consistency, and it's a good idea to do this before publishing your own source code
        online.</para>
    </sect2>

    <sect2 id="generating-documentation-from-interfaces">
      <title>Generating Documentation from Interfaces</title>

      <para>Whitespace and source code comments are removed during parsing and
      aren't significant in determining the semantics of the program. However,
      other tools in the OCaml distribution can interpret comments for their
      own ends.<indexterm class="singular">
          <primary>OCaml toolchain</primary>

          <secondary>ocamldoc</secondary>
        </indexterm><indexterm class="singular">
          <primary>interfaces</primary>

          <secondary>generating documentation from</secondary>
        </indexterm><indexterm class="singular">
          <primary>documentation, generating from interfaces</primary>
        </indexterm></para>

      <para>The <command moreinfo="none">ocamldoc</command> tool uses specially formatted comments
        in the source code to generate documentation bundles. These comments are combined with the
        function definitions and signatures, and output as structured documentation in a variety of
        formats. It can generate HTML pages, LaTeX and PDF documents, UNIX manual pages, and even
        module dependency graphs that can be viewed using <ulink url="http://www.graphviz.org">Graphviz</ulink>.</para>

      <para>Here's a sample of some source code that's been annotated with
      <command moreinfo="none">ocamldoc</command> comments:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/front-end/doc.ml">OCaml</ulink></para>

      <programlisting format="linespecific" language="ocaml">(** example.ml: The first special comment of the file is the comment 
    associated with the whole module. *)

(** Comment for exception My_exception. *)
exception My_exception of (int -&gt; int) * int

(** Comment for type [weather]  *)
type weather =
  | Rain of int (** The comment for construtor Rain *)
  | Sun         (** The comment for constructor Sun *)

(** Find the current weather for a country
    @author Anil Madhavapeddy
    @param location The country to get the weather for.
*)
let what_is_the_weather_in location =
  match location with
  | `Cambridge  -&gt; Rain 100
  | `New_york   -&gt; Rain 20
  | `California -&gt; Sun</programlisting>

      <para>The <command moreinfo="none">ocamldoc</command> comments are
      distinguished by beginning with the double asterisk. There are
      formatting conventions for the contents of the comment to mark metadata.
      For instance, the <literal moreinfo="none">@tag</literal> fields mark
      specific properties such as the author of that section of code.</para>

      <para>Try compiling the HTML documentation and UNIX man pages by running
      <command moreinfo="none">ocamldoc</command> over the source file:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/front-end/build_ocamldoc.out">Terminal</ulink></para>

      <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">mkdir -p html man/man3</userinput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">ocamldoc -html -d html doc.ml</userinput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">ocamldoc -man -d man/man3 doc.ml</userinput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">man -M man Doc</userinput></programlisting>

      <para>You should now have HTML files inside the <filename>html/</filename> directory and also
        be able to view the UNIX manual pages held in <filename>man/man3</filename>. There are quite
        a few comment formats and options to control the output for the various backends. Refer to
        the <ulink url="http://caml.inria.fr/pub/docs/manual-ocaml/manual029.html">OCaml
          manual</ulink> for the complete list.<indexterm class="singular">
          <primary>Xen</primary>
        </indexterm><indexterm class="singular">
          <primary>JSON data</primary>
          <secondary>Xen custom generator for</secondary>
        </indexterm><indexterm class="singular">
          <primary>Bibtex</primary>
        </indexterm><indexterm class="singular">
          <primary>OCaml toolchain</primary>
          <secondary>ocamldoc-generators</secondary>
        </indexterm><indexterm class="singular">
          <primary>Argot HTML generator</primary>
        </indexterm><indexterm class="singular">
          <primary>HTML generators</primary>
        </indexterm><indexterm class="endofrange" startref="SCpras"/><indexterm class="endofrange" startref="PARSsource"/><indexterm class="endofrange" startref="CPpars"/></para>

      <tip>
        <title>Using Custom ocamldoc Generators</title>

        <para>The default HTML output stylesheets from <command moreinfo="none">ocamldoc</command> are pretty spartan and distinctly
        Web 1.0. The tool supports plugging in custom documentation
        generators, and there are several available that provide prettier or
        more detailed output:</para>

        <itemizedlist>
          <listitem>
            <para><ulink url="http://argot.x9c.fr/">Argot</ulink> is an
            enhanced HTML generator that supports code folding and searching
            by name or type definition.</para>
          </listitem>

          <listitem>
            <para><ulink url="https://gitorious.org/ocamldoc-generators/ocamldoc-generators">ocamldoc generators</ulink> add support for Bibtex references within comments and
              generating literate documentation that embeds the code alongside the comments.</para>
          </listitem>

          <listitem>
            <para>JSON output is available via a custom <ulink url="https://github.com/xen-org/ocamldoc-json">generator</ulink>
            in Xen.</para>
          </listitem>
        </itemizedlist>
      </tip>
    </sect2>
  </sect1>

  <sect1 id="preprocessing-source-code">
    <title>Preprocessing Source Code</title>

    <para>One powerful feature in OCaml is a facility to extend the standard-language grammar
      without having to modify the compiler. You can roughly think of it as a type-safe version of
      the <literal moreinfo="none">cpp</literal> preprocessor used in C/C++ to control conditional
      compilation directives.<indexterm class="singular">
        <primary>grammars</primary>
        <secondary>extension of standard language</secondary>
      </indexterm><indexterm class="startofrange" id="SCpreproc">
        <primary>source code</primary>
        <secondary>preprocessing of</secondary>
      </indexterm><indexterm class="startofrange" id="CPpreproc">
        <primary>compilation process</primary>
        <secondary>preprocessing source code</secondary>
      </indexterm></para>

    <para>The OCaml distribution includes a system called Camlp4 for writing extensible parsers.
      This provides some OCaml libraries that are used to define grammars, as well as dynamically
      loadable syntax extensions of such grammars. Camlp4 modules register new language keywords and
      later transform these keywords (or indeed, any portion of the input program) into conventional
      OCaml code that can be understood by the rest of the compiler.<indexterm class="startofrange" id="SEcamlp">
        <primary>syntax extension</primary>
        <secondary sortas="Camlp4">in Camlp4</secondary>
      </indexterm><indexterm class="singular">
        <primary>programming</primary>
        <secondary>dynamic programming</secondary>
      </indexterm><indexterm class="singular">
        <primary>dynamic programming</primary>
      </indexterm><indexterm class="singular">
        <primary>Bin_prot library</primary>
      </indexterm><indexterm class="singular">
        <primary>Sexplib package</primary>
        <secondary>sexp converter</secondary>
      </indexterm><indexterm class="singular">
        <primary>fieldslib</primary>
      </indexterm><indexterm class="singular">
        <primary>parsing</primary>
        <secondary>extensible parsers</secondary>
      </indexterm><indexterm class="singular">
        <primary>extensible parsers</primary>
      </indexterm><indexterm class="startofrange" id="camlp">
        <primary>Camlp4 syntax extension mechanism</primary>
      </indexterm></para>

    <para>We've already seen several Core libraries that use Camlp4:</para>

    <variablelist>
      <varlistentry>
        <term><literal moreinfo="none">Fieldslib</literal></term>

        <listitem>
          <para>Generates first-class values that represent fields of a
          record</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal moreinfo="none">Sexplib</literal></term>

        <listitem>
          <para>To convert types to textual s-expressions</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal moreinfo="none">Bin_prot</literal></term>

        <listitem>
          <para>For efficient binary conversion and parsing</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <para>These libraries all extend the language in quite a minimal way by
    adding a <literal moreinfo="none">with</literal> keyword to type
    declarations to signify that extra code should be generated from that
    declaration. For example, here's a trivial use of Sexplib and
    Fieldslib:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/front-end/type_conv_example.ml">OCaml</ulink></para>

    <programlisting format="linespecific" language="ocaml">open Sexplib.Std

type t = {
  foo: int;
  bar: string
} with sexp, fields</programlisting>

    <para>Compiling this code will normally give you a syntax error if you do so without Camlp4,
      since the <literal moreinfo="none">with</literal> keyword isn't normally allowed after a type
      definition:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/front-end/build_type_conv_without_camlp4.out">Terminal</ulink></para>

    <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">ocamlfind ocamlc -c type_conv_example.ml</userinput>
<computeroutput moreinfo="none">File "type_conv_example.ml", line 6, characters 2-6:</computeroutput>
<computeroutput moreinfo="none">Error: Syntax error</computeroutput></programlisting>

    <para>Now add in the syntax extension packages for Fieldslib and Sexplib,
    and everything will compile again:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/front-end/build_type_conv_with_camlp4.out">Terminal</ulink></para>

    <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">ocamlfind ocamlc -c -syntax camlp4o -package sexplib.syntax \</userinput>
<computeroutput moreinfo="none">    -package fieldslib.syntax type_conv_example.ml</computeroutput></programlisting>

    <para>We've specified a couple of additional flags here. The <literal moreinfo="none">-syntax</literal> flag directs <command moreinfo="none">ocamlfind</command> to add the <literal moreinfo="none">-pp</literal> flag to the compiler command line. This flag
    instructs the compiler to run the preprocessor during its parsing
    phase.</para>

    <para>The <literal moreinfo="none">-package</literal> flag imports other
    OCaml libraries. The <literal moreinfo="none">.syntax</literal> suffix in
    the package name is a convention that indicates these libraries are
    preprocessors that should be run during parsing. The syntax extension
    modules are dynamically loaded into the <command moreinfo="none">camlp4o</command> command, which rewrites the input source
    code into conventional OCaml code that has no trace of the new keywords.
    The compiler then compiles this transformed code with no knowledge of the
    preprocessor's actions.</para>

    <para>Both Fieldslib and Sexplib need this new <literal moreinfo="none">with</literal> keyword,
      but they both can't register the same extension. Instead, a library called Type_conv provides
      the common extension framework for them to use. Type_conv registers the <literal moreinfo="none">with</literal> grammar extension to Camlp4, and the OCamlfind packaging
      ensures that it's loaded before Fieldslib or Sexplib.</para>

    <para>The two extensions generate boilerplate OCaml code based on the type definition at
      compilation time. This avoids the performance hit of doing the code generation dynamically and
      also doesn't require a just-in-time (JIT) runtime that can be a source of unpredictable
      dynamic behavior. Instead, all the extra code is simply generated at compilation time via
      Camlp4, and type information can be discarded from the runtime image.<indexterm class="singular">
        <primary sortas="Just">"Just-in-Time" dynamic patching</primary>
      </indexterm></para>

    <para>The syntax extensions accept an input AST and output a modified one.
    If you're not familiar with the Camlp4 module in question, how do you
    figure out what changes it's made to your code? The obvious way is to read
    the documentation that accompanies the extension. Another approach is to
    use the toplevel to explore the extension's behavior or run Camlp4
    manually yourself to see the transformation in action. We'll show you how
    to do both of these now.</para>

    <sect2 id="using-camlp4-interactively">
      <title>Using Camlp4 Interactively</title>

      <para>The <command moreinfo="none">utop</command> toplevel can run the
      phrases that you type through <command moreinfo="none">camlp4</command>
      automatically. You should have at least these lines in your <literal moreinfo="none">~/.ocamlinit</literal> file in your home directory (see
        <ulink url="http://realworldocaml.org/install">this Real World OCaml page</ulink> for more information):</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/front-end/camlp4_toplevel.topscript">OCaml utop</ulink></para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">#use "topfind" ;;</userinput>
<computeroutput moreinfo="none">- : unit = ()</computeroutput>
<computeroutput moreinfo="none">Findlib has been successfully loaded. Additional directives:</computeroutput>
<computeroutput moreinfo="none">  #require "package";;      to load a package</computeroutput>
<computeroutput moreinfo="none">  #list;;                   to list the available packages</computeroutput>
<computeroutput moreinfo="none">  #camlp4o;;                to load camlp4 (standard syntax)</computeroutput>
<computeroutput moreinfo="none">  #camlp4r;;                to load camlp4 (revised syntax)</computeroutput>
<computeroutput moreinfo="none">  #predicates "p,q,...";;   to set these predicates</computeroutput>
<computeroutput moreinfo="none">  Topfind.reset();;         to force that packages will be reloaded</computeroutput>
<computeroutput moreinfo="none">  #thread;;                 to enable threads</computeroutput>
<computeroutput moreinfo="none"/>
<computeroutput moreinfo="none">- : unit = ()</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">#camlp4o ;;</userinput></programlisting>

      <para>The first directive loads the <command moreinfo="none">ocamlfind</command> top-level interface that lets you
      require <command moreinfo="none">ocamlfind</command> packages (including
      all their dependent packages). The second directive instructs the
      toplevel to filter all phrases via Camlp4. You can now run <command moreinfo="none">utop</command> and load the syntax extensions in. We'll
      use the <literal moreinfo="none">comparelib</literal> syntax extension
      for our experiments.</para>

      <para>OCaml provides a built-in polymorphic comparison operator that inspects the runtime
        representation of two values to see if they're equal. As we noted in <xref linkend="maps-and-hash-tables"/>, the polymorphic comparison is less efficient than
        defining explicit comparison functions between values. However, it quickly becomes tedious
        to manually define comparison functions for complex type definitions.<indexterm class="singular">
          <primary>interactive input</primary>
          <secondary sortas="calmp4">with camlp4</secondary>
        </indexterm><indexterm class="singular">
          <primary>polymorphic comparisons</primary>
        </indexterm></para>

      <para>Let's see how <literal moreinfo="none">comparelib</literal> solves
      this problem by running it in <command moreinfo="none">utop</command>:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/front-end/camlp4_toplevel.topscript">OCaml utop</ulink>
      (part 1)</para>

      <programlisting format="linespecific" language="ocaml"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">#require "comparelib.syntax" ;;</userinput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">type t = { foo: string; bar : t } ;;</userinput>
<computeroutput moreinfo="none">type t = { foo : string; bar : t; }</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">type t = { foo: string; bar: t } with compare ;;</userinput>
<computeroutput moreinfo="none">type t = { foo : string; bar : t; }</computeroutput>
<computeroutput moreinfo="none">val compare : t -&gt; t -&gt; int = &lt;fun&gt;</computeroutput>
<computeroutput moreinfo="none">val compare_t : t -&gt; t -&gt; int = &lt;fun&gt;</computeroutput></programlisting>

      <para>The first definition of <literal moreinfo="none">t</literal> is a standard OCaml phrase
        and results in the expected output. The second one includes the <literal moreinfo="none">with compare</literal> directive. This is intercepted by <literal moreinfo="none">comparelib</literal> and transformed into the original type definition with two new
        functions also <phrase security="" role="keep-together">included</phrase>.</para>
    </sect2>

    <sect2 id="running-camlp4-from-the-command-line">
      <title>Running Camlp4 from the Command Line</title>

      <para>The toplevel is a quick way to examine the signatures generated from the extensions, but
        how can we see what these new functions actually do? We can't do this from <command moreinfo="none">utop</command> directly, since it embeds the Camlp4 invocation as an
        automated part of its operation.<indexterm class="singular">
          <primary>command-line parsing</primary>
          <secondary>with Camlp4</secondary>
        </indexterm></para>

      <para>Let's turn to the command line to obtain the result of the
      <literal moreinfo="none">comparelib</literal> transformation instead.
      Create a file that contains the type declaration from earlier:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/front-end/comparelib_test.ml">OCaml</ulink></para>

      <programlisting format="linespecific" language="ocaml">type t = { 
  foo: string; 
  bar: t
} with compare</programlisting>

      <para>We need to run the Camlp4 binary with the library paths to
      Comparelib and Type_conv. Let's use a small shell script to wrap this
      invocation:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/front-end/camlp4_dump.cmd">Shell script</ulink></para>

      <programlisting format="linespecific" language="bash">#!/bin/sh

OCAMLFIND="ocamlfind query -predicates syntax,preprocessor -r"
INCLUDE=`$OCAMLFIND -i-format comparelib.syntax`
ARCHIVES=`$OCAMLFIND -a-format comparelib.syntax`
camlp4o -printer o $INCLUDE $ARCHIVES $1</programlisting>

      <para>The script uses the <command moreinfo="none">ocamlfind</command>
      package manager to list the include and library paths needed by <literal moreinfo="none">comparelib</literal>. It then invokes the <command moreinfo="none">camlp4o</command> preprocessor with these paths and
      outputs the resulting AST to the standard output:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/front-end/process_comparelib_test.out">Terminal</ulink></para>

      <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">sh camlp4_dump.cmd comparelib_test.ml</userinput>
<computeroutput moreinfo="none">type t = { foo : string; bar : t }</computeroutput>
<computeroutput moreinfo="none"> </computeroutput>
<computeroutput moreinfo="none">let _ = fun (_ : t) -&gt; ()</computeroutput>
<computeroutput moreinfo="none">  </computeroutput>
<computeroutput moreinfo="none">let rec compare : t -&gt; t -&gt; int =</computeroutput>
<computeroutput moreinfo="none">  fun a__001_ b__002_ -&gt;</computeroutput>
<computeroutput moreinfo="none">    if Pervasives.( == ) a__001_ b__002_</computeroutput>
<computeroutput moreinfo="none">    then 0</computeroutput>
<computeroutput moreinfo="none">    else</computeroutput>
<computeroutput moreinfo="none">      (let ret =</computeroutput>
<computeroutput moreinfo="none">         (Pervasives.compare : string -&gt; string -&gt; int) a__001_.foo</computeroutput>
<computeroutput moreinfo="none">           b__002_.foo</computeroutput>
<computeroutput moreinfo="none">       in</computeroutput>
<computeroutput moreinfo="none">         if Pervasives.( &lt;&gt; ) ret 0</computeroutput>
<computeroutput moreinfo="none">         then ret</computeroutput>
<computeroutput moreinfo="none">         else compare a__001_.bar b__002_.bar)</computeroutput>
<computeroutput moreinfo="none">  </computeroutput>
<computeroutput moreinfo="none">let _ = compare</computeroutput>
<computeroutput moreinfo="none">  </computeroutput>
<computeroutput moreinfo="none">let compare_t = compare</computeroutput>
<computeroutput moreinfo="none">  </computeroutput>
<computeroutput moreinfo="none">let _ = compare_t</computeroutput>
<computeroutput moreinfo="none">  </computeroutput>
<computeroutput moreinfo="none"> </computeroutput></programlisting>

      <para>The output contains the original type definition accompanied by
      some automatically generated code that implements an explicit comparison
      function for each field in the record. If you're using the extension in
      your compiler command line, this generated code is then compiled as if
      you had typed it in yourself.</para>

      <para>Note that although the generated code uses <literal moreinfo="none">Pervasives.compare</literal>, it is also annotated with
      a <literal moreinfo="none">string</literal> type. This lets the compiler
      use a specialized string comparison function and not actually call the
      runtime polymorphic comparison function. This has implications for
      correctness, too: recall from <xref linkend="maps-and-hash-tables"/>
      that <literal moreinfo="none">comparelib</literal> provides reliable
      comparison functions that work for values that are logically the same
      but that have differing internal representations (e.g., <literal moreinfo="none">Int.Set.t</literal>).<indexterm class="singular">
          <primary>wildcards</primary>
        </indexterm><indexterm class="singular">
          <primary>bindings</primary>

          <secondary>wildcards in let bindings</secondary>
        </indexterm><indexterm class="singular">
          <primary>let syntax</primary>

          <secondary>wildcards in bindings</secondary>
        </indexterm></para>

      <note role="allow_break">
        <title>A Style Note: Wildcards in let Bindings</title>

        <para>You may have noticed the <literal moreinfo="none">let _ =
        fun</literal> construct in the autogenerated code above. The
        underscore in a <literal moreinfo="none">let</literal> binding is just
        the same as a wildcard underscore in a pattern match, and tells the
        compiler to accept any return value and discard it immediately.</para>

        <para>This is fine for mechanically generated code from Type_conv but
        should be avoided in code that you write by hand. If it's a
        unit-returning expression, then write a <literal moreinfo="none">unit</literal> binding explicitly instead. This will
        cause a type error if the expression changes type in the future (e.g.,
        due to code refactoring):</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/front-end/let_unit.syntax">Syntax</ulink></para>

        <programlisting format="linespecific">let () = &lt;expr&gt;</programlisting>

        <para>If the expression has a different type, then write it
        explicitly:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/front-end/let_notunit.ml">OCaml</ulink></para>

        <programlisting format="linespecific" language="ocaml">let (_:some_type) = &lt;expr&gt;
let () = ignore (&lt;expr&gt; : some_type)
)(* if the expression returns a unit Deferred.t *)
let () = don't_wait_for (&lt;expr&gt;</programlisting>

        <para>The last one is used to ignore Async expressions that should run
        in the background rather than blocking in the current thread.</para>

        <para>One other important reason for using wildcard matches is to bind
        a variable name to something that you want to use in future code but
        don't want to use right away. This would normally generate an "unused
        value" compiler warning. These warnings are suppressed for any
        variable name that's prepended with an underscore:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/front-end/unused_var.ml">OCaml</ulink></para>

        <programlisting format="linespecific" language="ocaml">let fn x y =
  let _z = x + y in
  ()</programlisting>

        <para>Although you don't use <literal moreinfo="none">_z</literal> in
        your code, this will never generate an unused variable warning.</para>
      </note>
    </sect2>

    <sect2 id="preprocessing-module-signatures">
      <title>Preprocessing Module Signatures</title>

      <para>Another useful feature of <literal moreinfo="none">type_conv</literal> is that it can
        generate module signatures, too. Copy the earlier type definition into a <literal moreinfo="none">comparelib_test.mli</literal> that's got exactly the same <phrase role="keep-together">content</phrase>:<indexterm class="singular">
          <primary>signatures</primary>
          <secondary>preprocessing module signatures</secondary>
        </indexterm><indexterm class="singular">
          <primary>modules</primary>
          <secondary>preprocessing signatures of</secondary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/front-end/comparelib_test.mli">OCaml</ulink></para>

      <programlisting format="linespecific" language="ocaml">type t = { 
  foo: string; 
  bar: t
} with compare</programlisting>

      <para>If you rerun the Camlp4 dumper script now, you'll see that
      different code is produced for signature files:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/front-end/process_comparelib_interface.out">Terminal</ulink></para>

      <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">sh camlp4_dump.cmd comparelib_test.mli</userinput>
<computeroutput moreinfo="none">type t = { foo : string; bar : t }</computeroutput>
<computeroutput moreinfo="none"> </computeroutput>
<computeroutput moreinfo="none">val compare : t -&gt; t -&gt; int</computeroutput>
<computeroutput moreinfo="none">  </computeroutput>
<computeroutput moreinfo="none"> </computeroutput></programlisting>

      <para>The external signature generated by <literal moreinfo="none">comparelib</literal> is much simpler than the actual
      code. Running Camlp4 directly on the original source code lets you see
      these all these transformations precisely.<indexterm class="singular">
          <primary>grammars</primary>

          <secondary>avoiding grammar clashes</secondary>
        </indexterm><indexterm class="singular">
          <primary>macros</primary>
        </indexterm><indexterm class="singular">
          <primary>conditional compilation</primary>
        </indexterm><indexterm class="singular">
          <primary>whitespace-sensitive indentation</primary>
        </indexterm><indexterm class="singular">
          <primary>syntax extension</primary>

          <secondary>potential overuse of</secondary>
        </indexterm></para>

      <caution role="allow_break">
        <title>Don't Overdo the Syntax Extensions</title>

        <para>Syntax extensions are a powerful extension mechanism that can
        completely alter your source code's layout and style. Core includes a
        very conservative set of extensions that take care to minimize the
        syntax changes. There are a number of third-party libraries that are
        much more ambitious—some introduce whitespace-sensitive indentation,
        while others build entirely new embedded languages using OCaml as a
        host language, and yet others introduce conditional compilation for
        macros or optional logging.</para>

        <para>While it's tempting to compress all your boilerplate code into Camlp4 extensions, it
          can make your source code much harder for other people to quickly read and understand.
          Core mainly focuses on type-driven code generation using the <literal moreinfo="none">type_conv</literal> extension and doesn't fundamentally change the OCaml syntax.</para>

        <para>Another thing to consider before deploying your own syntax
        extension is compatibility with other extensions. Two separate
        extensions can create a grammar clash that leads to odd syntax errors
        and hard-to-reproduce bugs. That's why most of Core's syntax
        extensions go through <literal moreinfo="none">type_conv</literal>,
        which acts as a single point for extending the grammar via the
        <literal moreinfo="none">with</literal> keyword.</para>
      </caution>
    </sect2>

    <sect2 id="further-reading-on-camlp4">
      <title>Further Reading on Camlp4</title>

      <para>We've deliberately only shown you how to use Camlp4 extensions
      here, and not how to build your own. The full details of building new
      extensions are fairly daunting and could be the subject of an entirely
      new book.<indexterm class="singular">
          <primary>syntax extension</primary>

          <secondary>building new</secondary>
        </indexterm><indexterm class="singular">
          <primary>extensions</primary>

          <see>syntax extensions</see>
        </indexterm></para>

      <para>The best resources to get started are:<indexterm class="endofrange" startref="SEcamlp"/><indexterm class="endofrange" startref="camlp"/><indexterm class="endofrange" startref="SCpreproc"/><indexterm class="endofrange" startref="CPpreproc"/></para>

      <itemizedlist>
        <listitem>
          <para>A series of <ulink url="http://ambassadortothecomputers.blogspot.co.uk/p/reading-camlp4.html">blog
          posts</ulink> by Jake Donham describe the internals of Camlp4 and
          its syntax extension mechanism</para>
        </listitem>

        <listitem>
          <para>The online <ulink url="http://brion.inria.fr/gallium/index.php/Camlp4">Camlp4
          wiki</ulink></para>
        </listitem>

        <listitem>
          <para>Using OPAM to install existing Camlp4 extensions and
          inspecting their source code</para>
        </listitem>
      </itemizedlist>
    </sect2>
  </sect1>

  <sect1 id="static-type-checking">
    <title>Static Type Checking</title>

    <para>After obtaining a valid abstract syntax tree, the compiler has to
    verify that the code obeys the rules of the OCaml type system. Code that
    is syntactically correct but misuses values is rejected with an
    explanation of the problem.</para>

    <para>Although type checking is done in a single pass in OCaml, it
    actually consists of three distinct steps that happen
    simultaneously:<indexterm class="singular">
        <primary>explicit subtyping</primary>

        <seealso>subtyping</seealso>
      </indexterm><indexterm class="singular">
        <primary>automatic type inference</primary>

        <seealso>type inference</seealso>
      </indexterm><indexterm class="singular">
        <primary>subtyping</primary>

        <secondary sortas="static">in static type checking</secondary>
      </indexterm><indexterm class="singular">
        <primary>modules</primary>

        <secondary sortas="static">in static type checking</secondary>
      </indexterm><indexterm class="singular">
        <primary>type inference</primary>

        <secondary sortas="static">in static type checking</secondary>
      </indexterm><indexterm class="startofrange" id="CPstatictype">
        <primary>compilation process</primary>

        <secondary>static type checking</secondary>
      </indexterm></para>

    <variablelist>
      <varlistentry>
        <term>automatic type inference</term>

        <listitem>
          <para>An algorithm that calculates types for a module without
          requiring manual type annotations</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>module system</term>

        <listitem>
          <para>Combines software components with explicit knowledge of their
          type signatures</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>explicit subtyping</term>

        <listitem>
          <para>Checks for objects and polymorphic variants</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <para>Automatic type inference lets you write succinct code for a
    particular task and have the compiler ensure that your use of variables is
    locally consistent.</para>

    <para>Type inference doesn't scale to very large codebases that depend on separate compilation
      of files. A small change in one module may ripple through thousands of other files and
      libraries and require all of them to be recompiled. The module system solves this by providing
      the facility to combine and manipulate explicit type signatures for modules within a large
      project, and also to reuse them via functors and first-class modules.<indexterm class="singular">
        <primary>modules</primary>
        <secondary>benefits of</secondary>
      </indexterm><indexterm class="singular">
        <primary>type inference</primary>
        <secondary>drawbacks of</secondary>
      </indexterm></para>

    <para>Subtyping in OCaml objects is always an explicit operation (via the
    <literal moreinfo="none">:&gt;</literal> operator). This means that it
    doesn't complicate the core type inference engine and can be tested as a
    separate concern.</para>

    <sect2 id="displaying-inferred-types-from-the-compiler">
      <title>Displaying Inferred Types from the Compiler</title>

      <para>We've already seen how you can explore type inference directly
      from the toplevel. It's also possible to generate type signatures for an
      entire file by asking the compiler to do the work for you. Create a file
      with a single type definition and value:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/front-end/typedef.ml">OCaml</ulink></para>

      <programlisting format="linespecific" language="ocaml">type t = Foo | Bar
let v = Foo</programlisting>

      <para>Now run the compiler with the <literal moreinfo="none">-i</literal> flag to infer the type signature for that
      file. This runs the type checker but doesn't compile the code any
      further after displaying the interface to the standard output:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/front-end/infer_typedef.out">Terminal</ulink></para>

      <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">ocamlc -i typedef.ml</userinput>
<computeroutput moreinfo="none">type t = Foo | Bar</computeroutput>
<computeroutput moreinfo="none">val v : t</computeroutput></programlisting>

      <para>The output is the default signature for the module that represents the input file. It's
        often useful to redirect this output to an <literal moreinfo="none">mli</literal> file to
        give you a starting signature to edit the external interface without having to type it all
        in by hand.</para>

      <para>The compiler stores a compiled version of the interface as a
      <literal moreinfo="none">cmi</literal> file. This interface is either
      obtained from compiling an <literal moreinfo="none">mli</literal>
      signature file for a module, or by the inferred type if there is only an
      <literal moreinfo="none">ml</literal> implementation present.</para>

      <para>The compiler makes sure that your <literal moreinfo="none">ml</literal> and <literal moreinfo="none">mli</literal>
      files have compatible signatures. The type checker throws an immediate
      error if this isn't the case:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/front-end/conflicting_interfaces.out">Terminal</ulink></para>

      <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">echo type t = Foo &gt; test.ml</userinput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">echo type t = Bar &gt; test.mli</userinput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">ocamlc -c test.mli test.ml</userinput>
<computeroutput moreinfo="none">File "test.ml", line 1:</computeroutput>
<computeroutput moreinfo="none">Error: The implementation test.ml does not match the interface test.cmi:</computeroutput>
<computeroutput moreinfo="none">       Type declarations do not match:</computeroutput>
<computeroutput moreinfo="none">         type t = Foo</computeroutput>
<computeroutput moreinfo="none">       is not included in</computeroutput>
<computeroutput moreinfo="none">         type t = Bar</computeroutput>
<computeroutput moreinfo="none">       File "test.ml", line 1, characters 5-12: Actual declaration</computeroutput>
<computeroutput moreinfo="none">       Fields number 1 have different names, Foo and Bar.</computeroutput></programlisting>

      <note role="allow_break">
        <title>Which Comes First: The ml or the mli?</title>

        <para>There are two schools of thought on which order OCaml code
        should be written in. It's very easy to begin writing code by starting
        with an <literal moreinfo="none">ml</literal> file and using the type
        inference to guide you as you build up your functions. The <literal moreinfo="none">mli</literal> file can then be generated as described,
        and the exported functions documented.<indexterm class="singular">
            <primary>code compilers</primary>

            <secondary>order of code</secondary>

            <seealso>compilaton process</seealso>
          </indexterm><indexterm class="singular">
            <primary>mli files</primary>
          </indexterm><indexterm class="singular">
            <primary>files</primary>

            <secondary>mli files</secondary>
          </indexterm><indexterm class="singular">
            <primary>ml files</primary>
          </indexterm><indexterm class="singular">
            <primary>files</primary>

            <secondary>ml files</secondary>
          </indexterm></para>

        <para>If you're writing code that spans multiple files, it's sometimes easier to start by
          writing all the <literal moreinfo="none">mli</literal> signatures and checking that they
          type-check against one another. Once the signatures are in place, you can write the
          implementations with the confidence that they'll all glue together correctly, with no
          cyclic dependencies among the modules.</para>

        <para>As with any such stylistic debate, you should experiment with which system works best
          for you. Everyone agrees on one thing though: no matter in what order you write them,
          production code should always explicitly define an <literal moreinfo="none">mli</literal>
          file for every <literal moreinfo="none">ml</literal> file in the project. It's also
          perfectly fine to have an <literal moreinfo="none">mli</literal> file without a
          corresponding <literal moreinfo="none">ml</literal> file if you're only declaring
          signatures (such as module types).</para>

        <para>Signature files provide a place to write succinct documentation
        and to abstract internal details that shouldn't be exported.
        Maintaining separate signature files also speeds up incremental
        compilation in larger code bases, since recompiling a <literal moreinfo="none">mli</literal> signature is much faster than a full
        compilation of the implementation to native code.</para>
      </note>
    </sect2>

    <sect2 id="type-inference-1">
      <title>Type Inference</title>

      <para>Type inference is the process of determining the appropriate types
      for expressions based on their use. It's a feature that's partially
      present in many other languages such as Haskell and Scala, but OCaml
      embeds it as a fundamental feature throughout the core
      language.<indexterm class="singular">
          <primary>Hindley-Milner algorithm</primary>
        </indexterm><indexterm class="singular">
          <primary>type inference</primary>

          <secondary>algorithm basis of</secondary>
        </indexterm></para>

      <para>OCaml type inference is based on the Hindley-Milner algorithm,
      which is notable for its ability to infer the most general type for an
      expression without requiring any explicit type annotations. The
      algorithm can deduce multiple types for an expression and has the notion
      of a <emphasis>principal type</emphasis> that is the most general choice
      from the possible inferences. Manual type annotations can specialize the
      type explicitly, but the automatic inference selects the most general
      type unless told otherwise.</para>

      <para>OCaml does have some language extensions that strain the limits of
      principal type inference, but by and large, most programs you write will
      never <emphasis>require</emphasis> annotations (although they sometimes
      help the compiler produce better error messages).</para>

      <sect3 id="adding-type-annotations-to-find-errors">
        <title>Adding type annotations to find errors</title>

        <para>It's often said that the hardest part of writing OCaml code is
        getting past the type checker—but once the code does compile, it works
        correctly the first time! This is an exaggeration of course, but it
        can certainly feel true when moving from a dynamically typed language.
        The OCaml static type system protects you from certain classes of bugs
        such as memory errors and abstraction violations by rejecting your
        program at compilation time rather than by generating an error at
        runtime. Learning how to navigate the type checker's compile-time
        feedback is key to building robust libraries and applications that
        take full advantage of these static checks.<indexterm class="singular">
            <primary>type inference</primary>

            <secondary>error detection with</secondary>
          </indexterm><indexterm class="singular">
            <primary>annotations, for type checking</primary>
          </indexterm><indexterm class="singular">
            <primary>errors</primary>

            <secondary>detecting with type annotations</secondary>
          </indexterm><indexterm class="singular">
            <primary>type annotations</primary>
          </indexterm><indexterm class="singular">
            <primary>compile-time static checking</primary>
          </indexterm></para>

        <para>There are a couple of tricks to make it easier to quickly locate
        type errors in your code. The first is to introduce manual type
        annotations to narrow down the source of your error more accurately.
        These annotations shouldn't actually change your types and can be
        removed once your code is correct. However, they act as anchors to
        locate errors while you're still writing your code.</para>

        <para>Manual type annotations are particularly useful if you use lots
        of polymorphic variants or objects. Type inference with row
        polymorphism can generate some very large signatures, and errors tend
        to propagate more widely than if you are using more explicitly typed
        variants or classes.<indexterm class="singular">
            <primary>polymorphic variant types</primary>

            <secondary>type checking and</secondary>
          </indexterm><indexterm class="singular">
            <primary>row polymorphism</primary>
          </indexterm></para>

        <para>For instance, consider this broken example that expresses some
        simple algebraic operations over integers:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/front-end/broken_poly.ml">OCaml</ulink></para>

        <programlisting format="linespecific" language="ocaml">let rec algebra =
  function
  | `Add (x,y) -&gt; (algebra x) + (algebra y)
  | `Sub (x,y) -&gt; (algebra x) - (algebra y)
  | `Mul (x,y) -&gt; (algebra x) * (algebra y)
  | `Num x     -&gt; x

let _ =
  algebra (
    `Add (
      (`Num 0),
      (`Sub (
          (`Num 1),
          (`Mul (
              (`Nu 3),(`Num 2)
            ))
        ))
    ))</programlisting>

        <para>There's a single character typo in the code so that it uses
        <literal moreinfo="none">Nu</literal> instead of <literal moreinfo="none">Num</literal>. The resulting type error is
        impressive:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/front-end/build_broken_poly.out">Terminal</ulink></para>

        <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">ocamlc -c broken_poly.ml</userinput>
<computeroutput moreinfo="none">File "broken_poly.ml", line 9, characters 10-154:</computeroutput>
<computeroutput moreinfo="none">Error: This expression has type</computeroutput>
<computeroutput moreinfo="none">         [&gt; `Add of</computeroutput>
<computeroutput moreinfo="none">              ([&lt; `Add of 'a * 'a</computeroutput>
<computeroutput moreinfo="none">                | `Mul of 'a * 'a</computeroutput>
<computeroutput moreinfo="none">                | `Num of int</computeroutput>
<computeroutput moreinfo="none">                | `Sub of 'a * 'a</computeroutput>
<computeroutput moreinfo="none">                &gt; `Num ]</computeroutput>
<computeroutput moreinfo="none">               as 'a) *</computeroutput>
<computeroutput moreinfo="none">              [&gt; `Sub of 'a * [&gt; `Mul of [&gt; `Nu of int ] * [&gt; `Num of int ] ] ] ]</computeroutput>
<computeroutput moreinfo="none">       but an expression was expected of type 'a</computeroutput>
<computeroutput moreinfo="none">       The second variant type does not allow tag(s) `Nu</computeroutput></programlisting>

        <para>The type error is perfectly accurate, but rather verbose and
        with a line number that doesn't point to the exact location of the
        incorrect variant name. The best the compiler can do is to point you
        in the general direction of the <literal moreinfo="none">algebra</literal> function application.</para>

        <para>This is because the type checker doesn't have enough information
        to match the inferred type of the <literal moreinfo="none">algebra</literal> definition to its application a few
        lines down. It calculates types for both expressions separately, and
        when they don't match up, outputs the difference as best it
        can.</para>

        <para>Let's see what happens with an explicit type annotation to help
        the compiler out:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/front-end/broken_poly_with_annot.ml">OCaml</ulink></para>

        <programlisting format="linespecific" language="ocaml">type t = [
  | `Add of t * t
  | `Sub of t * t
  | `Mul of t * t
  | `Num of int
]

let rec algebra (x:t) =
  match x with
  | `Add (x,y) -&gt; (algebra x) + (algebra y)
  | `Sub (x,y) -&gt; (algebra x) - (algebra y)
  | `Mul (x,y) -&gt; (algebra x) * (algebra y)
  | `Num x     -&gt; x

let _ =
  algebra (
    `Add (
      (`Num 0),
      (`Sub (
          (`Num 1),
          (`Mul (
              (`Nu 3),(`Num 2)
            ))
        ))
    ))</programlisting>

        <para>This code contains exactly the same error as before, but we've
        added a closed type definition of the polymorphic variants, and a type
        annotation to the <literal moreinfo="none">algebra</literal>
        definition. The compiler error we get is much more useful now:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/front-end/build_broken_poly_with_annot.out">Terminal</ulink></para>

        <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">ocamlc -i broken_poly_with_annot.ml</userinput>
<computeroutput moreinfo="none">File "broken_poly_with_annot.ml", line 22, characters 14-21:</computeroutput>
<computeroutput moreinfo="none">Error: This expression has type [&gt; `Nu of int ]</computeroutput>
<computeroutput moreinfo="none">       but an expression was expected of type t</computeroutput>
<computeroutput moreinfo="none">       The second variant type does not allow tag(s) `Nu</computeroutput></programlisting>

        <para>This error points directly to the correct line number that
        contains the typo. Once you fix the problem, you can remove the manual
        annotations if you prefer more succinct code. You can also leave the
        annotations there, of course, to help with future refactoring and
        debugging.</para>
      </sect3>

      <sect3 id="enforcing-principal-typing">
        <title>Enforcing principal typing</title>

        <para>The compiler also has a stricter <emphasis>principal type checking</emphasis> mode
          that is activated via the <phrase role="keep-together"><literal moreinfo="none">-principal</literal></phrase> flag. This warns about risky uses of type information
          to ensure that the type inference has one principal result. A type is considered risky if
          the success or failure of type inference depends on the order in which subexpressions are
            typed.<indexterm class="singular">
            <primary>type inference</primary>
            <secondary>principality checks</secondary>
          </indexterm><indexterm class="singular">
            <primary>risky type</primary>
          </indexterm><indexterm class="singular">
            <primary>principal type checking</primary>
          </indexterm></para>

        <para>The principality check only affects a few language
        features:</para>

        <itemizedlist>
          <listitem>
            <para>Polymorphic methods for objects</para>
          </listitem>

          <listitem>
            <para>Permuting the order of labeled arguments in a function from
            their type definition</para>
          </listitem>

          <listitem>
            <para>Discarding optional labeled arguments</para>
          </listitem>

          <listitem>
            <para>Generalized algebraic data types (GADTs) present from OCaml 4.0 onward</para>
          </listitem>

          <listitem>
            <para>Automatic disambiguation of record field and constructor
            names (since OCaml 4.1)</para>
          </listitem>
        </itemizedlist>

        <para>Here's an example of principality warnings when used with record
        disambiguation.</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/front-end/non_principal.ml">OCaml</ulink></para>

        <programlisting format="linespecific" language="ocaml">type s = { foo: int; bar: unit }
type t = { foo: int }

let f x =
  x.bar;
  x.foo</programlisting>

        <para>Inferring the signature with <literal moreinfo="none">-principal</literal> will show you a new
        warning:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/front-end/build_non_principal.out">Terminal</ulink></para>

        <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">ocamlc -i -principal non_principal.ml</userinput>
<computeroutput moreinfo="none">File "non_principal.ml", line 6, characters 4-7:</computeroutput>
<computeroutput moreinfo="none">Warning 18: this type-based field disambiguation is not principal.</computeroutput>
<computeroutput moreinfo="none">type s = { foo : int; bar : unit; }</computeroutput>
<computeroutput moreinfo="none">type t = { foo : int; }</computeroutput>
<computeroutput moreinfo="none">val f : s -&gt; int</computeroutput></programlisting>

        <para>This example isn't principal, since the inferred type for
        <literal moreinfo="none">x.foo</literal> is guided by the inferred
        type of <literal moreinfo="none">x.bar</literal>, whereas principal
        typing requires that each subexpression's type can be calculated
        independently. If the <literal moreinfo="none">x.bar</literal> use is
        removed from the definition of <literal moreinfo="none">f</literal>,
        its argument would be of type <literal moreinfo="none">t</literal> and
        not <literal moreinfo="none">type s</literal>.</para>

        <para>You can fix this either by permuting the order of the type
        declarations, or by adding an explicit type annotation:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/front-end/principal.ml">OCaml</ulink></para>

        <programlisting format="linespecific" language="ocaml">type s = { foo: int; bar: unit }
type t = { foo: int }

let f (x:s) =
  x.bar;
  x.foo</programlisting>

        <para>There is now no ambiguity about the inferred types, since we've
        explicitly given the argument a type, and the order of inference of
        the subexpressions no longer matters.</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/front-end/build_principal.out">Terminal</ulink></para>

        <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">ocamlc -i -principal principal.ml</userinput>
<computeroutput moreinfo="none">type s = { foo : int; bar : unit; }</computeroutput>
<computeroutput moreinfo="none">type t = { foo : int; }</computeroutput>
<computeroutput moreinfo="none">val f : s -&gt; int</computeroutput></programlisting>

        <para>The <command moreinfo="none">ocamlbuild</command> equivalent is to add the tag
            <literal moreinfo="none">principal</literal> to your build. The
            <emphasis>corebuild</emphasis> wrapper script actually adds this by default, but it does
          no harm to explicitly repeat it:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/principal/build_principal.out">Terminal</ulink></para>

        <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">corebuild -tag principal principal.cmi non_principal.cmi</userinput>
<computeroutput moreinfo="none">File "non_principal.ml", line 6, characters 4-7:</computeroutput>
<computeroutput moreinfo="none">Warning 18: this type-based field disambiguation is not principal.</computeroutput></programlisting>

        <para>Ideally, all code should systematically use <literal moreinfo="none">-principal</literal>. It reduces variance in type inference and enforces the notion of
          a single known type. However, there are drawbacks to this mode: type inference is slower,
          and the <literal moreinfo="none">cmi</literal> files become larger. This is generally only
          a problem if you extensively use objects, which usually have larger type signatures to
          cover all their methods.</para>

        <para>If compiling in principal mode works, it is guaranteed that the
        program will pass type checking in nonprincipal mode, too. For this
        reason, the <command moreinfo="none">corebuild</command> wrapper
        script activates principal mode by default, preferring stricter type
        inference over a small loss in compilation speed and extra disk space
        usage.</para>

        <para>Bear in mind that the <literal moreinfo="none">cmi</literal> files generated in
          principal mode differ from the default mode. Try to ensure that you compile your whole
          project with it activated. Getting the files mixed up won't let you violate type safety,
          but it can result in the type checker failing unexpectedly very occasionally. In this
          case, just recompile with a clean source tree.</para>
      </sect3>
    </sect2>

    <sect2 id="modules-and-separate-compilation">
      <title>Modules and Separate Compilation</title>

      <para>The OCaml module system enables smaller components to be reused
      effectively in large projects while still retaining all the benefits of
      static type safety. We covered the basics of using modules earlier in
      <xref linkend="files-modules-and-programs"/>. The module language that
      operates over these signatures also extends to functors and first-class
      modules, described in <xref linkend="functors"/> and <xref linkend="first-class-modules"/>, respectively.<indexterm class="singular">
          <primary>modules</primary>

          <secondary>separate compilation in</secondary>
        </indexterm></para>

      <para>This section discusses how the compiler implements them in more
      detail. Modules are essential for larger projects that consist of many
      source files (also known as <emphasis>compilation units</emphasis>).
      It's impractical to recompile every single source file when changing
      just one or two files, and the module system minimizes such
      recompilation while still encouraging code reuse.<indexterm class="singular">
          <primary>compilation units</primary>
        </indexterm></para>

      <sect3 id="the-mapping-between-files-and-modules">
        <title>The mapping between files and modules</title>

        <para>Individual compilation units provide a convenient way to break
        up a big module hierarchy into a collection of files. The relationship
        between files and modules can be explained directly in terms of the
        module system.<indexterm class="singular">
            <primary>files</primary>

            <secondary>relationship with modules</secondary>
          </indexterm></para>

        <para>Create a file called <literal moreinfo="none">alice.ml</literal>
        with the following contents:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/front-end/alice.ml">OCaml</ulink></para>

        <programlisting format="linespecific" language="ocaml">let friends = [ Bob.name ]</programlisting>

        <para>and a corresponding signature file:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/front-end/alice.mli">OCaml</ulink></para>

        <programlisting format="linespecific" language="ocaml">val friends : Bob.t list</programlisting>

        <para>These two files are exactly analogous to including the following
        code directly in another module that references <literal moreinfo="none">Alice</literal>:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/front-end/alice_combined.ml">OCaml</ulink></para>

        <programlisting format="linespecific" language="ocaml">module Alice : sig
  val friends : Bob.t list
end = struct
  let friends = [ Bob.name ]
end</programlisting>
      </sect3>

      <sect3 id="defining-a-module-search-path">
        <title>Defining a module search path</title>

        <para>In the preceding example, <literal moreinfo="none">Alice</literal> also has a reference to another module
        <literal moreinfo="none">Bob</literal>. For the overall type of
        <literal moreinfo="none">Alice</literal> to be valid, the compiler
        also needs to check that the <literal moreinfo="none">Bob</literal>
        module contains at least a <literal moreinfo="none">Bob.name</literal>
        value and defines a <literal moreinfo="none">Bob.t</literal>
        type.<indexterm class="singular">
            <primary>modules</primary>

            <secondary>defining search paths</secondary>
          </indexterm></para>

        <para>The type checker resolves such module references into concrete
        structures and signatures in order to unify types across module
        boundaries. It does this by searching a list of directories for a
        compiled interface file matching that module's name. For example, it
        will look for <literal moreinfo="none">alice.cmi</literal> and
        <literal moreinfo="none">bob.cmi</literal> on the search path and use
        the first ones it encounters as the interfaces for <literal moreinfo="none">Alice</literal> and <literal moreinfo="none">Bob</literal>.</para>

        <para>The module search path is set by adding <literal moreinfo="none">-I</literal> flags to the compiler command line with
        the directory containing the <literal moreinfo="none">cmi</literal>
        files as the argument. Manually specifying these flags gets complex
        when you have lots of libraries, and is the reason why the OCamlfind
        frontend to the compiler exists. OCamlfind automates the process of
        turning third-party package names and build descriptions into
        command-line flags that are passed to the compiler command
        line.</para>

        <para>By default, only the current directory and the OCaml standard
        library will be searched for <literal moreinfo="none">cmi</literal>
        files. The <literal moreinfo="none">Pervasives</literal> module from
        the standard library will also be opened by default in every
        compilation unit. The standard library location is obtained by running
        <literal moreinfo="none">ocamlc -where</literal> and can be overridden
        by setting the <literal moreinfo="none">CAMLLIB</literal> environment
        variable. Needless to say, don't override the default path unless you
        have a good reason to (such as setting up a cross-compilation
        environment).<indexterm class="singular">
            <primary>cmi files</primary>
          </indexterm><indexterm class="singular">
            <primary>files</primary>

            <secondary>cmi files</secondary>
          </indexterm><indexterm class="singular">
            <primary>OCaml toolchain</primary>

            <secondary>ocamlogjinfo</secondary>
          </indexterm></para>

        <sidebar>
          <title>Inspecting Compilation Units with ocamlobjinfo</title>

          <para>For separate compilation to be sound, we need to ensure that
          all the <literal moreinfo="none">cmi</literal> files used to
          type-check a module are the same across compilation runs. If they
          vary, this raises the possibility of two modules checking different
          type signatures for a common module with the same name. This in turn
          lets the program completely violate the static type system and can
          lead to memory corruption and crashes.</para>

          <para>OCaml guards against this by recording a MD5 checksum in every
          <literal moreinfo="none">cmi</literal>. Let's examine our earlier
          <literal moreinfo="none">typedef.ml</literal> more closely:</para>

          <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/front-end/typedef_objinfo.out">Terminal</ulink></para>

          <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">ocamlc -c typedef.ml</userinput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">ocamlobjinfo typedef.cmi</userinput>
<computeroutput moreinfo="none">File typedef.cmi</computeroutput>
<computeroutput moreinfo="none">Unit name: Typedef</computeroutput>
<computeroutput moreinfo="none">Interfaces imported:</computeroutput>
<computeroutput moreinfo="none">	bd274dc132ce5c3d8b6774d19cd373a6	Typedef</computeroutput>
<computeroutput moreinfo="none">	36b5bc8227dc9914c6d9fd9bdcfadb45	Pervasives</computeroutput></programlisting>

          <para><literal moreinfo="none">ocamlobjinfo</literal> examines the
          compiled interface and displays what other compilation units it
          depends on. In this case, we don't use any external modules other
          than <literal moreinfo="none">Pervasives</literal>. Every module
          depends on <literal moreinfo="none">Pervasives</literal> by default,
          unless you use the <literal moreinfo="none">-nopervasives</literal>
          flag (this is an advanced use case, and you shouldn't normally need
          it).</para>

          <para>The long alphanumeric identifier beside each module name is a
          hash calculated from all the types and values exported from that
          compilation unit. It's used during type-checking and linking to
          ensure that all of the compilation units have been compiled
          consistently against one another. A difference in the hashes means
          that a compilation unit with the same module name may have
          conflicting type signatures in different modules. The compiler will
          reject such programs with an error similar to this:</para>

          <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/front-end/inconsistent_compilation_units.out">Terminal</ulink></para>

          <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">ocamlc -c foo.ml</userinput>
<computeroutput moreinfo="none">File "foo.ml", line 1, characters 0-1:</computeroutput>
<computeroutput moreinfo="none">Error: The files /home/build/bar.cmi</computeroutput>
<computeroutput moreinfo="none">       and /usr/lib/ocaml/map.cmi make inconsistent assumptions</computeroutput>
<computeroutput moreinfo="none">       over interface Map</computeroutput></programlisting>

          <para>This hash check is very conservative, but ensures that
          separate compilation remains type-safe all the way up to the final
          link phase. Your build system should ensure that you never see the
          preceding error messages, but if you do run into it, just clean out
          your intermediate files and recompile from scratch.</para>
        </sidebar>
      </sect3>
    </sect2>

    <sect2 id="packing-modules-together">
      <title>Packing Modules Together</title>

      <para>The module-to-file mapping described so far rigidly enforces a 1:1
      mapping between a top-level module and a file. It's often convenient to
      split larger modules into separate files to make editing easier, but
      still compile them all into a single OCaml module.<indexterm class="singular">
          <primary>modules</primary>

          <secondary>packing together</secondary>
        </indexterm></para>

      <para>The <literal moreinfo="none">-pack</literal> compiler option
      accepts a list of compiled object files (<literal moreinfo="none">.cmo</literal> in bytecode and <literal moreinfo="none">.cmx</literal> for native code) and their associated
      <literal moreinfo="none">.cmi</literal> compiled interfaces, and
      combines them into a single module that contains them as submodules of
      the output. Packing thus generates an entirely new <literal moreinfo="none">.cmo</literal> (or <literal moreinfo="none">.cmx</literal> file) and <literal moreinfo="none">.cmi</literal> that includes the input modules.</para>

      <para>Packing for native code introduces an additional requirement: the
      modules that are intended to be packed must be compiled with the
      <literal moreinfo="none">-for-pack</literal> argument that specifies the
      eventual name of the pack. The easiest way to handle packing is to let
      <command moreinfo="none">ocamlbuild</command> figure out the
      command-line arguments for you, so let's try that out next with a simple
      example.</para>

      <para>First, create a couple of toy modules called <literal moreinfo="none">A.ml</literal> and <literal moreinfo="none">B.ml</literal> that contain a single value. You will
      also need a <literal moreinfo="none">_tags</literal> file that adds the
      <literal moreinfo="none">-for-pack</literal> option for the <literal moreinfo="none">cmx</literal> files (but careful to exclude the pack
      target itself). Finally, the <literal moreinfo="none">X.mlpack</literal>
      file contains the list of modules that are intended to be packed under
      module <literal moreinfo="none">X</literal>. There are special rules in
      <command moreinfo="none">ocamlbuild</command> that tell it how to map
      <literal moreinfo="none">%.mlpack</literal> files to the packed <literal moreinfo="none">%.cmx</literal> or <literal moreinfo="none">%.cmo</literal> equivalent:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/packing/show_files.out">Terminal</ulink></para>

      <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">cat A.ml</userinput>
<computeroutput moreinfo="none">let v = "hello"</computeroutput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">cat B.ml</userinput>
<computeroutput moreinfo="none">let w = 42</computeroutput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">cat _tags</userinput>
<computeroutput moreinfo="none">&lt;*.cmx&gt; and not "X.cmx": for-pack(X)</computeroutput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">cat X.mlpack</userinput>
<computeroutput moreinfo="none">A</computeroutput>
<computeroutput moreinfo="none">B</computeroutput></programlisting>

      <para>You can now run <emphasis>corebuild</emphasis> to build the <literal moreinfo="none">X.cmx</literal> file directly, but let's create a new module to link against <literal moreinfo="none">X</literal> to complete the example:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/packing/test.ml">OCaml</ulink></para>

      <programlisting format="linespecific" language="ocaml">let v = X.A.v
let w = X.B.w</programlisting>

      <para>You can now compile this test module and see that its inferred
      interface is the result of using the packed contents of <literal moreinfo="none">X</literal>. We further verify this by examining the
      imported interfaces in <literal moreinfo="none">Test</literal> and
      confirming that neither <literal moreinfo="none">A</literal> nor
      <literal moreinfo="none">B</literal> are mentioned in there and that
      only the packed <literal moreinfo="none">X</literal> module is
      used:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/packing/build_test.out">Terminal</ulink></para>

      <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">corebuild test.inferred.mli test.cmi</userinput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">cat _build/test.inferred.mli</userinput>
<computeroutput moreinfo="none">val v : string</computeroutput>
<computeroutput moreinfo="none">val w : int</computeroutput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">ocamlobjinfo _build/test.cmi</userinput>
<computeroutput moreinfo="none">File _build/test.cmi</computeroutput>
<computeroutput moreinfo="none">Unit name: Test</computeroutput>
<computeroutput moreinfo="none">Interfaces imported:</computeroutput>
<computeroutput moreinfo="none">	906fc1b74451f0c24ceaa085e0f26e5f	Test</computeroutput>
<computeroutput moreinfo="none">	36b5bc8227dc9914c6d9fd9bdcfadb45	Pervasives</computeroutput>
<computeroutput moreinfo="none">	25f4b4e10ec64c56b2987f5900045fec	X</computeroutput></programlisting>

      <warning>
        <title>Packing and Search Paths</title>

        <para>One very common build error that happens with packing is
        confusion resulting from building the packed <literal moreinfo="none">cmi</literal> in the same directory as the submodules.
        When you add this directory to your module search path, the submodules
        are also visible. If you forget to include the top-level prefix (e.g.,
        <literal moreinfo="none">X.A</literal>) and instead use a submodule
        directly (<literal moreinfo="none">A</literal>), then this will
        compile and link fine.</para>

        <para>However, the types of <literal moreinfo="none">A</literal> and <literal moreinfo="none">X.A</literal> are <emphasis>not</emphasis> automatically equivalent so
          the type checker will complain if you attempt to mix and match the packed and unpacked
          versions of the library.</para>

        <para>This mostly only happens with unit tests, since they are built at the same time as the
          library. You can avoid it by being aware of the need to open the packed module from the
          test, or only using the library after it has been installed (and hence not exposing the
          intermediate compiled modules).</para>
      </warning>
    </sect2>

    <sect2 id="shorter-module-paths-in-type-errors">
      <title>Shorter Module Paths in Type Errors</title>

      <para>Core uses the OCaml module system quite extensively to provide a complete replacement
        standard library. It collects these modules into a single <literal moreinfo="none">Std</literal> module, which provides a single module that needs to be opened to import
        the replacement modules and functions.<indexterm class="singular">
          <primary>errors</primary>
          <secondary>reducing verbosity in</secondary>
        </indexterm></para>

      <para>There's one downside to this approach: type errors suddenly get
      much more verbose. We can see this if you run the vanilla OCaml toplevel
      (not <command moreinfo="none">utop</command>).</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/front-end/short_paths_1.out">Terminal</ulink></para>

      <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">ocaml</userinput>
<computeroutput moreinfo="none"># List.map print_endline "" ;;</computeroutput>
<computeroutput moreinfo="none">Error: This expression has type string but an expression was expected of type</computeroutput>
<computeroutput moreinfo="none">         string list</computeroutput></programlisting>

      <para>This type error without <literal moreinfo="none">Core.Std</literal> has a straightforward type error.
      When we switch to Core, though, it gets more verbose:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/front-end/short_paths_2.out">Terminal</ulink></para>

      <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">ocaml</userinput>
<computeroutput moreinfo="none"># open Core.Std ;;</computeroutput>
<computeroutput moreinfo="none"># List.map ~f:print_endline "" ;;</computeroutput>
<computeroutput moreinfo="none">Error: This expression has type string but an expression was expected of type</computeroutput>
<computeroutput moreinfo="none">         'a Core.Std.List.t = 'a list</computeroutput></programlisting>

      <para>The default <literal moreinfo="none">List</literal> module in
      OCaml is overridden by <literal moreinfo="none">Core.Std.List</literal>.
      The compiler does its best to show the type equivalence, but at the cost
      of a more verbose error message.</para>

      <para>The compiler can remedy this via a so-called short paths
      heuristic. This causes the compiler to search all the type aliases for
      the shortest module path and use that as the preferred output type. The
      option is activated by passing <literal moreinfo="none">-short-paths</literal> to the compiler, and works on the
      toplevel, too.<indexterm class="singular">
          <primary>short paths heuristic</primary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/front-end/short_paths_3.out">Terminal</ulink></para>

      <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">ocaml -short-paths</userinput>
<computeroutput moreinfo="none"># open Core.Std;;</computeroutput>
<computeroutput moreinfo="none"># List.map ~f:print_endline "foo";;</computeroutput>
<computeroutput moreinfo="none">Error: This expression has type string but an expression was expected of type</computeroutput>
<computeroutput moreinfo="none">         'a list</computeroutput></programlisting>

      <para>The <command moreinfo="none">utop</command> enhanced toplevel activates short paths by
        default, which is why we have not had to do this before in our interactive examples.
        However, the compiler doesn't default to the short path heuristic, since there are some
        situations where the type aliasing information is useful to know, and it would be lost in
        the error if the shortest module path is always picked.</para>

      <para>You'll need to choose for yourself if you prefer short paths or
      the default behavior in your own projects, and pass the <literal moreinfo="none">-short-paths</literal> flag to the compiler if you need
      it.<indexterm class="endofrange" startref="CPstatictype"/></para>
    </sect2>
  </sect1>

  <sect1 id="the-typed-syntax-tree">
    <title>The Typed Syntax Tree</title>

    <para>When the type checking process has successfully completed, it is
    combined with the AST to form a <emphasis>typed abstract syntax
    tree</emphasis>. This contains precise location information for every
    token in the input file, and decorates each token with concrete type
    information.<indexterm class="singular">
        <primary>cmti files</primary>
      </indexterm><indexterm class="singular">
        <primary>cmt files</primary>
      </indexterm><indexterm class="singular">
        <primary>files</primary>

        <secondary>cmtii files</secondary>
      </indexterm><indexterm class="singular">
        <primary>files</primary>

        <secondary>cmt files</secondary>
      </indexterm><indexterm class="singular">
        <primary>AST (abstract syntax-tree)</primary>
      </indexterm><indexterm class="startofrange" id="typesyntree">
        <primary>typed syntax tree</primary>
      </indexterm><indexterm class="startofrange" id="CPtypsyn">
        <primary>compilation process</primary>

        <secondary>typed syntax tree</secondary>
      </indexterm></para>

    <para>The compiler can output this as compiled <literal moreinfo="none">cmt</literal> and <literal moreinfo="none">cmti</literal>
    files that contain the typed AST for the implementation and signatures of
    a compilation unit. This is activated by passing the <literal moreinfo="none">-bin-annot</literal> flag to the compiler.</para>

    <para>The <literal moreinfo="none">cmt</literal> files are particularly
    useful for IDE tools to match up OCaml source code at a specific location
    to the inferred or external types.</para>

    <sect2 id="using-ocp-index-for-auto-completion">
      <title>Using ocp-index for Autocompletion</title>

      <para>One such command-line tool to display autocompletion information
      in your editor is <command moreinfo="none">ocp-index</command>. Install
      it via OPAM as follows:<indexterm class="singular">
          <primary>autocompletion</primary>
        </indexterm><indexterm class="singular">
          <primary>ocp-index</primary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/front-end/install_ocp_index.out">Terminal</ulink></para>

      <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">opam install ocp-index</userinput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">ocp-index</userinput></programlisting>

      <para>Let's refer back to our Ncurses binding example from the beginning
      of <xref linkend="foreign-function-interface"/>. This module defined
      bindings for the Ncurses library. First, compile the interfaces with
      <phrase><literal moreinfo="none" role="keep-together">-bin-annot</literal></phrase> so that we can obtain the
        <literal moreinfo="none">cmt</literal> and <literal moreinfo="none">cmti</literal> files, and then run <command moreinfo="none">ocp-index</command> in completion mode:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/ocp-index/index_ncurses.out">Terminal</ulink></para>

      <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">corebuild -pkg ctypes.foreign -tag bin_annot ncurses.cmi</userinput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">ocp-index complete -I . Ncur</userinput>
<computeroutput moreinfo="none">Ncurses module</computeroutput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">ocp-index complete -I . Ncurses.a</userinput>
<computeroutput moreinfo="none">Ncurses.addstr val string -&gt; unit</computeroutput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">ocp-index complete -I . Ncurses.</userinput>
<computeroutput moreinfo="none">Ncurses.window val Ncurses.window Ctypes.typ</computeroutput>
<computeroutput moreinfo="none">Ncurses.wrefresh val Ncurses.window -&gt; unit</computeroutput>
<computeroutput moreinfo="none">Ncurses.initscr val unit -&gt; Ncurses.window</computeroutput>
<computeroutput moreinfo="none">Ncurses.endwin val unit -&gt; unit</computeroutput>
<computeroutput moreinfo="none">Ncurses.refresh val unit -&gt; unit</computeroutput>
<computeroutput moreinfo="none">Ncurses.newwin val int -&gt; int -&gt; int -&gt; int -&gt; Ncurses.window</computeroutput>
<computeroutput moreinfo="none">Ncurses.mvwaddch val Ncurses.window -&gt; int -&gt; int -&gt; char -&gt; unit</computeroutput>
<computeroutput moreinfo="none">Ncurses.mvwaddstr val Ncurses.window -&gt; int -&gt; int -&gt; string -&gt; unit</computeroutput>
<computeroutput moreinfo="none">Ncurses.addstr val string -&gt; unit</computeroutput>
<computeroutput moreinfo="none">Ncurses.box val Ncurses.window -&gt; char -&gt; char -&gt; unit</computeroutput>
<computeroutput moreinfo="none">Ncurses.cbreak val unit -&gt; int</computeroutput></programlisting>

      <para>You need to pass <command moreinfo="none">ocp-index</command> a set of directories to
        search for <literal moreinfo="none">cmt</literal> files in, and a fragment of text to
        autocomplete. As you can imagine, autocompletion is invaluable on larger codebases. See the
          <ulink url="https://github.com/ocamlpro/ocp-index"><emphasis>ocp-index</emphasis></ulink>
        home page for more information on how to integrate it with your favorite editor.</para>
    </sect2>

    <sect2 id="examining-the-typed-syntax-tree-directly">
      <title>Examining the Typed Syntax Tree Directly</title>

      <para>The compiler has a couple of advanced flags that can dump the raw
      output of the internal AST representation. You can't depend on these
      flags to give the same output across compiler revisions, but they are a
      useful learning tool.<indexterm class="singular">
          <primary>flags</primary>
        </indexterm></para>

      <para>We'll use our toy <literal moreinfo="none">typedef.ml</literal>
      again:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/front-end/typedef.ml">OCaml</ulink></para>

      <programlisting format="linespecific" language="ocaml">type t = Foo | Bar
let v = Foo</programlisting>

      <para>Let's first look at the untyped syntax tree that's generated from
      the parsing phase:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/front-end/parsetree_typedef.out">Terminal</ulink></para>

      <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">ocamlc -dparsetree typedef.ml 2&gt;&amp;1</userinput>
<computeroutput moreinfo="none">[</computeroutput>
<computeroutput moreinfo="none">  structure_item (typedef.ml[1,0+0]..[1,0+18])</computeroutput>
<computeroutput moreinfo="none">    Pstr_type</computeroutput>
<computeroutput moreinfo="none">    [</computeroutput>
<computeroutput moreinfo="none">      "t" (typedef.ml[1,0+5]..[1,0+6])</computeroutput>
<computeroutput moreinfo="none">        type_declaration (typedef.ml[1,0+5]..[1,0+18])</computeroutput>
<computeroutput moreinfo="none">          ptype_params =</computeroutput>
<computeroutput moreinfo="none">            []</computeroutput>
<computeroutput moreinfo="none">          ptype_cstrs =</computeroutput>
<computeroutput moreinfo="none">            []</computeroutput>
<computeroutput moreinfo="none">          ptype_kind =</computeroutput>
<computeroutput moreinfo="none">            Ptype_variant</computeroutput>
<computeroutput moreinfo="none">              [</computeroutput>
<computeroutput moreinfo="none">                (typedef.ml[1,0+9]..[1,0+12])</computeroutput>
<computeroutput moreinfo="none">                  "Foo" (typedef.ml[1,0+9]..[1,0+12])</computeroutput>
<computeroutput moreinfo="none">                  []</computeroutput>
<computeroutput moreinfo="none">                  None</computeroutput>
<computeroutput moreinfo="none">                (typedef.ml[1,0+15]..[1,0+18])</computeroutput>
<computeroutput moreinfo="none">                  "Bar" (typedef.ml[1,0+15]..[1,0+18])</computeroutput>
<computeroutput moreinfo="none">                  []</computeroutput>
<computeroutput moreinfo="none">                  None</computeroutput>
<computeroutput moreinfo="none">              ]</computeroutput>
<computeroutput moreinfo="none">          ptype_private = Public</computeroutput>
<computeroutput moreinfo="none">          ptype_manifest =</computeroutput>
<computeroutput moreinfo="none">            None</computeroutput>
<computeroutput moreinfo="none">    ]</computeroutput>
<computeroutput moreinfo="none">  structure_item (typedef.ml[2,19+0]..[2,19+11])</computeroutput>
<computeroutput moreinfo="none">    Pstr_value Nonrec</computeroutput>
<computeroutput moreinfo="none">    [</computeroutput>
<computeroutput moreinfo="none">      &lt;def&gt;</computeroutput>
<computeroutput moreinfo="none">        pattern (typedef.ml[2,19+4]..[2,19+5])</computeroutput>
<computeroutput moreinfo="none">          Ppat_var "v" (typedef.ml[2,19+4]..[2,19+5])</computeroutput>
<computeroutput moreinfo="none">        expression (typedef.ml[2,19+8]..[2,19+11])</computeroutput>
<computeroutput moreinfo="none">          Pexp_construct "Foo" (typedef.ml[2,19+8]..[2,19+11])</computeroutput>
<computeroutput moreinfo="none">          None</computeroutput>
<computeroutput moreinfo="none">          false</computeroutput>
<computeroutput moreinfo="none">    ]</computeroutput>
<computeroutput moreinfo="none">]</computeroutput>
<computeroutput moreinfo="none"> </computeroutput></programlisting>

      <para>This is rather a lot of output for a simple two-line program, but
      it shows just how much structure the OCaml parser generates even from a
      small source file.</para>

      <para>Each portion of the AST is decorated with the precise location information (including
        the filename and character location of the token). This code hasn't been type checked yet,
        so the raw tokens are all included.</para>

      <para>The typed AST that is normally output as a compiled <literal moreinfo="none">cmt</literal> file can be displayed in a more
      developer-readable form via the <literal moreinfo="none">-dtypedtree</literal> option:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/front-end/typedtree_typedef.out">Terminal</ulink></para>

      <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">ocamlc -dtypedtree typedef.ml 2&gt;&amp;1</userinput>
<computeroutput moreinfo="none">[</computeroutput>
<computeroutput moreinfo="none">  structure_item (typedef.ml[1,0+0]..typedef.ml[1,0+18])</computeroutput>
<computeroutput moreinfo="none">    Pstr_type</computeroutput>
<computeroutput moreinfo="none">    [</computeroutput>
<computeroutput moreinfo="none">      t/1008</computeroutput>
<computeroutput moreinfo="none">        type_declaration (typedef.ml[1,0+5]..typedef.ml[1,0+18])</computeroutput>
<computeroutput moreinfo="none">          ptype_params =</computeroutput>
<computeroutput moreinfo="none">            []</computeroutput>
<computeroutput moreinfo="none">          ptype_cstrs =</computeroutput>
<computeroutput moreinfo="none">            []</computeroutput>
<computeroutput moreinfo="none">          ptype_kind =</computeroutput>
<computeroutput moreinfo="none">            Ptype_variant</computeroutput>
<computeroutput moreinfo="none">              [</computeroutput>
<computeroutput moreinfo="none">                "Foo/1009"</computeroutput>
<computeroutput moreinfo="none">                  []</computeroutput>
<computeroutput moreinfo="none">                "Bar/1010"</computeroutput>
<computeroutput moreinfo="none">                  []</computeroutput>
<computeroutput moreinfo="none">              ]</computeroutput>
<computeroutput moreinfo="none">          ptype_private = Public</computeroutput>
<computeroutput moreinfo="none">          ptype_manifest =</computeroutput>
<computeroutput moreinfo="none">            None</computeroutput>
<computeroutput moreinfo="none">    ]</computeroutput>
<computeroutput moreinfo="none">  structure_item (typedef.ml[2,19+0]..typedef.ml[2,19+11])</computeroutput>
<computeroutput moreinfo="none">    Pstr_value Nonrec</computeroutput>
<computeroutput moreinfo="none">    [</computeroutput>
<computeroutput moreinfo="none">      &lt;def&gt;</computeroutput>
<computeroutput moreinfo="none">        pattern (typedef.ml[2,19+4]..typedef.ml[2,19+5])</computeroutput>
<computeroutput moreinfo="none">          Ppat_var "v/1011"</computeroutput>
<computeroutput moreinfo="none">        expression (typedef.ml[2,19+8]..typedef.ml[2,19+11])</computeroutput>
<computeroutput moreinfo="none">          Pexp_construct "Foo"</computeroutput>
<computeroutput moreinfo="none">          []</computeroutput>
<computeroutput moreinfo="none">          false</computeroutput>
<computeroutput moreinfo="none">    ]</computeroutput>
<computeroutput moreinfo="none">]</computeroutput>
<computeroutput moreinfo="none"> </computeroutput></programlisting>

      <para>The typed AST is more explicit than the untyped syntax tree. For
      instance, the type declaration has been given a unique name (<literal moreinfo="none">t/1008</literal>), as has the <literal moreinfo="none">v</literal> value (<literal moreinfo="none">v/1011</literal>).<indexterm class="endofrange" startref="typesyntree"/><indexterm class="endofrange" startref="CPtypsyn"/></para>

      <para>You'll rarely need to look at this raw output from the compiler unless you're building
        IDE tools such as <command moreinfo="none">ocp-index</command>, or are hacking on extensions
        to the core compiler itself. However, it's useful to know that this intermediate form exists
        before we delve further into the code generation process next, in <xref linkend="the-compiler-backend-byte-code-and-native-code"/>.</para>
      <para>There are several new integrated tools emerging that combine these typed AST files with common editors such as Emacs or Vim.  The best of these is <ulink url="https://github.com/def-lkb/merlin">Merlin</ulink>, which adds value and module autocompletion, displays inferred types and can build and display errors directly from within your editor.  There are instructions available on its homepage for configuring Merlin with your favorite editor.</para>
    </sect2>
  </sect1>
</chapter>

    <chapter id="the-compiler-backend-byte-code-and-native-code">
  <title>The Compiler Backend: Bytecode and Native code</title>

  <para>Once OCaml has passed the type checking stage, it can stop emitting
  syntax and type errors and begin the process of compiling the well-formed
  modules into executable code.</para>

  <para>In this chapter, we'll cover the following topics:</para>

  <itemizedlist>
    <listitem>
      <para>The untyped intermediate lambda code where pattern matching is
      optimized</para>
    </listitem>

    <listitem>
      <para>The bytecode <command moreinfo="none">ocamlc</command> compiler
      and <command moreinfo="none">ocamlrun</command> interpreter</para>
    </listitem>

    <listitem>
      <para>The native code <command moreinfo="none">ocamlopt</command> code
      generator, and debugging and profiling native code</para>
    </listitem>
  </itemizedlist>

  <sect1 id="the-untyped-lambda-form">
    <title>The Untyped Lambda Form</title>

    <para>The first code generation phase eliminates all the static type
    information into a simpler intermediate <emphasis>lambda form</emphasis>.
    The lambda form discards higher-level constructs such as modules and
    objects and replaces them with simpler values such as records and function
    pointers. Pattern matches are also analyzed and compiled into highly
    optimized automata.<indexterm class="singular">
        <primary>lambda form code</primary>

        <secondary>basics of</secondary>
      </indexterm><indexterm class="startofrange" id="CPuntype">
        <primary>compilation process</primary>

        <secondary>untyped lambda form</secondary>
      </indexterm></para>

    <para>The lambda form is the key stage that discards the OCaml type information and maps the
      source code to the runtime memory model described in <xref linkend="memory-representation-of-values"/>. This stage also performs some optimizations,
      most notably converting pattern-match statements into more optimized but low-level
      statements.</para>

    <sect2 id="pattern-matching-optimization">
      <title>Pattern Matching Optimization</title>

      <para>The compiler dumps the lambda form in an s-expression syntax if you add the <phrase role="keep-together"><literal moreinfo="none">-dlambda</literal></phrase> directive to the
        command line. Let's use this to learn more about how the OCaml pattern-matching engine works
        by building three different pattern matches and comparing their lambda forms.<indexterm class="singular">
          <primary>pattern matching</primary>
          <secondary>optimization in lambda form code</secondary>
        </indexterm><indexterm class="singular">
          <primary>lambda form code</primary>
          <secondary>pattern matching optimization</secondary>
        </indexterm></para>

      <para>Let's start by creating a straightforward exhaustive pattern match
      using four normal variants:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/back-end/pattern_monomorphic_large.ml">OCaml</ulink></para>

      <programlisting format="linespecific" language="ocaml">type t = | Alice | Bob | Charlie | David

let test v =
  match v with
  | Alice   -&gt; 100
  | Bob     -&gt; 101
  | Charlie -&gt; 102
  | David   -&gt; 103</programlisting>

      <para>The lambda output for this code looks like this:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/back-end/lambda_for_pattern_monomorphic_large.out">Terminal</ulink></para>

      <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">ocamlc -dlambda -c pattern_monomorphic_large.ml 2&gt;&amp;1</userinput>
<computeroutput moreinfo="none">(setglobal Pattern_monomorphic_large!</computeroutput>
<computeroutput moreinfo="none">  (let</computeroutput>
<computeroutput moreinfo="none">    (test/1013</computeroutput>
<computeroutput moreinfo="none">       (function v/1014</computeroutput>
<computeroutput moreinfo="none">         (switch* v/1014</computeroutput>
<computeroutput moreinfo="none">          case int 0: 100</computeroutput>
<computeroutput moreinfo="none">          case int 1: 101</computeroutput>
<computeroutput moreinfo="none">          case int 2: 102</computeroutput>
<computeroutput moreinfo="none">          case int 3: 103)))</computeroutput>
<computeroutput moreinfo="none">    (makeblock 0 test/1013)))</computeroutput></programlisting>

      <para>It's not important to understand every detail of this internal
      form, and it is explicitly undocumented since it can change across
      compiler revisions. Despite these caveats, some interesting points
      emerge from reading it:</para>

      <itemizedlist>
        <listitem>
          <para>There are no mention of modules or types any more. Global
          values are created via <literal moreinfo="none">setglobal</literal>,
          and OCaml values are constructed by <literal moreinfo="none">makeblock</literal>. The blocks are the runtime
          values you should remember from <xref linkend="memory-representation-of-values"/>.</para>
        </listitem>

        <listitem>
          <para>The pattern match has turned into a switch case that jumps to the right case
            depending on the header tag of <literal moreinfo="none">v</literal>. Recall that
            variants without parameters are stored in memory as integers in the order which they
            appear. The pattern-matching engine knows this and has transformed the pattern into an
            efficient jump table.</para>
        </listitem>

        <listitem>
          <para>Values are addressed by a unique name that distinguishes shadowed values by
            appending a number (e.g., <literal moreinfo="none">v/1014</literal>). The type safety
            checks in the earlier phase ensure that these low-level accesses never violate runtime
            memory safety, so this layer doesn't do any dynamic checks. Unwise use of unsafe
            features such as the <literal moreinfo="none">Obj.magic</literal> module can still
            easily induce crashes at this level.</para>
        </listitem>
      </itemizedlist>

      <para>The compiler computes a jump table in order to handle all four
      cases. If we drop the number of variants to just two, then there's no
      need for the complexity of computing this table:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/back-end/pattern_monomorphic_small.ml">OCaml</ulink></para>

      <programlisting format="linespecific" language="ocaml">type t = | Alice | Bob 

let test v =
  match v with
  | Alice   -&gt; 100
  | Bob     -&gt; 101</programlisting>

      <para>The lambda output for this code is now quite different:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/back-end/lambda_for_pattern_monomorphic_small.out">Terminal</ulink></para>

      <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">ocamlc -dlambda -c pattern_monomorphic_small.ml 2&gt;&amp;1</userinput>
<computeroutput moreinfo="none">(setglobal Pattern_monomorphic_small!</computeroutput>
<computeroutput moreinfo="none">  (let (test/1011 (function v/1012 (if (!= v/1012 0) 101 100)))</computeroutput>
<computeroutput moreinfo="none">    (makeblock 0 test/1011)))</computeroutput></programlisting>

      <para>The compiler emits simpler conditional jumps rather than setting
      up a jump table, since it statically determines that the range of
      possible variants is small enough. Finally, let's look at the same code,
      but with polymorphic variants instead of normal variants:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/back-end/pattern_polymorphic.ml">OCaml</ulink></para>

      <programlisting format="linespecific" language="ocaml">let test v =
  match v with
  | `Alice   -&gt; 100
  | `Bob     -&gt; 101
  | `Charlie -&gt; 102
  | `David   -&gt; 103
  | `Eve     -&gt; 104</programlisting>

      <para>The lambda form for this also shows up the runtime representation
      of polymorphic variants:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/back-end/lambda_for_pattern_polymorphic.out">Terminal</ulink></para>

      <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">ocamlc -dlambda -c pattern_polymorphic.ml 2&gt;&amp;1</userinput>
<computeroutput moreinfo="none">(setglobal Pattern_polymorphic!</computeroutput>
<computeroutput moreinfo="none">  (let</computeroutput>
<computeroutput moreinfo="none">    (test/1008</computeroutput>
<computeroutput moreinfo="none">       (function v/1009</computeroutput>
<computeroutput moreinfo="none">         (if (!= v/1009 3306965)</computeroutput>
<computeroutput moreinfo="none">           (if (&gt;= v/1009 482771474) (if (&gt;= v/1009 884917024) 100 102)</computeroutput>
<computeroutput moreinfo="none">             (if (&gt;= v/1009 3457716) 104 103))</computeroutput>
<computeroutput moreinfo="none">           101)))</computeroutput>
<computeroutput moreinfo="none">    (makeblock 0 test/1008)))</computeroutput></programlisting>

      <para>We mentioned in <xref linkend="variants"/> that pattern matching over polymorphic
        variants is slightly less efficient, and it should be clearer why this is the case now.
        Polymorphic variants have a runtime value that's calculated by hashing the variant name, and
        so the compiler can't use a jump table as it does for normal variants. Instead, it creates a
        decision tree that compares the hash values against the input variable in as few comparisons
        as possible.<indexterm class="singular">
          <primary>pattern matching</primary>
          <secondary>fundamental algorithms in</secondary>
        </indexterm></para>

      <note>
        <title>Learning More About Pattern Matching Compilation</title>

        <para>Pattern matching is an important part of OCaml programming.
        You'll often encounter deeply nested pattern matches over complex data
        structures in real code. A good paper that describes the fundamental
        algorithms implemented in OCaml is <ulink url="http://dl.acm.org/citation.cfm?id=507641">"Optimizing pattern
        matching"</ulink> by Fabrice Le Fessant and Luc Maranget.</para>

        <para>The paper describes the backtracking algorithm used in classical pattern matching
          compilation, and also several OCaml-specific optimizations, such as the use of
          exhaustiveness information and control flow optimizations via static exceptions.</para>

        <para>It's not essential that you understand all of this just to use
        pattern matching, of course, but it'll give you insight as to why
        pattern matching is such a lightweight language construct to use in
        OCaml code.</para>
      </note>
    </sect2>

    <sect2 id="benchmarking-pattern-matching">
      <title>Benchmarking Pattern Matching</title>

      <para>Let's benchmark these three pattern-matching techniques to quantify their runtime costs
        more accurately. The <literal moreinfo="none">Core_bench</literal> module runs the tests
        thousands of times and also calculates statistical variance of the results. You'll need to
          <literal moreinfo="none">opam install core_bench</literal> to get the library:<indexterm class="singular">
          <primary>pattern matching</primary>
          <secondary>benchmarking of</secondary>
        </indexterm><indexterm class="singular">
          <primary>lambda form code</primary>
          <secondary>pattern matching benchmarking</secondary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/back-end-bench/bench_patterns.ml">OCaml</ulink></para>

      <programlisting format="linespecific" language="ocaml">open Core.Std
open Core_bench.Std

type t = | Alice | Bob 
type s = | A | B | C | D | E

let polymorphic_pattern () =
  let test v =
    match v with
    | `Alice   -&gt; 100
    | `Bob     -&gt; 101
    | `Charlie -&gt; 102
    | `David   -&gt; 103
    | `Eve     -&gt; 104
  in
  List.iter ~f:(fun v -&gt; ignore(test v))
    [`Alice; `Bob; `Charlie; `David]

let monomorphic_pattern_small () =
  let test v =
    match v with
    | Alice   -&gt; 100
    | Bob     -&gt; 101 in
  List.iter ~f:(fun v -&gt; ignore(test v))
    [ Alice; Bob ]

let monomorphic_pattern_large () =
  let test v =
    match v with
    | A       -&gt; 100
    | B       -&gt; 101
    | C       -&gt; 102
    | D       -&gt; 103
    | E       -&gt; 104
  in
  List.iter ~f:(fun v -&gt; ignore(test v))
    [ A; B; C; D ]

let tests = [
  "Polymorphic pattern", polymorphic_pattern;
  "Monomorphic larger pattern", monomorphic_pattern_large;
  "Monomorphic small pattern", monomorphic_pattern_small;
]

let () =
  List.map tests ~f:(fun (name,test) -&gt; Bench.Test.create ~name test)
  |&gt; Bench.make_command
  |&gt; Command.run</programlisting>

      <para>Building and executing this example will run for around 30 seconds
      by default, and you'll see the results summarized in a neat
      table:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/back-end-bench/run_bench_patterns.out">Terminal</ulink></para>

      <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">corebuild -pkg core_bench bench_patterns.native</userinput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">./bench_patterns.native -ascii</userinput>
<computeroutput moreinfo="none">Estimated testing time 30s (change using -quota SECS).</computeroutput>
<computeroutput moreinfo="none">                                                     </computeroutput>
<computeroutput moreinfo="none">  Name                         Time (ns)   % of max  </computeroutput>
<computeroutput moreinfo="none"> ---------------------------- ----------- ---------- </computeroutput>
<computeroutput moreinfo="none">  Polymorphic pattern              31.51     100.00  </computeroutput>
<computeroutput moreinfo="none">  Monomorphic larger pattern       29.19      92.62  </computeroutput>
<computeroutput moreinfo="none">  Monomorphic small pattern        16.25      51.57  </computeroutput>
<computeroutput moreinfo="none">                                                     </computeroutput></programlisting>

      <para>These results confirm the performance hypothesis that we obtained earlier by inspecting
        the lambda code. The shortest running time comes from the small conditional pattern match,
        and polymorphic variant pattern matching is the slowest. There isn't a hugely significant
        difference in these examples, but you can use the same techniques to peer into the innards
        of your own source code and narrow down any performance hotspots.</para>

      <para>The lambda form is primarily a stepping stone to the bytecode
      executable format that we'll cover next. It's often easier to look at
      the textual output from this stage than to wade through the native
      assembly code from compiled executables.<indexterm class="endofrange" startref="CPuntype"/></para>
    </sect2>
  </sect1>

  <sect1 id="generating-portable-bytecode">
    <title>Generating Portable Bytecode</title>

    <para>After the lambda form has been generated, we are very close to
    having executable code. The OCaml toolchain branches into two separate
    compilers at this point. We'll describe the bytecode compiler first, which
    consists of two pieces:<indexterm class="singular">
        <primary>OCaml toolchain</primary>

        <secondary>ocamlrun</secondary>
      </indexterm><indexterm class="singular">
        <primary>OCaml toolchain</primary>

        <secondary>ocamlc</secondary>
      </indexterm><indexterm class="singular">
        <primary>bytecode compiler</primary>

        <secondary>tools used</secondary>
      </indexterm><indexterm class="startofrange" id="CPportbyte">
        <primary>compilation process</primary>

        <secondary>portable bytecode</secondary>
      </indexterm></para>

    <variablelist>
      <varlistentry>
        <term><command moreinfo="none">ocamlc</command></term>

        <listitem>
          <para>Compiles files into a bytecode that is a close mapping to the
          lambda form</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><command moreinfo="none">ocamlrun</command></term>

        <listitem>
          <para>A portable interpreter that executes the bytecode</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <para>The big advantage of using bytecode is simplicity, portability, and compilation speed. The
      mapping from the lambda form to bytecode is straightforward, and this results in predictable
      (but slow) execution speed.</para>

    <para>The bytecode interpreter implements a stack-based virtual machine. The OCaml stack and an
      associated accumulator store values that consist of:<indexterm class="singular">
        <primary>bytecode compiler</primary>
        <secondary>values stored by</secondary>
      </indexterm><indexterm class="singular">
        <primary>code offset values</primary>
      </indexterm><indexterm class="singular">
        <primary>block values</primary>
      </indexterm><indexterm class="singular">
        <primary>long values</primary>
      </indexterm><indexterm class="singular">
        <primary>values</primary>
        <secondary>stored by bytecode compiler</secondary>
      </indexterm></para>

    <variablelist>
      <varlistentry>
        <term>long</term>

        <listitem>
          <para>Values that correspond to an OCaml <literal moreinfo="none">int</literal> type</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>block</term>

        <listitem>
          <para>Values that contain the block header and a memory address with
          the data fields that contain further OCaml values indexed by an
          integer</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>code offset</term>

        <listitem>
          <para>Values that are relative to the starting code address</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <para>The interpreter virtual machine only has seven registers in total: the program counter,
      stack pointer, accumulator, exception and argument pointers, and environment and global data.
      You can display the bytecode instructions in textual form via <literal moreinfo="none">-dinstr</literal>. Try this on one of our earlier pattern-matching examples:</para>

    <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/back-end/instr_for_pattern_monomorphic_small.out">Terminal</ulink></para>

    <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">ocamlc -dinstr pattern_monomorphic_small.ml 2&gt;&amp;1</userinput>
<computeroutput moreinfo="none">	branch L2</computeroutput>
<computeroutput moreinfo="none">L1:	acc 0</computeroutput>
<computeroutput moreinfo="none">	push</computeroutput>
<computeroutput moreinfo="none">	const 0</computeroutput>
<computeroutput moreinfo="none">	neqint</computeroutput>
<computeroutput moreinfo="none">	branchifnot L3</computeroutput>
<computeroutput moreinfo="none">	const 101</computeroutput>
<computeroutput moreinfo="none">	return 1</computeroutput>
<computeroutput moreinfo="none">L3:	const 100</computeroutput>
<computeroutput moreinfo="none">	return 1</computeroutput>
<computeroutput moreinfo="none">L2:	closure L1, 0</computeroutput>
<computeroutput moreinfo="none">	push</computeroutput>
<computeroutput moreinfo="none">	acc 0</computeroutput>
<computeroutput moreinfo="none">	makeblock 1, 0</computeroutput>
<computeroutput moreinfo="none">	pop 1</computeroutput>
<computeroutput moreinfo="none">	setglobal Pattern_monomorphic_small!</computeroutput>
<computeroutput moreinfo="none"> </computeroutput></programlisting>

    <para>The preceding bytecode has been simplified from the lambda form into
    a set of simple instructions that are executed serially by the
    interpreter.</para>

    <para>There are around 140 instructions in total, but most are just minor
    variants of commonly encountered operations (e.g., function application at
    a specific arity). You can find full details <ulink url="http://cadmium.x9c.fr/distrib/caml-instructions.pdf">online</ulink>.<indexterm class="singular">
        <primary>bytecode compiler</primary>

        <secondary>instruction set for</secondary>
      </indexterm></para>

    <note>
      <title>Where Did the Bytecode Instruction Set Come From?</title>

      <para>The bytecode interpreter is much slower than compiled native code,
      but is still remarkably performant for an interpreter without a JIT
      compiler. Its efficiency can be traced back to Xavier Leroy's
      ground-breaking work in 1990, <ulink url="http://hal.inria.fr/docs/00/07/00/49/PS/RT-0117.ps">"The ZINC
      experiment: An Economical Implementation of the ML
      Language".</ulink></para>

      <para>This paper laid the theoretical basis for the implementation of an instruction set for a
        strictly evaluated functional language such as OCaml. The bytecode interpreter in modern
        OCaml is still based on the ZINC model. The native code compiler uses a different model
        since it uses CPU registers for function calls instead of always passing arguments on the
        stack, as the bytecode interpreter does.</para>

      <para>Understanding the reasoning behind the different implementations
      of the bytecode interpreter and the native compiler is a very useful
      exercise for any budding language hacker.</para>
    </note>

    <sect2 id="compiling-and-linking-bytecode">
      <title>Compiling and Linking Bytecode</title>

      <para>The <command moreinfo="none">ocamlc</command> command compiles
      individual <literal moreinfo="none">ml</literal> files into bytecode
      files that have a <literal moreinfo="none">cmo</literal> extension. The
      compiled bytecode files are matched with the associated <literal moreinfo="none">cmi</literal> interface, which contains the type
      signature exported to other compilation units.<indexterm class="singular">
          <primary>bytecode compiler</primary>

          <secondary>compiling and linking code</secondary>
        </indexterm></para>

      <para>A typical OCaml library consists of multiple source files, and
      hence multiple <literal moreinfo="none">cmo</literal> files that all
      need to be passed as command-line arguments to use the library from
      other code. The compiler can combine these multiple files into a more
      convenient single archive file by using the <literal moreinfo="none">-a</literal> flag. Bytecode archives are denoted by the
      <literal moreinfo="none">cma</literal> extension.</para>

      <para>The individual objects in the library are linked as regular
      <literal moreinfo="none">cmo</literal> files in the order specified when
      the library file was built. If an object file within the library isn't
      referenced elsewhere in the program, then it isn't included in the final
      binary unless the <literal moreinfo="none">-linkall</literal> flag
      forces its inclusion. This behavior is analogous to how C handles object
      files and archives (<literal moreinfo="none">.o</literal> and <literal moreinfo="none">.a</literal>, respectively).</para>

      <para>The bytecode files are then linked together with the OCaml
      standard library to produce an executable program. The order in which
      <literal moreinfo="none">.cmo</literal> arguments are presented on the
      command line defines the order in which compilation units are
      initialized at runtime. Remember that OCaml has no single <literal moreinfo="none">main</literal> function like C, so this link order is
      more important than in C programs.</para>
    </sect2>

    <sect2 id="executing-bytecode">
      <title>Executing Bytecode</title>

      <para>The bytecode runtime comprises three parts: the bytecode interpreter, GC, and a set of C
        functions that implement the primitive operations. The bytecode contains instructions to
        call these C functions when required.</para>

      <para>The OCaml linker produces bytecode that targets the standard OCaml
      runtime by default, and so needs to know about any C functions that are
      referenced from other libraries that aren't loaded by default.</para>

      <para>Information about these extra libraries can be specified while
      linking a bytecode archive:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/back-end-embed/link_dllib.out">Terminal</ulink></para>

      <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">ocamlc -a -o mylib.cma a.cmo b.cmo -dllib -lmylib</userinput>
</programlisting>

      <para>The <literal moreinfo="none">dllib</literal> flag embeds the
      arguments in the archive file. Any subsequent packages linking this
      archive will also include the extra C linking directive. This in turn
      lets the interpreter dynamically load the external library symbols when
      it executes the bytecode.</para>

      <para>You can also generate a complete standalone executable that
      bundles the <command moreinfo="none">ocamlrun</command> interpreter with
      the bytecode in a single binary. This is known as a <emphasis>custom
      runtime</emphasis> mode and is built as follows:<indexterm class="singular">
          <primary>custom runtime mode</primary>
        </indexterm></para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/back-end-embed/link_custom.out">Terminal</ulink></para>

      <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">ocamlc -a -o mylib.cma -custom a.cmo b.cmo -cclib -lmylib</userinput>
</programlisting>

      <para>OCamlbuild takes care of many of these details with its built-in rules. The <literal moreinfo="none">%.byte</literal> rule that you've been using throughout the book builds a
        bytecode executable, and adding the <literal moreinfo="none">custom</literal> tag will
        bundle the interpreter with it, too.<indexterm class="singular">
          <primary>%.byte rule</primary>
        </indexterm></para>

      <para>The custom mode is the most similar mode to native code
      compilation, as both generate standalone executables. There are quite a
      few other options available for compiling bytecode (notably with shared
      libraries or building custom runtimes). Full details can be found in the
      <ulink url="http://caml.inria.fr/pub/docs/manual-ocaml/manual022.html">OCaml</ulink>.</para>
    </sect2>

    <sect2 id="embedding-ocaml-bytecode-in-c">
      <title>Embedding OCaml Bytecode in C</title>

      <para>A consequence of using the bytecode compiler is that the final link phase must be
        performed by <command moreinfo="none">ocamlc</command>. However, you might sometimes want to
        embed your OCaml code inside an existing C application. OCaml also supports this mode of
        operation via the <phrase role="keep-together"><literal moreinfo="none">-output-obj</literal></phrase>
          directive.<indexterm class="singular">
          <primary>C object files</primary>
        </indexterm></para>

      <para>This mode causes <command moreinfo="none">ocamlc</command> to output an object file
        containing the bytecode for the OCaml part of the program, as well as a <literal moreinfo="none">caml_startup</literal> function. All of the OCaml modules are linked into
        this object file as bytecode, just as they would be for an executable.</para>

      <para>This object file can then be linked with C code using the standard C compiler, needing
        only the bytecode runtime library (which is installed as <literal moreinfo="none">libcamlrun.a</literal>). Creating an executable just requires you to link the runtime
        library with the bytecode object file. Here's an example to show how it all fits
        together.</para>

      <para>Create two OCaml source files that contain a single print
      line:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/back-end-embed/embed_me1.ml">OCaml</ulink></para>

      <programlisting format="linespecific" language="ocaml">let () = print_endline "hello embedded world 1"</programlisting>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/back-end-embed/embed_me2.ml">OCaml</ulink></para>

      <programlisting format="linespecific" language="ocaml">let () = print_endline "hello embedded world 2"</programlisting>

      <para>Next, create a C file to be your main entry point:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/back-end-embed/main.c">C</ulink></para>

      <programlisting format="linespecific" language="c">#include &lt;stdio.h&gt;
#include &lt;caml/alloc.h&gt;
#include &lt;caml/mlvalues.h&gt;
#include &lt;caml/memory.h&gt;
#include &lt;caml/callback.h&gt;

int 
main (int argc, char **argv)
{
  printf("Before calling OCaml\n");
  fflush(stdout);
  caml_startup (argv);
  printf("After calling OCaml\n");
  return 0;
}</programlisting>

      <para>Now compile the OCaml files into a standalone object file:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/back-end-embed/build_embed.out">Terminal</ulink></para>

      <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">rm -f embed_out.c</userinput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">ocamlc -output-obj -o embed_out.o embed_me1.ml embed_me2.ml</userinput></programlisting>

      <para>After this point, you no longer need the OCaml compiler, as
      <literal moreinfo="none">embed_out.o</literal> has all of the OCaml code
      compiled and linked into a single object file. Compile an output binary
      using <command moreinfo="none">gcc</command> to test this out:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/back-end-embed/build_embed_binary.out">Terminal</ulink></para>

      <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">gcc -fPIC -Wall -I`ocamlc -where` -L`ocamlc -where` -ltermcap -lm -ldl \</userinput>
<computeroutput moreinfo="none">  -o finalbc.native main.c embed_out.o -lcamlrun</computeroutput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">./finalbc.native</userinput>
<computeroutput moreinfo="none">Before calling OCaml</computeroutput>
<computeroutput moreinfo="none">hello embedded world 1</computeroutput>
<computeroutput moreinfo="none">hello embedded world 2</computeroutput>
<computeroutput moreinfo="none">After calling OCaml</computeroutput></programlisting>

      <para>You can inspect the commands that <command moreinfo="none">ocamlc</command> is invoking by adding <literal moreinfo="none">-verbose</literal> to the command line to help figure
      out the GCC command line if you get stuck. You can even obtain the C
      source code to the <literal moreinfo="none">-output-obj</literal> result
      by specifying a <literal moreinfo="none">.c</literal> output file
      extension instead of the <literal moreinfo="none">.o</literal> we used
      earlier:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/back-end-embed/build_embed_c.out">Terminal</ulink></para>

      <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">ocamlc -output-obj -o embed_out.c embed_me1.ml embed_me2.ml</userinput>
</programlisting>

      <para>Embedding OCaml code like this lets you write OCaml that
      interfaces with any environment that works with a C compiler. You can
      even cross back from the C code into OCaml by using the <literal moreinfo="none">Callback</literal> module to register named entry points
      in the OCaml code. This is explained in detail in the <ulink url="http://caml.inria.fr/pub/docs/manual-ocaml/manual033.html#toc149">interfacing
      with C</ulink> section of the OCaml manual.<indexterm class="endofrange" startref="CPportbyte"/></para>
    </sect2>
  </sect1>

  <sect1 id="compiling-fast-native-code">
    <title>Compiling Fast Native Code</title>

    <para>The native code compiler is ultimately the tool that most production
    OCaml code goes through. It compiles the lambda form into fast native code
    executables, with cross-module inlining and additional optimization passes
    that the bytecode interpreter doesn't perform. Care is taken to ensure
    compatibility with the bytecode runtime, so the same code should run
    identically when compiled with either toolchain.<indexterm class="singular">
        <primary>cmi files</primary>
      </indexterm><indexterm class="singular">
        <primary>files</primary>

        <secondary>cmi files</secondary>
      </indexterm><indexterm class="singular">
        <primary>cmx files</primary>
      </indexterm><indexterm class="singular">
        <primary>files</primary>

        <secondary>cmx files</secondary>
      </indexterm><indexterm class="singular">
        <primary>o files</primary>
      </indexterm><indexterm class="singular">
        <primary>files</primary>

        <secondary>o files</secondary>
      </indexterm><indexterm class="singular">
        <primary>OCaml toolchain</primary>

        <secondary>ocamlopt</secondary>
      </indexterm><indexterm class="singular">
        <primary>native-code compiler</primary>

        <secondary>benefits of</secondary>
      </indexterm><indexterm class="startofrange" id="CPfast">
        <primary>compilation process</primary>

        <secondary>fast native code</secondary>
      </indexterm></para>

    <para>The <command moreinfo="none">ocamlopt</command> command is the
    frontend to the native code compiler and has a very similar interface to
    <command moreinfo="none">ocamlc</command>. It also accepts <literal moreinfo="none">ml</literal> and <literal moreinfo="none">mli</literal>
    files, but compiles them to:</para>

    <itemizedlist>
      <listitem>
        <para>A <literal moreinfo="none">.o</literal> file containing native
        object code</para>
      </listitem>

      <listitem>
        <para>A <literal moreinfo="none">.cmx</literal> file containing extra
        information for linking and cross-module optimization</para>
      </listitem>

      <listitem>
        <para>A <literal moreinfo="none">.cmi</literal> compiled interface
        file that is the same as the bytecode compiler</para>
      </listitem>
    </itemizedlist>

    <para>When the compiler links modules together into an executable, it uses
    the contents of the <literal moreinfo="none">cmx</literal> files to
    perform cross-module inlining across compilation units. This can be a
    significant speedup for standard library functions that are frequently
    used outside of their module.</para>

    <para>Collections of <literal moreinfo="none">.cmx</literal> and <literal moreinfo="none">.o</literal> files can also be be linked into a <literal moreinfo="none">.cmxa</literal> archive by passing the <literal moreinfo="none">-a</literal> flag to the compiler. However, unlike the
    bytecode version, you must keep the individual <literal moreinfo="none">cmx</literal> files in the compiler search path so that
    they are available for cross-module inlining. If you don't do this, the
    compilation will still succeed, but you will have missed out on an
    important optimization and have slower binaries.</para>

    <sect2 id="inspecting-assembly-output">
      <title>Inspecting Assembly Output</title>

      <para>The native code compiler generates assembly language that is then
      passed to the system assembler for compiling into object files. You can
      get <command moreinfo="none">ocamlopt</command> to output the assembly
      by passing the <literal moreinfo="none">-S</literal> flag to the
      compiler command line.<indexterm class="singular">
          <primary>native-code compiler</primary>

          <secondary>inspecting assembly output</secondary>
        </indexterm></para>

      <para>The assembly code is highly architecture-specific, so the following discussion assumes
        an Intel or AMD 64-bit platform. We've generated the example code using <literal moreinfo="none">-inline 20</literal> and <literal moreinfo="none">-nodynlink</literal>
        since it's best to generate assembly code with the full optimizations that the compiler
        supports. Even though these optimizations make the code a bit harder to read, it will give
        you a more accurate picture of what executes on the CPU. Don't forget that you can use the
        lambda code from earlier to get a slightly higher-level picture of the code if you get lost
        in the more verbose assembly.</para>

      <sect3 id="the-impact-of-polymorphic-comparison">
        <title>The impact of polymorphic comparison</title>

        <para>We warned you in <xref linkend="maps-and-hash-tables"/> that using polymorphic
          comparison is both convenient and perilous. Let's look at precisely what the difference is
          at the assembly language level now.<indexterm class="singular">
            <primary>polymorphic comparisons</primary>
          </indexterm></para>

        <para>First let's create a comparison function where we've explicitly annotated the types,
          so the compiler knows that only integers are being compared:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/back-end/compare_mono.ml">OCaml</ulink></para>

        <programlisting format="linespecific" language="ocaml">let cmp (a:int) (b:int) =
  if a &gt; b then a else b</programlisting>

        <para>Now compile this into assembly and read the resulting <literal moreinfo="none">compare_mono.S</literal> file. This file extension may
        be lowercase on some platforms such as Linux:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/back-end/asm_from_compare_mono.out">Terminal</ulink></para>

        <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">ocamlopt -inline 20 -nodynlink -S compare_mono.ml</userinput>
</programlisting>

        <para>If you've never seen assembly language before, then the contents
        may be rather scary. While you'll need to learn x86 assembly to fully
        understand it, we'll try to give you some basic instructions to spot
        patterns in this section. The excerpt of the implementation of the
        <literal moreinfo="none">cmp</literal> function can be found
        below:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/back-end/cmp.S">Assembly</ulink></para>

        <programlisting format="linespecific" language="gas">_camlCompare_mono__cmp_1008:
        .cfi_startproc
.L101:
        cmpq    %rbx, %rax
        jle     .L100
        ret
        .align  2
.L100:
        movq    %rbx, %rax
        ret
        .cfi_endproc</programlisting>

        <para>The <literal moreinfo="none">_camlCompare_mono__cmp_1008</literal> is an assembly
        label that has been computed from the module name (<literal moreinfo="none">Compare_mono</literal>) and the function name
        (<literal moreinfo="none">cmp_1008</literal>). The numeric suffix for
        the function name comes straight from the lambda form (which you can
        inspect using <literal moreinfo="none">-dlambda</literal>, but in this
        case isn't necessary).</para>

        <para>The arguments to <literal moreinfo="none">cmp</literal> are
        passed in the <literal moreinfo="none">%rbx</literal> and <literal moreinfo="none">%rax</literal> registers, and compared using the
        <literal moreinfo="none">jle</literal> "jump if less than or equal"
        instruction. This requires both the arguments to be immediate integers
        to work. Now let's see what happens if our OCaml code omits the type
        annotations and is a polymorphic comparison instead:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/back-end/compare_poly.ml">OCaml</ulink></para>

        <programlisting format="linespecific" language="ocaml">let cmp a b =
  if a &gt; b then a else b</programlisting>

        <para>Compiling this code with <literal moreinfo="none">-S</literal>
        results in a significantly more complex assembly output for the same
        function:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/back-end/compare_poly_asm.S">Assembly</ulink></para>

        <programlisting format="linespecific" language="gas">_camlCompare_poly__cmp_1008:
        .cfi_startproc
        subq    $24, %rsp
        .cfi_adjust_cfa_offset  24
.L101:
        movq    %rax, 8(%rsp)
        movq    %rbx, 0(%rsp)
        movq    %rax, %rdi
        movq    %rbx, %rsi
        leaq    _caml_greaterthan(%rip), %rax
        call    _caml_c_call
.L102:
        leaq    _caml_young_ptr(%rip), %r11
        movq    (%r11), %r15
        cmpq    $1, %rax
        je      .L100
        movq    8(%rsp), %rax
        addq    $24, %rsp
        .cfi_adjust_cfa_offset  -24
        ret
        .cfi_adjust_cfa_offset  24
        .align  2
.L100:
        movq    0(%rsp), %rax
        addq    $24, %rsp
        .cfi_adjust_cfa_offset  -24
        ret
        .cfi_adjust_cfa_offset  24
        .cfi_endproc</programlisting>

        <para>The <literal moreinfo="none">.cfi</literal> directives are assembler hints that
          contain Call Frame Information that lets the debugger provide more sensible backtraces,
          and they have no effect on runtime performance. Notice that the rest of the implementation
          is no longer a simple register comparison. Instead, the arguments are pushed on the stack
          (the <literal moreinfo="none">%rsp</literal> register), and a C function call is invoked
          by placing a pointer to <literal moreinfo="none">caml_greaterthan</literal> in <literal moreinfo="none">%rax</literal> and jumping to <literal moreinfo="none">caml_c_call</literal>.<indexterm class="singular">
            <primary>backtraces</primary>
          </indexterm></para>

        <para>OCaml on x86_64 architectures caches the location of the minor
        heap in the <literal moreinfo="none">%r15</literal> register since
        it's so frequently referenced in OCaml functions. The minor heap
        pointer can also be changed by the C code that's being called (e.g.,
        when it allocates OCaml values), and so <literal moreinfo="none">%r15</literal> is restored after returning from the
        <literal moreinfo="none">caml_greaterthan</literal> call. Finally, the
        return value of the comparison is popped from the stack and
        returned.</para>
      </sect3>

      <sect3 id="benchmarking-polymorphic-comparison">
        <title>Benchmarking polymorphic comparison</title>

        <para>You don't have to fully understand the intricacies of assembly
        language to see that this polymorphic comparison is much heavier than
        the simple monomorphic integer comparison from earlier. Let's confirm
        this hypothesis again by writing a quick <literal moreinfo="none">Core_bench</literal> test with both functions:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/back-end-bench/bench_poly_and_mono.ml">OCaml</ulink></para>

        <programlisting format="linespecific" language="ocaml">open Core.Std
open Core_bench.Std

let polymorphic_compare () =
  let cmp a b = if a &gt; b then a else b in
  for i = 0 to 1000 do
    ignore(cmp 0 i)
  done

let monomorphic_compare () =
  let cmp (a:int) (b:int) =
    if a &gt; b then a else b in
  for i = 0 to 1000 do
    ignore(cmp 0 i)
  done

let tests =
  [ "Polymorphic comparison", polymorphic_compare;
    "Monomorphic comparison", monomorphic_compare ]

let () =
  List.map tests ~f:(fun (name,test) -&gt; Bench.Test.create ~name test)
  |&gt; Bench.make_command
  |&gt; Command.run</programlisting>

        <para>Running this shows quite a significant runtime difference
        between the two:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/back-end-bench/run_bench_poly_and_mono.out">Terminal</ulink></para>

        <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">corebuild -pkg core_bench bench_poly_and_mono.native</userinput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">./bench_poly_and_mono.native -ascii</userinput>
<computeroutput moreinfo="none">Estimated testing time 20s (change using -quota SECS).</computeroutput>
<computeroutput moreinfo="none">                                                 </computeroutput>
<computeroutput moreinfo="none">  Name                     Time (ns)   % of max  </computeroutput>
<computeroutput moreinfo="none"> ------------------------ ----------- ---------- </computeroutput>
<computeroutput moreinfo="none">  Polymorphic comparison      13_919     100.00  </computeroutput>
<computeroutput moreinfo="none">  Monomorphic comparison         815       5.86  </computeroutput>
<computeroutput moreinfo="none">                                                 </computeroutput></programlisting>

        <para>We see that the polymorphic comparison is close to 20 times slower! These results
          shouldn't be taken too seriously, as this is a very narrow test that, like all such
          microbenchmarks, isn't representative of more complex codebases. However, if you're
          building numerical code that runs many iterations in a tight inner loop, it's worth
          manually peering at the produced assembly code to see if you can hand-optimize it.</para>
      </sect3>
    </sect2>

    <sect2 id="debugging-native-code-binaries">
      <title>Debugging Native Code Binaries</title>

      <para>The native code compiler builds executables that can be debugged using conventional
        system debuggers such as GNU <command moreinfo="none">gdb</command>. You need to compile
        your libraries with the <literal moreinfo="none">-g</literal> option to add the debug
        information to the output, just as you need to with C compilers.<indexterm class="singular">
          <primary>debugging</primary>
          <secondary>native code binaries</secondary>
        </indexterm><indexterm class="singular">
          <primary>native-code compiler</primary>
          <secondary>debugging binaries</secondary>
        </indexterm></para>

      <para>Extra debugging information is inserted into the output assembly
      when the library is compiled in debug mode. These include the CFI stubs
      you will have noticed in the profiling output earlier (<literal moreinfo="none">.cfi_start_proc</literal> and <literal moreinfo="none">.cfi_end_proc</literal> to delimit an OCaml function
      call, for example).</para>

      <sect3 id="understanding-name-mangling">
        <title>Understanding name mangling</title>

        <para>So how do you refer to OCaml functions in an interactive debugger like <command moreinfo="none">gdb</command>? The first thing you need to know is how OCaml function
          names compile down to symbol names in the compiled object files, a procedure generally
          called <emphasis>name mangling</emphasis>.<indexterm class="singular">
            <primary>gdb debugger</primary>
          </indexterm><indexterm class="singular">
            <primary>debugging</primary>
            <secondary>interactive debuggers</secondary>
          </indexterm><indexterm class="singular">
            <primary>functions</primary>
            <secondary>name mangling of</secondary>
          </indexterm><indexterm class="singular">
            <primary>name mangling</primary>
          </indexterm></para>

        <para>Each OCaml source file is compiled into a native object file that must export a unique
          set of symbols to comply with the C binary interface. This means that any OCaml values
          that may be used by another compilation unit need to be mapped onto a symbol name. This
          mapping has to account for OCaml language features such as nested modules, anonymous
          functions, and variable names that shadow one another.</para>

        <para>The conversion follows some straightforward rules for named
        variables and functions:</para>

        <itemizedlist>
          <listitem>
            <para>The symbol is prefixed by <literal moreinfo="none">caml</literal> and the local module name, with
            dots replaced by underscores.</para>
          </listitem>

          <listitem>
            <para>This is followed by a double <literal moreinfo="none">__</literal> suffix and the variable name.</para>
          </listitem>

          <listitem>
            <para>The variable name is also suffixed by a <literal moreinfo="none">_</literal> and a
              number. This is the result of the lambda compilation, which replaces each variable
              name with a unique value within the module. You can determine this number by examining
              the <literal moreinfo="none">-dlambda</literal> output from <command moreinfo="none">ocamlopt</command>.</para>
          </listitem>
        </itemizedlist>

        <para>Anonymous functions are hard to predict without inspecting
        intermediate compiler output. If you need to debug them, it's usually
        easier to modify the source code to let-bind the anonymous function to
        a variable name.</para>
      </sect3>

      <sect3 id="interactive-breakpoints-with-the-gnu-debugger">
        <title>Interactive breakpoints with the GNU debugger</title>

        <para>Let's see name mangling in action with some interactive
        debugging using GNU <command moreinfo="none">gdb</command>.<indexterm class="singular">
            <primary>GNU debugger</primary>
          </indexterm></para>

        <caution>
          <title>Beware gdb on Mac OS X</title>

          <para>The examples here assume that you are running <command moreinfo="none">gdb</command> on either Linux or FreeBSD. Mac OS X
          10.8 does have <command moreinfo="none">gdb</command> installed, but
          it's a rather quirky experience that doesn't reliably interpret the
          debugging information contained in the native binaries. This can
          result in function names showing up as raw symbols such as <literal moreinfo="none">.L101</literal> instead of their more human-readable
          form.</para>

          <para>For OCaml 4.1, we'd recommend you do native code debugging on
          an alternate platform such as Linux, or manually look at the
          assembly code output to map the symbol names onto their precise
          OCaml functions.</para>
          <para>MacOS 10.9 removes <command>gdb</command> entirely and uses the lldb debugger from
            the LLVM project by default. Many of the guidelines here still apply since the debug
            information embedded in the binary output can be interpreted by lldb (or any other
            DWARF-aware debugger), but the command-line interfaces to lldb is different from
              <command>gdb</command>. Refer to the lldb manual for more information.</para>
        </caution>

        <para>Let's write a mutually recursive function that selects alternating values from a list.
          This isn't tail-recursive, so our stack size will grow as we single-step through the
          execution:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/back-end/alternate_list.ml">OCaml</ulink></para>

        <programlisting format="linespecific" language="ocaml">open Core.Std

let rec take =
  function
  |[] -&gt; []
  |hd::tl -&gt; hd :: (skip tl)
and skip =
  function
  |[] -&gt; []
  |_::tl -&gt; take tl

let () =
  take [1;2;3;4;5;6;7;8;9]
  |&gt; List.map ~f:string_of_int
  |&gt; String.concat ~sep:","
  |&gt; print_endline</programlisting>

        <para>Compile and run this with debugging symbols. You should see the
        following output:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/back-end-bench/run_alternate_list.out">Terminal</ulink></para>

        <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">corebuild -tag debug alternate_list.native</userinput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">./alternate_list.native -ascii</userinput>
<computeroutput moreinfo="none">1,3,5,7,9</computeroutput></programlisting>

        <para>Now we can run this interactively within <command moreinfo="none">gdb</command>:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/back-end/gdb_alternate0.out">Terminal</ulink></para>

        <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">gdb ./alternate_list.native</userinput>
<computeroutput moreinfo="none">GNU gdb (GDB) 7.4.1-debian</computeroutput>
<computeroutput moreinfo="none">Copyright (C) 2012 Free Software Foundation, Inc.</computeroutput>
<computeroutput moreinfo="none">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</computeroutput>
<computeroutput moreinfo="none">This is free software: you are free to change and redistribute it.</computeroutput>
<computeroutput moreinfo="none">There is NO WARRANTY, to the extent permitted by law.  Type "show copying"</computeroutput>
<computeroutput moreinfo="none">and "show warranty" for details.</computeroutput>
<computeroutput moreinfo="none">This GDB was configured as "x86_64-linux-gnu".</computeroutput>
<computeroutput moreinfo="none">For bug reporting instructions, please see:</computeroutput>
<computeroutput moreinfo="none">&lt;http://www.gnu.org/software/gdb/bugs/&gt;...</computeroutput>
<computeroutput moreinfo="none">Reading symbols from /home/avsm/alternate_list.native...done.</computeroutput>
<computeroutput moreinfo="none">(gdb)</computeroutput></programlisting>

        <para>The <command moreinfo="none">gdb</command> prompt lets you enter
        debug directives. Let's set the program to break just before the first
        call to <literal moreinfo="none">take</literal>:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/back-end/gdb_alternate1.out">Terminal</ulink></para>

        <programlisting format="linespecific" language="console"><computeroutput moreinfo="none">(gdb) break camlAlternate_list__take_69242 </computeroutput>
<computeroutput moreinfo="none">Breakpoint 1 at 0x5658d0: file alternate_list.ml, line 5.</computeroutput></programlisting>

        <para>We used the C symbol name by following the name mangling rules defined earlier. A
          convenient way to figure out the full name is by tab completion. Just type in a portion of
          the name and press the &lt;tab&gt; key to see a list of possible completions.</para>

        <para>Once you've set the breakpoint, start the program
        executing:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/back-end/gdb_alternate2.out">Terminal</ulink></para>

        <programlisting format="linespecific" language="console"><computeroutput moreinfo="none">(gdb) run</computeroutput>
<computeroutput moreinfo="none">Starting program: /home/avsm/alternate_list.native</computeroutput>
<computeroutput moreinfo="none">[Thread debugging using libthread_db enabled]</computeroutput>
<computeroutput moreinfo="none">Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".</computeroutput>
<computeroutput moreinfo="none"> </computeroutput>
<computeroutput moreinfo="none">Breakpoint 1, camlAlternate_list__take_69242 () at alternate_list.ml:5</computeroutput>
<computeroutput moreinfo="none">4         function</computeroutput></programlisting>

        <para>The binary has run until the first take invocation and stopped,
        waiting for further instructions. GDB has lots of features, so let's
        continue the program and check the stacktrace after a couple of
        recursions:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/back-end/gdb_alternate3.out">Terminal</ulink></para>

        <programlisting format="linespecific" language="console"><computeroutput moreinfo="none">(gdb) cont</computeroutput>
<computeroutput moreinfo="none">Continuing.</computeroutput>
<computeroutput moreinfo="none"> </computeroutput>
<computeroutput moreinfo="none">Breakpoint 1, camlAlternate_list__take_69242 () at alternate_list.ml:5</computeroutput>
<computeroutput moreinfo="none">4         function</computeroutput>
<computeroutput moreinfo="none">(gdb) cont</computeroutput>
<computeroutput moreinfo="none">Continuing.</computeroutput>
<computeroutput moreinfo="none"> </computeroutput>
<computeroutput moreinfo="none">Breakpoint 1, camlAlternate_list__take_69242 () at alternate_list.ml:5</computeroutput>
<computeroutput moreinfo="none">4         function</computeroutput>
<computeroutput moreinfo="none">(gdb) bt</computeroutput>
<computeroutput moreinfo="none">#0  camlAlternate_list__take_69242 () at alternate_list.ml:4</computeroutput>
<computeroutput moreinfo="none">#1  0x00000000005658e7 in camlAlternate_list__take_69242 () at alternate_list.ml:6</computeroutput>
<computeroutput moreinfo="none">#2  0x00000000005658e7 in camlAlternate_list__take_69242 () at alternate_list.ml:6</computeroutput>
<computeroutput moreinfo="none">#3  0x00000000005659f7 in camlAlternate_list__entry () at alternate_list.ml:14</computeroutput>
<computeroutput moreinfo="none">#4  0x0000000000560029 in caml_program ()</computeroutput>
<computeroutput moreinfo="none">#5  0x000000000080984a in caml_start_program ()</computeroutput>
<computeroutput moreinfo="none">#6  0x00000000008099a0 in ?? ()</computeroutput>
<computeroutput moreinfo="none">#7  0x0000000000000000 in ?? ()</computeroutput>
<computeroutput moreinfo="none">(gdb) clear camlAlternate_list__take_69242</computeroutput>
<computeroutput moreinfo="none">Deleted breakpoint 1 </computeroutput>
<computeroutput moreinfo="none">(gdb) cont</computeroutput>
<computeroutput moreinfo="none">Continuing.</computeroutput>
<computeroutput moreinfo="none">1,3,5,7,9</computeroutput>
<computeroutput moreinfo="none">[Inferior 1 (process 3546) exited normally]</computeroutput></programlisting>

        <para>The <literal moreinfo="none">cont</literal> command resumes execution after a
          breakpoint has paused it, <literal moreinfo="none">bt</literal> displays a stack
          backtrace, and <literal moreinfo="none">clear</literal> deletes the breakpoint so the
          application can execute until completion. GDB has a host of other features we won't cover
          here, but you can view more guidelines via Mark Shinwell's talk on <ulink url="http://www.youtube.com/watch?v=NF2WpWnB-nk&lt;">"Real-world debugging in
            OCaml."</ulink></para>

        <para>One very useful feature of OCaml native code is that C and OCaml share the same stack.
          This means that GDB backtraces can give you a combined view of what's going on in your
          program <emphasis>and</emphasis> runtime library. This includes any calls to C libraries
          or even callbacks into OCaml from the C layer if you're in an environment which embeds the
          OCaml runtime as a library.</para>
      </sect3>
    </sect2>

    <sect2 id="profiling-native-code">
      <title>Profiling Native Code</title>

      <para>The recording and analysis of where your application spends its
      execution time is known as <emphasis>performance profiling</emphasis>.
      OCaml native code binaries can be profiled just like any other C binary,
      by using the name mangling described earlier to map between OCaml
      variable names and the profiler output.<indexterm class="singular">
          <primary>profiling</primary>
        </indexterm><indexterm class="singular">
          <primary>performance profiling</primary>
        </indexterm><indexterm class="singular">
          <primary>native-code compiler</primary>

          <secondary>performance profiling</secondary>
        </indexterm></para>

      <para>Most profiling tools benefit from having some instrumentation
      included in the binary. OCaml supports two such tools:</para>

      <itemizedlist>
        <listitem>
          <para>GNU <command moreinfo="none">gprof</command>, to measure execution time and call
            graphs</para>
        </listitem>

        <listitem>
          <para>The <ulink url="https://perf.wiki.kernel.org/">Perf</ulink>
          profiling framework in modern versions of Linux</para>
        </listitem>
      </itemizedlist>

      <para>Note that many other tools that operate on native binaries, such as Valgrind, will work
        just fine with OCaml as long as the program is linked with the <literal moreinfo="none">-g</literal> flag to embed debugging symbols.</para>

      <sect3 id="gprof">
        <title>Gprof</title>

        <para><command moreinfo="none">gprof</command> produces an execution
        profile of an OCaml program by recording a call graph of which
        functions call one another, and recording the time these calls take
        during the program execution.<indexterm class="singular">
            <primary>gprof code profiler</primary>
          </indexterm></para>

        <para>Getting precise information out of <command moreinfo="none">gprof</command> requires passing the <literal moreinfo="none">-p</literal> flag to the native code compiler when
        compiling <emphasis>and</emphasis> linking the binary. This generates
        extra code that records profile information to a file called <literal moreinfo="none">gmon.out</literal> when the program is executed. This
        profile information can then be examined using <command moreinfo="none">gprof</command>.</para>
      </sect3>

      <sect3 id="perf">
        <title>Perf</title>

        <para>Perf is a more modern alternative to <command moreinfo="none">gprof</command> that doesn't require you to instrument
        the binary. Instead, it uses hardware counters and debug information
        within the binary to record information accurately.</para>

        <para>Run Perf on a compiled binary to record information first. We'll use our write barrier
          benchmark from earlier, which measures memory allocation versus in-place
          modification:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/back-end/perf_record.out">Terminal</ulink></para>

        <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">perf record -g ./barrier_bench.native</userinput>
<computeroutput moreinfo="none">Estimated testing time 20s (change using -quota SECS).</computeroutput>
<computeroutput moreinfo="none"> </computeroutput>
<computeroutput moreinfo="none">  Name        Time (ns)             Time 95ci   Percentage</computeroutput>
<computeroutput moreinfo="none">  ----        ---------             ---------   ----------</computeroutput>
<computeroutput moreinfo="none">  mutable     7_306_219   7_250_234-7_372_469        96.83</computeroutput>
<computeroutput moreinfo="none">  immutable   7_545_126   7_537_837-7_551_193       100.00</computeroutput>
<computeroutput moreinfo="none"> </computeroutput>
<computeroutput moreinfo="none">[ perf record: Woken up 11 times to write data ]</computeroutput>
<computeroutput moreinfo="none">[ perf record: Captured and wrote 2.722 MB perf.data (~118926 samples) ]</computeroutput>
<computeroutput moreinfo="none">perf record -g ./barrier.native</computeroutput>
<computeroutput moreinfo="none">Estimated testing time 20s (change using -quota SECS).</computeroutput>
<computeroutput moreinfo="none"> </computeroutput>
<computeroutput moreinfo="none">  Name        Time (ns)             Time 95ci   Percentage</computeroutput>
<computeroutput moreinfo="none">  ----        ---------             ---------   ----------</computeroutput>
<computeroutput moreinfo="none">  mutable     7_306_219   7_250_234-7_372_469        96.83</computeroutput>
<computeroutput moreinfo="none">  immutable   7_545_126   7_537_837-7_551_193       100.00</computeroutput>
<computeroutput moreinfo="none"> </computeroutput>
<computeroutput moreinfo="none">[ perf record: Woken up 11 times to write data ]</computeroutput>
<computeroutput moreinfo="none">[ perf record: Captured and wrote 2.722 MB perf.data (~118926 samples) ]</computeroutput></programlisting>

        <para>When this completes, you can interactively explore the
        results:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/back-end/perf_report.out">Terminal</ulink></para>

        <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">perf report -g</userinput>
<computeroutput moreinfo="none">+  48.86%  barrier.native  barrier.native  [.] camlBarrier__test_immutable_69282</computeroutput>
<computeroutput moreinfo="none">+  30.22%  barrier.native  barrier.native  [.] camlBarrier__test_mutable_69279</computeroutput>
<computeroutput moreinfo="none">+  20.22%  barrier.native  barrier.native  [.] caml_modify</computeroutput></programlisting>

        <para>This trace broadly reflects the results of the benchmark itself.
        The mutable benchmark consists of the combination of the call to
        <literal moreinfo="none">test_mutable</literal> and the <literal moreinfo="none">caml_modify</literal> write barrier function in the
        runtime. This adds up to slightly over half the execution time of the
        application.</para>

        <para>Perf has a growing collection of other commands that let you archive these runs and
          compare them against each other. You can read more on the <ulink url="http://perf.wiki.kernel.org">home page</ulink>.<indexterm class="singular">
            <primary>frame pointers</primary>
          </indexterm></para>

        <sidebar>
          <title>Using the Frame Pointer to Get More Accurate Traces</title>

          <para>Although Perf doesn't require adding in explicit probes to the
          binary, it does need to understand how to unwind function calls so
          that the kernel can accurately record the function backtrace for
          every event.</para>

          <para>OCaml stack frames are too complex for Perf to understand
          directly, and so it needs the compiler to fall back to using the
          same conventions as C for function calls. On 64-bit Intel systems,
          this means that a special register known as the <emphasis>frame
          pointer</emphasis> is used to record function call history.</para>

          <para>Using the frame pointer in this fashion means a slowdown
          (typically around 3-5%) since it's no longer available for
          general-purpose use. OCaml 4.1 thus makes the frame pointer an
          optional feature that can be used to improve the resolution of Perf
          traces.</para>

          <para>OPAM provides a compiler switch that compiles OCaml with the
          frame pointer activated:</para>

          <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/back-end/opam_switch.out">Terminal</ulink></para>

          <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">opam switch 4.01.0+fp</userinput>
</programlisting>

          <para>Using the frame pointer changes the OCaml calling convention,
          but OPAM takes care of recompiling all your libraries with the new
          interface. You can read more about this on the OCamlPro <ulink url="https://www.ocamlpro.com/2012/08/08/profiling-ocaml-amd64-code-under-linux/">blog</ulink>.</para>
        </sidebar>
      </sect3>
    </sect2>

    <sect2 id="embedding-native-code-in-c">
      <title>Embedding Native Code in C</title>

      <para>The native code compiler normally links a complete executable, but
      can also output a standalone native object file just as the bytecode
      compiler can. This object file has no further dependencies on OCaml
      except for the runtime library.<indexterm class="singular">
          <primary>libasmrun.a library</primary>
        </indexterm><indexterm class="singular">
          <primary>native-code compiler</primary>

          <secondary>embedding code in C</secondary>
        </indexterm></para>

      <para>The native code runtime is a different library from the bytecode one, and is installed
        as <literal moreinfo="none">libasmrun.a</literal> in the OCaml standard library
        directory.</para>

      <para>Try this custom linking by using the same source files from the
      bytecode embedding example earlier in this chapter:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/back-end-embed/build_embed_native.out">Terminal</ulink></para>

      <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">ocamlopt -output-obj -o embed_native.o embed_me1.ml embed_me2.ml</userinput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">gcc -Wall -I `ocamlc -where` -o final.native embed_native.o main.c \</userinput>
<computeroutput moreinfo="none">   -L `ocamlc -where` -lasmrun -ltermcap -lm -ldl</computeroutput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">./final.native</userinput>
<computeroutput moreinfo="none">Before calling OCaml</computeroutput>
<computeroutput moreinfo="none">hello embedded world 1</computeroutput>
<computeroutput moreinfo="none">hello embedded world 2</computeroutput>
<computeroutput moreinfo="none">After calling OCaml</computeroutput></programlisting>

      <para>The <literal moreinfo="none">embed_native.o</literal> is a standalone object file that
        has no further references to OCaml code beyond the runtime library, just as with the
        bytecode runtime. Do remember that the link order of the libraries is significant in modern
        GNU toolchains (especially as used in Ubuntu 11.10 and later) that resolve symbols from left
        to right in a single pass.<indexterm class="singular">
          <primary>debugging</primary>
          <secondary>activating debug runtime</secondary>
        </indexterm></para>

      <tip>
        <title>Activating the Debug Runtime</title>

        <para>Despite your best efforts, it is easy to introduce a bug into some components, such as
          C bindings, that causes heap invariants to be violated. OCaml includes a <literal moreinfo="none">libasmrund.a</literal> variant of the runtime library which is compiled
          with extra debugging checks that perform extra memory integrity checks during every
          garbage collection cycle. Running these extra checks will abort the program nearer the
          point of corruption and help isolate the bug in the C code.</para>

        <para>To use the debug library, just link your program with the
        <literal moreinfo="none">-runtime-variant d</literal> flag:</para>

        <para role="sourcecode"><ulink role="orm:hideurl:ital" url="https://github.com/realworldocaml/examples/tree/v1/code/back-end-embed/run_debug_hello.out">Terminal</ulink></para>

        <programlisting format="linespecific" language="console"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">ocamlopt -runtime-variant d -verbose -o hello.native hello.ml</userinput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">./hello.native</userinput>
<computeroutput moreinfo="none">### OCaml runtime: debug mode ###</computeroutput>
<computeroutput moreinfo="none">Initial minor heap size: 2048k bytes</computeroutput>
<computeroutput moreinfo="none">Initial major heap size: 992k bytes</computeroutput>
<computeroutput moreinfo="none">Initial space overhead: 80%</computeroutput>
<computeroutput moreinfo="none">Initial max overhead: 500%</computeroutput>
<computeroutput moreinfo="none">Initial heap increment: 992k bytes</computeroutput>
<computeroutput moreinfo="none">Initial allocation policy: 0</computeroutput>
<computeroutput moreinfo="none">Hello OCaml World!</computeroutput></programlisting>

        <para>If you get an error that <literal moreinfo="none">libasmrund.a</literal> is not found,
          it's probably because you're using OCaml 4.00 and not 4.01. It's only installed by default
          in the very latest version, which you should be using via the <literal moreinfo="none">4.01.0</literal> OPAM switch.<indexterm class="endofrange" startref="CPfast"/></para>
      </tip>
    </sect2>
  </sect1>

  <sect1 id="summarizing-the-file-extensions">
    <title>Summarizing the File Extensions</title>

    <para>We've seen how the compiler uses intermediate files to store various
    stages of the compilation toolchain. Here's a cheat sheet of all them in
    one place.<indexterm class="singular">
        <primary>files</primary>

        <secondary>chart of file extensions</secondary>
      </indexterm><indexterm class="singular">
        <primary>compilation process</primary>

        <secondary>file extensions</secondary>
      </indexterm></para>

    <para> <xref linkend="Table2301"/> shows the intermediate files generated by <command moreinfo="none">ocamlc</command>.</para>

    <table id="Table2301"><title>Intermediate files generated by the OCaml compiler toolchain</title>
      <tgroup cols="2">
        <colspec align="left"/>

        <colspec align="left"/>

        <thead>
          <row>
            <entry>Extension</entry>

            <entry>Purpose</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry><literal>.ml</literal></entry>

            <entry>Source files for compilation unit module
            implementations.</entry>
          </row>

          <row>
            <entry><literal>.mli</literal></entry>

            <entry>Source files for compilation unit module interfaces. If
            missing, generated from the <literal moreinfo="none">.ml</literal>
            file.</entry>
          </row>

          <row>
            <entry><literal>.cmi</literal></entry>

            <entry>Compiled module interface from a corresponding <literal moreinfo="none">.mli</literal> source file.</entry>
          </row>

          <row>
            <entry><literal>.cmo</literal></entry>

            <entry>Compiled bytecode object file of the module
            implementation.</entry>
          </row>

          <row>
            <entry><literal>.cma</literal></entry>

            <entry>Library of bytecode object files packed into a single
            file.</entry>
          </row>

          <row>
            <entry><literal>.o</literal></entry>

            <entry>C source files are compiled into native object files by the
            system <literal moreinfo="none">cc</literal>.</entry>
          </row>

          <row>
            <entry><literal>.cmt</literal></entry>

            <entry>Typed abstract syntax tree for module
            implementations.</entry>
          </row>

          <row>
            <entry><literal>.cmti</literal></entry>

            <entry>Typed abstract syntax tree for module interfaces.</entry>
          </row>

          <row>
            <entry><literal>.annot</literal></entry>

            <entry>Old-style annotation file for displaying <literal>typed</literal>, superseded by
                <literal moreinfo="none">cmt</literal> files.</entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <para>The native code compiler generates some additional files (see <xref linkend="Table2302"/>).<indexterm class="singular">
        <primary>native-code compiler</primary>
        <secondary>files generated by</secondary>
      </indexterm></para>

    <table id="Table2302"> <title>Intermediate outputs produced by the native code OCaml toolchain</title>
      <tgroup cols="2">
        <colspec align="left"/>

        <colspec align="left"/>

        <thead>
          <row>
            <entry>Extension</entry>

            <entry>Purpose</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry><literal>.o</literal></entry>

            <entry>Compiled native object file of the module
            implementation.</entry>
          </row>

          <row>
            <entry><literal>.cmx</literal></entry>

            <entry>Contains extra information for linking and cross-module
            optimization of the object file.</entry>
          </row>

          <row>
            <entry><literal>.cmxa and .a</literal></entry>

            <entry>Library of <literal moreinfo="none">cmx</literal> and
            <literal moreinfo="none">o</literal> units, stored in the <literal moreinfo="none">cmxa</literal> and <literal moreinfo="none">a</literal> files respectively. These files are
            always needed together.</entry>
          </row>

          <row>
            <entry><literal>.S </literal><emphasis>or</emphasis>
              <literal>.s</literal></entry>

            <entry>Assembly language output if <literal moreinfo="none">-S</literal> is specified.</entry>
          </row>
        </tbody>
      </tgroup>
    </table>
  </sect1>
</chapter>
  </part>
<index/>
<colophon id="colophon">
  <title>Colophon</title>

  <para>The animal on the cover of <emphasis>Real World OCaml</emphasis> is the Bactrian camel
      (<emphasis>Camelus bactrianus</emphasis>). The Bactrian camel, one of two species of camel, is
    native to Central Asia and has been used domestically in the area for thousands of years. Even
    though there are over two million domesticated Bactrian camels, only about a thousand are
    considered wild.</para>
  <para>The Bactrian camel is a large animal at 6 to 7.5 feet in height and 7.4 to 11.5 feet in
    length. An adult will typically weigh between 660 and 2,200 pounds. The Bactrian camel is
    distinctive for its two large humps on their back, hefty wooly coat, and dark brown color. It is
    a herbivore that will eat all kinds of vegetation, though they have been known to feed on dead
    animals. </para>
  <para>Humans have domesticated the Bactrian camel for travel purposes because of its great natural
    resiliency. For example, the Bactrian camel can thrive in habitats of both extreme cold and
    heat. It can also go without water for months and when water is available it can consume up to
    55 litres. </para>

  <para>The cover image is from <emphasis>Meyers Kleines Lexicon</emphasis>. The cover fonts are URW
    Typewriter and Guardian Sans. The text font is Adobe Minion Pro; the heading font is Adobe
    Myriad Condensed; and the code font is Dalton Maag's Ubuntu Mono.</para>
</colophon>
</book>
